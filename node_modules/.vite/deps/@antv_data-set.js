import {
  __commonJS
} from "./chunk-BHN6OJC3.js";

// node_modules/@antv/data-set/build/data-set.js
var require_data_set = __commonJS({
  "node_modules/@antv/data-set/build/data-set.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else if (typeof exports === "object")
        exports["DataSet"] = factory();
      else
        root["DataSet"] = factory();
    })(window, function() {
      return function(modules) {
        var installedModules = {};
        function __webpack_require__(moduleId) {
          if (installedModules[moduleId]) {
            return installedModules[moduleId].exports;
          }
          var module2 = installedModules[moduleId] = {
            i: moduleId,
            l: false,
            exports: {}
          };
          modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
          module2.l = true;
          return module2.exports;
        }
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        __webpack_require__.d = function(exports2, name, getter) {
          if (!__webpack_require__.o(exports2, name)) {
            Object.defineProperty(exports2, name, { enumerable: true, get: getter });
          }
        };
        __webpack_require__.r = function(exports2) {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
          }
          Object.defineProperty(exports2, "__esModule", { value: true });
        };
        __webpack_require__.t = function(value, mode) {
          if (mode & 1)
            value = __webpack_require__(value);
          if (mode & 8)
            return value;
          if (mode & 4 && typeof value === "object" && value && value.__esModule)
            return value;
          var ns = /* @__PURE__ */ Object.create(null);
          __webpack_require__.r(ns);
          Object.defineProperty(ns, "default", { enumerable: true, value });
          if (mode & 2 && typeof value != "string")
            for (var key in value)
              __webpack_require__.d(ns, key, function(key2) {
                return value[key2];
              }.bind(null, key));
          return ns;
        };
        __webpack_require__.n = function(module2) {
          var getter = module2 && module2.__esModule ? function getDefault() {
            return module2["default"];
          } : function getModuleExports() {
            return module2;
          };
          __webpack_require__.d(getter, "a", getter);
          return getter;
        };
        __webpack_require__.o = function(object, property) {
          return Object.prototype.hasOwnProperty.call(object, property);
        };
        __webpack_require__.p = "";
        return __webpack_require__(__webpack_require__.s = "./src/index.ts");
      }({
        "./node_modules/_@antv_hierarchy@0.6.6@@antv/hierarchy/build/hierarchy.js": function(module2, exports2, __webpack_require__) {
          (function webpackUniversalModuleDefinition(root, factory) {
            if (true)
              module2.exports = factory();
            else {
            }
          })(typeof self !== "undefined" ? self : this, function() {
            return function(modules) {
              var installedModules = {};
              function __webpack_require__2(moduleId) {
                if (installedModules[moduleId]) {
                  return installedModules[moduleId].exports;
                }
                var module3 = installedModules[moduleId] = {
                  i: moduleId,
                  l: false,
                  exports: {}
                };
                modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__2);
                module3.l = true;
                return module3.exports;
              }
              __webpack_require__2.m = modules;
              __webpack_require__2.c = installedModules;
              __webpack_require__2.d = function(exports3, name, getter) {
                if (!__webpack_require__2.o(exports3, name)) {
                  Object.defineProperty(exports3, name, {
                    configurable: false,
                    enumerable: true,
                    get: getter
                  });
                }
              };
              __webpack_require__2.n = function(module3) {
                var getter = module3 && module3.__esModule ? function getDefault() {
                  return module3["default"];
                } : function getModuleExports() {
                  return module3;
                };
                __webpack_require__2.d(getter, "a", getter);
                return getter;
              };
              __webpack_require__2.o = function(object, property) {
                return Object.prototype.hasOwnProperty.call(object, property);
              };
              __webpack_require__2.p = "";
              return __webpack_require__2(__webpack_require__2.s = 31);
            }([
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__is_type__ = __webpack_require__2(4);
                __webpack_exports__["a"] = function(value) {
                  return Array.isArray ? Array.isArray(value) : Object(__WEBPACK_IMPORTED_MODULE_0__is_type__["a"])(value, "Array");
                };
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var isArrayLike = function(value) {
                  return value !== null && typeof value !== "function" && isFinite(value.length);
                };
                __webpack_exports__["a"] = isArrayLike;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__is_array__ = __webpack_require__2(0);
                var __WEBPACK_IMPORTED_MODULE_1__is_object__ = __webpack_require__2(13);
                function each(elements, func) {
                  if (!elements) {
                    return;
                  }
                  var rst;
                  if (Object(__WEBPACK_IMPORTED_MODULE_0__is_array__["a"])(elements)) {
                    for (var i = 0, len = elements.length; i < len; i++) {
                      rst = func(elements[i], i);
                      if (rst === false) {
                        break;
                      }
                    }
                  } else if (Object(__WEBPACK_IMPORTED_MODULE_1__is_object__["a"])(elements)) {
                    for (var k in elements) {
                      if (elements.hasOwnProperty(k)) {
                        rst = func(elements[k], k);
                        if (rst === false) {
                          break;
                        }
                      }
                    }
                  }
                }
                __webpack_exports__["a"] = each;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__is_type__ = __webpack_require__2(4);
                __webpack_exports__["a"] = function(value) {
                  return Object(__WEBPACK_IMPORTED_MODULE_0__is_type__["a"])(value, "Function");
                };
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var toString = {}.toString;
                var isType = function(value, type) {
                  return toString.call(value) === "[object " + type + "]";
                };
                __webpack_exports__["a"] = isType;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__is_type__ = __webpack_require__2(4);
                var isNumber = function(value) {
                  return Object(__WEBPACK_IMPORTED_MODULE_0__is_type__["a"])(value, "Number");
                };
                __webpack_exports__["a"] = isNumber;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var isNil = function(value) {
                  return value === null || value === void 0;
                };
                __webpack_exports__["a"] = isNil;
              },
              function(module3, exports3, __webpack_require__2) {
                var _require = __webpack_require__2(33), mix = _require.mix;
                module3.exports = {
                  assign: mix
                };
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__is_type__ = __webpack_require__2(4);
                __webpack_exports__["a"] = function(str) {
                  return Object(__WEBPACK_IMPORTED_MODULE_0__is_type__["a"])(str, "String");
                };
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__is_object_like__ = __webpack_require__2(15);
                var __WEBPACK_IMPORTED_MODULE_1__is_type__ = __webpack_require__2(4);
                var isPlainObject = function(value) {
                  if (!Object(__WEBPACK_IMPORTED_MODULE_0__is_object_like__["a"])(value) || !Object(__WEBPACK_IMPORTED_MODULE_1__is_type__["a"])(value, "Object")) {
                    return false;
                  }
                  if (Object.getPrototypeOf(value) === null) {
                    return true;
                  }
                  var proto = value;
                  while (Object.getPrototypeOf(proto) !== null) {
                    proto = Object.getPrototypeOf(proto);
                  }
                  return Object.getPrototypeOf(value) === proto;
                };
                __webpack_exports__["a"] = isPlainObject;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__is_nil__ = __webpack_require__2(6);
                __webpack_exports__["a"] = function(value) {
                  if (Object(__WEBPACK_IMPORTED_MODULE_0__is_nil__["a"])(value))
                    return "";
                  return value.toString();
                };
              },
              function(module3, exports3, __webpack_require__2) {
                var hierarchy = __webpack_require__2(18);
                var Layout = function() {
                  function Layout2(root, options) {
                    if (options === void 0) {
                      options = {};
                    }
                    var me = this;
                    me.options = options;
                    me.rootNode = hierarchy(root, options);
                  }
                  var _proto = Layout2.prototype;
                  _proto.execute = function execute() {
                    throw new Error("please override this method");
                  };
                  return Layout2;
                }();
                module3.exports = Layout;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__is_array_like__ = __webpack_require__2(1);
                var contains = function(arr, value) {
                  if (!Object(__WEBPACK_IMPORTED_MODULE_0__is_array_like__["a"])(arr)) {
                    return false;
                  }
                  return arr.indexOf(value) > -1;
                };
                __webpack_exports__["a"] = contains;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                __webpack_exports__["a"] = function(value) {
                  var type = typeof value;
                  return value !== null && type === "object" || type === "function";
                };
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__each__ = __webpack_require__2(2);
                var __WEBPACK_IMPORTED_MODULE_1__is_array_like__ = __webpack_require__2(1);
                var filter = function(arr, func) {
                  if (!Object(__WEBPACK_IMPORTED_MODULE_1__is_array_like__["a"])(arr)) {
                    return arr;
                  }
                  var result = [];
                  Object(__WEBPACK_IMPORTED_MODULE_0__each__["a"])(arr, function(value, index) {
                    if (func(value, index)) {
                      result.push(value);
                    }
                  });
                  return result;
                };
                __webpack_exports__["a"] = filter;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var isObjectLike = function(value) {
                  return typeof value === "object" && value !== null;
                };
                __webpack_exports__["a"] = isObjectLike;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                __webpack_exports__["a"] = mix;
                function _mix(dist, obj) {
                  for (var key in obj) {
                    if (obj.hasOwnProperty(key) && key !== "constructor" && obj[key] !== void 0) {
                      dist[key] = obj[key];
                    }
                  }
                }
                function mix(dist, src1, src2, src3) {
                  if (src1)
                    _mix(dist, src1);
                  if (src2)
                    _mix(dist, src2);
                  if (src3)
                    _mix(dist, src3);
                  return dist;
                }
              },
              function(module3, exports3, __webpack_require__2) {
                var separateTree = __webpack_require__2(30);
                var VALID_DIRECTIONS = [
                  "LR",
                  "RL",
                  "TB",
                  "BT",
                  "H",
                  "V"
                ];
                var HORIZONTAL_DIRECTIONS = ["LR", "RL", "H"];
                var isHorizontal = function isHorizontal2(direction) {
                  return HORIZONTAL_DIRECTIONS.indexOf(direction) > -1;
                };
                var DEFAULT_DIRECTION = VALID_DIRECTIONS[0];
                module3.exports = function(root, options, layoutAlgrithm) {
                  var direction = options.direction || DEFAULT_DIRECTION;
                  options.isHorizontal = isHorizontal(direction);
                  if (direction && VALID_DIRECTIONS.indexOf(direction) === -1) {
                    throw new TypeError("Invalid direction: " + direction);
                  }
                  if (direction === VALID_DIRECTIONS[0]) {
                    layoutAlgrithm(root, options);
                  } else if (direction === VALID_DIRECTIONS[1]) {
                    layoutAlgrithm(root, options);
                    root.right2left();
                  } else if (direction === VALID_DIRECTIONS[2]) {
                    layoutAlgrithm(root, options);
                  } else if (direction === VALID_DIRECTIONS[3]) {
                    layoutAlgrithm(root, options);
                    root.bottom2top();
                  } else if (direction === VALID_DIRECTIONS[4] || direction === VALID_DIRECTIONS[5]) {
                    var _separateTree = separateTree(root, options), left = _separateTree.left, right = _separateTree.right;
                    layoutAlgrithm(left, options);
                    layoutAlgrithm(right, options);
                    options.isHorizontal ? left.right2left() : left.bottom2top();
                    right.translate(left.x - right.x, left.y - right.y);
                    root.x = left.x;
                    root.y = right.y;
                    var bb = root.getBoundingBox();
                    if (options.isHorizontal) {
                      if (bb.top < 0) {
                        root.translate(0, -bb.top);
                      }
                    } else {
                      if (bb.left < 0) {
                        root.translate(-bb.left, 0);
                      }
                    }
                  }
                  var fixedRoot = options.fixedRoot;
                  if (fixedRoot === void 0)
                    fixedRoot = true;
                  if (fixedRoot) {
                    root.translate(-(root.x + root.width / 2 + root.hgap), -(root.y + root.height / 2 + root.vgap));
                  }
                  return root;
                };
              },
              function(module3, exports3, __webpack_require__2) {
                var util = __webpack_require__2(7);
                var PEM = 18;
                var DEFAULT_HEIGHT = PEM * 2;
                var DEFAULT_GAP = PEM;
                var DEFAULT_OPTIONS = {
                  getId: function getId(d) {
                    return d.id || d.name;
                  },
                  getHGap: function getHGap(d) {
                    return d.hgap || DEFAULT_GAP;
                  },
                  getVGap: function getVGap(d) {
                    return d.vgap || DEFAULT_GAP;
                  },
                  getChildren: function getChildren(d) {
                    return d.children;
                  },
                  getHeight: function getHeight(d) {
                    return d.height || DEFAULT_HEIGHT;
                  },
                  getWidth: function getWidth(d) {
                    var label = d.label || " ";
                    return d.width || label.split("").length * PEM;
                  }
                };
                function Node(data, options) {
                  var me = this;
                  me.vgap = me.hgap = 0;
                  if (data instanceof Node)
                    return data;
                  me.data = data;
                  var hgap = options.getHGap(data);
                  var vgap = options.getVGap(data);
                  me.width = options.getWidth(data);
                  me.height = options.getHeight(data);
                  me.id = options.getId(data);
                  me.x = me.y = 0;
                  me.depth = 0;
                  if (!me.children) {
                    me.children = [];
                  }
                  me.addGap(hgap, vgap);
                  return me;
                }
                util.assign(Node.prototype, {
                  isRoot: function isRoot() {
                    return this.depth === 0;
                  },
                  isLeaf: function isLeaf() {
                    return this.children.length === 0;
                  },
                  addGap: function addGap(hgap, vgap) {
                    var me = this;
                    me.hgap += hgap;
                    me.vgap += vgap;
                    me.width += 2 * hgap;
                    me.height += 2 * vgap;
                  },
                  eachNode: function eachNode(callback) {
                    var me = this;
                    var nodes = [me];
                    var current;
                    while (current = nodes.shift()) {
                      callback(current);
                      nodes = current.children.concat(nodes);
                    }
                  },
                  DFTraverse: function DFTraverse(callback) {
                    this.eachNode(callback);
                  },
                  BFTraverse: function BFTraverse(callback) {
                    var me = this;
                    var nodes = [me];
                    var current;
                    while (current = nodes.shift()) {
                      callback(current);
                      nodes = nodes.concat(current.children);
                    }
                  },
                  getBoundingBox: function getBoundingBox() {
                    var bb = {
                      left: Number.MAX_VALUE,
                      top: Number.MAX_VALUE,
                      width: 0,
                      height: 0
                    };
                    this.eachNode(function(node) {
                      bb.left = Math.min(bb.left, node.x);
                      bb.top = Math.min(bb.top, node.y);
                      bb.width = Math.max(bb.width, node.x + node.width);
                      bb.height = Math.max(bb.height, node.y + node.height);
                    });
                    return bb;
                  },
                  translate: function translate(tx, ty) {
                    if (tx === void 0) {
                      tx = 0;
                    }
                    if (ty === void 0) {
                      ty = 0;
                    }
                    this.eachNode(function(node) {
                      node.x += tx;
                      node.y += ty;
                    });
                  },
                  right2left: function right2left() {
                    var me = this;
                    var bb = me.getBoundingBox();
                    me.eachNode(function(node) {
                      node.x = node.x - (node.x - bb.left) * 2 - node.width;
                    });
                    me.translate(bb.width, 0);
                  },
                  bottom2top: function bottom2top() {
                    var me = this;
                    var bb = me.getBoundingBox();
                    me.eachNode(function(node) {
                      node.y = node.y - (node.y - bb.top) * 2 - node.height;
                    });
                    me.translate(0, bb.height);
                  }
                });
                function hierarchy(data, options, isolated) {
                  if (options === void 0) {
                    options = {};
                  }
                  options = util.assign({}, DEFAULT_OPTIONS, options);
                  var root = new Node(data, options);
                  var nodes = [root];
                  var node;
                  if (!isolated && !data.collapsed) {
                    while (node = nodes.shift()) {
                      if (!node.data.collapsed) {
                        var children = options.getChildren(node.data);
                        var length = children ? children.length : 0;
                        node.children = new Array(length);
                        if (children && length) {
                          for (var i = 0; i < length; i++) {
                            var child = new Node(children[i], options);
                            node.children[i] = child;
                            nodes.push(child);
                            child.parent = node;
                            child.depth = node.depth + 1;
                          }
                        }
                      }
                    }
                  }
                  return root;
                }
                module3.exports = hierarchy;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__is_nil__ = __webpack_require__2(6);
                var __WEBPACK_IMPORTED_MODULE_1__keys__ = __webpack_require__2(20);
                function isMatch(obj, attrs) {
                  var _keys = Object(__WEBPACK_IMPORTED_MODULE_1__keys__["a"])(attrs);
                  var length = _keys.length;
                  if (Object(__WEBPACK_IMPORTED_MODULE_0__is_nil__["a"])(obj))
                    return !length;
                  for (var i = 0; i < length; i += 1) {
                    var key = _keys[i];
                    if (attrs[key] !== obj[key] || !(key in obj)) {
                      return false;
                    }
                  }
                  return true;
                }
                __webpack_exports__["a"] = isMatch;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__each__ = __webpack_require__2(2);
                var __WEBPACK_IMPORTED_MODULE_1__is_function__ = __webpack_require__2(3);
                var keys = Object.keys ? function(obj) {
                  return Object.keys(obj);
                } : function(obj) {
                  var result = [];
                  Object(__WEBPACK_IMPORTED_MODULE_0__each__["a"])(obj, function(value, key) {
                    if (!(Object(__WEBPACK_IMPORTED_MODULE_1__is_function__["a"])(obj) && key === "prototype")) {
                      result.push(key);
                    }
                  });
                  return result;
                };
                __webpack_exports__["a"] = keys;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__is_array_like__ = __webpack_require__2(1);
                var splice = Array.prototype.splice;
                var pullAt = function pullAt2(arr, indexes) {
                  if (!Object(__WEBPACK_IMPORTED_MODULE_0__is_array_like__["a"])(arr)) {
                    return [];
                  }
                  var length = arr ? indexes.length : 0;
                  var last = length - 1;
                  while (length--) {
                    var previous = void 0;
                    var index = indexes[length];
                    if (length === last || index !== previous) {
                      previous = index;
                      splice.call(arr, index, 1);
                    }
                  }
                  return arr;
                };
                __webpack_exports__["a"] = pullAt;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__contains__ = __webpack_require__2(12);
                var __WEBPACK_IMPORTED_MODULE_1__each__ = __webpack_require__2(2);
                var uniq = function(arr) {
                  var resultArr = [];
                  Object(__WEBPACK_IMPORTED_MODULE_1__each__["a"])(arr, function(item) {
                    if (!Object(__WEBPACK_IMPORTED_MODULE_0__contains__["a"])(resultArr, item)) {
                      resultArr.push(item);
                    }
                  });
                  return resultArr;
                };
                __webpack_exports__["a"] = uniq;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__is_array__ = __webpack_require__2(0);
                var __WEBPACK_IMPORTED_MODULE_1__is_function__ = __webpack_require__2(3);
                var __WEBPACK_IMPORTED_MODULE_2__group_by__ = __webpack_require__2(24);
                var groupToMap = function(data, condition) {
                  if (!condition) {
                    return {
                      0: data
                    };
                  }
                  if (!Object(__WEBPACK_IMPORTED_MODULE_1__is_function__["a"])(condition)) {
                    var paramsCondition_1 = Object(__WEBPACK_IMPORTED_MODULE_0__is_array__["a"])(condition) ? condition : condition.replace(/\s+/g, "").split("*");
                    condition = function(row) {
                      var unique = "_";
                      for (var i = 0, l = paramsCondition_1.length; i < l; i++) {
                        unique += row[paramsCondition_1[i]] && row[paramsCondition_1[i]].toString();
                      }
                      return unique;
                    };
                  }
                  var groups = Object(__WEBPACK_IMPORTED_MODULE_2__group_by__["a"])(data, condition);
                  return groups;
                };
                __webpack_exports__["a"] = groupToMap;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__each__ = __webpack_require__2(2);
                var __WEBPACK_IMPORTED_MODULE_1__is_array__ = __webpack_require__2(0);
                var __WEBPACK_IMPORTED_MODULE_2__is_function__ = __webpack_require__2(3);
                var hasOwnProperty = Object.prototype.hasOwnProperty;
                function groupBy(data, condition) {
                  if (!condition || !Object(__WEBPACK_IMPORTED_MODULE_1__is_array__["a"])(data)) {
                    return {};
                  }
                  var result = {};
                  var predicate = Object(__WEBPACK_IMPORTED_MODULE_2__is_function__["a"])(condition) ? condition : function(item) {
                    return item[condition];
                  };
                  var key;
                  Object(__WEBPACK_IMPORTED_MODULE_0__each__["a"])(data, function(item) {
                    key = predicate(item);
                    if (hasOwnProperty.call(result, key)) {
                      result[key].push(item);
                    } else {
                      result[key] = [item];
                    }
                  });
                  return result;
                }
                __webpack_exports__["a"] = groupBy;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                __webpack_exports__["a"] = function(obj, key) {
                  return obj.hasOwnProperty(key);
                };
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__each__ = __webpack_require__2(2);
                var __WEBPACK_IMPORTED_MODULE_1__is_function__ = __webpack_require__2(3);
                var values = Object.values ? function(obj) {
                  return Object.values(obj);
                } : function(obj) {
                  var result = [];
                  Object(__WEBPACK_IMPORTED_MODULE_0__each__["a"])(obj, function(value, key) {
                    if (!(Object(__WEBPACK_IMPORTED_MODULE_1__is_function__["a"])(obj) && key === "prototype")) {
                      result.push(value);
                    }
                  });
                  return result;
                };
                __webpack_exports__["a"] = values;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var toString = {}.toString;
                var getType = function(value) {
                  return toString.call(value).replace(/^\[object /, "").replace(/]$/, "");
                };
                __webpack_exports__["a"] = getType;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var objectProto = Object.prototype;
                var isPrototype = function(value) {
                  var Ctor = value && value.constructor;
                  var proto = typeof Ctor === "function" && Ctor.prototype || objectProto;
                  return value === proto;
                };
                __webpack_exports__["a"] = isPrototype;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__is_object_like__ = __webpack_require__2(15);
                var __WEBPACK_IMPORTED_MODULE_1__is_array_like__ = __webpack_require__2(1);
                var __WEBPACK_IMPORTED_MODULE_2__is_string__ = __webpack_require__2(8);
                var isEqual = function(value, other) {
                  if (value === other) {
                    return true;
                  }
                  if (!value || !other) {
                    return false;
                  }
                  if (Object(__WEBPACK_IMPORTED_MODULE_2__is_string__["a"])(value) || Object(__WEBPACK_IMPORTED_MODULE_2__is_string__["a"])(other)) {
                    return false;
                  }
                  if (Object(__WEBPACK_IMPORTED_MODULE_1__is_array_like__["a"])(value) || Object(__WEBPACK_IMPORTED_MODULE_1__is_array_like__["a"])(other)) {
                    if (value.length !== other.length) {
                      return false;
                    }
                    var rst = true;
                    for (var i = 0; i < value.length; i++) {
                      rst = isEqual(value[i], other[i]);
                      if (!rst) {
                        break;
                      }
                    }
                    return rst;
                  }
                  if (Object(__WEBPACK_IMPORTED_MODULE_0__is_object_like__["a"])(value) || Object(__WEBPACK_IMPORTED_MODULE_0__is_object_like__["a"])(other)) {
                    var valueKeys = Object.keys(value);
                    var otherKeys = Object.keys(other);
                    if (valueKeys.length !== otherKeys.length) {
                      return false;
                    }
                    var rst = true;
                    for (var i = 0; i < valueKeys.length; i++) {
                      rst = isEqual(value[valueKeys[i]], other[valueKeys[i]]);
                      if (!rst) {
                        break;
                      }
                    }
                    return rst;
                  }
                  return false;
                };
                __webpack_exports__["a"] = isEqual;
              },
              function(module3, exports3, __webpack_require__2) {
                var hierarchy = __webpack_require__2(18);
                module3.exports = function(root, options) {
                  var left = hierarchy(root.data, options, true);
                  var right = hierarchy(root.data, options, true);
                  var treeSize = root.children.length;
                  var rightTreeSize = Math.round(treeSize / 2);
                  var getSide = options.getSide || function(child2, index) {
                    if (index < rightTreeSize) {
                      return "right";
                    }
                    return "left";
                  };
                  for (var i = 0; i < treeSize; i++) {
                    var child = root.children[i];
                    var side = getSide(child, i);
                    if (side === "right") {
                      right.children.push(child);
                    } else {
                      left.children.push(child);
                    }
                  }
                  left.eachNode(function(node) {
                    if (!node.isRoot()) {
                      node.side = "left";
                    }
                  });
                  right.eachNode(function(node) {
                    if (!node.isRoot()) {
                      node.side = "right";
                    }
                  });
                  return {
                    left,
                    right
                  };
                };
              },
              function(module3, exports3, __webpack_require__2) {
                var hierarchy = {
                  compactBox: __webpack_require__2(32),
                  dendrogram: __webpack_require__2(114),
                  indented: __webpack_require__2(116),
                  mindmap: __webpack_require__2(118)
                };
                module3.exports = hierarchy;
              },
              function(module3, exports3, __webpack_require__2) {
                function _inheritsLoose(subClass, superClass) {
                  subClass.prototype = Object.create(superClass.prototype);
                  subClass.prototype.constructor = subClass;
                  subClass.__proto__ = superClass;
                }
                var TreeLayout = __webpack_require__2(11);
                var nonLayeredTidyTree = __webpack_require__2(113);
                var doTreeLayout = __webpack_require__2(17);
                var util = __webpack_require__2(7);
                var CompactBoxTreeLayout = function(_TreeLayout) {
                  _inheritsLoose(CompactBoxTreeLayout2, _TreeLayout);
                  function CompactBoxTreeLayout2() {
                    return _TreeLayout.apply(this, arguments) || this;
                  }
                  var _proto = CompactBoxTreeLayout2.prototype;
                  _proto.execute = function execute() {
                    var me = this;
                    return doTreeLayout(me.rootNode, me.options, nonLayeredTidyTree);
                  };
                  return CompactBoxTreeLayout2;
                }(TreeLayout);
                var DEFAULT_OPTIONS = {};
                function compactBoxLayout(root, options) {
                  options = util.assign({}, DEFAULT_OPTIONS, options);
                  return new CompactBoxTreeLayout(root, options).execute();
                }
                module3.exports = compactBoxLayout;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
                var __WEBPACK_IMPORTED_MODULE_0__contains__ = __webpack_require__2(12);
                __webpack_require__2.d(__webpack_exports__, "contains", function() {
                  return __WEBPACK_IMPORTED_MODULE_0__contains__["a"];
                });
                __webpack_require__2.d(__webpack_exports__, "includes", function() {
                  return __WEBPACK_IMPORTED_MODULE_0__contains__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_1__difference__ = __webpack_require__2(34);
                __webpack_require__2.d(__webpack_exports__, "difference", function() {
                  return __WEBPACK_IMPORTED_MODULE_1__difference__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_2__find__ = __webpack_require__2(35);
                __webpack_require__2.d(__webpack_exports__, "find", function() {
                  return __WEBPACK_IMPORTED_MODULE_2__find__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_3__find_index__ = __webpack_require__2(36);
                __webpack_require__2.d(__webpack_exports__, "findIndex", function() {
                  return __WEBPACK_IMPORTED_MODULE_3__find_index__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_4__first_value__ = __webpack_require__2(37);
                __webpack_require__2.d(__webpack_exports__, "firstValue", function() {
                  return __WEBPACK_IMPORTED_MODULE_4__first_value__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_5__flatten__ = __webpack_require__2(38);
                __webpack_require__2.d(__webpack_exports__, "flatten", function() {
                  return __WEBPACK_IMPORTED_MODULE_5__flatten__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_6__flatten_deep__ = __webpack_require__2(39);
                __webpack_require__2.d(__webpack_exports__, "flattenDeep", function() {
                  return __WEBPACK_IMPORTED_MODULE_6__flatten_deep__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_7__get_range__ = __webpack_require__2(40);
                __webpack_require__2.d(__webpack_exports__, "getRange", function() {
                  return __WEBPACK_IMPORTED_MODULE_7__get_range__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_8__pull__ = __webpack_require__2(41);
                __webpack_require__2.d(__webpack_exports__, "pull", function() {
                  return __WEBPACK_IMPORTED_MODULE_8__pull__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_9__pull_at__ = __webpack_require__2(21);
                __webpack_require__2.d(__webpack_exports__, "pullAt", function() {
                  return __WEBPACK_IMPORTED_MODULE_9__pull_at__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_10__reduce__ = __webpack_require__2(42);
                __webpack_require__2.d(__webpack_exports__, "reduce", function() {
                  return __WEBPACK_IMPORTED_MODULE_10__reduce__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_11__remove__ = __webpack_require__2(43);
                __webpack_require__2.d(__webpack_exports__, "remove", function() {
                  return __WEBPACK_IMPORTED_MODULE_11__remove__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_12__sort_by__ = __webpack_require__2(44);
                __webpack_require__2.d(__webpack_exports__, "sortBy", function() {
                  return __WEBPACK_IMPORTED_MODULE_12__sort_by__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_13__union__ = __webpack_require__2(45);
                __webpack_require__2.d(__webpack_exports__, "union", function() {
                  return __WEBPACK_IMPORTED_MODULE_13__union__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_14__uniq__ = __webpack_require__2(22);
                __webpack_require__2.d(__webpack_exports__, "uniq", function() {
                  return __WEBPACK_IMPORTED_MODULE_14__uniq__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_15__values_of_key__ = __webpack_require__2(46);
                __webpack_require__2.d(__webpack_exports__, "valuesOfKey", function() {
                  return __WEBPACK_IMPORTED_MODULE_15__values_of_key__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_16__head__ = __webpack_require__2(47);
                __webpack_require__2.d(__webpack_exports__, "head", function() {
                  return __WEBPACK_IMPORTED_MODULE_16__head__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_17__last__ = __webpack_require__2(48);
                __webpack_require__2.d(__webpack_exports__, "last", function() {
                  return __WEBPACK_IMPORTED_MODULE_17__last__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_18__starts_with__ = __webpack_require__2(49);
                __webpack_require__2.d(__webpack_exports__, "startsWith", function() {
                  return __WEBPACK_IMPORTED_MODULE_18__starts_with__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_19__ends_with__ = __webpack_require__2(50);
                __webpack_require__2.d(__webpack_exports__, "endsWith", function() {
                  return __WEBPACK_IMPORTED_MODULE_19__ends_with__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_20__filter__ = __webpack_require__2(14);
                __webpack_require__2.d(__webpack_exports__, "filter", function() {
                  return __WEBPACK_IMPORTED_MODULE_20__filter__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_21__every__ = __webpack_require__2(51);
                __webpack_require__2.d(__webpack_exports__, "every", function() {
                  return __WEBPACK_IMPORTED_MODULE_21__every__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_22__some__ = __webpack_require__2(52);
                __webpack_require__2.d(__webpack_exports__, "some", function() {
                  return __WEBPACK_IMPORTED_MODULE_22__some__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_23__group__ = __webpack_require__2(53);
                __webpack_require__2.d(__webpack_exports__, "group", function() {
                  return __WEBPACK_IMPORTED_MODULE_23__group__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_24__group_by__ = __webpack_require__2(24);
                __webpack_require__2.d(__webpack_exports__, "groupBy", function() {
                  return __WEBPACK_IMPORTED_MODULE_24__group_by__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_25__group_to_map__ = __webpack_require__2(23);
                __webpack_require__2.d(__webpack_exports__, "groupToMap", function() {
                  return __WEBPACK_IMPORTED_MODULE_25__group_to_map__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_26__get_wrap_behavior__ = __webpack_require__2(54);
                __webpack_require__2.d(__webpack_exports__, "getWrapBehavior", function() {
                  return __WEBPACK_IMPORTED_MODULE_26__get_wrap_behavior__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_27__wrap_behavior__ = __webpack_require__2(55);
                __webpack_require__2.d(__webpack_exports__, "wrapBehavior", function() {
                  return __WEBPACK_IMPORTED_MODULE_27__wrap_behavior__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_28__number2color__ = __webpack_require__2(56);
                __webpack_require__2.d(__webpack_exports__, "number2color", function() {
                  return __WEBPACK_IMPORTED_MODULE_28__number2color__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_29__parse_radius__ = __webpack_require__2(57);
                __webpack_require__2.d(__webpack_exports__, "parseRadius", function() {
                  return __WEBPACK_IMPORTED_MODULE_29__parse_radius__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_30__clamp__ = __webpack_require__2(58);
                __webpack_require__2.d(__webpack_exports__, "clamp", function() {
                  return __WEBPACK_IMPORTED_MODULE_30__clamp__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_31__fixed_base__ = __webpack_require__2(59);
                __webpack_require__2.d(__webpack_exports__, "fixedBase", function() {
                  return __WEBPACK_IMPORTED_MODULE_31__fixed_base__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_32__is_decimal__ = __webpack_require__2(60);
                __webpack_require__2.d(__webpack_exports__, "isDecimal", function() {
                  return __WEBPACK_IMPORTED_MODULE_32__is_decimal__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_33__is_even__ = __webpack_require__2(61);
                __webpack_require__2.d(__webpack_exports__, "isEven", function() {
                  return __WEBPACK_IMPORTED_MODULE_33__is_even__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_34__is_integer__ = __webpack_require__2(62);
                __webpack_require__2.d(__webpack_exports__, "isInteger", function() {
                  return __WEBPACK_IMPORTED_MODULE_34__is_integer__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_35__is_negative__ = __webpack_require__2(63);
                __webpack_require__2.d(__webpack_exports__, "isNegative", function() {
                  return __WEBPACK_IMPORTED_MODULE_35__is_negative__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_36__is_number_equal__ = __webpack_require__2(64);
                __webpack_require__2.d(__webpack_exports__, "isNumberEqual", function() {
                  return __WEBPACK_IMPORTED_MODULE_36__is_number_equal__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_37__is_odd__ = __webpack_require__2(65);
                __webpack_require__2.d(__webpack_exports__, "isOdd", function() {
                  return __WEBPACK_IMPORTED_MODULE_37__is_odd__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_38__is_positive__ = __webpack_require__2(66);
                __webpack_require__2.d(__webpack_exports__, "isPositive", function() {
                  return __WEBPACK_IMPORTED_MODULE_38__is_positive__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_39__max_by__ = __webpack_require__2(67);
                __webpack_require__2.d(__webpack_exports__, "maxBy", function() {
                  return __WEBPACK_IMPORTED_MODULE_39__max_by__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_40__min_by__ = __webpack_require__2(68);
                __webpack_require__2.d(__webpack_exports__, "minBy", function() {
                  return __WEBPACK_IMPORTED_MODULE_40__min_by__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_41__mod__ = __webpack_require__2(69);
                __webpack_require__2.d(__webpack_exports__, "mod", function() {
                  return __WEBPACK_IMPORTED_MODULE_41__mod__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_42__to_degree__ = __webpack_require__2(70);
                __webpack_require__2.d(__webpack_exports__, "toDegree", function() {
                  return __WEBPACK_IMPORTED_MODULE_42__to_degree__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_43__to_integer__ = __webpack_require__2(71);
                __webpack_require__2.d(__webpack_exports__, "toInteger", function() {
                  return __WEBPACK_IMPORTED_MODULE_43__to_integer__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_44__to_radian__ = __webpack_require__2(72);
                __webpack_require__2.d(__webpack_exports__, "toRadian", function() {
                  return __WEBPACK_IMPORTED_MODULE_44__to_radian__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_45__for_in__ = __webpack_require__2(73);
                __webpack_require__2.d(__webpack_exports__, "forIn", function() {
                  return __WEBPACK_IMPORTED_MODULE_45__for_in__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_46__has__ = __webpack_require__2(25);
                __webpack_require__2.d(__webpack_exports__, "has", function() {
                  return __WEBPACK_IMPORTED_MODULE_46__has__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_47__has_key__ = __webpack_require__2(74);
                __webpack_require__2.d(__webpack_exports__, "hasKey", function() {
                  return __WEBPACK_IMPORTED_MODULE_47__has_key__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_48__has_value__ = __webpack_require__2(75);
                __webpack_require__2.d(__webpack_exports__, "hasValue", function() {
                  return __WEBPACK_IMPORTED_MODULE_48__has_value__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_49__keys__ = __webpack_require__2(20);
                __webpack_require__2.d(__webpack_exports__, "keys", function() {
                  return __WEBPACK_IMPORTED_MODULE_49__keys__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_50__is_match__ = __webpack_require__2(19);
                __webpack_require__2.d(__webpack_exports__, "isMatch", function() {
                  return __WEBPACK_IMPORTED_MODULE_50__is_match__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_51__values__ = __webpack_require__2(26);
                __webpack_require__2.d(__webpack_exports__, "values", function() {
                  return __WEBPACK_IMPORTED_MODULE_51__values__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_52__lower_case__ = __webpack_require__2(76);
                __webpack_require__2.d(__webpack_exports__, "lowerCase", function() {
                  return __WEBPACK_IMPORTED_MODULE_52__lower_case__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_53__lower_first__ = __webpack_require__2(77);
                __webpack_require__2.d(__webpack_exports__, "lowerFirst", function() {
                  return __WEBPACK_IMPORTED_MODULE_53__lower_first__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_54__substitute__ = __webpack_require__2(78);
                __webpack_require__2.d(__webpack_exports__, "substitute", function() {
                  return __WEBPACK_IMPORTED_MODULE_54__substitute__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_55__upper_case__ = __webpack_require__2(79);
                __webpack_require__2.d(__webpack_exports__, "upperCase", function() {
                  return __WEBPACK_IMPORTED_MODULE_55__upper_case__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_56__upper_first__ = __webpack_require__2(80);
                __webpack_require__2.d(__webpack_exports__, "upperFirst", function() {
                  return __WEBPACK_IMPORTED_MODULE_56__upper_first__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_57__get_type__ = __webpack_require__2(27);
                __webpack_require__2.d(__webpack_exports__, "getType", function() {
                  return __WEBPACK_IMPORTED_MODULE_57__get_type__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_58__is_arguments__ = __webpack_require__2(81);
                __webpack_require__2.d(__webpack_exports__, "isArguments", function() {
                  return __WEBPACK_IMPORTED_MODULE_58__is_arguments__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_59__is_array__ = __webpack_require__2(0);
                __webpack_require__2.d(__webpack_exports__, "isArray", function() {
                  return __WEBPACK_IMPORTED_MODULE_59__is_array__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_60__is_array_like__ = __webpack_require__2(1);
                __webpack_require__2.d(__webpack_exports__, "isArrayLike", function() {
                  return __WEBPACK_IMPORTED_MODULE_60__is_array_like__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_61__is_boolean__ = __webpack_require__2(82);
                __webpack_require__2.d(__webpack_exports__, "isBoolean", function() {
                  return __WEBPACK_IMPORTED_MODULE_61__is_boolean__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_62__is_date__ = __webpack_require__2(83);
                __webpack_require__2.d(__webpack_exports__, "isDate", function() {
                  return __WEBPACK_IMPORTED_MODULE_62__is_date__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_63__is_error__ = __webpack_require__2(84);
                __webpack_require__2.d(__webpack_exports__, "isError", function() {
                  return __WEBPACK_IMPORTED_MODULE_63__is_error__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_64__is_function__ = __webpack_require__2(3);
                __webpack_require__2.d(__webpack_exports__, "isFunction", function() {
                  return __WEBPACK_IMPORTED_MODULE_64__is_function__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_65__is_finite__ = __webpack_require__2(85);
                __webpack_require__2.d(__webpack_exports__, "isFinite", function() {
                  return __WEBPACK_IMPORTED_MODULE_65__is_finite__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_66__is_nil__ = __webpack_require__2(6);
                __webpack_require__2.d(__webpack_exports__, "isNil", function() {
                  return __WEBPACK_IMPORTED_MODULE_66__is_nil__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_67__is_null__ = __webpack_require__2(86);
                __webpack_require__2.d(__webpack_exports__, "isNull", function() {
                  return __WEBPACK_IMPORTED_MODULE_67__is_null__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_68__is_number__ = __webpack_require__2(5);
                __webpack_require__2.d(__webpack_exports__, "isNumber", function() {
                  return __WEBPACK_IMPORTED_MODULE_68__is_number__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_69__is_object__ = __webpack_require__2(13);
                __webpack_require__2.d(__webpack_exports__, "isObject", function() {
                  return __WEBPACK_IMPORTED_MODULE_69__is_object__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_70__is_object_like__ = __webpack_require__2(15);
                __webpack_require__2.d(__webpack_exports__, "isObjectLike", function() {
                  return __WEBPACK_IMPORTED_MODULE_70__is_object_like__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_71__is_plain_object__ = __webpack_require__2(9);
                __webpack_require__2.d(__webpack_exports__, "isPlainObject", function() {
                  return __WEBPACK_IMPORTED_MODULE_71__is_plain_object__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_72__is_prototype__ = __webpack_require__2(28);
                __webpack_require__2.d(__webpack_exports__, "isPrototype", function() {
                  return __WEBPACK_IMPORTED_MODULE_72__is_prototype__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_73__is_reg_exp__ = __webpack_require__2(87);
                __webpack_require__2.d(__webpack_exports__, "isRegExp", function() {
                  return __WEBPACK_IMPORTED_MODULE_73__is_reg_exp__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_74__is_string__ = __webpack_require__2(8);
                __webpack_require__2.d(__webpack_exports__, "isString", function() {
                  return __WEBPACK_IMPORTED_MODULE_74__is_string__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_75__is_type__ = __webpack_require__2(4);
                __webpack_require__2.d(__webpack_exports__, "isType", function() {
                  return __WEBPACK_IMPORTED_MODULE_75__is_type__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_76__is_undefined__ = __webpack_require__2(88);
                __webpack_require__2.d(__webpack_exports__, "isUndefined", function() {
                  return __WEBPACK_IMPORTED_MODULE_76__is_undefined__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_77__is_element__ = __webpack_require__2(89);
                __webpack_require__2.d(__webpack_exports__, "isElement", function() {
                  return __WEBPACK_IMPORTED_MODULE_77__is_element__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_78__request_animation_frame__ = __webpack_require__2(90);
                __webpack_require__2.d(__webpack_exports__, "requestAnimationFrame", function() {
                  return __WEBPACK_IMPORTED_MODULE_78__request_animation_frame__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_79__clear_animation_frame__ = __webpack_require__2(91);
                __webpack_require__2.d(__webpack_exports__, "clearAnimationFrame", function() {
                  return __WEBPACK_IMPORTED_MODULE_79__clear_animation_frame__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_80__augment__ = __webpack_require__2(92);
                __webpack_require__2.d(__webpack_exports__, "augment", function() {
                  return __WEBPACK_IMPORTED_MODULE_80__augment__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_81__clone__ = __webpack_require__2(93);
                __webpack_require__2.d(__webpack_exports__, "clone", function() {
                  return __WEBPACK_IMPORTED_MODULE_81__clone__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_82__debounce__ = __webpack_require__2(94);
                __webpack_require__2.d(__webpack_exports__, "debounce", function() {
                  return __WEBPACK_IMPORTED_MODULE_82__debounce__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_83__memoize__ = __webpack_require__2(95);
                __webpack_require__2.d(__webpack_exports__, "memoize", function() {
                  return __WEBPACK_IMPORTED_MODULE_83__memoize__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_84__deep_mix__ = __webpack_require__2(96);
                __webpack_require__2.d(__webpack_exports__, "deepMix", function() {
                  return __WEBPACK_IMPORTED_MODULE_84__deep_mix__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_85__each__ = __webpack_require__2(2);
                __webpack_require__2.d(__webpack_exports__, "each", function() {
                  return __WEBPACK_IMPORTED_MODULE_85__each__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_86__extend__ = __webpack_require__2(97);
                __webpack_require__2.d(__webpack_exports__, "extend", function() {
                  return __WEBPACK_IMPORTED_MODULE_86__extend__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_87__index_of__ = __webpack_require__2(98);
                __webpack_require__2.d(__webpack_exports__, "indexOf", function() {
                  return __WEBPACK_IMPORTED_MODULE_87__index_of__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_88__is_empty__ = __webpack_require__2(99);
                __webpack_require__2.d(__webpack_exports__, "isEmpty", function() {
                  return __WEBPACK_IMPORTED_MODULE_88__is_empty__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_89__is_equal__ = __webpack_require__2(29);
                __webpack_require__2.d(__webpack_exports__, "isEqual", function() {
                  return __WEBPACK_IMPORTED_MODULE_89__is_equal__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_90__is_equal_with__ = __webpack_require__2(100);
                __webpack_require__2.d(__webpack_exports__, "isEqualWith", function() {
                  return __WEBPACK_IMPORTED_MODULE_90__is_equal_with__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_91__map__ = __webpack_require__2(101);
                __webpack_require__2.d(__webpack_exports__, "map", function() {
                  return __WEBPACK_IMPORTED_MODULE_91__map__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_92__map_values__ = __webpack_require__2(102);
                __webpack_require__2.d(__webpack_exports__, "mapValues", function() {
                  return __WEBPACK_IMPORTED_MODULE_92__map_values__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_93__mix__ = __webpack_require__2(16);
                __webpack_require__2.d(__webpack_exports__, "mix", function() {
                  return __WEBPACK_IMPORTED_MODULE_93__mix__["a"];
                });
                __webpack_require__2.d(__webpack_exports__, "assign", function() {
                  return __WEBPACK_IMPORTED_MODULE_93__mix__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_94__get__ = __webpack_require__2(103);
                __webpack_require__2.d(__webpack_exports__, "get", function() {
                  return __WEBPACK_IMPORTED_MODULE_94__get__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_95__set__ = __webpack_require__2(104);
                __webpack_require__2.d(__webpack_exports__, "set", function() {
                  return __WEBPACK_IMPORTED_MODULE_95__set__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_96__pick__ = __webpack_require__2(105);
                __webpack_require__2.d(__webpack_exports__, "pick", function() {
                  return __WEBPACK_IMPORTED_MODULE_96__pick__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_97__throttle__ = __webpack_require__2(106);
                __webpack_require__2.d(__webpack_exports__, "throttle", function() {
                  return __WEBPACK_IMPORTED_MODULE_97__throttle__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_98__to_array__ = __webpack_require__2(107);
                __webpack_require__2.d(__webpack_exports__, "toArray", function() {
                  return __WEBPACK_IMPORTED_MODULE_98__to_array__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_99__to_string__ = __webpack_require__2(10);
                __webpack_require__2.d(__webpack_exports__, "toString", function() {
                  return __WEBPACK_IMPORTED_MODULE_99__to_string__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_100__unique_id__ = __webpack_require__2(108);
                __webpack_require__2.d(__webpack_exports__, "uniqueId", function() {
                  return __WEBPACK_IMPORTED_MODULE_100__unique_id__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_101__noop__ = __webpack_require__2(109);
                __webpack_require__2.d(__webpack_exports__, "noop", function() {
                  return __WEBPACK_IMPORTED_MODULE_101__noop__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_102__identity__ = __webpack_require__2(110);
                __webpack_require__2.d(__webpack_exports__, "identity", function() {
                  return __WEBPACK_IMPORTED_MODULE_102__identity__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_103__size__ = __webpack_require__2(111);
                __webpack_require__2.d(__webpack_exports__, "size", function() {
                  return __WEBPACK_IMPORTED_MODULE_103__size__["a"];
                });
                var __WEBPACK_IMPORTED_MODULE_104__cache__ = __webpack_require__2(112);
                __webpack_require__2.d(__webpack_exports__, "Cache", function() {
                  return __WEBPACK_IMPORTED_MODULE_104__cache__["a"];
                });
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__filter__ = __webpack_require__2(14);
                var __WEBPACK_IMPORTED_MODULE_1__contains__ = __webpack_require__2(12);
                var difference = function(arr, values) {
                  if (values === void 0) {
                    values = [];
                  }
                  return Object(__WEBPACK_IMPORTED_MODULE_0__filter__["a"])(arr, function(value) {
                    return !Object(__WEBPACK_IMPORTED_MODULE_1__contains__["a"])(values, value);
                  });
                };
                __webpack_exports__["a"] = difference;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__is_function__ = __webpack_require__2(3);
                var __WEBPACK_IMPORTED_MODULE_1__is_match__ = __webpack_require__2(19);
                var __WEBPACK_IMPORTED_MODULE_2__is_array__ = __webpack_require__2(0);
                var __WEBPACK_IMPORTED_MODULE_3__is_plain_object__ = __webpack_require__2(9);
                function find(arr, predicate) {
                  if (!Object(__WEBPACK_IMPORTED_MODULE_2__is_array__["a"])(arr))
                    return null;
                  var _predicate;
                  if (Object(__WEBPACK_IMPORTED_MODULE_0__is_function__["a"])(predicate)) {
                    _predicate = predicate;
                  }
                  if (Object(__WEBPACK_IMPORTED_MODULE_3__is_plain_object__["a"])(predicate)) {
                    _predicate = function(a) {
                      return Object(__WEBPACK_IMPORTED_MODULE_1__is_match__["a"])(a, predicate);
                    };
                  }
                  if (_predicate) {
                    for (var i = 0; i < arr.length; i += 1) {
                      if (_predicate(arr[i])) {
                        return arr[i];
                      }
                    }
                  }
                  return null;
                }
                __webpack_exports__["a"] = find;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                function findIndex(arr, predicate, fromIndex) {
                  if (fromIndex === void 0) {
                    fromIndex = 0;
                  }
                  for (var i = fromIndex; i < arr.length; i++) {
                    if (predicate(arr[i], i)) {
                      return i;
                    }
                  }
                  return -1;
                }
                __webpack_exports__["a"] = findIndex;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__is_nil__ = __webpack_require__2(6);
                var __WEBPACK_IMPORTED_MODULE_1__is_array__ = __webpack_require__2(0);
                var firstValue = function(data, name) {
                  var rst = null;
                  for (var i = 0; i < data.length; i++) {
                    var obj = data[i];
                    var value = obj[name];
                    if (!Object(__WEBPACK_IMPORTED_MODULE_0__is_nil__["a"])(value)) {
                      if (Object(__WEBPACK_IMPORTED_MODULE_1__is_array__["a"])(value)) {
                        rst = value[0];
                      } else {
                        rst = value;
                      }
                      break;
                    }
                  }
                  return rst;
                };
                __webpack_exports__["a"] = firstValue;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__is_array__ = __webpack_require__2(0);
                var flatten = function(arr) {
                  if (!Object(__WEBPACK_IMPORTED_MODULE_0__is_array__["a"])(arr)) {
                    return [];
                  }
                  var rst = [];
                  for (var i = 0; i < arr.length; i++) {
                    rst = rst.concat(arr[i]);
                  }
                  return rst;
                };
                __webpack_exports__["a"] = flatten;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__is_array__ = __webpack_require__2(0);
                var flattenDeep = function(arr, result) {
                  if (result === void 0) {
                    result = [];
                  }
                  if (!Object(__WEBPACK_IMPORTED_MODULE_0__is_array__["a"])(arr)) {
                    result.push(arr);
                  } else {
                    for (var i = 0; i < arr.length; i += 1) {
                      flattenDeep(arr[i], result);
                    }
                  }
                  return result;
                };
                __webpack_exports__["a"] = flattenDeep;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__is_array__ = __webpack_require__2(0);
                var __WEBPACK_IMPORTED_MODULE_1__filter__ = __webpack_require__2(14);
                var getRange = function(values) {
                  values = Object(__WEBPACK_IMPORTED_MODULE_1__filter__["a"])(values, function(v) {
                    return !isNaN(v);
                  });
                  if (!values.length) {
                    return {
                      min: 0,
                      max: 0
                    };
                  }
                  if (Object(__WEBPACK_IMPORTED_MODULE_0__is_array__["a"])(values[0])) {
                    var tmp = [];
                    for (var i = 0; i < values.length; i++) {
                      tmp = tmp.concat(values[i]);
                    }
                    values = tmp;
                  }
                  var max = Math.max.apply(null, values);
                  var min = Math.min.apply(null, values);
                  return {
                    min,
                    max
                  };
                };
                __webpack_exports__["a"] = getRange;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var arrPrototype = Array.prototype;
                var splice = arrPrototype.splice;
                var indexOf = arrPrototype.indexOf;
                var pull = function(arr) {
                  var values = [];
                  for (var _i = 1; _i < arguments.length; _i++) {
                    values[_i - 1] = arguments[_i];
                  }
                  for (var i = 0; i < values.length; i++) {
                    var value = values[i];
                    var fromIndex = -1;
                    while ((fromIndex = indexOf.call(arr, value)) > -1) {
                      splice.call(arr, fromIndex, 1);
                    }
                  }
                  return arr;
                };
                __webpack_exports__["a"] = pull;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__each__ = __webpack_require__2(2);
                var __WEBPACK_IMPORTED_MODULE_1__is_array__ = __webpack_require__2(0);
                var __WEBPACK_IMPORTED_MODULE_2__is_plain_object__ = __webpack_require__2(9);
                var reduce = function(arr, fn, init) {
                  if (!Object(__WEBPACK_IMPORTED_MODULE_1__is_array__["a"])(arr) && !Object(__WEBPACK_IMPORTED_MODULE_2__is_plain_object__["a"])(arr)) {
                    return arr;
                  }
                  var result = init;
                  Object(__WEBPACK_IMPORTED_MODULE_0__each__["a"])(arr, function(data, i) {
                    result = fn(result, data, i);
                  });
                  return result;
                };
                __webpack_exports__["a"] = reduce;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__is_array_like__ = __webpack_require__2(1);
                var __WEBPACK_IMPORTED_MODULE_1__pull_at__ = __webpack_require__2(21);
                var remove = function(arr, predicate) {
                  var result = [];
                  if (!Object(__WEBPACK_IMPORTED_MODULE_0__is_array_like__["a"])(arr)) {
                    return result;
                  }
                  var i = -1;
                  var indexes = [];
                  var length = arr.length;
                  while (++i < length) {
                    var value = arr[i];
                    if (predicate(value, i, arr)) {
                      result.push(value);
                      indexes.push(i);
                    }
                  }
                  Object(__WEBPACK_IMPORTED_MODULE_1__pull_at__["a"])(arr, indexes);
                  return result;
                };
                __webpack_exports__["a"] = remove;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__is_array__ = __webpack_require__2(0);
                var __WEBPACK_IMPORTED_MODULE_1__is_string__ = __webpack_require__2(8);
                var __WEBPACK_IMPORTED_MODULE_2__is_function__ = __webpack_require__2(3);
                function sortBy(arr, key) {
                  var comparer;
                  if (Object(__WEBPACK_IMPORTED_MODULE_2__is_function__["a"])(key)) {
                    comparer = function(a, b) {
                      return key(a) - key(b);
                    };
                  } else {
                    var keys_1 = [];
                    if (Object(__WEBPACK_IMPORTED_MODULE_1__is_string__["a"])(key)) {
                      keys_1.push(key);
                    } else if (Object(__WEBPACK_IMPORTED_MODULE_0__is_array__["a"])(key)) {
                      keys_1 = key;
                    }
                    comparer = function(a, b) {
                      for (var i = 0; i < keys_1.length; i += 1) {
                        var prop = keys_1[i];
                        if (a[prop] > b[prop]) {
                          return 1;
                        }
                        if (a[prop] < b[prop]) {
                          return -1;
                        }
                      }
                      return 0;
                    };
                  }
                  arr.sort(comparer);
                  return arr;
                }
                __webpack_exports__["a"] = sortBy;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__uniq__ = __webpack_require__2(22);
                var union = function() {
                  var sources = [];
                  for (var _i = 0; _i < arguments.length; _i++) {
                    sources[_i] = arguments[_i];
                  }
                  return Object(__WEBPACK_IMPORTED_MODULE_0__uniq__["a"])([].concat.apply([], sources));
                };
                __webpack_exports__["a"] = union;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__each__ = __webpack_require__2(2);
                var __WEBPACK_IMPORTED_MODULE_1__is_array__ = __webpack_require__2(0);
                var __WEBPACK_IMPORTED_MODULE_2__is_nil__ = __webpack_require__2(6);
                __webpack_exports__["a"] = function(data, name) {
                  var rst = [];
                  var tmpMap = {};
                  data.forEach(function(obj) {
                    var value = obj[name];
                    if (!Object(__WEBPACK_IMPORTED_MODULE_2__is_nil__["a"])(value)) {
                      if (!Object(__WEBPACK_IMPORTED_MODULE_1__is_array__["a"])(value)) {
                        value = [value];
                      }
                      Object(__WEBPACK_IMPORTED_MODULE_0__each__["a"])(value, function(val) {
                        if (!tmpMap[val]) {
                          rst.push(val);
                          tmpMap[val] = true;
                        }
                      });
                    }
                  });
                  return rst;
                };
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                __webpack_exports__["a"] = head;
                var __WEBPACK_IMPORTED_MODULE_0__is_array_like__ = __webpack_require__2(1);
                function head(o) {
                  if (Object(__WEBPACK_IMPORTED_MODULE_0__is_array_like__["a"])(o)) {
                    return o[0];
                  }
                  return void 0;
                }
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                __webpack_exports__["a"] = last;
                var __WEBPACK_IMPORTED_MODULE_0__is_array_like__ = __webpack_require__2(1);
                function last(o) {
                  if (Object(__WEBPACK_IMPORTED_MODULE_0__is_array_like__["a"])(o)) {
                    var arr = o;
                    return arr[arr.length - 1];
                  }
                  return void 0;
                }
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__is_array__ = __webpack_require__2(0);
                var __WEBPACK_IMPORTED_MODULE_1__is_string__ = __webpack_require__2(8);
                function startsWith(arr, e) {
                  return Object(__WEBPACK_IMPORTED_MODULE_0__is_array__["a"])(arr) || Object(__WEBPACK_IMPORTED_MODULE_1__is_string__["a"])(arr) ? arr[0] === e : false;
                }
                __webpack_exports__["a"] = startsWith;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__is_array__ = __webpack_require__2(0);
                var __WEBPACK_IMPORTED_MODULE_1__is_string__ = __webpack_require__2(8);
                function endsWith(arr, e) {
                  return Object(__WEBPACK_IMPORTED_MODULE_0__is_array__["a"])(arr) || Object(__WEBPACK_IMPORTED_MODULE_1__is_string__["a"])(arr) ? arr[arr.length - 1] === e : false;
                }
                __webpack_exports__["a"] = endsWith;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var every = function(arr, func) {
                  for (var i = 0; i < arr.length; i++) {
                    if (!func(arr[i], i))
                      return false;
                  }
                  return true;
                };
                __webpack_exports__["a"] = every;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var some = function(arr, func) {
                  for (var i = 0; i < arr.length; i++) {
                    if (func(arr[i], i))
                      return true;
                  }
                  return false;
                };
                __webpack_exports__["a"] = some;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__group_to_map__ = __webpack_require__2(23);
                __webpack_exports__["a"] = function(data, condition) {
                  if (!condition) {
                    return [data];
                  }
                  var groups = Object(__WEBPACK_IMPORTED_MODULE_0__group_to_map__["a"])(data, condition);
                  var array = [];
                  for (var i in groups) {
                    array.push(groups[i]);
                  }
                  return array;
                };
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                function getWrapBehavior(obj, action) {
                  return obj["_wrap_" + action];
                }
                __webpack_exports__["a"] = getWrapBehavior;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                function wrapBehavior(obj, action) {
                  if (obj["_wrap_" + action]) {
                    return obj["_wrap_" + action];
                  }
                  var method = function(e) {
                    obj[action](e);
                  };
                  obj["_wrap_" + action] = method;
                  return method;
                }
                __webpack_exports__["a"] = wrapBehavior;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var numColorCache = {};
                function numberToColor(num) {
                  var color = numColorCache[num];
                  if (!color) {
                    var str = num.toString(16);
                    for (var i = str.length; i < 6; i++) {
                      str = "0" + str;
                    }
                    color = "#" + str;
                    numColorCache[num] = color;
                  }
                  return color;
                }
                __webpack_exports__["a"] = numberToColor;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__is_array__ = __webpack_require__2(0);
                function parseRadius(radius) {
                  var r1 = 0, r2 = 0, r3 = 0, r4 = 0;
                  if (Object(__WEBPACK_IMPORTED_MODULE_0__is_array__["a"])(radius)) {
                    if (radius.length === 1) {
                      r1 = r2 = r3 = r4 = radius[0];
                    } else if (radius.length === 2) {
                      r1 = r3 = radius[0];
                      r2 = r4 = radius[1];
                    } else if (radius.length === 3) {
                      r1 = radius[0];
                      r2 = r4 = radius[1];
                      r3 = radius[2];
                    } else {
                      r1 = radius[0];
                      r2 = radius[1];
                      r3 = radius[2];
                      r4 = radius[3];
                    }
                  } else {
                    r1 = r2 = r3 = r4 = radius;
                  }
                  return {
                    r1,
                    r2,
                    r3,
                    r4
                  };
                }
                __webpack_exports__["a"] = parseRadius;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var clamp = function(a, min, max) {
                  if (a < min) {
                    return min;
                  } else if (a > max) {
                    return max;
                  }
                  return a;
                };
                __webpack_exports__["a"] = clamp;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var fixedBase = function(v, base) {
                  var str = base.toString();
                  var index = str.indexOf(".");
                  if (index === -1) {
                    return Math.round(v);
                  }
                  var length = str.substr(index + 1).length;
                  if (length > 20) {
                    length = 20;
                  }
                  return parseFloat(v.toFixed(length));
                };
                __webpack_exports__["a"] = fixedBase;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__is_number__ = __webpack_require__2(5);
                var isDecimal = function(num) {
                  return Object(__WEBPACK_IMPORTED_MODULE_0__is_number__["a"])(num) && num % 1 !== 0;
                };
                __webpack_exports__["a"] = isDecimal;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__is_number__ = __webpack_require__2(5);
                var isEven = function(num) {
                  return Object(__WEBPACK_IMPORTED_MODULE_0__is_number__["a"])(num) && num % 2 === 0;
                };
                __webpack_exports__["a"] = isEven;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__is_number__ = __webpack_require__2(5);
                var isInteger = Number.isInteger ? Number.isInteger : function(num) {
                  return Object(__WEBPACK_IMPORTED_MODULE_0__is_number__["a"])(num) && num % 1 === 0;
                };
                __webpack_exports__["a"] = isInteger;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__is_number__ = __webpack_require__2(5);
                var isNegative = function(num) {
                  return Object(__WEBPACK_IMPORTED_MODULE_0__is_number__["a"])(num) && num < 0;
                };
                __webpack_exports__["a"] = isNegative;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                __webpack_exports__["a"] = isNumberEqual;
                var PRECISION = 1e-5;
                function isNumberEqual(a, b, precision) {
                  if (precision === void 0) {
                    precision = PRECISION;
                  }
                  return Math.abs(a - b) < precision;
                }
                ;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__is_number__ = __webpack_require__2(5);
                var isOdd = function(num) {
                  return Object(__WEBPACK_IMPORTED_MODULE_0__is_number__["a"])(num) && num % 2 !== 0;
                };
                __webpack_exports__["a"] = isOdd;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__is_number__ = __webpack_require__2(5);
                var isPositive = function(num) {
                  return Object(__WEBPACK_IMPORTED_MODULE_0__is_number__["a"])(num) && num > 0;
                };
                __webpack_exports__["a"] = isPositive;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__each__ = __webpack_require__2(2);
                var __WEBPACK_IMPORTED_MODULE_1__is_array__ = __webpack_require__2(0);
                var __WEBPACK_IMPORTED_MODULE_2__is_function__ = __webpack_require__2(3);
                __webpack_exports__["a"] = function(arr, fn) {
                  if (!Object(__WEBPACK_IMPORTED_MODULE_1__is_array__["a"])(arr)) {
                    return void 0;
                  }
                  var max = arr[0];
                  var maxData;
                  if (Object(__WEBPACK_IMPORTED_MODULE_2__is_function__["a"])(fn)) {
                    maxData = fn(arr[0]);
                  } else {
                    maxData = arr[0][fn];
                  }
                  var data;
                  Object(__WEBPACK_IMPORTED_MODULE_0__each__["a"])(arr, function(val) {
                    if (Object(__WEBPACK_IMPORTED_MODULE_2__is_function__["a"])(fn)) {
                      data = fn(val);
                    } else {
                      data = val[fn];
                    }
                    if (data > maxData) {
                      max = val;
                      maxData = data;
                    }
                  });
                  return max;
                };
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__each__ = __webpack_require__2(2);
                var __WEBPACK_IMPORTED_MODULE_1__is_array__ = __webpack_require__2(0);
                var __WEBPACK_IMPORTED_MODULE_2__is_function__ = __webpack_require__2(3);
                __webpack_exports__["a"] = function(arr, fn) {
                  if (!Object(__WEBPACK_IMPORTED_MODULE_1__is_array__["a"])(arr)) {
                    return void 0;
                  }
                  var min = arr[0];
                  var minData;
                  if (Object(__WEBPACK_IMPORTED_MODULE_2__is_function__["a"])(fn)) {
                    minData = fn(arr[0]);
                  } else {
                    minData = arr[0][fn];
                  }
                  var data;
                  Object(__WEBPACK_IMPORTED_MODULE_0__each__["a"])(arr, function(val) {
                    if (Object(__WEBPACK_IMPORTED_MODULE_2__is_function__["a"])(fn)) {
                      data = fn(val);
                    } else {
                      data = val[fn];
                    }
                    if (data < minData) {
                      min = val;
                      minData = data;
                    }
                  });
                  return min;
                };
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var mod = function(n, m) {
                  return (n % m + m) % m;
                };
                __webpack_exports__["a"] = mod;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var DEGREE = 180 / Math.PI;
                var toDegree = function(radian) {
                  return DEGREE * radian;
                };
                __webpack_exports__["a"] = toDegree;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                __webpack_exports__["a"] = parseInt;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var RADIAN = Math.PI / 180;
                var toRadian = function(degree) {
                  return RADIAN * degree;
                };
                __webpack_exports__["a"] = toRadian;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__each__ = __webpack_require__2(2);
                __webpack_exports__["a"] = __WEBPACK_IMPORTED_MODULE_0__each__["a"];
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__has__ = __webpack_require__2(25);
                __webpack_exports__["a"] = __WEBPACK_IMPORTED_MODULE_0__has__["a"];
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__contains__ = __webpack_require__2(12);
                var __WEBPACK_IMPORTED_MODULE_1__values__ = __webpack_require__2(26);
                __webpack_exports__["a"] = function(obj, value) {
                  return Object(__WEBPACK_IMPORTED_MODULE_0__contains__["a"])(Object(__WEBPACK_IMPORTED_MODULE_1__values__["a"])(obj), value);
                };
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__to_string__ = __webpack_require__2(10);
                var lowerCase = function(str) {
                  return Object(__WEBPACK_IMPORTED_MODULE_0__to_string__["a"])(str).toLowerCase();
                };
                __webpack_exports__["a"] = lowerCase;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__to_string__ = __webpack_require__2(10);
                var lowerFirst = function(value) {
                  var str = Object(__WEBPACK_IMPORTED_MODULE_0__to_string__["a"])(value);
                  return str.charAt(0).toLowerCase() + str.substring(1);
                };
                __webpack_exports__["a"] = lowerFirst;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                function substitute(str, o) {
                  if (!str || !o) {
                    return str;
                  }
                  return str.replace(/\\?\{([^{}]+)\}/g, function(match, name) {
                    if (match.charAt(0) === "\\") {
                      return match.slice(1);
                    }
                    return o[name] === void 0 ? "" : o[name];
                  });
                }
                __webpack_exports__["a"] = substitute;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__to_string__ = __webpack_require__2(10);
                var upperCase = function(str) {
                  return Object(__WEBPACK_IMPORTED_MODULE_0__to_string__["a"])(str).toUpperCase();
                };
                __webpack_exports__["a"] = upperCase;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__to_string__ = __webpack_require__2(10);
                var upperFirst = function(value) {
                  var str = Object(__WEBPACK_IMPORTED_MODULE_0__to_string__["a"])(value);
                  return str.charAt(0).toUpperCase() + str.substring(1);
                };
                __webpack_exports__["a"] = upperFirst;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__is_type__ = __webpack_require__2(4);
                var isArguments = function(value) {
                  return Object(__WEBPACK_IMPORTED_MODULE_0__is_type__["a"])(value, "Arguments");
                };
                __webpack_exports__["a"] = isArguments;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__is_type__ = __webpack_require__2(4);
                var isBoolean = function(value) {
                  return Object(__WEBPACK_IMPORTED_MODULE_0__is_type__["a"])(value, "Boolean");
                };
                __webpack_exports__["a"] = isBoolean;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__is_type__ = __webpack_require__2(4);
                var isDate = function(value) {
                  return Object(__WEBPACK_IMPORTED_MODULE_0__is_type__["a"])(value, "Date");
                };
                __webpack_exports__["a"] = isDate;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__is_type__ = __webpack_require__2(4);
                var isError = function(value) {
                  return Object(__WEBPACK_IMPORTED_MODULE_0__is_type__["a"])(value, "Error");
                };
                __webpack_exports__["a"] = isError;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__is_number__ = __webpack_require__2(5);
                __webpack_exports__["a"] = function(value) {
                  return Object(__WEBPACK_IMPORTED_MODULE_0__is_number__["a"])(value) && isFinite(value);
                };
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var isNull = function(value) {
                  return value === null;
                };
                __webpack_exports__["a"] = isNull;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__is_type__ = __webpack_require__2(4);
                var isRegExp = function(str) {
                  return Object(__WEBPACK_IMPORTED_MODULE_0__is_type__["a"])(str, "RegExp");
                };
                __webpack_exports__["a"] = isRegExp;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var isUndefined = function(value) {
                  return value === void 0;
                };
                __webpack_exports__["a"] = isUndefined;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var isElement = function(o) {
                  return o instanceof Element || o instanceof HTMLDocument;
                };
                __webpack_exports__["a"] = isElement;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                __webpack_exports__["a"] = requestAnimationFrame;
                function requestAnimationFrame(fn) {
                  var method = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function(f) {
                    return setTimeout(f, 16);
                  };
                  return method(fn);
                }
                ;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                __webpack_exports__["a"] = cancelAnimationFrame;
                function cancelAnimationFrame(handler) {
                  var method = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.msCancelAnimationFrame || clearTimeout;
                  method(handler);
                }
                ;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__mix__ = __webpack_require__2(16);
                var __WEBPACK_IMPORTED_MODULE_1__is_function__ = __webpack_require__2(3);
                var augment = function() {
                  var args = [];
                  for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                  }
                  var c = args[0];
                  for (var i = 1; i < args.length; i++) {
                    var obj = args[i];
                    if (Object(__WEBPACK_IMPORTED_MODULE_1__is_function__["a"])(obj)) {
                      obj = obj.prototype;
                    }
                    Object(__WEBPACK_IMPORTED_MODULE_0__mix__["a"])(c.prototype, obj);
                  }
                };
                __webpack_exports__["a"] = augment;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__is_array__ = __webpack_require__2(0);
                var clone = function(obj) {
                  if (typeof obj !== "object" || obj === null) {
                    return obj;
                  }
                  var rst;
                  if (Object(__WEBPACK_IMPORTED_MODULE_0__is_array__["a"])(obj)) {
                    rst = [];
                    for (var i = 0, l = obj.length; i < l; i++) {
                      if (typeof obj[i] === "object" && obj[i] != null) {
                        rst[i] = clone(obj[i]);
                      } else {
                        rst[i] = obj[i];
                      }
                    }
                  } else {
                    rst = {};
                    for (var k in obj) {
                      if (typeof obj[k] === "object" && obj[k] != null) {
                        rst[k] = clone(obj[k]);
                      } else {
                        rst[k] = obj[k];
                      }
                    }
                  }
                  return rst;
                };
                __webpack_exports__["a"] = clone;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                function debounce(func, wait, immediate) {
                  var timeout;
                  return function() {
                    var context = this, args = arguments;
                    var later = function() {
                      timeout = null;
                      if (!immediate) {
                        func.apply(context, args);
                      }
                    };
                    var callNow = immediate && !timeout;
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                    if (callNow) {
                      func.apply(context, args);
                    }
                  };
                }
                __webpack_exports__["a"] = debounce;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__is_function__ = __webpack_require__2(3);
                __webpack_exports__["a"] = function(f, resolver) {
                  if (!Object(__WEBPACK_IMPORTED_MODULE_0__is_function__["a"])(f)) {
                    throw new TypeError("Expected a function");
                  }
                  var memoized = function() {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                      args[_i] = arguments[_i];
                    }
                    var key = resolver ? resolver.apply(this, args) : args[0];
                    var cache = memoized.cache;
                    if (cache.has(key)) {
                      return cache.get(key);
                    }
                    var result = f.apply(this, args);
                    cache.set(key, result);
                    return result;
                  };
                  memoized.cache = /* @__PURE__ */ new Map();
                  return memoized;
                };
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__is_array__ = __webpack_require__2(0);
                var __WEBPACK_IMPORTED_MODULE_1__is_plain_object__ = __webpack_require__2(9);
                var MAX_MIX_LEVEL = 5;
                function _deepMix(dist, src, level, maxLevel) {
                  level = level || 0;
                  maxLevel = maxLevel || MAX_MIX_LEVEL;
                  for (var key in src) {
                    if (src.hasOwnProperty(key)) {
                      var value = src[key];
                      if (value !== null && Object(__WEBPACK_IMPORTED_MODULE_1__is_plain_object__["a"])(value)) {
                        if (!Object(__WEBPACK_IMPORTED_MODULE_1__is_plain_object__["a"])(dist[key])) {
                          dist[key] = {};
                        }
                        if (level < maxLevel) {
                          _deepMix(dist[key], value, level + 1, maxLevel);
                        } else {
                          dist[key] = src[key];
                        }
                      } else if (Object(__WEBPACK_IMPORTED_MODULE_0__is_array__["a"])(value)) {
                        dist[key] = [];
                        dist[key] = dist[key].concat(value);
                      } else if (value !== void 0) {
                        dist[key] = value;
                      }
                    }
                  }
                }
                var deepMix = function(rst) {
                  var args = [];
                  for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                  }
                  for (var i = 0; i < args.length; i += 1) {
                    _deepMix(rst, args[i]);
                  }
                  return rst;
                };
                __webpack_exports__["a"] = deepMix;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__mix__ = __webpack_require__2(16);
                var __WEBPACK_IMPORTED_MODULE_1__is_function__ = __webpack_require__2(3);
                var extend = function(subclass, superclass, overrides, staticOverrides) {
                  if (!Object(__WEBPACK_IMPORTED_MODULE_1__is_function__["a"])(superclass)) {
                    overrides = superclass;
                    superclass = subclass;
                    subclass = function() {
                    };
                  }
                  var create = Object.create ? function(proto, c) {
                    return Object.create(proto, {
                      constructor: {
                        value: c
                      }
                    });
                  } : function(proto, c) {
                    function Tmp() {
                    }
                    Tmp.prototype = proto;
                    var o = new Tmp();
                    o.constructor = c;
                    return o;
                  };
                  var superObj = create(superclass.prototype, subclass);
                  subclass.prototype = Object(__WEBPACK_IMPORTED_MODULE_0__mix__["a"])(superObj, subclass.prototype);
                  subclass.superclass = create(superclass.prototype, superclass);
                  Object(__WEBPACK_IMPORTED_MODULE_0__mix__["a"])(superObj, overrides);
                  Object(__WEBPACK_IMPORTED_MODULE_0__mix__["a"])(subclass, staticOverrides);
                  return subclass;
                };
                __webpack_exports__["a"] = extend;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__is_array_like__ = __webpack_require__2(1);
                var indexOf = function(arr, obj) {
                  if (!Object(__WEBPACK_IMPORTED_MODULE_0__is_array_like__["a"])(arr)) {
                    return -1;
                  }
                  var m = Array.prototype.indexOf;
                  if (m) {
                    return m.call(arr, obj);
                  }
                  var index = -1;
                  for (var i = 0; i < arr.length; i++) {
                    if (arr[i] === obj) {
                      index = i;
                      break;
                    }
                  }
                  return index;
                };
                __webpack_exports__["a"] = indexOf;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__is_nil__ = __webpack_require__2(6);
                var __WEBPACK_IMPORTED_MODULE_1__is_array_like__ = __webpack_require__2(1);
                var __WEBPACK_IMPORTED_MODULE_2__get_type__ = __webpack_require__2(27);
                var __WEBPACK_IMPORTED_MODULE_3__is_prototype__ = __webpack_require__2(28);
                var hasOwnProperty = Object.prototype.hasOwnProperty;
                function isEmpty(value) {
                  if (Object(__WEBPACK_IMPORTED_MODULE_0__is_nil__["a"])(value)) {
                    return true;
                  }
                  if (Object(__WEBPACK_IMPORTED_MODULE_1__is_array_like__["a"])(value)) {
                    return !value.length;
                  }
                  var type = Object(__WEBPACK_IMPORTED_MODULE_2__get_type__["a"])(value);
                  if (type === "Map" || type === "Set") {
                    return !value.size;
                  }
                  if (Object(__WEBPACK_IMPORTED_MODULE_3__is_prototype__["a"])(value)) {
                    return !Object.keys(value).length;
                  }
                  for (var key in value) {
                    if (hasOwnProperty.call(value, key)) {
                      return false;
                    }
                  }
                  return true;
                }
                __webpack_exports__["a"] = isEmpty;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__is_function__ = __webpack_require__2(3);
                var __WEBPACK_IMPORTED_MODULE_1__is_equal__ = __webpack_require__2(29);
                __webpack_exports__["a"] = function(value, other, fn) {
                  if (!Object(__WEBPACK_IMPORTED_MODULE_0__is_function__["a"])(fn)) {
                    return Object(__WEBPACK_IMPORTED_MODULE_1__is_equal__["a"])(value, other);
                  }
                  return !!fn(value, other);
                };
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__each__ = __webpack_require__2(2);
                var __WEBPACK_IMPORTED_MODULE_1__is_array_like__ = __webpack_require__2(1);
                var map = function(arr, func) {
                  if (!Object(__WEBPACK_IMPORTED_MODULE_1__is_array_like__["a"])(arr)) {
                    return arr;
                  }
                  var result = [];
                  Object(__WEBPACK_IMPORTED_MODULE_0__each__["a"])(arr, function(value, index) {
                    result.push(func(value, index));
                  });
                  return result;
                };
                __webpack_exports__["a"] = map;
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__is_nil__ = __webpack_require__2(6);
                var __WEBPACK_IMPORTED_MODULE_1__is_object__ = __webpack_require__2(13);
                var identity = function(v) {
                  return v;
                };
                __webpack_exports__["a"] = function(object, func) {
                  if (func === void 0) {
                    func = identity;
                  }
                  var r = {};
                  if (Object(__WEBPACK_IMPORTED_MODULE_1__is_object__["a"])(object) && !Object(__WEBPACK_IMPORTED_MODULE_0__is_nil__["a"])(object)) {
                    Object.keys(object).forEach(function(key) {
                      r[key] = func(object[key], key);
                    });
                  }
                  return r;
                };
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__is_string__ = __webpack_require__2(8);
                __webpack_exports__["a"] = function(obj, key, defaultValue) {
                  var p = 0;
                  var keyArr = Object(__WEBPACK_IMPORTED_MODULE_0__is_string__["a"])(key) ? key.split(".") : key;
                  while (obj && p < keyArr.length) {
                    obj = obj[keyArr[p++]];
                  }
                  return obj === void 0 || p < keyArr.length ? defaultValue : obj;
                };
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__is_object__ = __webpack_require__2(13);
                var __WEBPACK_IMPORTED_MODULE_1__is_string__ = __webpack_require__2(8);
                var __WEBPACK_IMPORTED_MODULE_2__is_number__ = __webpack_require__2(5);
                __webpack_exports__["a"] = function(obj, path, value) {
                  var o = obj;
                  var keyArr = Object(__WEBPACK_IMPORTED_MODULE_1__is_string__["a"])(path) ? path.split(".") : path;
                  keyArr.forEach(function(key, idx) {
                    if (idx < keyArr.length - 1) {
                      if (!Object(__WEBPACK_IMPORTED_MODULE_0__is_object__["a"])(o[key])) {
                        o[key] = Object(__WEBPACK_IMPORTED_MODULE_2__is_number__["a"])(keyArr[idx + 1]) ? [] : {};
                      }
                      o = o[key];
                    } else {
                      o[key] = value;
                    }
                  });
                  return obj;
                };
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__each__ = __webpack_require__2(2);
                var __WEBPACK_IMPORTED_MODULE_1__is_plain_object__ = __webpack_require__2(9);
                var hasOwnProperty = Object.prototype.hasOwnProperty;
                __webpack_exports__["a"] = function(object, keys) {
                  if (object === null || !Object(__WEBPACK_IMPORTED_MODULE_1__is_plain_object__["a"])(object)) {
                    return {};
                  }
                  var result = {};
                  Object(__WEBPACK_IMPORTED_MODULE_0__each__["a"])(keys, function(key) {
                    if (hasOwnProperty.call(object, key)) {
                      result[key] = object[key];
                    }
                  });
                  return result;
                };
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                __webpack_exports__["a"] = function(func, wait, options) {
                  var timeout, context, args, result;
                  var previous = 0;
                  if (!options)
                    options = {};
                  var later = function() {
                    previous = options.leading === false ? 0 : Date.now();
                    timeout = null;
                    result = func.apply(context, args);
                    if (!timeout)
                      context = args = null;
                  };
                  var throttled = function() {
                    var now = Date.now();
                    if (!previous && options.leading === false)
                      previous = now;
                    var remaining = wait - (now - previous);
                    context = this;
                    args = arguments;
                    if (remaining <= 0 || remaining > wait) {
                      if (timeout) {
                        clearTimeout(timeout);
                        timeout = null;
                      }
                      previous = now;
                      result = func.apply(context, args);
                      if (!timeout)
                        context = args = null;
                    } else if (!timeout && options.trailing !== false) {
                      timeout = setTimeout(later, remaining);
                    }
                    return result;
                  };
                  throttled.cancel = function() {
                    clearTimeout(timeout);
                    previous = 0;
                    timeout = context = args = null;
                  };
                  return throttled;
                };
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var __WEBPACK_IMPORTED_MODULE_0__is_array_like__ = __webpack_require__2(1);
                __webpack_exports__["a"] = function(value) {
                  return Object(__WEBPACK_IMPORTED_MODULE_0__is_array_like__["a"])(value) ? Array.prototype.slice.call(value) : [];
                };
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var map = {};
                __webpack_exports__["a"] = function(prefix) {
                  prefix = prefix || "g";
                  if (!map[prefix]) {
                    map[prefix] = 1;
                  } else {
                    map[prefix] += 1;
                  }
                  return prefix + map[prefix];
                };
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                __webpack_exports__["a"] = function() {
                };
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                __webpack_exports__["a"] = function(v) {
                  return v;
                };
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                __webpack_exports__["a"] = size;
                var __WEBPACK_IMPORTED_MODULE_0__is_nil__ = __webpack_require__2(6);
                var __WEBPACK_IMPORTED_MODULE_1__is_array_like__ = __webpack_require__2(1);
                function size(o) {
                  if (Object(__WEBPACK_IMPORTED_MODULE_0__is_nil__["a"])(o)) {
                    return 0;
                  }
                  if (Object(__WEBPACK_IMPORTED_MODULE_1__is_array_like__["a"])(o)) {
                    return o.length;
                  }
                  return Object.keys(o).length;
                }
              },
              function(module3, __webpack_exports__, __webpack_require__2) {
                "use strict";
                var default_1 = function() {
                  function default_12() {
                    this.map = {};
                  }
                  default_12.prototype.has = function(key) {
                    return this.map[key] !== void 0;
                  };
                  default_12.prototype.get = function(key, def) {
                    var v = this.map[key];
                    return v === void 0 ? def : v;
                  };
                  default_12.prototype.set = function(key, value) {
                    this.map[key] = value;
                  };
                  default_12.prototype.clear = function() {
                    this.map = {};
                  };
                  default_12.prototype.delete = function(key) {
                    delete this.map[key];
                  };
                  default_12.prototype.size = function() {
                    return Object.keys(this.map).length;
                  };
                  return default_12;
                }();
                __webpack_exports__["a"] = default_1;
              },
              function(module3, exports3) {
                function WrappedTree(w, h, y, c) {
                  if (c === void 0) {
                    c = [];
                  }
                  var me = this;
                  me.w = w || 0;
                  me.h = h || 0;
                  me.y = y || 0;
                  me.x = 0;
                  me.c = c || [];
                  me.cs = c.length;
                  me.prelim = 0;
                  me.mod = 0;
                  me.shift = 0;
                  me.change = 0;
                  me.tl = null;
                  me.tr = null;
                  me.el = null;
                  me.er = null;
                  me.msel = 0;
                  me.mser = 0;
                }
                WrappedTree.fromNode = function(root, isHorizontal) {
                  if (!root)
                    return null;
                  var children = [];
                  root.children.forEach(function(child) {
                    children.push(WrappedTree.fromNode(child, isHorizontal));
                  });
                  if (isHorizontal)
                    return new WrappedTree(root.height, root.width, root.x, children);
                  return new WrappedTree(root.width, root.height, root.y, children);
                };
                function moveRight(node, move, isHorizontal) {
                  if (isHorizontal) {
                    node.y += move;
                  } else {
                    node.x += move;
                  }
                  node.children.forEach(function(child) {
                    moveRight(child, move, isHorizontal);
                  });
                }
                function getMin(node, isHorizontal) {
                  var res = isHorizontal ? node.y : node.x;
                  node.children.forEach(function(child) {
                    res = Math.min(getMin(child, isHorizontal), res);
                  });
                  return res;
                }
                function normalize(node, isHorizontal) {
                  var min = getMin(node, isHorizontal);
                  moveRight(node, -min, isHorizontal);
                }
                function convertBack(converted, root, isHorizontal) {
                  if (isHorizontal) {
                    root.y = converted.x;
                  } else {
                    root.x = converted.x;
                  }
                  converted.c.forEach(function(child, i) {
                    convertBack(child, root.children[i], isHorizontal);
                  });
                }
                function layer(node, isHorizontal, d) {
                  if (d === void 0) {
                    d = 0;
                  }
                  if (isHorizontal) {
                    node.x = d;
                    d += node.width;
                  } else {
                    node.y = d;
                    d += node.height;
                  }
                  node.children.forEach(function(child) {
                    layer(child, isHorizontal, d);
                  });
                }
                module3.exports = function(root, options) {
                  if (options === void 0) {
                    options = {};
                  }
                  var isHorizontal = options.isHorizontal;
                  function firstWalk(t) {
                    if (t.cs === 0) {
                      setExtremes(t);
                      return;
                    }
                    firstWalk(t.c[0]);
                    var ih = updateIYL(bottom(t.c[0].el), 0, null);
                    for (var i = 1; i < t.cs; ++i) {
                      firstWalk(t.c[i]);
                      var min = bottom(t.c[i].er);
                      separate(t, i, ih);
                      ih = updateIYL(min, i, ih);
                    }
                    positionRoot(t);
                    setExtremes(t);
                  }
                  function setExtremes(t) {
                    if (t.cs === 0) {
                      t.el = t;
                      t.er = t;
                      t.msel = t.mser = 0;
                    } else {
                      t.el = t.c[0].el;
                      t.msel = t.c[0].msel;
                      t.er = t.c[t.cs - 1].er;
                      t.mser = t.c[t.cs - 1].mser;
                    }
                  }
                  function separate(t, i, ih) {
                    var sr = t.c[i - 1];
                    var mssr = sr.mod;
                    var cl = t.c[i];
                    var mscl = cl.mod;
                    while (sr !== null && cl !== null) {
                      if (bottom(sr) > ih.low)
                        ih = ih.nxt;
                      var dist = mssr + sr.prelim + sr.w - (mscl + cl.prelim);
                      if (dist > 0) {
                        mscl += dist;
                        moveSubtree(t, i, ih.index, dist);
                      }
                      var sy = bottom(sr);
                      var cy = bottom(cl);
                      if (sy <= cy) {
                        sr = nextRightContour(sr);
                        if (sr !== null)
                          mssr += sr.mod;
                      }
                      if (sy >= cy) {
                        cl = nextLeftContour(cl);
                        if (cl !== null)
                          mscl += cl.mod;
                      }
                    }
                    if (!sr && !!cl) {
                      setLeftThread(t, i, cl, mscl);
                    } else if (!!sr && !cl) {
                      setRightThread(t, i, sr, mssr);
                    }
                  }
                  function moveSubtree(t, i, si, dist) {
                    t.c[i].mod += dist;
                    t.c[i].msel += dist;
                    t.c[i].mser += dist;
                    distributeExtra(t, i, si, dist);
                  }
                  function nextLeftContour(t) {
                    return t.cs === 0 ? t.tl : t.c[0];
                  }
                  function nextRightContour(t) {
                    return t.cs === 0 ? t.tr : t.c[t.cs - 1];
                  }
                  function bottom(t) {
                    return t.y + t.h;
                  }
                  function setLeftThread(t, i, cl, modsumcl) {
                    var li = t.c[0].el;
                    li.tl = cl;
                    var diff = modsumcl - cl.mod - t.c[0].msel;
                    li.mod += diff;
                    li.prelim -= diff;
                    t.c[0].el = t.c[i].el;
                    t.c[0].msel = t.c[i].msel;
                  }
                  function setRightThread(t, i, sr, modsumsr) {
                    var ri = t.c[i].er;
                    ri.tr = sr;
                    var diff = modsumsr - sr.mod - t.c[i].mser;
                    ri.mod += diff;
                    ri.prelim -= diff;
                    t.c[i].er = t.c[i - 1].er;
                    t.c[i].mser = t.c[i - 1].mser;
                  }
                  function positionRoot(t) {
                    t.prelim = (t.c[0].prelim + t.c[0].mod + t.c[t.cs - 1].mod + t.c[t.cs - 1].prelim + t.c[t.cs - 1].w) / 2 - t.w / 2;
                  }
                  function secondWalk(t, modsum) {
                    modsum += t.mod;
                    t.x = t.prelim + modsum;
                    addChildSpacing(t);
                    for (var i = 0; i < t.cs; i++) {
                      secondWalk(t.c[i], modsum);
                    }
                  }
                  function distributeExtra(t, i, si, dist) {
                    if (si !== i - 1) {
                      var nr = i - si;
                      t.c[si + 1].shift += dist / nr;
                      t.c[i].shift -= dist / nr;
                      t.c[i].change -= dist - dist / nr;
                    }
                  }
                  function addChildSpacing(t) {
                    var d = 0;
                    var modsumdelta = 0;
                    for (var i = 0; i < t.cs; i++) {
                      d += t.c[i].shift;
                      modsumdelta += d + t.c[i].change;
                      t.c[i].mod += modsumdelta;
                    }
                  }
                  function updateIYL(low, index, ih) {
                    while (ih !== null && low >= ih.low) {
                      ih = ih.nxt;
                    }
                    return {
                      low,
                      index,
                      nxt: ih
                    };
                  }
                  layer(root, isHorizontal);
                  var wt = WrappedTree.fromNode(root, isHorizontal);
                  firstWalk(wt);
                  secondWalk(wt, 0);
                  convertBack(wt, root, isHorizontal);
                  normalize(root, isHorizontal);
                  return root;
                };
              },
              function(module3, exports3, __webpack_require__2) {
                function _inheritsLoose(subClass, superClass) {
                  subClass.prototype = Object.create(superClass.prototype);
                  subClass.prototype.constructor = subClass;
                  subClass.__proto__ = superClass;
                }
                var TreeLayout = __webpack_require__2(11);
                var dendrogram = __webpack_require__2(115);
                var doTreeLayout = __webpack_require__2(17);
                var util = __webpack_require__2(7);
                var DendrogramLayout = function(_TreeLayout) {
                  _inheritsLoose(DendrogramLayout2, _TreeLayout);
                  function DendrogramLayout2() {
                    return _TreeLayout.apply(this, arguments) || this;
                  }
                  var _proto = DendrogramLayout2.prototype;
                  _proto.execute = function execute() {
                    var me = this;
                    me.rootNode.width = 0;
                    return doTreeLayout(me.rootNode, me.options, dendrogram);
                  };
                  return DendrogramLayout2;
                }(TreeLayout);
                var DEFAULT_OPTIONS = {};
                function dendrogramLayout(root, options) {
                  options = util.assign({}, DEFAULT_OPTIONS, options);
                  return new DendrogramLayout(root, options).execute();
                }
                module3.exports = dendrogramLayout;
              },
              function(module3, exports3, __webpack_require__2) {
                var util = __webpack_require__2(7);
                function WrappedTree(height, children) {
                  if (height === void 0) {
                    height = 0;
                  }
                  if (children === void 0) {
                    children = [];
                  }
                  var me = this;
                  me.x = me.y = 0;
                  me.leftChild = me.rightChild = null;
                  me.height = 0;
                  me.children = children;
                }
                var DEFAULT_OPTIONS = {
                  isHorizontal: true,
                  nodeSep: 20,
                  nodeSize: 20,
                  rankSep: 200,
                  subTreeSep: 10
                };
                function convertBack(converted, root, isHorizontal) {
                  if (isHorizontal) {
                    root.x = converted.x;
                    root.y = converted.y;
                  } else {
                    root.x = converted.y;
                    root.y = converted.x;
                  }
                  converted.children.forEach(function(child, i) {
                    convertBack(child, root.children[i], isHorizontal);
                  });
                }
                module3.exports = function(root, options) {
                  if (options === void 0) {
                    options = {};
                  }
                  options = util.assign({}, DEFAULT_OPTIONS, options);
                  var maxDepth = 0;
                  function wrappedTreeFromNode(n) {
                    if (!n)
                      return null;
                    n.width = 0;
                    if (n.depth && n.depth > maxDepth) {
                      maxDepth = n.depth;
                    }
                    var children = n.children;
                    var childrenCount = children.length;
                    var t = new WrappedTree(n.height, []);
                    children.forEach(function(child, i) {
                      var childWT = wrappedTreeFromNode(child);
                      t.children.push(childWT);
                      if (i === 0) {
                        t.leftChild = childWT;
                      }
                      if (i === childrenCount - 1) {
                        t.rightChild = childWT;
                      }
                    });
                    t.originNode = n;
                    t.isLeaf = n.isLeaf();
                    return t;
                  }
                  function getDrawingDepth(t) {
                    if (t.isLeaf || t.children.length === 0) {
                      t.drawingDepth = maxDepth;
                    } else {
                      var depths = t.children.map(function(child) {
                        return getDrawingDepth(child);
                      });
                      var minChildDepth = Math.min.apply(null, depths);
                      t.drawingDepth = minChildDepth - 1;
                    }
                    return t.drawingDepth;
                  }
                  var prevLeaf;
                  function position(t) {
                    t.x = t.drawingDepth * options.rankSep;
                    if (t.isLeaf) {
                      t.y = 0;
                      if (prevLeaf) {
                        t.y = prevLeaf.y + prevLeaf.height + options.nodeSep;
                        if (t.originNode.parent !== prevLeaf.originNode.parent) {
                          t.y += options.subTreeSep;
                        }
                      }
                      prevLeaf = t;
                    } else {
                      t.children.forEach(function(child) {
                        position(child);
                      });
                      t.y = (t.leftChild.y + t.rightChild.y) / 2;
                    }
                  }
                  var wt = wrappedTreeFromNode(root);
                  getDrawingDepth(wt);
                  position(wt);
                  convertBack(wt, root, options.isHorizontal);
                  return root;
                };
              },
              function(module3, exports3, __webpack_require__2) {
                function _inheritsLoose(subClass, superClass) {
                  subClass.prototype = Object.create(superClass.prototype);
                  subClass.prototype.constructor = subClass;
                  subClass.__proto__ = superClass;
                }
                var TreeLayout = __webpack_require__2(11);
                var indentedTree = __webpack_require__2(117);
                var separateTree = __webpack_require__2(30);
                var util = __webpack_require__2(7);
                var VALID_DIRECTIONS = [
                  "LR",
                  "RL",
                  "H"
                ];
                var DEFAULT_DIRECTION = VALID_DIRECTIONS[0];
                var IndentedLayout = function(_TreeLayout) {
                  _inheritsLoose(IndentedLayout2, _TreeLayout);
                  function IndentedLayout2() {
                    return _TreeLayout.apply(this, arguments) || this;
                  }
                  var _proto = IndentedLayout2.prototype;
                  _proto.execute = function execute() {
                    var me = this;
                    var options = me.options;
                    var root = me.rootNode;
                    options.isHorizontal = true;
                    var _options$indent = options.indent, indent = _options$indent === void 0 ? 20 : _options$indent, _options$dropCap = options.dropCap, dropCap = _options$dropCap === void 0 ? true : _options$dropCap;
                    var direction = options.direction || DEFAULT_DIRECTION;
                    if (direction && VALID_DIRECTIONS.indexOf(direction) === -1) {
                      throw new TypeError("Invalid direction: " + direction);
                    }
                    if (direction === VALID_DIRECTIONS[0]) {
                      indentedTree(root, indent, dropCap);
                    } else if (direction === VALID_DIRECTIONS[1]) {
                      indentedTree(root, indent, dropCap);
                      root.right2left();
                    } else if (direction === VALID_DIRECTIONS[2]) {
                      var _separateTree = separateTree(root, options), left = _separateTree.left, right = _separateTree.right;
                      indentedTree(left, indent, dropCap);
                      left.right2left();
                      indentedTree(right, indent, dropCap);
                      var bbox = left.getBoundingBox();
                      right.translate(bbox.width, 0);
                      root.x = right.x - root.width / 2;
                    }
                    return root;
                  };
                  return IndentedLayout2;
                }(TreeLayout);
                var DEFAULT_OPTIONS = {};
                function indentedLayout(root, options) {
                  options = util.assign({}, DEFAULT_OPTIONS, options);
                  return new IndentedLayout(root, options).execute();
                }
                module3.exports = indentedLayout;
              },
              function(module3, exports3) {
                function positionNode(node, previousNode, dx, dropCap) {
                  if (!dropCap) {
                    try {
                      if (node.id === node.parent.children[0].id) {
                        node.x += dx * node.depth;
                        node.y = previousNode ? previousNode.y : 0;
                        return;
                      }
                    } catch (e) {
                    }
                  }
                  node.x += dx * node.depth;
                  node.y = previousNode ? previousNode.y + previousNode.height : 0;
                  return;
                }
                module3.exports = function(root, indent, dropCap) {
                  var previousNode = null;
                  root.eachNode(function(node) {
                    positionNode(node, previousNode, indent, dropCap);
                    previousNode = node;
                  });
                };
              },
              function(module3, exports3, __webpack_require__2) {
                function _inheritsLoose(subClass, superClass) {
                  subClass.prototype = Object.create(superClass.prototype);
                  subClass.prototype.constructor = subClass;
                  subClass.__proto__ = superClass;
                }
                var TreeLayout = __webpack_require__2(11);
                var mindmap = __webpack_require__2(119);
                var doTreeLayout = __webpack_require__2(17);
                var util = __webpack_require__2(7);
                var MindmapLayout = function(_TreeLayout) {
                  _inheritsLoose(MindmapLayout2, _TreeLayout);
                  function MindmapLayout2() {
                    return _TreeLayout.apply(this, arguments) || this;
                  }
                  var _proto = MindmapLayout2.prototype;
                  _proto.execute = function execute() {
                    var me = this;
                    return doTreeLayout(me.rootNode, me.options, mindmap);
                  };
                  return MindmapLayout2;
                }(TreeLayout);
                var DEFAULT_OPTIONS = {};
                function mindmapLayout(root, options) {
                  options = util.assign({}, DEFAULT_OPTIONS, options);
                  return new MindmapLayout(root, options).execute();
                }
                module3.exports = mindmapLayout;
              },
              function(module3, exports3, __webpack_require__2) {
                var util = __webpack_require__2(7);
                function secondWalk(node, options) {
                  var totalHeight = 0;
                  if (!node.children.length) {
                    totalHeight = node.height;
                  } else {
                    node.children.forEach(function(c) {
                      totalHeight += secondWalk(c, options);
                    });
                  }
                  node._subTreeSep = options.getSubTreeSep(node.data);
                  node.totalHeight = Math.max(node.height, totalHeight) + 2 * node._subTreeSep;
                  return node.totalHeight;
                }
                function thirdWalk(node) {
                  var children = node.children;
                  var len = children.length;
                  if (len) {
                    children.forEach(function(c) {
                      thirdWalk(c);
                    });
                    var first = children[0];
                    var last = children[len - 1];
                    var childrenHeight = last.y - first.y + last.height;
                    var childrenTotalHeight = 0;
                    children.forEach(function(child) {
                      childrenTotalHeight += child.totalHeight;
                    });
                    if (childrenHeight > node.height) {
                      node.y = first.y + childrenHeight / 2 - node.height / 2;
                    } else if (children.length !== 1 || node.height > childrenTotalHeight) {
                      var offset = node.y + (node.height - childrenHeight) / 2 - first.y;
                      children.forEach(function(c) {
                        c.translate(0, offset);
                      });
                    } else {
                      node.y = (first.y + first.height / 2 + last.y + last.height / 2) / 2 - node.height / 2;
                    }
                  }
                }
                var DEFAULT_OPTIONS = {
                  getSubTreeSep: function getSubTreeSep() {
                    return 0;
                  }
                };
                module3.exports = function(root, options) {
                  if (options === void 0) {
                    options = {};
                  }
                  options = util.assign({}, DEFAULT_OPTIONS, options);
                  root.parent = {
                    x: 0,
                    width: 0,
                    height: 0,
                    y: 0
                  };
                  root.BFTraverse(function(node) {
                    node.x = node.parent.x + node.parent.width;
                  });
                  root.parent = null;
                  secondWalk(root, options);
                  root.startY = 0;
                  root.y = root.totalHeight / 2 - root.height / 2;
                  root.eachNode(function(node) {
                    var children = node.children;
                    var len = children.length;
                    if (len) {
                      var first = children[0];
                      first.startY = node.startY + node._subTreeSep;
                      if (len === 1) {
                        first.y = node.y + node.height / 2 - first.height / 2;
                      } else {
                        first.y = first.startY + first.totalHeight / 2 - first.height / 2;
                        for (var i = 1; i < len; i++) {
                          var c = children[i];
                          c.startY = children[i - 1].startY + children[i - 1].totalHeight;
                          c.y = c.startY + c.totalHeight / 2 - c.height / 2;
                        }
                      }
                    }
                  });
                  thirdWalk(root);
                };
              }
            ]);
          });
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/augment.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var mix_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/mix.js");
          var is_function_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-function.js");
          var augment = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var c = args[0];
            for (var i = 1; i < args.length; i++) {
              var obj = args[i];
              if (is_function_1.default(obj)) {
                obj = obj.prototype;
              }
              mix_1.default(c.prototype, obj);
            }
          };
          exports2.default = augment;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/cache.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var default_1 = function() {
            function default_12() {
              this.map = {};
            }
            default_12.prototype.has = function(key) {
              return this.map[key] !== void 0;
            };
            default_12.prototype.get = function(key, def) {
              var v = this.map[key];
              return v === void 0 ? def : v;
            };
            default_12.prototype.set = function(key, value) {
              this.map[key] = value;
            };
            default_12.prototype.clear = function() {
              this.map = {};
            };
            default_12.prototype.delete = function(key) {
              delete this.map[key];
            };
            default_12.prototype.size = function() {
              return Object.keys(this.map).length;
            };
            return default_12;
          }();
          exports2.default = default_1;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/clamp.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var clamp = function(a, min, max) {
            if (a < min) {
              return min;
            } else if (a > max) {
              return max;
            }
            return a;
          };
          exports2.default = clamp;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/clear-animation-frame.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          function cancelAnimationFrame(handler) {
            var method = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.msCancelAnimationFrame || clearTimeout;
            method(handler);
          }
          exports2.default = cancelAnimationFrame;
          ;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/clone.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_array_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-array.js");
          var clone = function(obj) {
            if (typeof obj !== "object" || obj === null) {
              return obj;
            }
            var rst;
            if (is_array_1.default(obj)) {
              rst = [];
              for (var i = 0, l = obj.length; i < l; i++) {
                if (typeof obj[i] === "object" && obj[i] != null) {
                  rst[i] = clone(obj[i]);
                } else {
                  rst[i] = obj[i];
                }
              }
            } else {
              rst = {};
              for (var k in obj) {
                if (typeof obj[k] === "object" && obj[k] != null) {
                  rst[k] = clone(obj[k]);
                } else {
                  rst[k] = obj[k];
                }
              }
            }
            return rst;
          };
          exports2.default = clone;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/contains.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_array_like_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-array-like.js");
          var contains = function(arr, value) {
            if (!is_array_like_1.default(arr)) {
              return false;
            }
            return arr.indexOf(value) > -1;
          };
          exports2.default = contains;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/debounce.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          function debounce(func, wait, immediate) {
            var timeout;
            return function() {
              var context = this, args = arguments;
              var later = function() {
                timeout = null;
                if (!immediate) {
                  func.apply(context, args);
                }
              };
              var callNow = immediate && !timeout;
              clearTimeout(timeout);
              timeout = setTimeout(later, wait);
              if (callNow) {
                func.apply(context, args);
              }
            };
          }
          exports2.default = debounce;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/deep-mix.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_array_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-array.js");
          var is_plain_object_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-plain-object.js");
          var MAX_MIX_LEVEL = 5;
          function _deepMix(dist, src, level, maxLevel) {
            level = level || 0;
            maxLevel = maxLevel || MAX_MIX_LEVEL;
            for (var key in src) {
              if (src.hasOwnProperty(key)) {
                var value = src[key];
                if (value !== null && is_plain_object_1.default(value)) {
                  if (!is_plain_object_1.default(dist[key])) {
                    dist[key] = {};
                  }
                  if (level < maxLevel) {
                    _deepMix(dist[key], value, level + 1, maxLevel);
                  } else {
                    dist[key] = src[key];
                  }
                } else if (is_array_1.default(value)) {
                  dist[key] = [];
                  dist[key] = dist[key].concat(value);
                } else if (value !== void 0) {
                  dist[key] = value;
                }
              }
            }
          }
          var deepMix = function(rst) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
              args[_i - 1] = arguments[_i];
            }
            for (var i = 0; i < args.length; i += 1) {
              _deepMix(rst, args[i]);
            }
            return rst;
          };
          exports2.default = deepMix;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/difference.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var filter_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/filter.js");
          var contains_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/contains.js");
          var difference = function(arr, values) {
            if (values === void 0) {
              values = [];
            }
            return filter_1.default(arr, function(value) {
              return !contains_1.default(values, value);
            });
          };
          exports2.default = difference;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/each.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_array_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-array.js");
          var is_object_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-object.js");
          function each(elements, func) {
            if (!elements) {
              return;
            }
            var rst;
            if (is_array_1.default(elements)) {
              for (var i = 0, len = elements.length; i < len; i++) {
                rst = func(elements[i], i);
                if (rst === false) {
                  break;
                }
              }
            } else if (is_object_1.default(elements)) {
              for (var k in elements) {
                if (elements.hasOwnProperty(k)) {
                  rst = func(elements[k], k);
                  if (rst === false) {
                    break;
                  }
                }
              }
            }
          }
          exports2.default = each;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/ends-with.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_array_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-array.js");
          var is_string_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-string.js");
          function endsWith(arr, e) {
            return is_array_1.default(arr) || is_string_1.default(arr) ? arr[arr.length - 1] === e : false;
          }
          exports2.default = endsWith;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/every.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var every = function(arr, func) {
            for (var i = 0; i < arr.length; i++) {
              if (!func(arr[i], i))
                return false;
            }
            return true;
          };
          exports2.default = every;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/extend.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var mix_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/mix.js");
          var is_function_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-function.js");
          var extend = function(subclass, superclass, overrides, staticOverrides) {
            if (!is_function_1.default(superclass)) {
              overrides = superclass;
              superclass = subclass;
              subclass = function() {
              };
            }
            var create = Object.create ? function(proto, c) {
              return Object.create(proto, {
                constructor: {
                  value: c
                }
              });
            } : function(proto, c) {
              function Tmp() {
              }
              Tmp.prototype = proto;
              var o = new Tmp();
              o.constructor = c;
              return o;
            };
            var superObj = create(superclass.prototype, subclass);
            subclass.prototype = mix_1.default(superObj, subclass.prototype);
            subclass.superclass = create(superclass.prototype, superclass);
            mix_1.default(superObj, overrides);
            mix_1.default(subclass, staticOverrides);
            return subclass;
          };
          exports2.default = extend;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/filter.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_array_like_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-array-like.js");
          var filter = function(arr, func) {
            if (!is_array_like_1.default(arr)) {
              return arr;
            }
            var result = [];
            for (var index = 0; index < arr.length; index++) {
              var value = arr[index];
              if (func(value, index)) {
                result.push(value);
              }
            }
            return result;
          };
          exports2.default = filter;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/find-index.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          function findIndex(arr, predicate, fromIndex) {
            if (fromIndex === void 0) {
              fromIndex = 0;
            }
            for (var i = fromIndex; i < arr.length; i++) {
              if (predicate(arr[i], i)) {
                return i;
              }
            }
            return -1;
          }
          exports2.default = findIndex;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/find.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_function_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-function.js");
          var is_match_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-match.js");
          var is_array_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-array.js");
          var is_plain_object_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-plain-object.js");
          function find(arr, predicate) {
            if (!is_array_1.default(arr))
              return null;
            var _predicate;
            if (is_function_1.default(predicate)) {
              _predicate = predicate;
            }
            if (is_plain_object_1.default(predicate)) {
              _predicate = function(a) {
                return is_match_1.default(a, predicate);
              };
            }
            if (_predicate) {
              for (var i = 0; i < arr.length; i += 1) {
                if (_predicate(arr[i])) {
                  return arr[i];
                }
              }
            }
            return null;
          }
          exports2.default = find;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/first-value.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_nil_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-nil.js");
          var is_array_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-array.js");
          var firstValue = function(data, name) {
            var rst = null;
            for (var i = 0; i < data.length; i++) {
              var obj = data[i];
              var value = obj[name];
              if (!is_nil_1.default(value)) {
                if (is_array_1.default(value)) {
                  rst = value[0];
                } else {
                  rst = value;
                }
                break;
              }
            }
            return rst;
          };
          exports2.default = firstValue;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/fixed-base.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var fixedBase = function(v, base) {
            var str = base.toString();
            var index = str.indexOf(".");
            if (index === -1) {
              return Math.round(v);
            }
            var length = str.substr(index + 1).length;
            if (length > 20) {
              length = 20;
            }
            return parseFloat(v.toFixed(length));
          };
          exports2.default = fixedBase;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/flatten-deep.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_array_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-array.js");
          var flattenDeep = function(arr, result) {
            if (result === void 0) {
              result = [];
            }
            if (!is_array_1.default(arr)) {
              result.push(arr);
            } else {
              for (var i = 0; i < arr.length; i += 1) {
                flattenDeep(arr[i], result);
              }
            }
            return result;
          };
          exports2.default = flattenDeep;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/flatten.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_array_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-array.js");
          var flatten = function(arr) {
            if (!is_array_1.default(arr)) {
              return [];
            }
            var rst = [];
            for (var i = 0; i < arr.length; i++) {
              rst = rst.concat(arr[i]);
            }
            return rst;
          };
          exports2.default = flatten;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/for-in.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var each_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/each.js");
          exports2.default = each_1.default;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/get-range.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_array_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-array.js");
          var getRange = function(values) {
            var filterValues = values.filter(function(v) {
              return !isNaN(v);
            });
            if (!filterValues.length) {
              return {
                min: 0,
                max: 0
              };
            }
            if (is_array_1.default(values[0])) {
              var tmp = [];
              for (var i = 0; i < values.length; i++) {
                tmp = tmp.concat(values[i]);
              }
              filterValues = tmp;
            }
            var max = Math.max.apply(null, filterValues);
            var min = Math.min.apply(null, filterValues);
            return {
              min,
              max
            };
          };
          exports2.default = getRange;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/get-type.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var toString = {}.toString;
          var getType = function(value) {
            return toString.call(value).replace(/^\[object /, "").replace(/]$/, "");
          };
          exports2.default = getType;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/get-wrap-behavior.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          function getWrapBehavior(obj, action) {
            return obj["_wrap_" + action];
          }
          exports2.default = getWrapBehavior;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/get.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_string_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-string.js");
          exports2.default = function(obj, key, defaultValue) {
            var p = 0;
            var keyArr = is_string_1.default(key) ? key.split(".") : key;
            while (obj && p < keyArr.length) {
              obj = obj[keyArr[p++]];
            }
            return obj === void 0 || p < keyArr.length ? defaultValue : obj;
          };
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/group-by.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_array_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-array.js");
          var is_function_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-function.js");
          var hasOwnProperty = Object.prototype.hasOwnProperty;
          function groupBy(data, condition) {
            if (!condition || !is_array_1.default(data)) {
              return {};
            }
            var result = {};
            var predicate = is_function_1.default(condition) ? condition : function(item2) {
              return item2[condition];
            };
            var key;
            for (var i = 0; i < data.length; i++) {
              var item = data[i];
              key = predicate(item);
              if (hasOwnProperty.call(result, key)) {
                result[key].push(item);
              } else {
                result[key] = [item];
              }
            }
            return result;
          }
          exports2.default = groupBy;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/group-to-map.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_array_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-array.js");
          var is_function_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-function.js");
          var group_by_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/group-by.js");
          var groupToMap = function(data, condition) {
            if (!condition) {
              return {
                0: data
              };
            }
            if (!is_function_1.default(condition)) {
              var paramsCondition_1 = is_array_1.default(condition) ? condition : condition.replace(/\s+/g, "").split("*");
              condition = function(row) {
                var unique = "_";
                for (var i = 0, l = paramsCondition_1.length; i < l; i++) {
                  unique += row[paramsCondition_1[i]] && row[paramsCondition_1[i]].toString();
                }
                return unique;
              };
            }
            var groups = group_by_1.default(data, condition);
            return groups;
          };
          exports2.default = groupToMap;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/group.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var group_to_map_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/group-to-map.js");
          exports2.default = function(data, condition) {
            if (!condition) {
              return [data];
            }
            var groups = group_to_map_1.default(data, condition);
            var array = [];
            for (var i in groups) {
              array.push(groups[i]);
            }
            return array;
          };
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/has-key.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var has_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/has.js");
          exports2.default = has_1.default;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/has-value.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var contains_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/contains.js");
          var values_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/values.js");
          exports2.default = function(obj, value) {
            return contains_1.default(values_1.default(obj), value);
          };
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/has.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.default = function(obj, key) {
            return obj.hasOwnProperty(key);
          };
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/head.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_array_like_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-array-like.js");
          function head(o) {
            if (is_array_like_1.default(o)) {
              return o[0];
            }
            return void 0;
          }
          exports2.default = head;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/identity.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.default = function(v) {
            return v;
          };
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/index-of.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_array_like_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-array-like.js");
          var indexOf = function(arr, obj) {
            if (!is_array_like_1.default(arr)) {
              return -1;
            }
            var m = Array.prototype.indexOf;
            if (m) {
              return m.call(arr, obj);
            }
            var index = -1;
            for (var i = 0; i < arr.length; i++) {
              if (arr[i] === obj) {
                index = i;
                break;
              }
            }
            return index;
          };
          exports2.default = indexOf;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var contains_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/contains.js");
          Object.defineProperty(exports2, "contains", { enumerable: true, get: function() {
            return contains_1.default;
          } });
          Object.defineProperty(exports2, "includes", { enumerable: true, get: function() {
            return contains_1.default;
          } });
          var difference_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/difference.js");
          Object.defineProperty(exports2, "difference", { enumerable: true, get: function() {
            return difference_1.default;
          } });
          var find_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/find.js");
          Object.defineProperty(exports2, "find", { enumerable: true, get: function() {
            return find_1.default;
          } });
          var find_index_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/find-index.js");
          Object.defineProperty(exports2, "findIndex", { enumerable: true, get: function() {
            return find_index_1.default;
          } });
          var first_value_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/first-value.js");
          Object.defineProperty(exports2, "firstValue", { enumerable: true, get: function() {
            return first_value_1.default;
          } });
          var flatten_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/flatten.js");
          Object.defineProperty(exports2, "flatten", { enumerable: true, get: function() {
            return flatten_1.default;
          } });
          var flatten_deep_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/flatten-deep.js");
          Object.defineProperty(exports2, "flattenDeep", { enumerable: true, get: function() {
            return flatten_deep_1.default;
          } });
          var get_range_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/get-range.js");
          Object.defineProperty(exports2, "getRange", { enumerable: true, get: function() {
            return get_range_1.default;
          } });
          var pull_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/pull.js");
          Object.defineProperty(exports2, "pull", { enumerable: true, get: function() {
            return pull_1.default;
          } });
          var pull_at_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/pull-at.js");
          Object.defineProperty(exports2, "pullAt", { enumerable: true, get: function() {
            return pull_at_1.default;
          } });
          var reduce_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/reduce.js");
          Object.defineProperty(exports2, "reduce", { enumerable: true, get: function() {
            return reduce_1.default;
          } });
          var remove_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/remove.js");
          Object.defineProperty(exports2, "remove", { enumerable: true, get: function() {
            return remove_1.default;
          } });
          var sort_by_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/sort-by.js");
          Object.defineProperty(exports2, "sortBy", { enumerable: true, get: function() {
            return sort_by_1.default;
          } });
          var union_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/union.js");
          Object.defineProperty(exports2, "union", { enumerable: true, get: function() {
            return union_1.default;
          } });
          var uniq_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/uniq.js");
          Object.defineProperty(exports2, "uniq", { enumerable: true, get: function() {
            return uniq_1.default;
          } });
          var values_of_key_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/values-of-key.js");
          Object.defineProperty(exports2, "valuesOfKey", { enumerable: true, get: function() {
            return values_of_key_1.default;
          } });
          var head_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/head.js");
          Object.defineProperty(exports2, "head", { enumerable: true, get: function() {
            return head_1.default;
          } });
          var last_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/last.js");
          Object.defineProperty(exports2, "last", { enumerable: true, get: function() {
            return last_1.default;
          } });
          var starts_with_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/starts-with.js");
          Object.defineProperty(exports2, "startsWith", { enumerable: true, get: function() {
            return starts_with_1.default;
          } });
          var ends_with_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/ends-with.js");
          Object.defineProperty(exports2, "endsWith", { enumerable: true, get: function() {
            return ends_with_1.default;
          } });
          var filter_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/filter.js");
          Object.defineProperty(exports2, "filter", { enumerable: true, get: function() {
            return filter_1.default;
          } });
          var every_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/every.js");
          Object.defineProperty(exports2, "every", { enumerable: true, get: function() {
            return every_1.default;
          } });
          var some_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/some.js");
          Object.defineProperty(exports2, "some", { enumerable: true, get: function() {
            return some_1.default;
          } });
          var group_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/group.js");
          Object.defineProperty(exports2, "group", { enumerable: true, get: function() {
            return group_1.default;
          } });
          var group_by_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/group-by.js");
          Object.defineProperty(exports2, "groupBy", { enumerable: true, get: function() {
            return group_by_1.default;
          } });
          var group_to_map_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/group-to-map.js");
          Object.defineProperty(exports2, "groupToMap", { enumerable: true, get: function() {
            return group_to_map_1.default;
          } });
          var get_wrap_behavior_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/get-wrap-behavior.js");
          Object.defineProperty(exports2, "getWrapBehavior", { enumerable: true, get: function() {
            return get_wrap_behavior_1.default;
          } });
          var wrap_behavior_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/wrap-behavior.js");
          Object.defineProperty(exports2, "wrapBehavior", { enumerable: true, get: function() {
            return wrap_behavior_1.default;
          } });
          var number2color_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/number2color.js");
          Object.defineProperty(exports2, "number2color", { enumerable: true, get: function() {
            return number2color_1.default;
          } });
          var parse_radius_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/parse-radius.js");
          Object.defineProperty(exports2, "parseRadius", { enumerable: true, get: function() {
            return parse_radius_1.default;
          } });
          var clamp_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/clamp.js");
          Object.defineProperty(exports2, "clamp", { enumerable: true, get: function() {
            return clamp_1.default;
          } });
          var fixed_base_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/fixed-base.js");
          Object.defineProperty(exports2, "fixedBase", { enumerable: true, get: function() {
            return fixed_base_1.default;
          } });
          var is_decimal_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-decimal.js");
          Object.defineProperty(exports2, "isDecimal", { enumerable: true, get: function() {
            return is_decimal_1.default;
          } });
          var is_even_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-even.js");
          Object.defineProperty(exports2, "isEven", { enumerable: true, get: function() {
            return is_even_1.default;
          } });
          var is_integer_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-integer.js");
          Object.defineProperty(exports2, "isInteger", { enumerable: true, get: function() {
            return is_integer_1.default;
          } });
          var is_negative_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-negative.js");
          Object.defineProperty(exports2, "isNegative", { enumerable: true, get: function() {
            return is_negative_1.default;
          } });
          var is_number_equal_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-number-equal.js");
          Object.defineProperty(exports2, "isNumberEqual", { enumerable: true, get: function() {
            return is_number_equal_1.default;
          } });
          var is_odd_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-odd.js");
          Object.defineProperty(exports2, "isOdd", { enumerable: true, get: function() {
            return is_odd_1.default;
          } });
          var is_positive_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-positive.js");
          Object.defineProperty(exports2, "isPositive", { enumerable: true, get: function() {
            return is_positive_1.default;
          } });
          var max_by_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/max-by.js");
          Object.defineProperty(exports2, "maxBy", { enumerable: true, get: function() {
            return max_by_1.default;
          } });
          var min_by_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/min-by.js");
          Object.defineProperty(exports2, "minBy", { enumerable: true, get: function() {
            return min_by_1.default;
          } });
          var mod_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/mod.js");
          Object.defineProperty(exports2, "mod", { enumerable: true, get: function() {
            return mod_1.default;
          } });
          var to_degree_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/to-degree.js");
          Object.defineProperty(exports2, "toDegree", { enumerable: true, get: function() {
            return to_degree_1.default;
          } });
          var to_integer_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/to-integer.js");
          Object.defineProperty(exports2, "toInteger", { enumerable: true, get: function() {
            return to_integer_1.default;
          } });
          var to_radian_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/to-radian.js");
          Object.defineProperty(exports2, "toRadian", { enumerable: true, get: function() {
            return to_radian_1.default;
          } });
          var for_in_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/for-in.js");
          Object.defineProperty(exports2, "forIn", { enumerable: true, get: function() {
            return for_in_1.default;
          } });
          var has_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/has.js");
          Object.defineProperty(exports2, "has", { enumerable: true, get: function() {
            return has_1.default;
          } });
          var has_key_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/has-key.js");
          Object.defineProperty(exports2, "hasKey", { enumerable: true, get: function() {
            return has_key_1.default;
          } });
          var has_value_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/has-value.js");
          Object.defineProperty(exports2, "hasValue", { enumerable: true, get: function() {
            return has_value_1.default;
          } });
          var keys_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/keys.js");
          Object.defineProperty(exports2, "keys", { enumerable: true, get: function() {
            return keys_1.default;
          } });
          var is_match_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-match.js");
          Object.defineProperty(exports2, "isMatch", { enumerable: true, get: function() {
            return is_match_1.default;
          } });
          var values_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/values.js");
          Object.defineProperty(exports2, "values", { enumerable: true, get: function() {
            return values_1.default;
          } });
          var lower_case_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/lower-case.js");
          Object.defineProperty(exports2, "lowerCase", { enumerable: true, get: function() {
            return lower_case_1.default;
          } });
          var lower_first_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/lower-first.js");
          Object.defineProperty(exports2, "lowerFirst", { enumerable: true, get: function() {
            return lower_first_1.default;
          } });
          var substitute_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/substitute.js");
          Object.defineProperty(exports2, "substitute", { enumerable: true, get: function() {
            return substitute_1.default;
          } });
          var upper_case_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/upper-case.js");
          Object.defineProperty(exports2, "upperCase", { enumerable: true, get: function() {
            return upper_case_1.default;
          } });
          var upper_first_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/upper-first.js");
          Object.defineProperty(exports2, "upperFirst", { enumerable: true, get: function() {
            return upper_first_1.default;
          } });
          var get_type_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/get-type.js");
          Object.defineProperty(exports2, "getType", { enumerable: true, get: function() {
            return get_type_1.default;
          } });
          var is_arguments_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-arguments.js");
          Object.defineProperty(exports2, "isArguments", { enumerable: true, get: function() {
            return is_arguments_1.default;
          } });
          var is_array_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-array.js");
          Object.defineProperty(exports2, "isArray", { enumerable: true, get: function() {
            return is_array_1.default;
          } });
          var is_array_like_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-array-like.js");
          Object.defineProperty(exports2, "isArrayLike", { enumerable: true, get: function() {
            return is_array_like_1.default;
          } });
          var is_boolean_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-boolean.js");
          Object.defineProperty(exports2, "isBoolean", { enumerable: true, get: function() {
            return is_boolean_1.default;
          } });
          var is_date_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-date.js");
          Object.defineProperty(exports2, "isDate", { enumerable: true, get: function() {
            return is_date_1.default;
          } });
          var is_error_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-error.js");
          Object.defineProperty(exports2, "isError", { enumerable: true, get: function() {
            return is_error_1.default;
          } });
          var is_function_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-function.js");
          Object.defineProperty(exports2, "isFunction", { enumerable: true, get: function() {
            return is_function_1.default;
          } });
          var is_finite_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-finite.js");
          Object.defineProperty(exports2, "isFinite", { enumerable: true, get: function() {
            return is_finite_1.default;
          } });
          var is_nil_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-nil.js");
          Object.defineProperty(exports2, "isNil", { enumerable: true, get: function() {
            return is_nil_1.default;
          } });
          var is_null_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-null.js");
          Object.defineProperty(exports2, "isNull", { enumerable: true, get: function() {
            return is_null_1.default;
          } });
          var is_number_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-number.js");
          Object.defineProperty(exports2, "isNumber", { enumerable: true, get: function() {
            return is_number_1.default;
          } });
          var is_object_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-object.js");
          Object.defineProperty(exports2, "isObject", { enumerable: true, get: function() {
            return is_object_1.default;
          } });
          var is_object_like_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-object-like.js");
          Object.defineProperty(exports2, "isObjectLike", { enumerable: true, get: function() {
            return is_object_like_1.default;
          } });
          var is_plain_object_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-plain-object.js");
          Object.defineProperty(exports2, "isPlainObject", { enumerable: true, get: function() {
            return is_plain_object_1.default;
          } });
          var is_prototype_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-prototype.js");
          Object.defineProperty(exports2, "isPrototype", { enumerable: true, get: function() {
            return is_prototype_1.default;
          } });
          var is_reg_exp_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-reg-exp.js");
          Object.defineProperty(exports2, "isRegExp", { enumerable: true, get: function() {
            return is_reg_exp_1.default;
          } });
          var is_string_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-string.js");
          Object.defineProperty(exports2, "isString", { enumerable: true, get: function() {
            return is_string_1.default;
          } });
          var is_type_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-type.js");
          Object.defineProperty(exports2, "isType", { enumerable: true, get: function() {
            return is_type_1.default;
          } });
          var is_undefined_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-undefined.js");
          Object.defineProperty(exports2, "isUndefined", { enumerable: true, get: function() {
            return is_undefined_1.default;
          } });
          var is_element_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-element.js");
          Object.defineProperty(exports2, "isElement", { enumerable: true, get: function() {
            return is_element_1.default;
          } });
          var request_animation_frame_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/request-animation-frame.js");
          Object.defineProperty(exports2, "requestAnimationFrame", { enumerable: true, get: function() {
            return request_animation_frame_1.default;
          } });
          var clear_animation_frame_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/clear-animation-frame.js");
          Object.defineProperty(exports2, "clearAnimationFrame", { enumerable: true, get: function() {
            return clear_animation_frame_1.default;
          } });
          var augment_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/augment.js");
          Object.defineProperty(exports2, "augment", { enumerable: true, get: function() {
            return augment_1.default;
          } });
          var clone_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/clone.js");
          Object.defineProperty(exports2, "clone", { enumerable: true, get: function() {
            return clone_1.default;
          } });
          var debounce_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/debounce.js");
          Object.defineProperty(exports2, "debounce", { enumerable: true, get: function() {
            return debounce_1.default;
          } });
          var memoize_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/memoize.js");
          Object.defineProperty(exports2, "memoize", { enumerable: true, get: function() {
            return memoize_1.default;
          } });
          var deep_mix_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/deep-mix.js");
          Object.defineProperty(exports2, "deepMix", { enumerable: true, get: function() {
            return deep_mix_1.default;
          } });
          var each_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/each.js");
          Object.defineProperty(exports2, "each", { enumerable: true, get: function() {
            return each_1.default;
          } });
          var extend_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/extend.js");
          Object.defineProperty(exports2, "extend", { enumerable: true, get: function() {
            return extend_1.default;
          } });
          var index_of_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index-of.js");
          Object.defineProperty(exports2, "indexOf", { enumerable: true, get: function() {
            return index_of_1.default;
          } });
          var is_empty_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-empty.js");
          Object.defineProperty(exports2, "isEmpty", { enumerable: true, get: function() {
            return is_empty_1.default;
          } });
          var is_equal_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-equal.js");
          Object.defineProperty(exports2, "isEqual", { enumerable: true, get: function() {
            return is_equal_1.default;
          } });
          var is_equal_with_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-equal-with.js");
          Object.defineProperty(exports2, "isEqualWith", { enumerable: true, get: function() {
            return is_equal_with_1.default;
          } });
          var map_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/map.js");
          Object.defineProperty(exports2, "map", { enumerable: true, get: function() {
            return map_1.default;
          } });
          var map_values_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/map-values.js");
          Object.defineProperty(exports2, "mapValues", { enumerable: true, get: function() {
            return map_values_1.default;
          } });
          var mix_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/mix.js");
          Object.defineProperty(exports2, "mix", { enumerable: true, get: function() {
            return mix_1.default;
          } });
          Object.defineProperty(exports2, "assign", { enumerable: true, get: function() {
            return mix_1.default;
          } });
          var get_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/get.js");
          Object.defineProperty(exports2, "get", { enumerable: true, get: function() {
            return get_1.default;
          } });
          var set_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/set.js");
          Object.defineProperty(exports2, "set", { enumerable: true, get: function() {
            return set_1.default;
          } });
          var pick_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/pick.js");
          Object.defineProperty(exports2, "pick", { enumerable: true, get: function() {
            return pick_1.default;
          } });
          var throttle_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/throttle.js");
          Object.defineProperty(exports2, "throttle", { enumerable: true, get: function() {
            return throttle_1.default;
          } });
          var to_array_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/to-array.js");
          Object.defineProperty(exports2, "toArray", { enumerable: true, get: function() {
            return to_array_1.default;
          } });
          var to_string_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/to-string.js");
          Object.defineProperty(exports2, "toString", { enumerable: true, get: function() {
            return to_string_1.default;
          } });
          var unique_id_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/unique-id.js");
          Object.defineProperty(exports2, "uniqueId", { enumerable: true, get: function() {
            return unique_id_1.default;
          } });
          var noop_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/noop.js");
          Object.defineProperty(exports2, "noop", { enumerable: true, get: function() {
            return noop_1.default;
          } });
          var identity_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/identity.js");
          Object.defineProperty(exports2, "identity", { enumerable: true, get: function() {
            return identity_1.default;
          } });
          var size_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/size.js");
          Object.defineProperty(exports2, "size", { enumerable: true, get: function() {
            return size_1.default;
          } });
          var cache_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/cache.js");
          Object.defineProperty(exports2, "Cache", { enumerable: true, get: function() {
            return cache_1.default;
          } });
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-arguments.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_type_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-type.js");
          var isArguments = function(value) {
            return is_type_1.default(value, "Arguments");
          };
          exports2.default = isArguments;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-array-like.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var isArrayLike = function(value) {
            return value !== null && typeof value !== "function" && isFinite(value.length);
          };
          exports2.default = isArrayLike;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-array.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_type_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-type.js");
          exports2.default = function(value) {
            return Array.isArray ? Array.isArray(value) : is_type_1.default(value, "Array");
          };
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-boolean.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_type_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-type.js");
          var isBoolean = function(value) {
            return is_type_1.default(value, "Boolean");
          };
          exports2.default = isBoolean;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-date.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_type_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-type.js");
          var isDate = function(value) {
            return is_type_1.default(value, "Date");
          };
          exports2.default = isDate;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-decimal.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_number_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-number.js");
          var isDecimal = function(num) {
            return is_number_1.default(num) && num % 1 !== 0;
          };
          exports2.default = isDecimal;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-element.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var isElement = function(o) {
            return o instanceof Element || o instanceof HTMLDocument;
          };
          exports2.default = isElement;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-empty.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_nil_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-nil.js");
          var is_array_like_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-array-like.js");
          var get_type_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/get-type.js");
          var is_prototype_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-prototype.js");
          var hasOwnProperty = Object.prototype.hasOwnProperty;
          function isEmpty(value) {
            if (is_nil_1.default(value)) {
              return true;
            }
            if (is_array_like_1.default(value)) {
              return !value.length;
            }
            var type = get_type_1.default(value);
            if (type === "Map" || type === "Set") {
              return !value.size;
            }
            if (is_prototype_1.default(value)) {
              return !Object.keys(value).length;
            }
            for (var key in value) {
              if (hasOwnProperty.call(value, key)) {
                return false;
              }
            }
            return true;
          }
          exports2.default = isEmpty;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-equal-with.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_function_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-function.js");
          var is_equal_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-equal.js");
          exports2.default = function(value, other, fn) {
            if (!is_function_1.default(fn)) {
              return is_equal_1.default(value, other);
            }
            return !!fn(value, other);
          };
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-equal.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_object_like_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-object-like.js");
          var is_array_like_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-array-like.js");
          var is_string_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-string.js");
          var isEqual = function(value, other) {
            if (value === other) {
              return true;
            }
            if (!value || !other) {
              return false;
            }
            if (is_string_1.default(value) || is_string_1.default(other)) {
              return false;
            }
            if (is_array_like_1.default(value) || is_array_like_1.default(other)) {
              if (value.length !== other.length) {
                return false;
              }
              var rst = true;
              for (var i = 0; i < value.length; i++) {
                rst = isEqual(value[i], other[i]);
                if (!rst) {
                  break;
                }
              }
              return rst;
            }
            if (is_object_like_1.default(value) || is_object_like_1.default(other)) {
              var valueKeys = Object.keys(value);
              var otherKeys = Object.keys(other);
              if (valueKeys.length !== otherKeys.length) {
                return false;
              }
              var rst = true;
              for (var i = 0; i < valueKeys.length; i++) {
                rst = isEqual(value[valueKeys[i]], other[valueKeys[i]]);
                if (!rst) {
                  break;
                }
              }
              return rst;
            }
            return false;
          };
          exports2.default = isEqual;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-error.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_type_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-type.js");
          var isError = function(value) {
            return is_type_1.default(value, "Error");
          };
          exports2.default = isError;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-even.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_number_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-number.js");
          var isEven = function(num) {
            return is_number_1.default(num) && num % 2 === 0;
          };
          exports2.default = isEven;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-finite.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_number_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-number.js");
          function default_1(value) {
            return is_number_1.default(value) && isFinite(value);
          }
          exports2.default = default_1;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-function.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_type_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-type.js");
          exports2.default = function(value) {
            return is_type_1.default(value, "Function");
          };
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-integer.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_number_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-number.js");
          var isInteger = Number.isInteger ? Number.isInteger : function(num) {
            return is_number_1.default(num) && num % 1 === 0;
          };
          exports2.default = isInteger;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-match.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_nil_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-nil.js");
          var keys_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/keys.js");
          function isMatch(obj, attrs) {
            var _keys = keys_1.default(attrs);
            var length = _keys.length;
            if (is_nil_1.default(obj))
              return !length;
            for (var i = 0; i < length; i += 1) {
              var key = _keys[i];
              if (attrs[key] !== obj[key] || !(key in obj)) {
                return false;
              }
            }
            return true;
          }
          exports2.default = isMatch;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-negative.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_number_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-number.js");
          var isNegative = function(num) {
            return is_number_1.default(num) && num < 0;
          };
          exports2.default = isNegative;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-nil.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var isNil = function(value) {
            return value === null || value === void 0;
          };
          exports2.default = isNil;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-null.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var isNull = function(value) {
            return value === null;
          };
          exports2.default = isNull;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-number-equal.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var PRECISION = 1e-5;
          function isNumberEqual(a, b, precision) {
            if (precision === void 0) {
              precision = PRECISION;
            }
            return Math.abs(a - b) < precision;
          }
          exports2.default = isNumberEqual;
          ;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-number.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_type_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-type.js");
          var isNumber = function(value) {
            return is_type_1.default(value, "Number");
          };
          exports2.default = isNumber;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-object-like.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var isObjectLike = function(value) {
            return typeof value === "object" && value !== null;
          };
          exports2.default = isObjectLike;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-object.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.default = function(value) {
            var type = typeof value;
            return value !== null && type === "object" || type === "function";
          };
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-odd.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_number_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-number.js");
          var isOdd = function(num) {
            return is_number_1.default(num) && num % 2 !== 0;
          };
          exports2.default = isOdd;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-plain-object.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_object_like_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-object-like.js");
          var is_type_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-type.js");
          var isPlainObject = function(value) {
            if (!is_object_like_1.default(value) || !is_type_1.default(value, "Object")) {
              return false;
            }
            if (Object.getPrototypeOf(value) === null) {
              return true;
            }
            var proto = value;
            while (Object.getPrototypeOf(proto) !== null) {
              proto = Object.getPrototypeOf(proto);
            }
            return Object.getPrototypeOf(value) === proto;
          };
          exports2.default = isPlainObject;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-positive.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_number_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-number.js");
          var isPositive = function(num) {
            return is_number_1.default(num) && num > 0;
          };
          exports2.default = isPositive;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-prototype.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var objectProto = Object.prototype;
          var isPrototype = function(value) {
            var Ctor = value && value.constructor;
            var proto = typeof Ctor === "function" && Ctor.prototype || objectProto;
            return value === proto;
          };
          exports2.default = isPrototype;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-reg-exp.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_type_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-type.js");
          var isRegExp = function(str) {
            return is_type_1.default(str, "RegExp");
          };
          exports2.default = isRegExp;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-string.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_type_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-type.js");
          exports2.default = function(str) {
            return is_type_1.default(str, "String");
          };
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-type.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var toString = {}.toString;
          var isType = function(value, type) {
            return toString.call(value) === "[object " + type + "]";
          };
          exports2.default = isType;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-undefined.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var isUndefined = function(value) {
            return value === void 0;
          };
          exports2.default = isUndefined;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/keys.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var each_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/each.js");
          var is_function_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-function.js");
          var keys = Object.keys ? function(obj) {
            return Object.keys(obj);
          } : function(obj) {
            var result = [];
            each_1.default(obj, function(value, key) {
              if (!(is_function_1.default(obj) && key === "prototype")) {
                result.push(key);
              }
            });
            return result;
          };
          exports2.default = keys;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/last.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_array_like_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-array-like.js");
          function last(o) {
            if (is_array_like_1.default(o)) {
              var arr = o;
              return arr[arr.length - 1];
            }
            return void 0;
          }
          exports2.default = last;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/lower-case.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var to_string_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/to-string.js");
          var lowerCase = function(str) {
            return to_string_1.default(str).toLowerCase();
          };
          exports2.default = lowerCase;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/lower-first.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var to_string_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/to-string.js");
          var lowerFirst = function(value) {
            var str = to_string_1.default(value);
            return str.charAt(0).toLowerCase() + str.substring(1);
          };
          exports2.default = lowerFirst;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/map-values.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_nil_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-nil.js");
          var is_object_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-object.js");
          var identity = function(v) {
            return v;
          };
          exports2.default = function(object, func) {
            if (func === void 0) {
              func = identity;
            }
            var r = {};
            if (is_object_1.default(object) && !is_nil_1.default(object)) {
              Object.keys(object).forEach(function(key) {
                r[key] = func(object[key], key);
              });
            }
            return r;
          };
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/map.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_array_like_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-array-like.js");
          var map = function(arr, func) {
            if (!is_array_like_1.default(arr)) {
              return arr;
            }
            var result = [];
            for (var index = 0; index < arr.length; index++) {
              var value = arr[index];
              result.push(func(value, index));
            }
            return result;
          };
          exports2.default = map;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/max-by.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var each_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/each.js");
          var is_array_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-array.js");
          var is_function_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-function.js");
          exports2.default = function(arr, fn) {
            if (!is_array_1.default(arr)) {
              return void 0;
            }
            var max = arr[0];
            var maxData;
            if (is_function_1.default(fn)) {
              maxData = fn(arr[0]);
            } else {
              maxData = arr[0][fn];
            }
            var data;
            each_1.default(arr, function(val) {
              if (is_function_1.default(fn)) {
                data = fn(val);
              } else {
                data = val[fn];
              }
              if (data > maxData) {
                max = val;
                maxData = data;
              }
            });
            return max;
          };
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/memoize.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_function_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-function.js");
          exports2.default = function(f, resolver) {
            if (!is_function_1.default(f)) {
              throw new TypeError("Expected a function");
            }
            var memoized = function() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              var key = resolver ? resolver.apply(this, args) : args[0];
              var cache = memoized.cache;
              if (cache.has(key)) {
                return cache.get(key);
              }
              var result = f.apply(this, args);
              cache.set(key, result);
              return result;
            };
            memoized.cache = /* @__PURE__ */ new Map();
            return memoized;
          };
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/min-by.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var each_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/each.js");
          var is_array_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-array.js");
          var is_function_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-function.js");
          exports2.default = function(arr, fn) {
            if (!is_array_1.default(arr)) {
              return void 0;
            }
            var min = arr[0];
            var minData;
            if (is_function_1.default(fn)) {
              minData = fn(arr[0]);
            } else {
              minData = arr[0][fn];
            }
            var data;
            each_1.default(arr, function(val) {
              if (is_function_1.default(fn)) {
                data = fn(val);
              } else {
                data = val[fn];
              }
              if (data < minData) {
                min = val;
                minData = data;
              }
            });
            return min;
          };
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/mix.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          function _mix(dist, obj) {
            for (var key in obj) {
              if (obj.hasOwnProperty(key) && key !== "constructor" && obj[key] !== void 0) {
                dist[key] = obj[key];
              }
            }
          }
          function mix(dist, src1, src2, src3) {
            if (src1)
              _mix(dist, src1);
            if (src2)
              _mix(dist, src2);
            if (src3)
              _mix(dist, src3);
            return dist;
          }
          exports2.default = mix;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/mod.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var mod = function(n, m) {
            return (n % m + m) % m;
          };
          exports2.default = mod;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/noop.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.default = function() {
          };
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/number2color.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var numColorCache = {};
          function numberToColor(num) {
            var color = numColorCache[num];
            if (!color) {
              var str = num.toString(16);
              for (var i = str.length; i < 6; i++) {
                str = "0" + str;
              }
              color = "#" + str;
              numColorCache[num] = color;
            }
            return color;
          }
          exports2.default = numberToColor;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/parse-radius.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_array_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-array.js");
          function parseRadius(radius) {
            var r1 = 0, r2 = 0, r3 = 0, r4 = 0;
            if (is_array_1.default(radius)) {
              if (radius.length === 1) {
                r1 = r2 = r3 = r4 = radius[0];
              } else if (radius.length === 2) {
                r1 = r3 = radius[0];
                r2 = r4 = radius[1];
              } else if (radius.length === 3) {
                r1 = radius[0];
                r2 = r4 = radius[1];
                r3 = radius[2];
              } else {
                r1 = radius[0];
                r2 = radius[1];
                r3 = radius[2];
                r4 = radius[3];
              }
            } else {
              r1 = r2 = r3 = r4 = radius;
            }
            return {
              r1,
              r2,
              r3,
              r4
            };
          }
          exports2.default = parseRadius;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/pick.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var each_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/each.js");
          var is_plain_object_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-plain-object.js");
          var hasOwnProperty = Object.prototype.hasOwnProperty;
          exports2.default = function(object, keys) {
            if (object === null || !is_plain_object_1.default(object)) {
              return {};
            }
            var result = {};
            each_1.default(keys, function(key) {
              if (hasOwnProperty.call(object, key)) {
                result[key] = object[key];
              }
            });
            return result;
          };
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/pull-at.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_array_like_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-array-like.js");
          var splice = Array.prototype.splice;
          var pullAt = function pullAt2(arr, indexes) {
            if (!is_array_like_1.default(arr)) {
              return [];
            }
            var length = arr ? indexes.length : 0;
            var last = length - 1;
            while (length--) {
              var previous = void 0;
              var index = indexes[length];
              if (length === last || index !== previous) {
                previous = index;
                splice.call(arr, index, 1);
              }
            }
            return arr;
          };
          exports2.default = pullAt;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/pull.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var arrPrototype = Array.prototype;
          var splice = arrPrototype.splice;
          var indexOf = arrPrototype.indexOf;
          var pull = function(arr) {
            var values = [];
            for (var _i = 1; _i < arguments.length; _i++) {
              values[_i - 1] = arguments[_i];
            }
            for (var i = 0; i < values.length; i++) {
              var value = values[i];
              var fromIndex = -1;
              while ((fromIndex = indexOf.call(arr, value)) > -1) {
                splice.call(arr, fromIndex, 1);
              }
            }
            return arr;
          };
          exports2.default = pull;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/reduce.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var each_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/each.js");
          var is_array_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-array.js");
          var is_plain_object_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-plain-object.js");
          var reduce = function(arr, fn, init) {
            if (!is_array_1.default(arr) && !is_plain_object_1.default(arr)) {
              return arr;
            }
            var result = init;
            each_1.default(arr, function(data, i) {
              result = fn(result, data, i);
            });
            return result;
          };
          exports2.default = reduce;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/remove.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_array_like_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-array-like.js");
          var pull_at_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/pull-at.js");
          var remove = function(arr, predicate) {
            var result = [];
            if (!is_array_like_1.default(arr)) {
              return result;
            }
            var i = -1;
            var indexes = [];
            var length = arr.length;
            while (++i < length) {
              var value = arr[i];
              if (predicate(value, i, arr)) {
                result.push(value);
                indexes.push(i);
              }
            }
            pull_at_1.default(arr, indexes);
            return result;
          };
          exports2.default = remove;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/request-animation-frame.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          function requestAnimationFrame(fn) {
            var method = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function(f) {
              return setTimeout(f, 16);
            };
            return method(fn);
          }
          exports2.default = requestAnimationFrame;
          ;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/set.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_object_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-object.js");
          var is_string_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-string.js");
          var is_number_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-number.js");
          exports2.default = function(obj, path, value) {
            var o = obj;
            var keyArr = is_string_1.default(path) ? path.split(".") : path;
            keyArr.forEach(function(key, idx) {
              if (idx < keyArr.length - 1) {
                if (!is_object_1.default(o[key])) {
                  o[key] = is_number_1.default(keyArr[idx + 1]) ? [] : {};
                }
                o = o[key];
              } else {
                o[key] = value;
              }
            });
            return obj;
          };
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/size.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_nil_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-nil.js");
          var is_array_like_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-array-like.js");
          function size(o) {
            if (is_nil_1.default(o)) {
              return 0;
            }
            if (is_array_like_1.default(o)) {
              return o.length;
            }
            return Object.keys(o).length;
          }
          exports2.default = size;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/some.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var some = function(arr, func) {
            for (var i = 0; i < arr.length; i++) {
              if (func(arr[i], i))
                return true;
            }
            return false;
          };
          exports2.default = some;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/sort-by.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_array_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-array.js");
          var is_string_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-string.js");
          var is_function_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-function.js");
          function sortBy(arr, key) {
            var comparer;
            if (is_function_1.default(key)) {
              comparer = function(a, b) {
                return key(a) - key(b);
              };
            } else {
              var keys_1 = [];
              if (is_string_1.default(key)) {
                keys_1.push(key);
              } else if (is_array_1.default(key)) {
                keys_1 = key;
              }
              comparer = function(a, b) {
                for (var i = 0; i < keys_1.length; i += 1) {
                  var prop = keys_1[i];
                  if (a[prop] > b[prop]) {
                    return 1;
                  }
                  if (a[prop] < b[prop]) {
                    return -1;
                  }
                }
                return 0;
              };
            }
            arr.sort(comparer);
            return arr;
          }
          exports2.default = sortBy;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/starts-with.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_array_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-array.js");
          var is_string_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-string.js");
          function startsWith(arr, e) {
            return is_array_1.default(arr) || is_string_1.default(arr) ? arr[0] === e : false;
          }
          exports2.default = startsWith;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/substitute.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          function substitute(str, o) {
            if (!str || !o) {
              return str;
            }
            return str.replace(/\\?\{([^{}]+)\}/g, function(match, name) {
              if (match.charAt(0) === "\\") {
                return match.slice(1);
              }
              return o[name] === void 0 ? "" : o[name];
            });
          }
          exports2.default = substitute;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/throttle.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.default = function(func, wait, options) {
            var timeout, context, args, result;
            var previous = 0;
            if (!options)
              options = {};
            var later = function() {
              previous = options.leading === false ? 0 : Date.now();
              timeout = null;
              result = func.apply(context, args);
              if (!timeout)
                context = args = null;
            };
            var throttled = function() {
              var now = Date.now();
              if (!previous && options.leading === false)
                previous = now;
              var remaining = wait - (now - previous);
              context = this;
              args = arguments;
              if (remaining <= 0 || remaining > wait) {
                if (timeout) {
                  clearTimeout(timeout);
                  timeout = null;
                }
                previous = now;
                result = func.apply(context, args);
                if (!timeout)
                  context = args = null;
              } else if (!timeout && options.trailing !== false) {
                timeout = setTimeout(later, remaining);
              }
              return result;
            };
            throttled.cancel = function() {
              clearTimeout(timeout);
              previous = 0;
              timeout = context = args = null;
            };
            return throttled;
          };
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/to-array.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_array_like_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-array-like.js");
          exports2.default = function(value) {
            return is_array_like_1.default(value) ? Array.prototype.slice.call(value) : [];
          };
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/to-degree.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var DEGREE = 180 / Math.PI;
          var toDegree = function(radian) {
            return DEGREE * radian;
          };
          exports2.default = toDegree;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/to-integer.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.default = parseInt;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/to-radian.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var RADIAN = Math.PI / 180;
          var toRadian = function(degree) {
            return RADIAN * degree;
          };
          exports2.default = toRadian;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/to-string.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_nil_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-nil.js");
          exports2.default = function(value) {
            if (is_nil_1.default(value))
              return "";
            return value.toString();
          };
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/union.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var uniq_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/uniq.js");
          var union = function() {
            var sources = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              sources[_i] = arguments[_i];
            }
            return uniq_1.default([].concat.apply([], sources));
          };
          exports2.default = union;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/uniq.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var contains_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/contains.js");
          var each_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/each.js");
          var uniq = function(arr) {
            var resultArr = [];
            each_1.default(arr, function(item) {
              if (!contains_1.default(resultArr, item)) {
                resultArr.push(item);
              }
            });
            return resultArr;
          };
          exports2.default = uniq;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/unique-id.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var map = {};
          exports2.default = function(prefix) {
            prefix = prefix || "g";
            if (!map[prefix]) {
              map[prefix] = 1;
            } else {
              map[prefix] += 1;
            }
            return prefix + map[prefix];
          };
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/upper-case.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var to_string_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/to-string.js");
          var upperCase = function(str) {
            return to_string_1.default(str).toUpperCase();
          };
          exports2.default = upperCase;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/upper-first.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var to_string_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/to-string.js");
          var upperFirst = function(value) {
            var str = to_string_1.default(value);
            return str.charAt(0).toUpperCase() + str.substring(1);
          };
          exports2.default = upperFirst;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/values-of-key.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var is_array_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-array.js");
          var is_nil_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-nil.js");
          exports2.default = function(data, name) {
            var rst = [];
            var tmpMap = {};
            for (var i = 0; i < data.length; i++) {
              var obj = data[i];
              var value = obj[name];
              if (!is_nil_1.default(value)) {
                if (!is_array_1.default(value)) {
                  value = [value];
                }
                for (var j = 0; j < value.length; j++) {
                  var val = value[j];
                  if (!tmpMap[val]) {
                    rst.push(val);
                    tmpMap[val] = true;
                  }
                }
              }
            }
            return rst;
          };
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/values.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var each_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/each.js");
          var is_function_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-function.js");
          var values = Object.values ? function(obj) {
            return Object.values(obj);
          } : function(obj) {
            var result = [];
            each_1.default(obj, function(value, key) {
              if (!(is_function_1.default(obj) && key === "prototype")) {
                result.push(value);
              }
            });
            return result;
          };
          exports2.default = values;
        },
        "./node_modules/_@antv_util@2.0.10@@antv/util/lib/wrap-behavior.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          function wrapBehavior(obj, action) {
            if (obj["_wrap_" + action]) {
              return obj["_wrap_" + action];
            }
            var method = function(e) {
              obj[action](e);
            };
            obj["_wrap_" + action] = method;
            return method;
          }
          exports2.default = wrapBehavior;
        },
        "./node_modules/_abs-svg-path@0.1.1@abs-svg-path/index.js": function(module2, exports2) {
          module2.exports = absolutize;
          function absolutize(path) {
            var startX = 0;
            var startY = 0;
            var x = 0;
            var y = 0;
            return path.map(function(seg) {
              seg = seg.slice();
              var type = seg[0];
              var command = type.toUpperCase();
              if (type != command) {
                seg[0] = command;
                switch (type) {
                  case "a":
                    seg[6] += x;
                    seg[7] += y;
                    break;
                  case "v":
                    seg[1] += y;
                    break;
                  case "h":
                    seg[1] += x;
                    break;
                  default:
                    for (var i = 1; i < seg.length; ) {
                      seg[i++] += x;
                      seg[i++] += y;
                    }
                }
              }
              switch (command) {
                case "Z":
                  x = startX;
                  y = startY;
                  break;
                case "H":
                  x = seg[1];
                  break;
                case "V":
                  y = seg[1];
                  break;
                case "M":
                  x = startX = seg[1];
                  y = startY = seg[2];
                  break;
                default:
                  x = seg[seg.length - 2];
                  y = seg[seg.length - 1];
              }
              return seg;
            });
          }
        },
        "./node_modules/_d3-array@1.2.4@d3-array/dist/d3-array.js": function(module2, exports2, __webpack_require__) {
          (function(global, factory) {
            true ? factory(exports2) : void 0;
          })(this, function(exports3) {
            "use strict";
            function ascending(a, b) {
              return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
            }
            function bisector(compare) {
              if (compare.length === 1)
                compare = ascendingComparator(compare);
              return {
                left: function(a, x, lo, hi) {
                  if (lo == null)
                    lo = 0;
                  if (hi == null)
                    hi = a.length;
                  while (lo < hi) {
                    var mid = lo + hi >>> 1;
                    if (compare(a[mid], x) < 0)
                      lo = mid + 1;
                    else
                      hi = mid;
                  }
                  return lo;
                },
                right: function(a, x, lo, hi) {
                  if (lo == null)
                    lo = 0;
                  if (hi == null)
                    hi = a.length;
                  while (lo < hi) {
                    var mid = lo + hi >>> 1;
                    if (compare(a[mid], x) > 0)
                      hi = mid;
                    else
                      lo = mid + 1;
                  }
                  return lo;
                }
              };
            }
            function ascendingComparator(f) {
              return function(d, x) {
                return ascending(f(d), x);
              };
            }
            var ascendingBisect = bisector(ascending);
            var bisectRight = ascendingBisect.right;
            var bisectLeft = ascendingBisect.left;
            function pairs(array2, f) {
              if (f == null)
                f = pair;
              var i = 0, n = array2.length - 1, p = array2[0], pairs2 = new Array(n < 0 ? 0 : n);
              while (i < n)
                pairs2[i] = f(p, p = array2[++i]);
              return pairs2;
            }
            function pair(a, b) {
              return [a, b];
            }
            function cross(values0, values1, reduce) {
              var n0 = values0.length, n1 = values1.length, values = new Array(n0 * n1), i0, i1, i, value0;
              if (reduce == null)
                reduce = pair;
              for (i0 = i = 0; i0 < n0; ++i0) {
                for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {
                  values[i] = reduce(value0, values1[i1]);
                }
              }
              return values;
            }
            function descending(a, b) {
              return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
            }
            function number(x) {
              return x === null ? NaN : +x;
            }
            function variance(values, valueof) {
              var n = values.length, m = 0, i = -1, mean2 = 0, value, delta, sum2 = 0;
              if (valueof == null) {
                while (++i < n) {
                  if (!isNaN(value = number(values[i]))) {
                    delta = value - mean2;
                    mean2 += delta / ++m;
                    sum2 += delta * (value - mean2);
                  }
                }
              } else {
                while (++i < n) {
                  if (!isNaN(value = number(valueof(values[i], i, values)))) {
                    delta = value - mean2;
                    mean2 += delta / ++m;
                    sum2 += delta * (value - mean2);
                  }
                }
              }
              if (m > 1)
                return sum2 / (m - 1);
            }
            function deviation(array2, f) {
              var v = variance(array2, f);
              return v ? Math.sqrt(v) : v;
            }
            function extent(values, valueof) {
              var n = values.length, i = -1, value, min2, max2;
              if (valueof == null) {
                while (++i < n) {
                  if ((value = values[i]) != null && value >= value) {
                    min2 = max2 = value;
                    while (++i < n) {
                      if ((value = values[i]) != null) {
                        if (min2 > value)
                          min2 = value;
                        if (max2 < value)
                          max2 = value;
                      }
                    }
                  }
                }
              } else {
                while (++i < n) {
                  if ((value = valueof(values[i], i, values)) != null && value >= value) {
                    min2 = max2 = value;
                    while (++i < n) {
                      if ((value = valueof(values[i], i, values)) != null) {
                        if (min2 > value)
                          min2 = value;
                        if (max2 < value)
                          max2 = value;
                      }
                    }
                  }
                }
              }
              return [min2, max2];
            }
            var array = Array.prototype;
            var slice = array.slice;
            var map = array.map;
            function constant(x) {
              return function() {
                return x;
              };
            }
            function identity(x) {
              return x;
            }
            function range(start, stop, step) {
              start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;
              var i = -1, n = Math.max(0, Math.ceil((stop - start) / step)) | 0, range2 = new Array(n);
              while (++i < n) {
                range2[i] = start + i * step;
              }
              return range2;
            }
            var e10 = Math.sqrt(50), e5 = Math.sqrt(10), e2 = Math.sqrt(2);
            function ticks(start, stop, count) {
              var reverse, i = -1, n, ticks2, step;
              stop = +stop, start = +start, count = +count;
              if (start === stop && count > 0)
                return [start];
              if (reverse = stop < start)
                n = start, start = stop, stop = n;
              if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step))
                return [];
              if (step > 0) {
                start = Math.ceil(start / step);
                stop = Math.floor(stop / step);
                ticks2 = new Array(n = Math.ceil(stop - start + 1));
                while (++i < n)
                  ticks2[i] = (start + i) * step;
              } else {
                start = Math.floor(start * step);
                stop = Math.ceil(stop * step);
                ticks2 = new Array(n = Math.ceil(start - stop + 1));
                while (++i < n)
                  ticks2[i] = (start - i) / step;
              }
              if (reverse)
                ticks2.reverse();
              return ticks2;
            }
            function tickIncrement(start, stop, count) {
              var step = (stop - start) / Math.max(0, count), power = Math.floor(Math.log(step) / Math.LN10), error = step / Math.pow(10, power);
              return power >= 0 ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
            }
            function tickStep(start, stop, count) {
              var step0 = Math.abs(stop - start) / Math.max(0, count), step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)), error = step0 / step1;
              if (error >= e10)
                step1 *= 10;
              else if (error >= e5)
                step1 *= 5;
              else if (error >= e2)
                step1 *= 2;
              return stop < start ? -step1 : step1;
            }
            function sturges(values) {
              return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
            }
            function histogram() {
              var value = identity, domain = extent, threshold = sturges;
              function histogram2(data) {
                var i, n = data.length, x, values = new Array(n);
                for (i = 0; i < n; ++i) {
                  values[i] = value(data[i], i, data);
                }
                var xz = domain(values), x0 = xz[0], x1 = xz[1], tz = threshold(values, x0, x1);
                if (!Array.isArray(tz)) {
                  tz = tickStep(x0, x1, tz);
                  tz = range(Math.ceil(x0 / tz) * tz, x1, tz);
                }
                var m = tz.length;
                while (tz[0] <= x0)
                  tz.shift(), --m;
                while (tz[m - 1] > x1)
                  tz.pop(), --m;
                var bins = new Array(m + 1), bin;
                for (i = 0; i <= m; ++i) {
                  bin = bins[i] = [];
                  bin.x0 = i > 0 ? tz[i - 1] : x0;
                  bin.x1 = i < m ? tz[i] : x1;
                }
                for (i = 0; i < n; ++i) {
                  x = values[i];
                  if (x0 <= x && x <= x1) {
                    bins[bisectRight(tz, x, 0, m)].push(data[i]);
                  }
                }
                return bins;
              }
              histogram2.value = function(_) {
                return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram2) : value;
              };
              histogram2.domain = function(_) {
                return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram2) : domain;
              };
              histogram2.thresholds = function(_) {
                return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram2) : threshold;
              };
              return histogram2;
            }
            function quantile(values, p, valueof) {
              if (valueof == null)
                valueof = number;
              if (!(n = values.length))
                return;
              if ((p = +p) <= 0 || n < 2)
                return +valueof(values[0], 0, values);
              if (p >= 1)
                return +valueof(values[n - 1], n - 1, values);
              var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = +valueof(values[i0], i0, values), value1 = +valueof(values[i0 + 1], i0 + 1, values);
              return value0 + (value1 - value0) * (i - i0);
            }
            function freedmanDiaconis(values, min2, max2) {
              values = map.call(values, number).sort(ascending);
              return Math.ceil((max2 - min2) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * Math.pow(values.length, -1 / 3)));
            }
            function scott(values, min2, max2) {
              return Math.ceil((max2 - min2) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));
            }
            function max(values, valueof) {
              var n = values.length, i = -1, value, max2;
              if (valueof == null) {
                while (++i < n) {
                  if ((value = values[i]) != null && value >= value) {
                    max2 = value;
                    while (++i < n) {
                      if ((value = values[i]) != null && value > max2) {
                        max2 = value;
                      }
                    }
                  }
                }
              } else {
                while (++i < n) {
                  if ((value = valueof(values[i], i, values)) != null && value >= value) {
                    max2 = value;
                    while (++i < n) {
                      if ((value = valueof(values[i], i, values)) != null && value > max2) {
                        max2 = value;
                      }
                    }
                  }
                }
              }
              return max2;
            }
            function mean(values, valueof) {
              var n = values.length, m = n, i = -1, value, sum2 = 0;
              if (valueof == null) {
                while (++i < n) {
                  if (!isNaN(value = number(values[i])))
                    sum2 += value;
                  else
                    --m;
                }
              } else {
                while (++i < n) {
                  if (!isNaN(value = number(valueof(values[i], i, values))))
                    sum2 += value;
                  else
                    --m;
                }
              }
              if (m)
                return sum2 / m;
            }
            function median(values, valueof) {
              var n = values.length, i = -1, value, numbers = [];
              if (valueof == null) {
                while (++i < n) {
                  if (!isNaN(value = number(values[i]))) {
                    numbers.push(value);
                  }
                }
              } else {
                while (++i < n) {
                  if (!isNaN(value = number(valueof(values[i], i, values)))) {
                    numbers.push(value);
                  }
                }
              }
              return quantile(numbers.sort(ascending), 0.5);
            }
            function merge(arrays) {
              var n = arrays.length, m, i = -1, j = 0, merged, array2;
              while (++i < n)
                j += arrays[i].length;
              merged = new Array(j);
              while (--n >= 0) {
                array2 = arrays[n];
                m = array2.length;
                while (--m >= 0) {
                  merged[--j] = array2[m];
                }
              }
              return merged;
            }
            function min(values, valueof) {
              var n = values.length, i = -1, value, min2;
              if (valueof == null) {
                while (++i < n) {
                  if ((value = values[i]) != null && value >= value) {
                    min2 = value;
                    while (++i < n) {
                      if ((value = values[i]) != null && min2 > value) {
                        min2 = value;
                      }
                    }
                  }
                }
              } else {
                while (++i < n) {
                  if ((value = valueof(values[i], i, values)) != null && value >= value) {
                    min2 = value;
                    while (++i < n) {
                      if ((value = valueof(values[i], i, values)) != null && min2 > value) {
                        min2 = value;
                      }
                    }
                  }
                }
              }
              return min2;
            }
            function permute(array2, indexes) {
              var i = indexes.length, permutes = new Array(i);
              while (i--)
                permutes[i] = array2[indexes[i]];
              return permutes;
            }
            function scan(values, compare) {
              if (!(n = values.length))
                return;
              var n, i = 0, j = 0, xi, xj = values[j];
              if (compare == null)
                compare = ascending;
              while (++i < n) {
                if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {
                  xj = xi, j = i;
                }
              }
              if (compare(xj, xj) === 0)
                return j;
            }
            function shuffle(array2, i0, i1) {
              var m = (i1 == null ? array2.length : i1) - (i0 = i0 == null ? 0 : +i0), t, i;
              while (m) {
                i = Math.random() * m-- | 0;
                t = array2[m + i0];
                array2[m + i0] = array2[i + i0];
                array2[i + i0] = t;
              }
              return array2;
            }
            function sum(values, valueof) {
              var n = values.length, i = -1, value, sum2 = 0;
              if (valueof == null) {
                while (++i < n) {
                  if (value = +values[i])
                    sum2 += value;
                }
              } else {
                while (++i < n) {
                  if (value = +valueof(values[i], i, values))
                    sum2 += value;
                }
              }
              return sum2;
            }
            function transpose(matrix) {
              if (!(n = matrix.length))
                return [];
              for (var i = -1, m = min(matrix, length), transpose2 = new Array(m); ++i < m; ) {
                for (var j = -1, n, row = transpose2[i] = new Array(n); ++j < n; ) {
                  row[j] = matrix[j][i];
                }
              }
              return transpose2;
            }
            function length(d) {
              return d.length;
            }
            function zip() {
              return transpose(arguments);
            }
            exports3.bisect = bisectRight;
            exports3.bisectRight = bisectRight;
            exports3.bisectLeft = bisectLeft;
            exports3.ascending = ascending;
            exports3.bisector = bisector;
            exports3.cross = cross;
            exports3.descending = descending;
            exports3.deviation = deviation;
            exports3.extent = extent;
            exports3.histogram = histogram;
            exports3.thresholdFreedmanDiaconis = freedmanDiaconis;
            exports3.thresholdScott = scott;
            exports3.thresholdSturges = sturges;
            exports3.max = max;
            exports3.mean = mean;
            exports3.median = median;
            exports3.merge = merge;
            exports3.min = min;
            exports3.pairs = pairs;
            exports3.permute = permute;
            exports3.quantile = quantile;
            exports3.range = range;
            exports3.scan = scan;
            exports3.shuffle = shuffle;
            exports3.sum = sum;
            exports3.ticks = ticks;
            exports3.tickIncrement = tickIncrement;
            exports3.tickStep = tickStep;
            exports3.transpose = transpose;
            exports3.variance = variance;
            exports3.zip = zip;
            Object.defineProperty(exports3, "__esModule", { value: true });
          });
        },
        "./node_modules/_d3-array@2.11.0@d3-array/dist/d3-array.js": function(module2, exports2, __webpack_require__) {
          var tslib_1 = __webpack_require__("./node_modules/_tslib@2.1.0@tslib/tslib.js");
          (function(global, factory) {
            true ? factory(exports2) : void 0;
          })(this, function(exports3) {
            "use strict";
            function ascending(a, b) {
              return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
            }
            function bisector(f) {
              var delta = f;
              var compare = f;
              if (f.length === 1) {
                delta = function(d, x) {
                  return f(d) - x;
                };
                compare = ascendingComparator(f);
              }
              function left(a, x, lo, hi) {
                if (lo == null)
                  lo = 0;
                if (hi == null)
                  hi = a.length;
                while (lo < hi) {
                  var mid = lo + hi >>> 1;
                  if (compare(a[mid], x) < 0)
                    lo = mid + 1;
                  else
                    hi = mid;
                }
                return lo;
              }
              function right(a, x, lo, hi) {
                if (lo == null)
                  lo = 0;
                if (hi == null)
                  hi = a.length;
                while (lo < hi) {
                  var mid = lo + hi >>> 1;
                  if (compare(a[mid], x) > 0)
                    hi = mid;
                  else
                    lo = mid + 1;
                }
                return lo;
              }
              function center(a, x, lo, hi) {
                if (lo == null)
                  lo = 0;
                if (hi == null)
                  hi = a.length;
                var i = left(a, x, lo, hi - 1);
                return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
              }
              return { left, center, right };
            }
            function ascendingComparator(f) {
              return function(d, x) {
                return ascending(f(d), x);
              };
            }
            function number(x) {
              return x === null ? NaN : +x;
            }
            function numbers(values, valueof) {
              var values_1, values_1_1, value, e_1_1, index_1, values_2, values_2_1, value, e_2_1;
              var e_1, _a, e_2, _b;
              return tslib_1.__generator(this, function(_c) {
                switch (_c.label) {
                  case 0:
                    if (!(valueof === void 0))
                      return [3, 9];
                    _c.label = 1;
                  case 1:
                    _c.trys.push([1, 6, 7, 8]);
                    values_1 = tslib_1.__values(values), values_1_1 = values_1.next();
                    _c.label = 2;
                  case 2:
                    if (!!values_1_1.done)
                      return [3, 5];
                    value = values_1_1.value;
                    if (!(value != null && (value = +value) >= value))
                      return [3, 4];
                    return [4, value];
                  case 3:
                    _c.sent();
                    _c.label = 4;
                  case 4:
                    values_1_1 = values_1.next();
                    return [3, 2];
                  case 5:
                    return [3, 8];
                  case 6:
                    e_1_1 = _c.sent();
                    e_1 = { error: e_1_1 };
                    return [3, 8];
                  case 7:
                    try {
                      if (values_1_1 && !values_1_1.done && (_a = values_1.return))
                        _a.call(values_1);
                    } finally {
                      if (e_1)
                        throw e_1.error;
                    }
                    return [7];
                  case 8:
                    return [3, 17];
                  case 9:
                    index_1 = -1;
                    _c.label = 10;
                  case 10:
                    _c.trys.push([10, 15, 16, 17]);
                    values_2 = tslib_1.__values(values), values_2_1 = values_2.next();
                    _c.label = 11;
                  case 11:
                    if (!!values_2_1.done)
                      return [3, 14];
                    value = values_2_1.value;
                    if (!((value = valueof(value, ++index_1, values)) != null && (value = +value) >= value))
                      return [3, 13];
                    return [4, value];
                  case 12:
                    _c.sent();
                    _c.label = 13;
                  case 13:
                    values_2_1 = values_2.next();
                    return [3, 11];
                  case 14:
                    return [3, 17];
                  case 15:
                    e_2_1 = _c.sent();
                    e_2 = { error: e_2_1 };
                    return [3, 17];
                  case 16:
                    try {
                      if (values_2_1 && !values_2_1.done && (_b = values_2.return))
                        _b.call(values_2);
                    } finally {
                      if (e_2)
                        throw e_2.error;
                    }
                    return [7];
                  case 17:
                    return [2];
                }
              });
            }
            var ascendingBisect = bisector(ascending);
            var bisectRight = ascendingBisect.right;
            var bisectLeft = ascendingBisect.left;
            var bisectCenter = bisector(number).center;
            function count(values, valueof) {
              var e_3, _a, e_4, _b;
              var count2 = 0;
              if (valueof === void 0) {
                try {
                  for (var values_3 = tslib_1.__values(values), values_3_1 = values_3.next(); !values_3_1.done; values_3_1 = values_3.next()) {
                    var value = values_3_1.value;
                    if (value != null && (value = +value) >= value) {
                      ++count2;
                    }
                  }
                } catch (e_3_1) {
                  e_3 = { error: e_3_1 };
                } finally {
                  try {
                    if (values_3_1 && !values_3_1.done && (_a = values_3.return))
                      _a.call(values_3);
                  } finally {
                    if (e_3)
                      throw e_3.error;
                  }
                }
              } else {
                var index_2 = -1;
                try {
                  for (var values_4 = tslib_1.__values(values), values_4_1 = values_4.next(); !values_4_1.done; values_4_1 = values_4.next()) {
                    var value = values_4_1.value;
                    if ((value = valueof(value, ++index_2, values)) != null && (value = +value) >= value) {
                      ++count2;
                    }
                  }
                } catch (e_4_1) {
                  e_4 = { error: e_4_1 };
                } finally {
                  try {
                    if (values_4_1 && !values_4_1.done && (_b = values_4.return))
                      _b.call(values_4);
                  } finally {
                    if (e_4)
                      throw e_4.error;
                  }
                }
              }
              return count2;
            }
            function length(array2) {
              return array2.length | 0;
            }
            function empty(length2) {
              return !(length2 > 0);
            }
            function arrayify(values) {
              return typeof values !== "object" || "length" in values ? values : Array.from(values);
            }
            function reducer(reduce2) {
              return function(values) {
                return reduce2.apply(void 0, tslib_1.__spread(values));
              };
            }
            function cross() {
              var values = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                values[_i] = arguments[_i];
              }
              var reduce2 = typeof values[values.length - 1] === "function" && reducer(values.pop());
              values = values.map(arrayify);
              var lengths = values.map(length);
              var j = values.length - 1;
              var index2 = new Array(j + 1).fill(0);
              var product = [];
              if (j < 0 || lengths.some(empty))
                return product;
              while (true) {
                product.push(index2.map(function(j2, i2) {
                  return values[i2][j2];
                }));
                var i = j;
                while (++index2[i] === lengths[i]) {
                  if (i === 0)
                    return reduce2 ? product.map(reduce2) : product;
                  index2[i--] = 0;
                }
              }
            }
            function cumsum(values, valueof) {
              var sum2 = 0, index2 = 0;
              return Float64Array.from(values, valueof === void 0 ? function(v) {
                return sum2 += +v || 0;
              } : function(v) {
                return sum2 += +valueof(v, index2++, values) || 0;
              });
            }
            function descending(a, b) {
              return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
            }
            function variance(values, valueof) {
              var e_5, _a, e_6, _b;
              var count2 = 0;
              var delta;
              var mean2 = 0;
              var sum2 = 0;
              if (valueof === void 0) {
                try {
                  for (var values_5 = tslib_1.__values(values), values_5_1 = values_5.next(); !values_5_1.done; values_5_1 = values_5.next()) {
                    var value = values_5_1.value;
                    if (value != null && (value = +value) >= value) {
                      delta = value - mean2;
                      mean2 += delta / ++count2;
                      sum2 += delta * (value - mean2);
                    }
                  }
                } catch (e_5_1) {
                  e_5 = { error: e_5_1 };
                } finally {
                  try {
                    if (values_5_1 && !values_5_1.done && (_a = values_5.return))
                      _a.call(values_5);
                  } finally {
                    if (e_5)
                      throw e_5.error;
                  }
                }
              } else {
                var index_3 = -1;
                try {
                  for (var values_6 = tslib_1.__values(values), values_6_1 = values_6.next(); !values_6_1.done; values_6_1 = values_6.next()) {
                    var value = values_6_1.value;
                    if ((value = valueof(value, ++index_3, values)) != null && (value = +value) >= value) {
                      delta = value - mean2;
                      mean2 += delta / ++count2;
                      sum2 += delta * (value - mean2);
                    }
                  }
                } catch (e_6_1) {
                  e_6 = { error: e_6_1 };
                } finally {
                  try {
                    if (values_6_1 && !values_6_1.done && (_b = values_6.return))
                      _b.call(values_6);
                  } finally {
                    if (e_6)
                      throw e_6.error;
                  }
                }
              }
              if (count2 > 1)
                return sum2 / (count2 - 1);
            }
            function deviation(values, valueof) {
              var v = variance(values, valueof);
              return v ? Math.sqrt(v) : v;
            }
            function extent(values, valueof) {
              var e_7, _a, e_8, _b;
              var min2;
              var max2;
              if (valueof === void 0) {
                try {
                  for (var values_7 = tslib_1.__values(values), values_7_1 = values_7.next(); !values_7_1.done; values_7_1 = values_7.next()) {
                    var value = values_7_1.value;
                    if (value != null) {
                      if (min2 === void 0) {
                        if (value >= value)
                          min2 = max2 = value;
                      } else {
                        if (min2 > value)
                          min2 = value;
                        if (max2 < value)
                          max2 = value;
                      }
                    }
                  }
                } catch (e_7_1) {
                  e_7 = { error: e_7_1 };
                } finally {
                  try {
                    if (values_7_1 && !values_7_1.done && (_a = values_7.return))
                      _a.call(values_7);
                  } finally {
                    if (e_7)
                      throw e_7.error;
                  }
                }
              } else {
                var index_4 = -1;
                try {
                  for (var values_8 = tslib_1.__values(values), values_8_1 = values_8.next(); !values_8_1.done; values_8_1 = values_8.next()) {
                    var value = values_8_1.value;
                    if ((value = valueof(value, ++index_4, values)) != null) {
                      if (min2 === void 0) {
                        if (value >= value)
                          min2 = max2 = value;
                      } else {
                        if (min2 > value)
                          min2 = value;
                        if (max2 < value)
                          max2 = value;
                      }
                    }
                  }
                } catch (e_8_1) {
                  e_8 = { error: e_8_1 };
                } finally {
                  try {
                    if (values_8_1 && !values_8_1.done && (_b = values_8.return))
                      _b.call(values_8);
                  } finally {
                    if (e_8)
                      throw e_8.error;
                  }
                }
              }
              return [min2, max2];
            }
            var Adder = function() {
              function Adder2() {
                this._partials = new Float64Array(32);
                this._n = 0;
              }
              Adder2.prototype.add = function(x) {
                var p = this._partials;
                var i = 0;
                for (var j = 0; j < this._n && j < 32; j++) {
                  var y = p[j], hi = x + y, lo = Math.abs(x) < Math.abs(y) ? x - (hi - y) : y - (hi - x);
                  if (lo)
                    p[i++] = lo;
                  x = hi;
                }
                p[i] = x;
                this._n = i + 1;
                return this;
              };
              Adder2.prototype.valueOf = function() {
                var p = this._partials;
                var n = this._n, x, y, lo, hi = 0;
                if (n > 0) {
                  hi = p[--n];
                  while (n > 0) {
                    x = hi;
                    y = p[--n];
                    hi = x + y;
                    lo = y - (hi - x);
                    if (lo)
                      break;
                  }
                  if (n > 0 && (lo < 0 && p[n - 1] < 0 || lo > 0 && p[n - 1] > 0)) {
                    y = lo * 2;
                    x = hi + y;
                    if (y == x - hi)
                      hi = x;
                  }
                }
                return hi;
              };
              return Adder2;
            }();
            function fsum(values, valueof) {
              var e_9, _a, e_10, _b;
              var adder = new Adder();
              if (valueof === void 0) {
                try {
                  for (var values_9 = tslib_1.__values(values), values_9_1 = values_9.next(); !values_9_1.done; values_9_1 = values_9.next()) {
                    var value = values_9_1.value;
                    if (value = +value) {
                      adder.add(value);
                    }
                  }
                } catch (e_9_1) {
                  e_9 = { error: e_9_1 };
                } finally {
                  try {
                    if (values_9_1 && !values_9_1.done && (_a = values_9.return))
                      _a.call(values_9);
                  } finally {
                    if (e_9)
                      throw e_9.error;
                  }
                }
              } else {
                var index_5 = -1;
                try {
                  for (var values_10 = tslib_1.__values(values), values_10_1 = values_10.next(); !values_10_1.done; values_10_1 = values_10.next()) {
                    var value = values_10_1.value;
                    if (value = +valueof(value, ++index_5, values)) {
                      adder.add(value);
                    }
                  }
                } catch (e_10_1) {
                  e_10 = { error: e_10_1 };
                } finally {
                  try {
                    if (values_10_1 && !values_10_1.done && (_b = values_10.return))
                      _b.call(values_10);
                  } finally {
                    if (e_10)
                      throw e_10.error;
                  }
                }
              }
              return +adder;
            }
            var InternMap = function(_super) {
              tslib_1.__extends(InternMap2, _super);
              function InternMap2(entries, key) {
                var e_11, _a;
                if (entries === void 0) {
                  entries = [];
                }
                if (key === void 0) {
                  key = keyof;
                }
                var _this = _super.call(this) || this;
                Object.defineProperties(_this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
                try {
                  for (var entries_1 = tslib_1.__values(entries), entries_1_1 = entries_1.next(); !entries_1_1.done; entries_1_1 = entries_1.next()) {
                    var _b = tslib_1.__read(entries_1_1.value, 2), key_1 = _b[0], value = _b[1];
                    _this.set(key_1, value);
                  }
                } catch (e_11_1) {
                  e_11 = { error: e_11_1 };
                } finally {
                  try {
                    if (entries_1_1 && !entries_1_1.done && (_a = entries_1.return))
                      _a.call(entries_1);
                  } finally {
                    if (e_11)
                      throw e_11.error;
                  }
                }
                return _this;
              }
              InternMap2.prototype.get = function(key) {
                return _super.prototype.get.call(this, intern_get(this, key));
              };
              InternMap2.prototype.has = function(key) {
                return _super.prototype.has.call(this, intern_get(this, key));
              };
              InternMap2.prototype.set = function(key, value) {
                return _super.prototype.set.call(this, intern_set(this, key), value);
              };
              InternMap2.prototype.delete = function(key) {
                return _super.prototype.delete.call(this, intern_delete(this, key));
              };
              return InternMap2;
            }(Map);
            var InternSet = function(_super) {
              tslib_1.__extends(InternSet2, _super);
              function InternSet2(values, key) {
                var e_12, _a;
                if (values === void 0) {
                  values = [];
                }
                if (key === void 0) {
                  key = keyof;
                }
                var _this = _super.call(this) || this;
                Object.defineProperties(_this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
                try {
                  for (var values_11 = tslib_1.__values(values), values_11_1 = values_11.next(); !values_11_1.done; values_11_1 = values_11.next()) {
                    var value = values_11_1.value;
                    _this.add(value);
                  }
                } catch (e_12_1) {
                  e_12 = { error: e_12_1 };
                } finally {
                  try {
                    if (values_11_1 && !values_11_1.done && (_a = values_11.return))
                      _a.call(values_11);
                  } finally {
                    if (e_12)
                      throw e_12.error;
                  }
                }
                return _this;
              }
              InternSet2.prototype.has = function(value) {
                return _super.prototype.has.call(this, intern_get(this, value));
              };
              InternSet2.prototype.add = function(value) {
                return _super.prototype.add.call(this, intern_set(this, value));
              };
              InternSet2.prototype.delete = function(value) {
                return _super.prototype.delete.call(this, intern_delete(this, value));
              };
              return InternSet2;
            }(Set);
            function intern_get(_a, value) {
              var _intern = _a._intern, _key = _a._key;
              var key = _key(value);
              return _intern.has(key) ? _intern.get(key) : value;
            }
            function intern_set(_a, value) {
              var _intern = _a._intern, _key = _a._key;
              var key = _key(value);
              if (_intern.has(key))
                return _intern.get(key);
              _intern.set(key, value);
              return value;
            }
            function intern_delete(_a, value) {
              var _intern = _a._intern, _key = _a._key;
              var key = _key(value);
              if (_intern.has(key)) {
                value = _intern.get(value);
                _intern.delete(key);
              }
              return value;
            }
            function keyof(value) {
              return value !== null && typeof value === "object" ? value.valueOf() : value;
            }
            function identity(x) {
              return x;
            }
            function group(values) {
              var keys = [];
              for (var _i = 1; _i < arguments.length; _i++) {
                keys[_i - 1] = arguments[_i];
              }
              return nest(values, identity, identity, keys);
            }
            function groups(values) {
              var keys = [];
              for (var _i = 1; _i < arguments.length; _i++) {
                keys[_i - 1] = arguments[_i];
              }
              return nest(values, Array.from, identity, keys);
            }
            function rollup(values, reduce2) {
              var keys = [];
              for (var _i = 2; _i < arguments.length; _i++) {
                keys[_i - 2] = arguments[_i];
              }
              return nest(values, identity, reduce2, keys);
            }
            function rollups(values, reduce2) {
              var keys = [];
              for (var _i = 2; _i < arguments.length; _i++) {
                keys[_i - 2] = arguments[_i];
              }
              return nest(values, Array.from, reduce2, keys);
            }
            function index(values) {
              var keys = [];
              for (var _i = 1; _i < arguments.length; _i++) {
                keys[_i - 1] = arguments[_i];
              }
              return nest(values, identity, unique, keys);
            }
            function indexes(values) {
              var keys = [];
              for (var _i = 1; _i < arguments.length; _i++) {
                keys[_i - 1] = arguments[_i];
              }
              return nest(values, Array.from, unique, keys);
            }
            function unique(values) {
              if (values.length !== 1)
                throw new Error("duplicate key");
              return values[0];
            }
            function nest(values, map2, reduce2, keys) {
              return function regroup(values2, i) {
                var e_13, _a, e_14, _b;
                if (i >= keys.length)
                  return reduce2(values2);
                var groups2 = new InternMap();
                var keyof2 = keys[i++];
                var index2 = -1;
                try {
                  for (var values_12 = tslib_1.__values(values2), values_12_1 = values_12.next(); !values_12_1.done; values_12_1 = values_12.next()) {
                    var value = values_12_1.value;
                    var key = keyof2(value, ++index2, values2);
                    var group_1 = groups2.get(key);
                    if (group_1)
                      group_1.push(value);
                    else
                      groups2.set(key, [value]);
                  }
                } catch (e_13_1) {
                  e_13 = { error: e_13_1 };
                } finally {
                  try {
                    if (values_12_1 && !values_12_1.done && (_a = values_12.return))
                      _a.call(values_12);
                  } finally {
                    if (e_13)
                      throw e_13.error;
                  }
                }
                try {
                  for (var groups_1 = tslib_1.__values(groups2), groups_1_1 = groups_1.next(); !groups_1_1.done; groups_1_1 = groups_1.next()) {
                    var _c = tslib_1.__read(groups_1_1.value, 2), key = _c[0], values_13 = _c[1];
                    groups2.set(key, regroup(values_13, i));
                  }
                } catch (e_14_1) {
                  e_14 = { error: e_14_1 };
                } finally {
                  try {
                    if (groups_1_1 && !groups_1_1.done && (_b = groups_1.return))
                      _b.call(groups_1);
                  } finally {
                    if (e_14)
                      throw e_14.error;
                  }
                }
                return map2(groups2);
              }(values, 0);
            }
            function permute(source, keys) {
              return Array.from(keys, function(key) {
                return source[key];
              });
            }
            function sort(values) {
              var F = [];
              for (var _i = 1; _i < arguments.length; _i++) {
                F[_i - 1] = arguments[_i];
              }
              if (typeof values[Symbol.iterator] !== "function")
                throw new TypeError("values is not iterable");
              values = Array.from(values);
              var _a = tslib_1.__read(F, 1), _b = _a[0], f = _b === void 0 ? ascending : _b;
              if (f.length === 1 || F.length > 1) {
                var index_6 = Uint32Array.from(values, function(d, i) {
                  return i;
                });
                if (F.length > 1) {
                  F = F.map(function(f2) {
                    return values.map(f2);
                  });
                  index_6.sort(function(i, j) {
                    var e_15, _a2;
                    try {
                      for (var F_1 = tslib_1.__values(F), F_1_1 = F_1.next(); !F_1_1.done; F_1_1 = F_1.next()) {
                        var f_1 = F_1_1.value;
                        var c = ascending(f_1[i], f_1[j]);
                        if (c)
                          return c;
                      }
                    } catch (e_15_1) {
                      e_15 = { error: e_15_1 };
                    } finally {
                      try {
                        if (F_1_1 && !F_1_1.done && (_a2 = F_1.return))
                          _a2.call(F_1);
                      } finally {
                        if (e_15)
                          throw e_15.error;
                      }
                    }
                  });
                } else {
                  f = values.map(f);
                  index_6.sort(function(i, j) {
                    return ascending(f[i], f[j]);
                  });
                }
                return permute(values, index_6);
              }
              return values.sort(f);
            }
            function groupSort(values, reduce2, key) {
              return (reduce2.length === 1 ? sort(rollup(values, reduce2, key), function(_a, _b) {
                var _c = tslib_1.__read(_a, 2), ak = _c[0], av = _c[1];
                var _d = tslib_1.__read(_b, 2), bk = _d[0], bv = _d[1];
                return ascending(av, bv) || ascending(ak, bk);
              }) : sort(group(values, key), function(_a, _b) {
                var _c = tslib_1.__read(_a, 2), ak = _c[0], av = _c[1];
                var _d = tslib_1.__read(_b, 2), bk = _d[0], bv = _d[1];
                return reduce2(av, bv) || ascending(ak, bk);
              })).map(function(_a) {
                var _b = tslib_1.__read(_a, 1), key2 = _b[0];
                return key2;
              });
            }
            var array = Array.prototype;
            var slice = array.slice;
            function constant(x) {
              return function() {
                return x;
              };
            }
            var e10 = Math.sqrt(50), e5 = Math.sqrt(10), e2 = Math.sqrt(2);
            function ticks(start, stop, count2) {
              var reverse2, i = -1, n, ticks2, step;
              stop = +stop, start = +start, count2 = +count2;
              if (start === stop && count2 > 0)
                return [start];
              if (reverse2 = stop < start)
                n = start, start = stop, stop = n;
              if ((step = tickIncrement(start, stop, count2)) === 0 || !isFinite(step))
                return [];
              if (step > 0) {
                start = Math.ceil(start / step);
                stop = Math.floor(stop / step);
                ticks2 = new Array(n = Math.ceil(stop - start + 1));
                while (++i < n)
                  ticks2[i] = (start + i) * step;
              } else {
                step = -step;
                start = Math.ceil(start * step);
                stop = Math.floor(stop * step);
                ticks2 = new Array(n = Math.ceil(stop - start + 1));
                while (++i < n)
                  ticks2[i] = (start + i) / step;
              }
              if (reverse2)
                ticks2.reverse();
              return ticks2;
            }
            function tickIncrement(start, stop, count2) {
              var step = (stop - start) / Math.max(0, count2), power = Math.floor(Math.log(step) / Math.LN10), error = step / Math.pow(10, power);
              return power >= 0 ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
            }
            function tickStep(start, stop, count2) {
              var step0 = Math.abs(stop - start) / Math.max(0, count2), step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)), error = step0 / step1;
              if (error >= e10)
                step1 *= 10;
              else if (error >= e5)
                step1 *= 5;
              else if (error >= e2)
                step1 *= 2;
              return stop < start ? -step1 : step1;
            }
            function nice(start, stop, count2) {
              var prestep;
              while (true) {
                var step = tickIncrement(start, stop, count2);
                if (step === prestep || step === 0 || !isFinite(step)) {
                  return [start, stop];
                } else if (step > 0) {
                  start = Math.floor(start / step) * step;
                  stop = Math.ceil(stop / step) * step;
                } else if (step < 0) {
                  start = Math.ceil(start * step) / step;
                  stop = Math.floor(stop * step) / step;
                }
                prestep = step;
              }
            }
            function sturges(values) {
              return Math.ceil(Math.log(count(values)) / Math.LN2) + 1;
            }
            function bin() {
              var value = identity, domain = extent, threshold = sturges;
              function histogram(data) {
                var _a;
                if (!Array.isArray(data))
                  data = Array.from(data);
                var i, n = data.length, x, values = new Array(n);
                for (i = 0; i < n; ++i) {
                  values[i] = value(data[i], i, data);
                }
                var xz = domain(values), x0 = xz[0], x1 = xz[1], tz = threshold(values, x0, x1);
                if (!Array.isArray(tz)) {
                  var max_1 = x1, tn = +tz;
                  if (domain === extent)
                    _a = tslib_1.__read(nice(x0, x1, tn), 2), x0 = _a[0], x1 = _a[1];
                  tz = ticks(x0, x1, tn);
                  if (tz[tz.length - 1] >= x1) {
                    if (max_1 >= x1 && domain === extent) {
                      var step = tickIncrement(x0, x1, tn);
                      if (isFinite(step)) {
                        if (step > 0) {
                          x1 = (Math.floor(x1 / step) + 1) * step;
                        } else if (step < 0) {
                          x1 = (Math.ceil(x1 * -step) + 1) / -step;
                        }
                      }
                    } else {
                      tz.pop();
                    }
                  }
                }
                var m = tz.length;
                while (tz[0] <= x0)
                  tz.shift(), --m;
                while (tz[m - 1] > x1)
                  tz.pop(), --m;
                var bins = new Array(m + 1), bin2;
                for (i = 0; i <= m; ++i) {
                  bin2 = bins[i] = [];
                  bin2.x0 = i > 0 ? tz[i - 1] : x0;
                  bin2.x1 = i < m ? tz[i] : x1;
                }
                for (i = 0; i < n; ++i) {
                  x = values[i];
                  if (x0 <= x && x <= x1) {
                    bins[bisectRight(tz, x, 0, m)].push(data[i]);
                  }
                }
                return bins;
              }
              histogram.value = function(_) {
                return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram) : value;
              };
              histogram.domain = function(_) {
                return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram) : domain;
              };
              histogram.thresholds = function(_) {
                return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;
              };
              return histogram;
            }
            function max(values, valueof) {
              var e_16, _a, e_17, _b;
              var max2;
              if (valueof === void 0) {
                try {
                  for (var values_14 = tslib_1.__values(values), values_14_1 = values_14.next(); !values_14_1.done; values_14_1 = values_14.next()) {
                    var value = values_14_1.value;
                    if (value != null && (max2 < value || max2 === void 0 && value >= value)) {
                      max2 = value;
                    }
                  }
                } catch (e_16_1) {
                  e_16 = { error: e_16_1 };
                } finally {
                  try {
                    if (values_14_1 && !values_14_1.done && (_a = values_14.return))
                      _a.call(values_14);
                  } finally {
                    if (e_16)
                      throw e_16.error;
                  }
                }
              } else {
                var index_7 = -1;
                try {
                  for (var values_15 = tslib_1.__values(values), values_15_1 = values_15.next(); !values_15_1.done; values_15_1 = values_15.next()) {
                    var value = values_15_1.value;
                    if ((value = valueof(value, ++index_7, values)) != null && (max2 < value || max2 === void 0 && value >= value)) {
                      max2 = value;
                    }
                  }
                } catch (e_17_1) {
                  e_17 = { error: e_17_1 };
                } finally {
                  try {
                    if (values_15_1 && !values_15_1.done && (_b = values_15.return))
                      _b.call(values_15);
                  } finally {
                    if (e_17)
                      throw e_17.error;
                  }
                }
              }
              return max2;
            }
            function min(values, valueof) {
              var e_18, _a, e_19, _b;
              var min2;
              if (valueof === void 0) {
                try {
                  for (var values_16 = tslib_1.__values(values), values_16_1 = values_16.next(); !values_16_1.done; values_16_1 = values_16.next()) {
                    var value = values_16_1.value;
                    if (value != null && (min2 > value || min2 === void 0 && value >= value)) {
                      min2 = value;
                    }
                  }
                } catch (e_18_1) {
                  e_18 = { error: e_18_1 };
                } finally {
                  try {
                    if (values_16_1 && !values_16_1.done && (_a = values_16.return))
                      _a.call(values_16);
                  } finally {
                    if (e_18)
                      throw e_18.error;
                  }
                }
              } else {
                var index_8 = -1;
                try {
                  for (var values_17 = tslib_1.__values(values), values_17_1 = values_17.next(); !values_17_1.done; values_17_1 = values_17.next()) {
                    var value = values_17_1.value;
                    if ((value = valueof(value, ++index_8, values)) != null && (min2 > value || min2 === void 0 && value >= value)) {
                      min2 = value;
                    }
                  }
                } catch (e_19_1) {
                  e_19 = { error: e_19_1 };
                } finally {
                  try {
                    if (values_17_1 && !values_17_1.done && (_b = values_17.return))
                      _b.call(values_17);
                  } finally {
                    if (e_19)
                      throw e_19.error;
                  }
                }
              }
              return min2;
            }
            function quickselect(array2, k, left, right, compare) {
              if (left === void 0) {
                left = 0;
              }
              if (right === void 0) {
                right = array2.length - 1;
              }
              if (compare === void 0) {
                compare = ascending;
              }
              while (right > left) {
                if (right - left > 600) {
                  var n = right - left + 1;
                  var m = k - left + 1;
                  var z = Math.log(n);
                  var s = 0.5 * Math.exp(2 * z / 3);
                  var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
                  var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
                  var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
                  quickselect(array2, k, newLeft, newRight, compare);
                }
                var t = array2[k];
                var i = left;
                var j = right;
                swap(array2, left, k);
                if (compare(array2[right], t) > 0)
                  swap(array2, left, right);
                while (i < j) {
                  swap(array2, i, j), ++i, --j;
                  while (compare(array2[i], t) < 0)
                    ++i;
                  while (compare(array2[j], t) > 0)
                    --j;
                }
                if (compare(array2[left], t) === 0)
                  swap(array2, left, j);
                else
                  ++j, swap(array2, j, right);
                if (j <= k)
                  left = j + 1;
                if (k <= j)
                  right = j - 1;
              }
              return array2;
            }
            function swap(array2, i, j) {
              var t = array2[i];
              array2[i] = array2[j];
              array2[j] = t;
            }
            function quantile(values, p, valueof) {
              values = Float64Array.from(numbers(values, valueof));
              if (!(n = values.length))
                return;
              if ((p = +p) <= 0 || n < 2)
                return min(values);
              if (p >= 1)
                return max(values);
              var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = max(quickselect(values, i0).subarray(0, i0 + 1)), value1 = min(values.subarray(i0 + 1));
              return value0 + (value1 - value0) * (i - i0);
            }
            function quantileSorted(values, p, valueof) {
              if (valueof === void 0) {
                valueof = number;
              }
              if (!(n = values.length))
                return;
              if ((p = +p) <= 0 || n < 2)
                return +valueof(values[0], 0, values);
              if (p >= 1)
                return +valueof(values[n - 1], n - 1, values);
              var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = +valueof(values[i0], i0, values), value1 = +valueof(values[i0 + 1], i0 + 1, values);
              return value0 + (value1 - value0) * (i - i0);
            }
            function freedmanDiaconis(values, min2, max2) {
              return Math.ceil((max2 - min2) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * Math.pow(count(values), -1 / 3)));
            }
            function scott(values, min2, max2) {
              return Math.ceil((max2 - min2) / (3.5 * deviation(values) * Math.pow(count(values), -1 / 3)));
            }
            function maxIndex(values, valueof) {
              var e_20, _a, e_21, _b;
              var max2;
              var maxIndex2 = -1;
              var index2 = -1;
              if (valueof === void 0) {
                try {
                  for (var values_18 = tslib_1.__values(values), values_18_1 = values_18.next(); !values_18_1.done; values_18_1 = values_18.next()) {
                    var value = values_18_1.value;
                    ++index2;
                    if (value != null && (max2 < value || max2 === void 0 && value >= value)) {
                      max2 = value, maxIndex2 = index2;
                    }
                  }
                } catch (e_20_1) {
                  e_20 = { error: e_20_1 };
                } finally {
                  try {
                    if (values_18_1 && !values_18_1.done && (_a = values_18.return))
                      _a.call(values_18);
                  } finally {
                    if (e_20)
                      throw e_20.error;
                  }
                }
              } else {
                try {
                  for (var values_19 = tslib_1.__values(values), values_19_1 = values_19.next(); !values_19_1.done; values_19_1 = values_19.next()) {
                    var value = values_19_1.value;
                    if ((value = valueof(value, ++index2, values)) != null && (max2 < value || max2 === void 0 && value >= value)) {
                      max2 = value, maxIndex2 = index2;
                    }
                  }
                } catch (e_21_1) {
                  e_21 = { error: e_21_1 };
                } finally {
                  try {
                    if (values_19_1 && !values_19_1.done && (_b = values_19.return))
                      _b.call(values_19);
                  } finally {
                    if (e_21)
                      throw e_21.error;
                  }
                }
              }
              return maxIndex2;
            }
            function mean(values, valueof) {
              var e_22, _a, e_23, _b;
              var count2 = 0;
              var sum2 = 0;
              if (valueof === void 0) {
                try {
                  for (var values_20 = tslib_1.__values(values), values_20_1 = values_20.next(); !values_20_1.done; values_20_1 = values_20.next()) {
                    var value = values_20_1.value;
                    if (value != null && (value = +value) >= value) {
                      ++count2, sum2 += value;
                    }
                  }
                } catch (e_22_1) {
                  e_22 = { error: e_22_1 };
                } finally {
                  try {
                    if (values_20_1 && !values_20_1.done && (_a = values_20.return))
                      _a.call(values_20);
                  } finally {
                    if (e_22)
                      throw e_22.error;
                  }
                }
              } else {
                var index_9 = -1;
                try {
                  for (var values_21 = tslib_1.__values(values), values_21_1 = values_21.next(); !values_21_1.done; values_21_1 = values_21.next()) {
                    var value = values_21_1.value;
                    if ((value = valueof(value, ++index_9, values)) != null && (value = +value) >= value) {
                      ++count2, sum2 += value;
                    }
                  }
                } catch (e_23_1) {
                  e_23 = { error: e_23_1 };
                } finally {
                  try {
                    if (values_21_1 && !values_21_1.done && (_b = values_21.return))
                      _b.call(values_21);
                  } finally {
                    if (e_23)
                      throw e_23.error;
                  }
                }
              }
              if (count2)
                return sum2 / count2;
            }
            function median(values, valueof) {
              return quantile(values, 0.5, valueof);
            }
            function flatten(arrays) {
              var arrays_1, arrays_1_1, array_1, e_24_1;
              var e_24, _a;
              return tslib_1.__generator(this, function(_b) {
                switch (_b.label) {
                  case 0:
                    _b.trys.push([0, 5, 6, 7]);
                    arrays_1 = tslib_1.__values(arrays), arrays_1_1 = arrays_1.next();
                    _b.label = 1;
                  case 1:
                    if (!!arrays_1_1.done)
                      return [3, 4];
                    array_1 = arrays_1_1.value;
                    return [5, tslib_1.__values(array_1)];
                  case 2:
                    _b.sent();
                    _b.label = 3;
                  case 3:
                    arrays_1_1 = arrays_1.next();
                    return [3, 1];
                  case 4:
                    return [3, 7];
                  case 5:
                    e_24_1 = _b.sent();
                    e_24 = { error: e_24_1 };
                    return [3, 7];
                  case 6:
                    try {
                      if (arrays_1_1 && !arrays_1_1.done && (_a = arrays_1.return))
                        _a.call(arrays_1);
                    } finally {
                      if (e_24)
                        throw e_24.error;
                    }
                    return [7];
                  case 7:
                    return [2];
                }
              });
            }
            function merge(arrays) {
              return Array.from(flatten(arrays));
            }
            function minIndex(values, valueof) {
              var e_25, _a, e_26, _b;
              var min2;
              var minIndex2 = -1;
              var index2 = -1;
              if (valueof === void 0) {
                try {
                  for (var values_22 = tslib_1.__values(values), values_22_1 = values_22.next(); !values_22_1.done; values_22_1 = values_22.next()) {
                    var value = values_22_1.value;
                    ++index2;
                    if (value != null && (min2 > value || min2 === void 0 && value >= value)) {
                      min2 = value, minIndex2 = index2;
                    }
                  }
                } catch (e_25_1) {
                  e_25 = { error: e_25_1 };
                } finally {
                  try {
                    if (values_22_1 && !values_22_1.done && (_a = values_22.return))
                      _a.call(values_22);
                  } finally {
                    if (e_25)
                      throw e_25.error;
                  }
                }
              } else {
                try {
                  for (var values_23 = tslib_1.__values(values), values_23_1 = values_23.next(); !values_23_1.done; values_23_1 = values_23.next()) {
                    var value = values_23_1.value;
                    if ((value = valueof(value, ++index2, values)) != null && (min2 > value || min2 === void 0 && value >= value)) {
                      min2 = value, minIndex2 = index2;
                    }
                  }
                } catch (e_26_1) {
                  e_26 = { error: e_26_1 };
                } finally {
                  try {
                    if (values_23_1 && !values_23_1.done && (_b = values_23.return))
                      _b.call(values_23);
                  } finally {
                    if (e_26)
                      throw e_26.error;
                  }
                }
              }
              return minIndex2;
            }
            function pairs(values, pairof) {
              var e_27, _a;
              if (pairof === void 0) {
                pairof = pair;
              }
              var pairs2 = [];
              var previous;
              var first = false;
              try {
                for (var values_24 = tslib_1.__values(values), values_24_1 = values_24.next(); !values_24_1.done; values_24_1 = values_24.next()) {
                  var value = values_24_1.value;
                  if (first)
                    pairs2.push(pairof(previous, value));
                  previous = value;
                  first = true;
                }
              } catch (e_27_1) {
                e_27 = { error: e_27_1 };
              } finally {
                try {
                  if (values_24_1 && !values_24_1.done && (_a = values_24.return))
                    _a.call(values_24);
                } finally {
                  if (e_27)
                    throw e_27.error;
                }
              }
              return pairs2;
            }
            function pair(a, b) {
              return [a, b];
            }
            function range(start, stop, step) {
              start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;
              var i = -1, n = Math.max(0, Math.ceil((stop - start) / step)) | 0, range2 = new Array(n);
              while (++i < n) {
                range2[i] = start + i * step;
              }
              return range2;
            }
            function least(values, compare) {
              var e_28, _a, e_29, _b;
              if (compare === void 0) {
                compare = ascending;
              }
              var min2;
              var defined = false;
              if (compare.length === 1) {
                var minValue = void 0;
                try {
                  for (var values_25 = tslib_1.__values(values), values_25_1 = values_25.next(); !values_25_1.done; values_25_1 = values_25.next()) {
                    var element = values_25_1.value;
                    var value = compare(element);
                    if (defined ? ascending(value, minValue) < 0 : ascending(value, value) === 0) {
                      min2 = element;
                      minValue = value;
                      defined = true;
                    }
                  }
                } catch (e_28_1) {
                  e_28 = { error: e_28_1 };
                } finally {
                  try {
                    if (values_25_1 && !values_25_1.done && (_a = values_25.return))
                      _a.call(values_25);
                  } finally {
                    if (e_28)
                      throw e_28.error;
                  }
                }
              } else {
                try {
                  for (var values_26 = tslib_1.__values(values), values_26_1 = values_26.next(); !values_26_1.done; values_26_1 = values_26.next()) {
                    var value = values_26_1.value;
                    if (defined ? compare(value, min2) < 0 : compare(value, value) === 0) {
                      min2 = value;
                      defined = true;
                    }
                  }
                } catch (e_29_1) {
                  e_29 = { error: e_29_1 };
                } finally {
                  try {
                    if (values_26_1 && !values_26_1.done && (_b = values_26.return))
                      _b.call(values_26);
                  } finally {
                    if (e_29)
                      throw e_29.error;
                  }
                }
              }
              return min2;
            }
            function leastIndex(values, compare) {
              var e_30, _a;
              if (compare === void 0) {
                compare = ascending;
              }
              if (compare.length === 1)
                return minIndex(values, compare);
              var minValue;
              var min2 = -1;
              var index2 = -1;
              try {
                for (var values_27 = tslib_1.__values(values), values_27_1 = values_27.next(); !values_27_1.done; values_27_1 = values_27.next()) {
                  var value = values_27_1.value;
                  ++index2;
                  if (min2 < 0 ? compare(value, value) === 0 : compare(value, minValue) < 0) {
                    minValue = value;
                    min2 = index2;
                  }
                }
              } catch (e_30_1) {
                e_30 = { error: e_30_1 };
              } finally {
                try {
                  if (values_27_1 && !values_27_1.done && (_a = values_27.return))
                    _a.call(values_27);
                } finally {
                  if (e_30)
                    throw e_30.error;
                }
              }
              return min2;
            }
            function greatest(values, compare) {
              var e_31, _a, e_32, _b;
              if (compare === void 0) {
                compare = ascending;
              }
              var max2;
              var defined = false;
              if (compare.length === 1) {
                var maxValue = void 0;
                try {
                  for (var values_28 = tslib_1.__values(values), values_28_1 = values_28.next(); !values_28_1.done; values_28_1 = values_28.next()) {
                    var element = values_28_1.value;
                    var value = compare(element);
                    if (defined ? ascending(value, maxValue) > 0 : ascending(value, value) === 0) {
                      max2 = element;
                      maxValue = value;
                      defined = true;
                    }
                  }
                } catch (e_31_1) {
                  e_31 = { error: e_31_1 };
                } finally {
                  try {
                    if (values_28_1 && !values_28_1.done && (_a = values_28.return))
                      _a.call(values_28);
                  } finally {
                    if (e_31)
                      throw e_31.error;
                  }
                }
              } else {
                try {
                  for (var values_29 = tslib_1.__values(values), values_29_1 = values_29.next(); !values_29_1.done; values_29_1 = values_29.next()) {
                    var value = values_29_1.value;
                    if (defined ? compare(value, max2) > 0 : compare(value, value) === 0) {
                      max2 = value;
                      defined = true;
                    }
                  }
                } catch (e_32_1) {
                  e_32 = { error: e_32_1 };
                } finally {
                  try {
                    if (values_29_1 && !values_29_1.done && (_b = values_29.return))
                      _b.call(values_29);
                  } finally {
                    if (e_32)
                      throw e_32.error;
                  }
                }
              }
              return max2;
            }
            function greatestIndex(values, compare) {
              var e_33, _a;
              if (compare === void 0) {
                compare = ascending;
              }
              if (compare.length === 1)
                return maxIndex(values, compare);
              var maxValue;
              var max2 = -1;
              var index2 = -1;
              try {
                for (var values_30 = tslib_1.__values(values), values_30_1 = values_30.next(); !values_30_1.done; values_30_1 = values_30.next()) {
                  var value = values_30_1.value;
                  ++index2;
                  if (max2 < 0 ? compare(value, value) === 0 : compare(value, maxValue) > 0) {
                    maxValue = value;
                    max2 = index2;
                  }
                }
              } catch (e_33_1) {
                e_33 = { error: e_33_1 };
              } finally {
                try {
                  if (values_30_1 && !values_30_1.done && (_a = values_30.return))
                    _a.call(values_30);
                } finally {
                  if (e_33)
                    throw e_33.error;
                }
              }
              return max2;
            }
            function scan(values, compare) {
              var index2 = leastIndex(values, compare);
              return index2 < 0 ? void 0 : index2;
            }
            var shuffle = shuffler(Math.random);
            function shuffler(random) {
              return function shuffle2(array2, i0, i1) {
                if (i0 === void 0) {
                  i0 = 0;
                }
                if (i1 === void 0) {
                  i1 = array2.length;
                }
                var m = i1 - (i0 = +i0);
                while (m) {
                  var i = random() * m-- | 0, t = array2[m + i0];
                  array2[m + i0] = array2[i + i0];
                  array2[i + i0] = t;
                }
                return array2;
              };
            }
            function sum(values, valueof) {
              var e_34, _a, e_35, _b;
              var sum2 = 0;
              if (valueof === void 0) {
                try {
                  for (var values_31 = tslib_1.__values(values), values_31_1 = values_31.next(); !values_31_1.done; values_31_1 = values_31.next()) {
                    var value = values_31_1.value;
                    if (value = +value) {
                      sum2 += value;
                    }
                  }
                } catch (e_34_1) {
                  e_34 = { error: e_34_1 };
                } finally {
                  try {
                    if (values_31_1 && !values_31_1.done && (_a = values_31.return))
                      _a.call(values_31);
                  } finally {
                    if (e_34)
                      throw e_34.error;
                  }
                }
              } else {
                var index_10 = -1;
                try {
                  for (var values_32 = tslib_1.__values(values), values_32_1 = values_32.next(); !values_32_1.done; values_32_1 = values_32.next()) {
                    var value = values_32_1.value;
                    if (value = +valueof(value, ++index_10, values)) {
                      sum2 += value;
                    }
                  }
                } catch (e_35_1) {
                  e_35 = { error: e_35_1 };
                } finally {
                  try {
                    if (values_32_1 && !values_32_1.done && (_b = values_32.return))
                      _b.call(values_32);
                  } finally {
                    if (e_35)
                      throw e_35.error;
                  }
                }
              }
              return sum2;
            }
            function transpose(matrix) {
              if (!(n = matrix.length))
                return [];
              for (var i = -1, m = min(matrix, length$1), transpose2 = new Array(m); ++i < m; ) {
                for (var j = -1, n, row = transpose2[i] = new Array(n); ++j < n; ) {
                  row[j] = matrix[j][i];
                }
              }
              return transpose2;
            }
            function length$1(d) {
              return d.length;
            }
            function zip() {
              return transpose(arguments);
            }
            function every(values, test) {
              var e_36, _a;
              if (typeof test !== "function")
                throw new TypeError("test is not a function");
              var index2 = -1;
              try {
                for (var values_33 = tslib_1.__values(values), values_33_1 = values_33.next(); !values_33_1.done; values_33_1 = values_33.next()) {
                  var value = values_33_1.value;
                  if (!test(value, ++index2, values)) {
                    return false;
                  }
                }
              } catch (e_36_1) {
                e_36 = { error: e_36_1 };
              } finally {
                try {
                  if (values_33_1 && !values_33_1.done && (_a = values_33.return))
                    _a.call(values_33);
                } finally {
                  if (e_36)
                    throw e_36.error;
                }
              }
              return true;
            }
            function some(values, test) {
              var e_37, _a;
              if (typeof test !== "function")
                throw new TypeError("test is not a function");
              var index2 = -1;
              try {
                for (var values_34 = tslib_1.__values(values), values_34_1 = values_34.next(); !values_34_1.done; values_34_1 = values_34.next()) {
                  var value = values_34_1.value;
                  if (test(value, ++index2, values)) {
                    return true;
                  }
                }
              } catch (e_37_1) {
                e_37 = { error: e_37_1 };
              } finally {
                try {
                  if (values_34_1 && !values_34_1.done && (_a = values_34.return))
                    _a.call(values_34);
                } finally {
                  if (e_37)
                    throw e_37.error;
                }
              }
              return false;
            }
            function filter(values, test) {
              var e_38, _a;
              if (typeof test !== "function")
                throw new TypeError("test is not a function");
              var array2 = [];
              var index2 = -1;
              try {
                for (var values_35 = tslib_1.__values(values), values_35_1 = values_35.next(); !values_35_1.done; values_35_1 = values_35.next()) {
                  var value = values_35_1.value;
                  if (test(value, ++index2, values)) {
                    array2.push(value);
                  }
                }
              } catch (e_38_1) {
                e_38 = { error: e_38_1 };
              } finally {
                try {
                  if (values_35_1 && !values_35_1.done && (_a = values_35.return))
                    _a.call(values_35);
                } finally {
                  if (e_38)
                    throw e_38.error;
                }
              }
              return array2;
            }
            function map(values, mapper) {
              if (typeof values[Symbol.iterator] !== "function")
                throw new TypeError("values is not iterable");
              if (typeof mapper !== "function")
                throw new TypeError("mapper is not a function");
              return Array.from(values, function(value, index2) {
                return mapper(value, index2, values);
              });
            }
            function reduce(values, reducer2, value) {
              var _a, _b;
              if (typeof reducer2 !== "function")
                throw new TypeError("reducer is not a function");
              var iterator = values[Symbol.iterator]();
              var done, next, index2 = -1;
              if (arguments.length < 3) {
                _a = iterator.next(), done = _a.done, value = _a.value;
                if (done)
                  return;
                ++index2;
              }
              while (_b = iterator.next(), done = _b.done, next = _b.value, _b, !done) {
                value = reducer2(value, next, ++index2, values);
              }
              return value;
            }
            function reverse(values) {
              if (typeof values[Symbol.iterator] !== "function")
                throw new TypeError("values is not iterable");
              return Array.from(values).reverse();
            }
            function difference(values) {
              var e_39, _a, e_40, _b;
              var others = [];
              for (var _i = 1; _i < arguments.length; _i++) {
                others[_i - 1] = arguments[_i];
              }
              values = new Set(values);
              try {
                for (var others_1 = tslib_1.__values(others), others_1_1 = others_1.next(); !others_1_1.done; others_1_1 = others_1.next()) {
                  var other = others_1_1.value;
                  try {
                    for (var other_1 = (e_40 = void 0, tslib_1.__values(other)), other_1_1 = other_1.next(); !other_1_1.done; other_1_1 = other_1.next()) {
                      var value = other_1_1.value;
                      values.delete(value);
                    }
                  } catch (e_40_1) {
                    e_40 = { error: e_40_1 };
                  } finally {
                    try {
                      if (other_1_1 && !other_1_1.done && (_b = other_1.return))
                        _b.call(other_1);
                    } finally {
                      if (e_40)
                        throw e_40.error;
                    }
                  }
                }
              } catch (e_39_1) {
                e_39 = { error: e_39_1 };
              } finally {
                try {
                  if (others_1_1 && !others_1_1.done && (_a = others_1.return))
                    _a.call(others_1);
                } finally {
                  if (e_39)
                    throw e_39.error;
                }
              }
              return values;
            }
            function disjoint(values, other) {
              var e_41, _a, _b;
              var iterator = other[Symbol.iterator](), set2 = /* @__PURE__ */ new Set();
              try {
                for (var values_36 = tslib_1.__values(values), values_36_1 = values_36.next(); !values_36_1.done; values_36_1 = values_36.next()) {
                  var v = values_36_1.value;
                  if (set2.has(v))
                    return false;
                  var value = void 0, done = void 0;
                  while (_b = iterator.next(), value = _b.value, done = _b.done, _b) {
                    if (done)
                      break;
                    if (Object.is(v, value))
                      return false;
                    set2.add(value);
                  }
                }
              } catch (e_41_1) {
                e_41 = { error: e_41_1 };
              } finally {
                try {
                  if (values_36_1 && !values_36_1.done && (_a = values_36.return))
                    _a.call(values_36);
                } finally {
                  if (e_41)
                    throw e_41.error;
                }
              }
              return true;
            }
            function set(values) {
              return values instanceof Set ? values : new Set(values);
            }
            function intersection(values) {
              var e_42, _a, e_43, _b;
              var others = [];
              for (var _i = 1; _i < arguments.length; _i++) {
                others[_i - 1] = arguments[_i];
              }
              values = new Set(values);
              others = others.map(set);
              try {
                out:
                  for (var values_37 = tslib_1.__values(values), values_37_1 = values_37.next(); !values_37_1.done; values_37_1 = values_37.next()) {
                    var value = values_37_1.value;
                    try {
                      for (var others_2 = (e_43 = void 0, tslib_1.__values(others)), others_2_1 = others_2.next(); !others_2_1.done; others_2_1 = others_2.next()) {
                        var other = others_2_1.value;
                        if (!other.has(value)) {
                          values.delete(value);
                          continue out;
                        }
                      }
                    } catch (e_43_1) {
                      e_43 = { error: e_43_1 };
                    } finally {
                      try {
                        if (others_2_1 && !others_2_1.done && (_b = others_2.return))
                          _b.call(others_2);
                      } finally {
                        if (e_43)
                          throw e_43.error;
                      }
                    }
                  }
              } catch (e_42_1) {
                e_42 = { error: e_42_1 };
              } finally {
                try {
                  if (values_37_1 && !values_37_1.done && (_a = values_37.return))
                    _a.call(values_37);
                } finally {
                  if (e_42)
                    throw e_42.error;
                }
              }
              return values;
            }
            function superset(values, other) {
              var e_44, _a, _b;
              var iterator = values[Symbol.iterator](), set2 = /* @__PURE__ */ new Set();
              try {
                for (var other_2 = tslib_1.__values(other), other_2_1 = other_2.next(); !other_2_1.done; other_2_1 = other_2.next()) {
                  var o = other_2_1.value;
                  if (set2.has(o))
                    continue;
                  var value = void 0, done = void 0;
                  while (_b = iterator.next(), value = _b.value, done = _b.done, _b) {
                    if (done)
                      return false;
                    set2.add(value);
                    if (Object.is(o, value))
                      break;
                  }
                }
              } catch (e_44_1) {
                e_44 = { error: e_44_1 };
              } finally {
                try {
                  if (other_2_1 && !other_2_1.done && (_a = other_2.return))
                    _a.call(other_2);
                } finally {
                  if (e_44)
                    throw e_44.error;
                }
              }
              return true;
            }
            function subset(values, other) {
              return superset(other, values);
            }
            function union() {
              var e_45, _a, e_46, _b;
              var others = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                others[_i] = arguments[_i];
              }
              var set2 = /* @__PURE__ */ new Set();
              try {
                for (var others_3 = tslib_1.__values(others), others_3_1 = others_3.next(); !others_3_1.done; others_3_1 = others_3.next()) {
                  var other = others_3_1.value;
                  try {
                    for (var other_3 = (e_46 = void 0, tslib_1.__values(other)), other_3_1 = other_3.next(); !other_3_1.done; other_3_1 = other_3.next()) {
                      var o = other_3_1.value;
                      set2.add(o);
                    }
                  } catch (e_46_1) {
                    e_46 = { error: e_46_1 };
                  } finally {
                    try {
                      if (other_3_1 && !other_3_1.done && (_b = other_3.return))
                        _b.call(other_3);
                    } finally {
                      if (e_46)
                        throw e_46.error;
                    }
                  }
                }
              } catch (e_45_1) {
                e_45 = { error: e_45_1 };
              } finally {
                try {
                  if (others_3_1 && !others_3_1.done && (_a = others_3.return))
                    _a.call(others_3);
                } finally {
                  if (e_45)
                    throw e_45.error;
                }
              }
              return set2;
            }
            exports3.Adder = Adder;
            exports3.InternMap = InternMap;
            exports3.InternSet = InternSet;
            exports3.ascending = ascending;
            exports3.bin = bin;
            exports3.bisect = bisectRight;
            exports3.bisectCenter = bisectCenter;
            exports3.bisectLeft = bisectLeft;
            exports3.bisectRight = bisectRight;
            exports3.bisector = bisector;
            exports3.count = count;
            exports3.cross = cross;
            exports3.cumsum = cumsum;
            exports3.descending = descending;
            exports3.deviation = deviation;
            exports3.difference = difference;
            exports3.disjoint = disjoint;
            exports3.every = every;
            exports3.extent = extent;
            exports3.filter = filter;
            exports3.fsum = fsum;
            exports3.greatest = greatest;
            exports3.greatestIndex = greatestIndex;
            exports3.group = group;
            exports3.groupSort = groupSort;
            exports3.groups = groups;
            exports3.histogram = bin;
            exports3.index = index;
            exports3.indexes = indexes;
            exports3.intersection = intersection;
            exports3.least = least;
            exports3.leastIndex = leastIndex;
            exports3.map = map;
            exports3.max = max;
            exports3.maxIndex = maxIndex;
            exports3.mean = mean;
            exports3.median = median;
            exports3.merge = merge;
            exports3.min = min;
            exports3.minIndex = minIndex;
            exports3.nice = nice;
            exports3.pairs = pairs;
            exports3.permute = permute;
            exports3.quantile = quantile;
            exports3.quantileSorted = quantileSorted;
            exports3.quickselect = quickselect;
            exports3.range = range;
            exports3.reduce = reduce;
            exports3.reverse = reverse;
            exports3.rollup = rollup;
            exports3.rollups = rollups;
            exports3.scan = scan;
            exports3.shuffle = shuffle;
            exports3.shuffler = shuffler;
            exports3.some = some;
            exports3.sort = sort;
            exports3.subset = subset;
            exports3.sum = sum;
            exports3.superset = superset;
            exports3.thresholdFreedmanDiaconis = freedmanDiaconis;
            exports3.thresholdScott = scott;
            exports3.thresholdSturges = sturges;
            exports3.tickIncrement = tickIncrement;
            exports3.tickStep = tickStep;
            exports3.ticks = ticks;
            exports3.transpose = transpose;
            exports3.union = union;
            exports3.variance = variance;
            exports3.zip = zip;
            Object.defineProperty(exports3, "__esModule", { value: true });
          });
        },
        "./node_modules/_d3-collection@1.0.7@d3-collection/dist/d3-collection.js": function(module2, exports2, __webpack_require__) {
          (function(global, factory) {
            true ? factory(exports2) : void 0;
          })(this, function(exports3) {
            "use strict";
            var prefix = "$";
            function Map2() {
            }
            Map2.prototype = map.prototype = {
              constructor: Map2,
              has: function(key) {
                return prefix + key in this;
              },
              get: function(key) {
                return this[prefix + key];
              },
              set: function(key, value) {
                this[prefix + key] = value;
                return this;
              },
              remove: function(key) {
                var property = prefix + key;
                return property in this && delete this[property];
              },
              clear: function() {
                for (var property in this)
                  if (property[0] === prefix)
                    delete this[property];
              },
              keys: function() {
                var keys2 = [];
                for (var property in this)
                  if (property[0] === prefix)
                    keys2.push(property.slice(1));
                return keys2;
              },
              values: function() {
                var values2 = [];
                for (var property in this)
                  if (property[0] === prefix)
                    values2.push(this[property]);
                return values2;
              },
              entries: function() {
                var entries2 = [];
                for (var property in this)
                  if (property[0] === prefix)
                    entries2.push({ key: property.slice(1), value: this[property] });
                return entries2;
              },
              size: function() {
                var size = 0;
                for (var property in this)
                  if (property[0] === prefix)
                    ++size;
                return size;
              },
              empty: function() {
                for (var property in this)
                  if (property[0] === prefix)
                    return false;
                return true;
              },
              each: function(f) {
                for (var property in this)
                  if (property[0] === prefix)
                    f(this[property], property.slice(1), this);
              }
            };
            function map(object, f) {
              var map2 = new Map2();
              if (object instanceof Map2)
                object.each(function(value, key2) {
                  map2.set(key2, value);
                });
              else if (Array.isArray(object)) {
                var i = -1, n = object.length, o;
                if (f == null)
                  while (++i < n)
                    map2.set(i, object[i]);
                else
                  while (++i < n)
                    map2.set(f(o = object[i], i, object), o);
              } else if (object)
                for (var key in object)
                  map2.set(key, object[key]);
              return map2;
            }
            function nest() {
              var keys2 = [], sortKeys = [], sortValues, rollup, nest2;
              function apply(array, depth, createResult, setResult) {
                if (depth >= keys2.length) {
                  if (sortValues != null)
                    array.sort(sortValues);
                  return rollup != null ? rollup(array) : array;
                }
                var i = -1, n = array.length, key = keys2[depth++], keyValue, value, valuesByKey = map(), values2, result = createResult();
                while (++i < n) {
                  if (values2 = valuesByKey.get(keyValue = key(value = array[i]) + "")) {
                    values2.push(value);
                  } else {
                    valuesByKey.set(keyValue, [value]);
                  }
                }
                valuesByKey.each(function(values3, key2) {
                  setResult(result, key2, apply(values3, depth, createResult, setResult));
                });
                return result;
              }
              function entries2(map$$1, depth) {
                if (++depth > keys2.length)
                  return map$$1;
                var array, sortKey = sortKeys[depth - 1];
                if (rollup != null && depth >= keys2.length)
                  array = map$$1.entries();
                else
                  array = [], map$$1.each(function(v, k) {
                    array.push({ key: k, values: entries2(v, depth) });
                  });
                return sortKey != null ? array.sort(function(a, b) {
                  return sortKey(a.key, b.key);
                }) : array;
              }
              return nest2 = {
                object: function(array) {
                  return apply(array, 0, createObject, setObject);
                },
                map: function(array) {
                  return apply(array, 0, createMap, setMap);
                },
                entries: function(array) {
                  return entries2(apply(array, 0, createMap, setMap), 0);
                },
                key: function(d) {
                  keys2.push(d);
                  return nest2;
                },
                sortKeys: function(order) {
                  sortKeys[keys2.length - 1] = order;
                  return nest2;
                },
                sortValues: function(order) {
                  sortValues = order;
                  return nest2;
                },
                rollup: function(f) {
                  rollup = f;
                  return nest2;
                }
              };
            }
            function createObject() {
              return {};
            }
            function setObject(object, key, value) {
              object[key] = value;
            }
            function createMap() {
              return map();
            }
            function setMap(map$$1, key, value) {
              map$$1.set(key, value);
            }
            function Set2() {
            }
            var proto = map.prototype;
            Set2.prototype = set.prototype = {
              constructor: Set2,
              has: proto.has,
              add: function(value) {
                value += "";
                this[prefix + value] = value;
                return this;
              },
              remove: proto.remove,
              clear: proto.clear,
              values: proto.keys,
              size: proto.size,
              empty: proto.empty,
              each: proto.each
            };
            function set(object, f) {
              var set2 = new Set2();
              if (object instanceof Set2)
                object.each(function(value) {
                  set2.add(value);
                });
              else if (object) {
                var i = -1, n = object.length;
                if (f == null)
                  while (++i < n)
                    set2.add(object[i]);
                else
                  while (++i < n)
                    set2.add(f(object[i], i, object));
              }
              return set2;
            }
            function keys(map2) {
              var keys2 = [];
              for (var key in map2)
                keys2.push(key);
              return keys2;
            }
            function values(map2) {
              var values2 = [];
              for (var key in map2)
                values2.push(map2[key]);
              return values2;
            }
            function entries(map2) {
              var entries2 = [];
              for (var key in map2)
                entries2.push({ key, value: map2[key] });
              return entries2;
            }
            exports3.nest = nest;
            exports3.set = set;
            exports3.map = map;
            exports3.keys = keys;
            exports3.values = values;
            exports3.entries = entries;
            Object.defineProperty(exports3, "__esModule", { value: true });
          });
        },
        "./node_modules/_d3-composite-projections@1.4.0@d3-composite-projections/d3-composite-projections.js": function(module2, exports2, __webpack_require__) {
          var tslib_1 = __webpack_require__("./node_modules/_tslib@2.1.0@tslib/tslib.js");
          (function(global, factory) {
            true ? factory(exports2, __webpack_require__("./node_modules/_d3-geo@2.0.1@d3-geo/dist/d3-geo.js"), __webpack_require__("./node_modules/_d3-path@2.0.0@d3-path/dist/d3-path.js")) : void 0;
          })(this, function(exports3, d3Geo, d3Path) {
            "use strict";
            var epsilon = 1e-6;
            function noop() {
            }
            var x0 = Infinity, y0 = x0, x1 = -x0, y1 = x1;
            var boundsStream = {
              point: boundsPoint,
              lineStart: noop,
              lineEnd: noop,
              polygonStart: noop,
              polygonEnd: noop,
              result: function() {
                var bounds = [[x0, y0], [x1, y1]];
                x1 = y1 = -(y0 = x0 = Infinity);
                return bounds;
              }
            };
            function boundsPoint(x, y) {
              if (x < x0)
                x0 = x;
              if (x > x1)
                x1 = x;
              if (y < y0)
                y0 = y;
              if (y > y1)
                y1 = y;
            }
            function fitExtent(projection, extent, object) {
              var w = extent[1][0] - extent[0][0], h = extent[1][1] - extent[0][1], clip = projection.clipExtent && projection.clipExtent();
              projection.scale(150).translate([0, 0]);
              if (clip != null)
                projection.clipExtent(null);
              d3Geo.geoStream(object, projection.stream(boundsStream));
              var b = boundsStream.result(), k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])), x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2, y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
              if (clip != null)
                projection.clipExtent(clip);
              return projection.scale(k * 150).translate([x, y]);
            }
            function fitSize(projection, size, object) {
              return fitExtent(projection, [[0, 0], size], object);
            }
            function multiplex(streams) {
              var n = streams.length;
              return {
                point: function(x, y) {
                  var i = -1;
                  while (++i < n)
                    streams[i].point(x, y);
                },
                sphere: function() {
                  var i = -1;
                  while (++i < n)
                    streams[i].sphere();
                },
                lineStart: function() {
                  var i = -1;
                  while (++i < n)
                    streams[i].lineStart();
                },
                lineEnd: function() {
                  var i = -1;
                  while (++i < n)
                    streams[i].lineEnd();
                },
                polygonStart: function() {
                  var i = -1;
                  while (++i < n)
                    streams[i].polygonStart();
                },
                polygonEnd: function() {
                  var i = -1;
                  while (++i < n)
                    streams[i].polygonEnd();
                }
              };
            }
            function albersUsa() {
              var cache, cacheStream, lower48 = d3Geo.geoAlbers(), lower48Point, alaska = d3Geo.geoConicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, hawaii = d3Geo.geoConicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, point, pointStream = { point: function(x, y) {
                point = [x, y];
              } };
              function albersUsa2(coordinates) {
                var x = coordinates[0], y = coordinates[1];
                return point = null, (lower48Point.point(x, y), point) || (alaskaPoint.point(x, y), point) || (hawaiiPoint.point(x, y), point);
              }
              albersUsa2.invert = function(coordinates) {
                var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
                return (y >= 0.12 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii : lower48).invert(coordinates);
              };
              albersUsa2.stream = function(stream) {
                return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
              };
              albersUsa2.precision = function(_) {
                if (!arguments.length)
                  return lower48.precision();
                lower48.precision(_), alaska.precision(_), hawaii.precision(_);
                return reset();
              };
              albersUsa2.scale = function(_) {
                if (!arguments.length)
                  return lower48.scale();
                lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
                return albersUsa2.translate(lower48.translate());
              };
              albersUsa2.translate = function(_) {
                if (!arguments.length)
                  return lower48.translate();
                var k = lower48.scale(), x = +_[0], y = +_[1];
                lower48Point = lower48.translate(_).clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]]).stream(pointStream);
                alaskaPoint = alaska.translate([x - 0.307 * k, y + 0.201 * k]).clipExtent([[x - 0.425 * k + epsilon, y + 0.12 * k + epsilon], [x - 0.214 * k - epsilon, y + 0.234 * k - epsilon]]).stream(pointStream);
                hawaiiPoint = hawaii.translate([x - 0.205 * k, y + 0.212 * k]).clipExtent([[x - 0.214 * k + epsilon, y + 0.166 * k + epsilon], [x - 0.115 * k - epsilon, y + 0.234 * k - epsilon]]).stream(pointStream);
                return reset();
              };
              albersUsa2.fitExtent = function(extent, object) {
                return fitExtent(albersUsa2, extent, object);
              };
              albersUsa2.fitSize = function(size, object) {
                return fitSize(albersUsa2, size, object);
              };
              function reset() {
                cache = cacheStream = null;
                return albersUsa2;
              }
              albersUsa2.drawCompositionBorders = function(context) {
                var hawaii1 = lower48([-102.91, 26.3]);
                var hawaii2 = lower48([-104, 27.5]);
                var hawaii3 = lower48([-108, 29.1]);
                var hawaii4 = lower48([-110, 29.1]);
                var alaska1 = lower48([-110, 26.7]);
                var alaska2 = lower48([-112.8, 27.6]);
                var alaska3 = lower48([-114.3, 30.6]);
                var alaska4 = lower48([-119.3, 30.1]);
                context.moveTo(hawaii1[0], hawaii1[1]);
                context.lineTo(hawaii2[0], hawaii2[1]);
                context.lineTo(hawaii3[0], hawaii3[1]);
                context.lineTo(hawaii4[0], hawaii4[1]);
                context.moveTo(alaska1[0], alaska1[1]);
                context.lineTo(alaska2[0], alaska2[1]);
                context.lineTo(alaska3[0], alaska3[1]);
                context.lineTo(alaska4[0], alaska4[1]);
              };
              albersUsa2.getCompositionBorders = function() {
                var context = d3Path.path();
                this.drawCompositionBorders(context);
                return context.toString();
              };
              return albersUsa2.scale(1070);
            }
            function multiplex$1(streams) {
              var n = streams.length;
              return {
                point: function(x, y) {
                  var i = -1;
                  while (++i < n)
                    streams[i].point(x, y);
                },
                sphere: function() {
                  var i = -1;
                  while (++i < n)
                    streams[i].sphere();
                },
                lineStart: function() {
                  var i = -1;
                  while (++i < n)
                    streams[i].lineStart();
                },
                lineEnd: function() {
                  var i = -1;
                  while (++i < n)
                    streams[i].lineEnd();
                },
                polygonStart: function() {
                  var i = -1;
                  while (++i < n)
                    streams[i].polygonStart();
                },
                polygonEnd: function() {
                  var i = -1;
                  while (++i < n)
                    streams[i].polygonEnd();
                }
              };
            }
            function albersUsaTerritories() {
              var cache, cacheStream, lower48 = d3Geo.geoAlbers(), lower48Point, alaska = d3Geo.geoConicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, hawaii = d3Geo.geoConicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, puertoRico = d3Geo.geoConicEqualArea().rotate([66, 0]).center([0, 18]).parallels([8, 18]), puertoRicoPoint, samoa = d3Geo.geoEquirectangular().rotate([173, 14]), samoaPoint, guam = d3Geo.geoEquirectangular().rotate([-145, -16.8]), guamPoint, point, pointStream = { point: function(x, y) {
                point = [x, y];
              } };
              function albersUsa2(coordinates) {
                var x = coordinates[0], y = coordinates[1];
                return point = null, (lower48Point.point(x, y), point) || (alaskaPoint.point(x, y), point) || (hawaiiPoint.point(x, y), point) || (puertoRicoPoint.point(x, y), point) || (samoaPoint.point(x, y), point) || (guamPoint.point(x, y), point);
              }
              albersUsa2.invert = function(coordinates) {
                var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
                return (y >= 0.12 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii : y >= 0.2064 && y < 0.2413 && x >= 0.312 && x < 0.385 ? puertoRico : y >= 0.09 && y < 0.1197 && x >= -0.4243 && x < -0.3232 ? samoa : y >= -0.0518 && y < 0.0895 && x >= -0.4243 && x < -0.3824 ? guam : lower48).invert(coordinates);
              };
              albersUsa2.stream = function(stream) {
                return cache && cacheStream === stream ? cache : cache = multiplex$1([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream), puertoRico.stream(stream), samoa.stream(stream), guam.stream(stream)]);
              };
              albersUsa2.precision = function(_) {
                if (!arguments.length) {
                  return lower48.precision();
                }
                lower48.precision(_);
                alaska.precision(_);
                hawaii.precision(_);
                puertoRico.precision(_);
                samoa.precision(_);
                guam.precision(_);
                return reset();
              };
              albersUsa2.scale = function(_) {
                if (!arguments.length) {
                  return lower48.scale();
                }
                lower48.scale(_);
                alaska.scale(_ * 0.35);
                hawaii.scale(_);
                puertoRico.scale(_);
                samoa.scale(_ * 2);
                guam.scale(_);
                return albersUsa2.translate(lower48.translate());
              };
              albersUsa2.translate = function(_) {
                if (!arguments.length) {
                  return lower48.translate();
                }
                var k = lower48.scale(), x = +_[0], y = +_[1];
                lower48Point = lower48.translate(_).clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]]).stream(pointStream);
                alaskaPoint = alaska.translate([x - 0.307 * k, y + 0.201 * k]).clipExtent([[x - 0.425 * k + epsilon, y + 0.12 * k + epsilon], [x - 0.214 * k - epsilon, y + 0.233 * k - epsilon]]).stream(pointStream);
                hawaiiPoint = hawaii.translate([x - 0.205 * k, y + 0.212 * k]).clipExtent([[x - 0.214 * k + epsilon, y + 0.166 * k + epsilon], [x - 0.115 * k - epsilon, y + 0.233 * k - epsilon]]).stream(pointStream);
                puertoRicoPoint = puertoRico.translate([x + 0.35 * k, y + 0.224 * k]).clipExtent([[x + 0.312 * k + epsilon, y + 0.2064 * k + epsilon], [x + 0.385 * k - epsilon, y + 0.233 * k - epsilon]]).stream(pointStream);
                samoaPoint = samoa.translate([x - 0.492 * k, y + 0.09 * k]).clipExtent([[x - 0.4243 * k + epsilon, y + 0.0903 * k + epsilon], [x - 0.3233 * k - epsilon, y + 0.1197 * k - epsilon]]).stream(pointStream);
                guamPoint = guam.translate([x - 0.408 * k, y + 0.018 * k]).clipExtent([[x - 0.4244 * k + epsilon, y - 0.0519 * k + epsilon], [x - 0.3824 * k - epsilon, y + 0.0895 * k - epsilon]]).stream(pointStream);
                return reset();
              };
              albersUsa2.fitExtent = function(extent, object) {
                return fitExtent(albersUsa2, extent, object);
              };
              albersUsa2.fitSize = function(size, object) {
                return fitSize(albersUsa2, size, object);
              };
              function reset() {
                cache = cacheStream = null;
                return albersUsa2;
              }
              albersUsa2.drawCompositionBorders = function(context) {
                var ulhawaii = lower48([-110.4641, 28.2805]);
                var urhawaii = lower48([-104.0597, 28.9528]);
                var ldhawaii = lower48([-103.7049, 25.1031]);
                var llhawaii = lower48([-109.8337, 24.4531]);
                var ulalaska = lower48([-124.4745, 28.1407]);
                var uralaska = lower48([-110.931, 30.8844]);
                var ldalaska = lower48([-109.8337, 24.4531]);
                var llalaska = lower48([-122.4628, 21.8562]);
                var ulpuertoRico = lower48([-76.8579, 25.1544]);
                var urpuertoRico = lower48([-72.429, 24.2097]);
                var ldpuertoRico = lower48([-72.8265, 22.7056]);
                var llpuertoRico = lower48([-77.1852, 23.6392]);
                var ulsamoa = lower48([-125.0093, 29.7791]);
                var ursamoa = lower48([-118.5193, 31.3262]);
                var ldsamoa = lower48([-118.064, 29.6912]);
                var llsamoa = lower48([-124.4369, 28.169]);
                var ulguam = lower48([-128.1314, 37.4582]);
                var urguam = lower48([-125.2132, 38.214]);
                var ldguam = lower48([-122.3616, 30.5115]);
                var llguam = lower48([-125.0315, 29.8211]);
                context.moveTo(ulhawaii[0], ulhawaii[1]);
                context.lineTo(urhawaii[0], urhawaii[1]);
                context.lineTo(ldhawaii[0], ldhawaii[1]);
                context.lineTo(ldhawaii[0], ldhawaii[1]);
                context.lineTo(llhawaii[0], llhawaii[1]);
                context.closePath();
                context.moveTo(ulalaska[0], ulalaska[1]);
                context.lineTo(uralaska[0], uralaska[1]);
                context.lineTo(ldalaska[0], ldalaska[1]);
                context.lineTo(ldalaska[0], ldalaska[1]);
                context.lineTo(llalaska[0], llalaska[1]);
                context.closePath();
                context.moveTo(ulpuertoRico[0], ulpuertoRico[1]);
                context.lineTo(urpuertoRico[0], urpuertoRico[1]);
                context.lineTo(ldpuertoRico[0], ldpuertoRico[1]);
                context.lineTo(ldpuertoRico[0], ldpuertoRico[1]);
                context.lineTo(llpuertoRico[0], llpuertoRico[1]);
                context.closePath();
                context.moveTo(ulsamoa[0], ulsamoa[1]);
                context.lineTo(ursamoa[0], ursamoa[1]);
                context.lineTo(ldsamoa[0], ldsamoa[1]);
                context.lineTo(ldsamoa[0], ldsamoa[1]);
                context.lineTo(llsamoa[0], llsamoa[1]);
                context.closePath();
                context.moveTo(ulguam[0], ulguam[1]);
                context.lineTo(urguam[0], urguam[1]);
                context.lineTo(ldguam[0], ldguam[1]);
                context.lineTo(ldguam[0], ldguam[1]);
                context.lineTo(llguam[0], llguam[1]);
                context.closePath();
              };
              albersUsa2.getCompositionBorders = function() {
                var context = d3Path.path();
                this.drawCompositionBorders(context);
                return context.toString();
              };
              return albersUsa2.scale(1070);
            }
            function multiplex$2(streams) {
              var n = streams.length;
              return {
                point: function(x, y) {
                  var i = -1;
                  while (++i < n) {
                    streams[i].point(x, y);
                  }
                },
                sphere: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].sphere();
                  }
                },
                lineStart: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].lineStart();
                  }
                },
                lineEnd: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].lineEnd();
                  }
                },
                polygonStart: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].polygonStart();
                  }
                },
                polygonEnd: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].polygonEnd();
                  }
                }
              };
            }
            function conicConformalSpain() {
              var cache, cacheStream, iberianPeninsule = d3Geo.geoConicConformal().rotate([5, -38.6]).parallels([0, 60]), iberianPeninsulePoint, canaryIslands = d3Geo.geoConicConformal().rotate([5, -38.6]).parallels([0, 60]), canaryIslandsPoint, point, pointStream = { point: function(x, y) {
                point = [x, y];
              } };
              function conicConformalSpain2(coordinates) {
                var x = coordinates[0], y = coordinates[1];
                return point = null, (iberianPeninsulePoint.point(x, y), point) || (canaryIslandsPoint.point(x, y), point);
              }
              conicConformalSpain2.invert = function(coordinates) {
                var k = iberianPeninsule.scale(), t = iberianPeninsule.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
                return (y >= 0.05346 && y < 0.0897 && x >= -0.13388 && x < -0.0322 ? canaryIslands : iberianPeninsule).invert(coordinates);
              };
              conicConformalSpain2.stream = function(stream) {
                return cache && cacheStream === stream ? cache : cache = multiplex$2([iberianPeninsule.stream(cacheStream = stream), canaryIslands.stream(stream)]);
              };
              conicConformalSpain2.precision = function(_) {
                if (!arguments.length) {
                  return iberianPeninsule.precision();
                }
                iberianPeninsule.precision(_);
                canaryIslands.precision(_);
                return reset();
              };
              conicConformalSpain2.scale = function(_) {
                if (!arguments.length) {
                  return iberianPeninsule.scale();
                }
                iberianPeninsule.scale(_);
                canaryIslands.scale(_);
                return conicConformalSpain2.translate(iberianPeninsule.translate());
              };
              conicConformalSpain2.translate = function(_) {
                if (!arguments.length) {
                  return iberianPeninsule.translate();
                }
                var k = iberianPeninsule.scale(), x = +_[0], y = +_[1];
                iberianPeninsulePoint = iberianPeninsule.translate(_).clipExtent([[x - 0.06857 * k, y - 0.1288 * k], [x + 0.13249 * k, y + 0.06 * k]]).stream(pointStream);
                canaryIslandsPoint = canaryIslands.translate([x + 0.1 * k, y - 0.094 * k]).clipExtent([[x - 0.1331 * k + epsilon, y + 0.053457 * k + epsilon], [x - 0.0354 * k - epsilon, y + 0.08969 * k - epsilon]]).stream(pointStream);
                return reset();
              };
              conicConformalSpain2.fitExtent = function(extent, object) {
                return fitExtent(conicConformalSpain2, extent, object);
              };
              conicConformalSpain2.fitSize = function(size, object) {
                return fitSize(conicConformalSpain2, size, object);
              };
              function reset() {
                cache = cacheStream = null;
                return conicConformalSpain2;
              }
              conicConformalSpain2.drawCompositionBorders = function(context) {
                var ulCanaryIslands = iberianPeninsule([-14.034675, 34.965007]);
                var urCanaryIslands = iberianPeninsule([-7.4208899, 35.536988]);
                var ldCanaryIslands = iberianPeninsule([-7.3148275, 33.54359]);
                context.moveTo(ulCanaryIslands[0], ulCanaryIslands[1]);
                context.lineTo(urCanaryIslands[0], urCanaryIslands[1]);
                context.lineTo(ldCanaryIslands[0], ldCanaryIslands[1]);
              };
              conicConformalSpain2.getCompositionBorders = function() {
                var context = d3Path.path();
                this.drawCompositionBorders(context);
                return context.toString();
              };
              return conicConformalSpain2.scale(2700);
            }
            function multiplex$3(streams) {
              var n = streams.length;
              return {
                point: function(x, y) {
                  var i = -1;
                  while (++i < n) {
                    streams[i].point(x, y);
                  }
                },
                sphere: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].sphere();
                  }
                },
                lineStart: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].lineStart();
                  }
                },
                lineEnd: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].lineEnd();
                  }
                },
                polygonStart: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].polygonStart();
                  }
                },
                polygonEnd: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].polygonEnd();
                  }
                }
              };
            }
            function conicConformalPortugal() {
              var cache, cacheStream, iberianPeninsule = d3Geo.geoConicConformal().rotate([10, -39.3]).parallels([0, 60]), iberianPeninsulePoint, madeira = d3Geo.geoConicConformal().rotate([17, -32.7]).parallels([0, 60]), madeiraPoint, azores = d3Geo.geoConicConformal().rotate([27.8, -38.6]).parallels([0, 60]), azoresPoint, point, pointStream = { point: function(x, y) {
                point = [x, y];
              } };
              function conicConformalPortugal2(coordinates) {
                var x = coordinates[0], y = coordinates[1];
                return point = null, (iberianPeninsulePoint.point(x, y), point) || (madeiraPoint.point(x, y), point) || (azoresPoint.point(x, y), point);
              }
              conicConformalPortugal2.invert = function(coordinates) {
                var k = iberianPeninsule.scale(), t = iberianPeninsule.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
                return (y >= 93e-4 && y < 0.03678 && x >= -0.03875 && x < -0.0116 ? madeira : y >= -0.0412 && y < 91e-4 && x >= -0.07782 && x < -0.01166 ? azores : iberianPeninsule).invert(coordinates);
              };
              conicConformalPortugal2.stream = function(stream) {
                return cache && cacheStream === stream ? cache : cache = multiplex$3([iberianPeninsule.stream(cacheStream = stream), madeira.stream(stream), azores.stream(stream)]);
              };
              conicConformalPortugal2.precision = function(_) {
                if (!arguments.length) {
                  return iberianPeninsule.precision();
                }
                iberianPeninsule.precision(_);
                madeira.precision(_);
                azores.precision(_);
                return reset();
              };
              conicConformalPortugal2.scale = function(_) {
                if (!arguments.length) {
                  return iberianPeninsule.scale();
                }
                iberianPeninsule.scale(_);
                madeira.scale(_);
                azores.scale(_ * 0.6);
                return conicConformalPortugal2.translate(iberianPeninsule.translate());
              };
              conicConformalPortugal2.translate = function(_) {
                if (!arguments.length) {
                  return iberianPeninsule.translate();
                }
                var k = iberianPeninsule.scale(), x = +_[0], y = +_[1];
                iberianPeninsulePoint = iberianPeninsule.translate(_).clipExtent([[x - 0.0115 * k, y - 0.1138 * k], [x + 0.2105 * k, y + 0.0673 * k]]).stream(pointStream);
                madeiraPoint = madeira.translate([x - 0.0265 * k, y + 0.025 * k]).clipExtent([[x - 0.0388 * k + epsilon, y + 93e-4 * k + epsilon], [x - 0.0116 * k - epsilon, y + 0.0368 * k - epsilon]]).stream(pointStream);
                azoresPoint = azores.translate([x - 0.045 * k, y + -0.02 * k]).clipExtent([[x - 0.0778 * k + epsilon, y - 0.0413 * k + epsilon], [x - 0.0117 * k - epsilon, y + 91e-4 * k - epsilon]]).stream(pointStream);
                return reset();
              };
              conicConformalPortugal2.fitExtent = function(extent, object) {
                return fitExtent(conicConformalPortugal2, extent, object);
              };
              conicConformalPortugal2.fitSize = function(size, object) {
                return fitSize(conicConformalPortugal2, size, object);
              };
              function reset() {
                cache = cacheStream = null;
                return conicConformalPortugal2;
              }
              conicConformalPortugal2.drawCompositionBorders = function(context) {
                var ulmadeira = iberianPeninsule([-12.8351, 38.7113]);
                var urmadeira = iberianPeninsule([-10.8482, 38.7633]);
                var ldmadeira = iberianPeninsule([-10.8181, 37.2072]);
                var llmadeira = iberianPeninsule([-12.7345, 37.1573]);
                var ulazores = iberianPeninsule([-16.0753, 41.4436]);
                var urazores = iberianPeninsule([-10.9168, 41.6861]);
                var ldazores = iberianPeninsule([-10.8557, 38.7747]);
                var llazores = iberianPeninsule([-15.6728, 38.5505]);
                context.moveTo(ulmadeira[0], ulmadeira[1]);
                context.lineTo(urmadeira[0], urmadeira[1]);
                context.lineTo(ldmadeira[0], ldmadeira[1]);
                context.lineTo(ldmadeira[0], ldmadeira[1]);
                context.lineTo(llmadeira[0], llmadeira[1]);
                context.closePath();
                context.moveTo(ulazores[0], ulazores[1]);
                context.lineTo(urazores[0], urazores[1]);
                context.lineTo(ldazores[0], ldazores[1]);
                context.lineTo(ldazores[0], ldazores[1]);
                context.lineTo(llazores[0], llazores[1]);
                context.closePath();
              };
              conicConformalPortugal2.getCompositionBorders = function() {
                var context = d3Path.path();
                this.drawCompositionBorders(context);
                return context.toString();
              };
              return conicConformalPortugal2.scale(4200);
            }
            function multiplex$4(streams) {
              var n = streams.length;
              return {
                point: function(x, y) {
                  var i = -1;
                  while (++i < n) {
                    streams[i].point(x, y);
                  }
                },
                sphere: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].sphere();
                  }
                },
                lineStart: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].lineStart();
                  }
                },
                lineEnd: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].lineEnd();
                  }
                },
                polygonStart: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].polygonStart();
                  }
                },
                polygonEnd: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].polygonEnd();
                  }
                }
              };
            }
            function mercatorEcuador() {
              var cache, cacheStream, mainland = d3Geo.geoMercator().rotate([80, 1.5]), mainlandPoint, galapagos = d3Geo.geoMercator().rotate([90.73, 1]), galapagosPoint, point, pointStream = { point: function(x, y) {
                point = [x, y];
              } };
              function mercatorEcuador2(coordinates) {
                var x = coordinates[0], y = coordinates[1];
                return point = null, (mainlandPoint.point(x, y), point) || (galapagosPoint.point(x, y), point);
              }
              mercatorEcuador2.invert = function(coordinates) {
                var k = mainland.scale(), t = mainland.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
                return (y >= -0.0676 && y < -0.026 && x >= -0.0857 && x < -0.0263 ? galapagos : mainland).invert(coordinates);
              };
              mercatorEcuador2.stream = function(stream) {
                return cache && cacheStream === stream ? cache : cache = multiplex$4([mainland.stream(cacheStream = stream), galapagos.stream(stream)]);
              };
              mercatorEcuador2.precision = function(_) {
                if (!arguments.length) {
                  return mainland.precision();
                }
                mainland.precision(_);
                galapagos.precision(_);
                return reset();
              };
              mercatorEcuador2.scale = function(_) {
                if (!arguments.length) {
                  return mainland.scale();
                }
                mainland.scale(_);
                galapagos.scale(_);
                return mercatorEcuador2.translate(mainland.translate());
              };
              mercatorEcuador2.translate = function(_) {
                if (!arguments.length) {
                  return mainland.translate();
                }
                var k = mainland.scale(), x = +_[0], y = +_[1];
                mainlandPoint = mainland.translate(_).clipExtent([[x - 0.0262 * k, y - 0.0734 * k], [x + 0.1741 * k, y + 0.079 * k]]).stream(pointStream);
                galapagosPoint = galapagos.translate([x - 0.06 * k, y - 0.04 * k]).clipExtent([[x - 0.0857 * k + epsilon, y - 0.0676 * k + epsilon], [x - 0.0263 * k - epsilon, y - 0.026 * k - epsilon]]).stream(pointStream);
                return reset();
              };
              mercatorEcuador2.fitExtent = function(extent, object) {
                return fitExtent(mercatorEcuador2, extent, object);
              };
              mercatorEcuador2.fitSize = function(size, object) {
                return fitSize(mercatorEcuador2, size, object);
              };
              function reset() {
                cache = cacheStream = null;
                return mercatorEcuador2;
              }
              mercatorEcuador2.drawCompositionBorders = function(context) {
                var ulgalapagos = mainland([-84.9032, 2.3757]);
                var urgalapagos = mainland([-81.5047, 2.3708]);
                var ldgalapagos = mainland([-81.5063, -0.01]);
                var llgalapagos = mainland([-84.9086, -5e-3]);
                context.moveTo(ulgalapagos[0], ulgalapagos[1]);
                context.lineTo(urgalapagos[0], urgalapagos[1]);
                context.lineTo(ldgalapagos[0], ldgalapagos[1]);
                context.lineTo(llgalapagos[0], llgalapagos[1]);
                context.closePath();
              };
              mercatorEcuador2.getCompositionBorders = function() {
                var context = d3Path.path();
                this.drawCompositionBorders(context);
                return context.toString();
              };
              return mercatorEcuador2.scale(3500);
            }
            function multiplex$5(streams) {
              var n = streams.length;
              return {
                point: function(x, y) {
                  var i = -1;
                  while (++i < n) {
                    streams[i].point(x, y);
                  }
                },
                sphere: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].sphere();
                  }
                },
                lineStart: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].lineStart();
                  }
                },
                lineEnd: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].lineEnd();
                  }
                },
                polygonStart: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].polygonStart();
                  }
                },
                polygonEnd: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].polygonEnd();
                  }
                }
              };
            }
            function transverseMercatorChile() {
              var cache, cacheStream, mainland = d3Geo.geoTransverseMercator().rotate([72, 37]), mainlandPoint, antarctic = d3Geo.geoStereographic().rotate([72, 0]), antarcticPoint, juanFernandez = d3Geo.geoMercator().rotate([80, 33.5]), juanFernandezPoint, pascua = d3Geo.geoMercator().rotate([110, 25]), pascuaPoint, point, pointStream = { point: function(x, y) {
                point = [x, y];
              } };
              function transverseMercatorChile2(coordinates) {
                var x = coordinates[0], y = coordinates[1];
                return point = null, (mainlandPoint.point(x, y), point) || (antarcticPoint.point(x, y), point) || (juanFernandezPoint.point(x, y), point) || (pascuaPoint.point(x, y), point);
              }
              transverseMercatorChile2.invert = function(coordinates) {
                var k = mainland.scale(), t = mainland.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
                return (y >= 0.2582 && y < 0.32 && x >= -0.1036 && x < -0.087 ? antarctic : y >= -0.01298 && y < 0.0133 && x >= -0.11396 && x < -0.05944 ? juanFernandez : y >= 0.01539 && y < 0.03911 && x >= -0.089 && x < -0.0588 ? pascua : mainland).invert(coordinates);
              };
              transverseMercatorChile2.stream = function(stream) {
                return cache && cacheStream === stream ? cache : cache = multiplex$5([mainland.stream(cacheStream = stream), antarctic.stream(stream), juanFernandez.stream(stream), pascua.stream(stream)]);
              };
              transverseMercatorChile2.precision = function(_) {
                if (!arguments.length) {
                  return mainland.precision();
                }
                mainland.precision(_);
                antarctic.precision(_);
                juanFernandez.precision(_);
                pascua.precision(_);
                return reset();
              };
              transverseMercatorChile2.scale = function(_) {
                if (!arguments.length) {
                  return mainland.scale();
                }
                mainland.scale(_);
                antarctic.scale(_ * 0.15);
                juanFernandez.scale(_ * 1.5);
                pascua.scale(_ * 1.5);
                return transverseMercatorChile2.translate(mainland.translate());
              };
              transverseMercatorChile2.translate = function(_) {
                if (!arguments.length) {
                  return mainland.translate();
                }
                var k = mainland.scale(), x = +_[0], y = +_[1];
                mainlandPoint = mainland.translate(_).clipExtent([[x - 0.059 * k, y - 0.3835 * k], [x + 0.4498 * k, y + 0.3375 * k]]).stream(pointStream);
                antarcticPoint = antarctic.translate([x - 0.087 * k, y + 0.17 * k]).clipExtent([[x - 0.1166 * k + epsilon, y + 0.2582 * k + epsilon], [x - 0.06 * k - epsilon, y + 0.32 * k - epsilon]]).stream(pointStream);
                juanFernandezPoint = juanFernandez.translate([x - 0.092 * k, y - 0 * k]).clipExtent([[x - 0.114 * k + epsilon, y - 0.013 * k + epsilon], [x - 0.0594 * k - epsilon, y + 0.0133 * k - epsilon]]).stream(pointStream);
                pascuaPoint = pascua.translate([x - 0.089 * k, y - 0.0265 * k]).clipExtent([[x - 0.089 * k + epsilon, y + 0.0154 * k + epsilon], [x - 0.0588 * k - epsilon, y + 0.0391 * k - epsilon]]).stream(pointStream);
                return reset();
              };
              transverseMercatorChile2.fitExtent = function(extent, object) {
                return fitExtent(transverseMercatorChile2, extent, object);
              };
              transverseMercatorChile2.fitSize = function(size, object) {
                return fitSize(transverseMercatorChile2, size, object);
              };
              function reset() {
                cache = cacheStream = null;
                return transverseMercatorChile2;
              }
              transverseMercatorChile2.drawCompositionBorders = function(context) {
                var ulantarctic = mainland([-82.6999, -51.3043]);
                var urantarctic = mainland([-77.5442, -51.6631]);
                var ldantarctic = mainland([-78.0254, -55.186]);
                var llantarctic = mainland([-83.6106, -54.7785]);
                var uljuanFernandez = mainland([-80.0638, -35.984]);
                var urjuanFernandez = mainland([-76.2153, -36.1811]);
                var ldjuanFernandez = mainland([-76.2994, -37.6839]);
                var lljuanFernandez = mainland([-80.2231, -37.4757]);
                var ulpascua = mainland([-78.442, -37.706]);
                var urpascua = mainland([-76.263, -37.8054]);
                var ldpascua = mainland([-76.344, -39.1595]);
                var llpascua = mainland([-78.5638, -39.0559]);
                context.moveTo(ulantarctic[0], ulantarctic[1]);
                context.lineTo(urantarctic[0], urantarctic[1]);
                context.lineTo(ldantarctic[0], ldantarctic[1]);
                context.lineTo(ldantarctic[0], ldantarctic[1]);
                context.lineTo(llantarctic[0], llantarctic[1]);
                context.closePath();
                context.moveTo(uljuanFernandez[0], uljuanFernandez[1]);
                context.lineTo(urjuanFernandez[0], urjuanFernandez[1]);
                context.lineTo(ldjuanFernandez[0], ldjuanFernandez[1]);
                context.lineTo(ldjuanFernandez[0], ldjuanFernandez[1]);
                context.lineTo(lljuanFernandez[0], lljuanFernandez[1]);
                context.closePath();
                context.moveTo(ulpascua[0], ulpascua[1]);
                context.lineTo(urpascua[0], urpascua[1]);
                context.lineTo(ldpascua[0], ldpascua[1]);
                context.lineTo(ldpascua[0], ldpascua[1]);
                context.lineTo(llpascua[0], llpascua[1]);
                context.closePath();
              };
              transverseMercatorChile2.getCompositionBorders = function() {
                var context = d3Path.path();
                this.drawCompositionBorders(context);
                return context.toString();
              };
              return transverseMercatorChile2.scale(700);
            }
            function multiplex$6(streams) {
              var n = streams.length;
              return {
                point: function(x, y) {
                  var i = -1;
                  while (++i < n) {
                    streams[i].point(x, y);
                  }
                },
                sphere: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].sphere();
                  }
                },
                lineStart: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].lineStart();
                  }
                },
                lineEnd: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].lineEnd();
                  }
                },
                polygonStart: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].polygonStart();
                  }
                },
                polygonEnd: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].polygonEnd();
                  }
                }
              };
            }
            function conicEquidistantJapan() {
              var cache, cacheStream, mainland = d3Geo.geoConicEquidistant().rotate([-136, -22]).parallels([40, 34]), mainlandPoint, hokkaido = d3Geo.geoConicEquidistant().rotate([-146, -26]).parallels([40, 34]), hokkaidoPoint, okinawa = d3Geo.geoConicEquidistant().rotate([-126, -19]).parallels([40, 34]), okinawaPoint, point, pointStream = { point: function(x, y) {
                point = [x, y];
              } };
              function conicEquidistantJapan2(coordinates) {
                var x = coordinates[0], y = coordinates[1];
                return point = null, (mainlandPoint.point(x, y), point) || (hokkaidoPoint.point(x, y), point) || (okinawaPoint.point(x, y), point);
              }
              conicEquidistantJapan2.invert = function(coordinates) {
                var k = mainland.scale(), t = mainland.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
                return (y >= -0.10925 && y < -0.02701 && x >= -0.135 && x < -0.0397 ? hokkaido : y >= 0.04713 && y < 0.11138 && x >= -0.03986 && x < 0.051 ? okinawa : mainland).invert(coordinates);
              };
              conicEquidistantJapan2.stream = function(stream) {
                return cache && cacheStream === stream ? cache : cache = multiplex$6([mainland.stream(cacheStream = stream), hokkaido.stream(stream), okinawa.stream(stream)]);
              };
              conicEquidistantJapan2.precision = function(_) {
                if (!arguments.length) {
                  return mainland.precision();
                }
                mainland.precision(_);
                hokkaido.precision(_);
                okinawa.precision(_);
                return reset();
              };
              conicEquidistantJapan2.scale = function(_) {
                if (!arguments.length) {
                  return mainland.scale();
                }
                mainland.scale(_);
                hokkaido.scale(_);
                okinawa.scale(_ * 0.7);
                return conicEquidistantJapan2.translate(mainland.translate());
              };
              conicEquidistantJapan2.translate = function(_) {
                if (!arguments.length) {
                  return mainland.translate();
                }
                var k = mainland.scale(), x = +_[0], y = +_[1];
                mainlandPoint = mainland.translate(_).clipExtent([[x - 0.1352 * k, y - 0.1091 * k], [x + 0.117 * k, y + 0.098 * k]]).stream(pointStream);
                hokkaidoPoint = hokkaido.translate([x - 0.0425 * k, y - 5e-3 * k]).clipExtent([[x - 0.135 * k + epsilon, y - 0.1093 * k + epsilon], [x - 0.0397 * k - epsilon, y - 0.027 * k - epsilon]]).stream(pointStream);
                okinawaPoint = okinawa.translate(_).clipExtent([[x - 0.0399 * k + epsilon, y + 0.0471 * k + epsilon], [x + 0.051 * k - epsilon, y + 0.1114 * k - epsilon]]).stream(pointStream);
                return reset();
              };
              conicEquidistantJapan2.fitExtent = function(extent, object) {
                return fitExtent(conicEquidistantJapan2, extent, object);
              };
              conicEquidistantJapan2.fitSize = function(size, object) {
                return fitSize(conicEquidistantJapan2, size, object);
              };
              function reset() {
                cache = cacheStream = null;
                return conicEquidistantJapan2;
              }
              conicEquidistantJapan2.drawCompositionBorders = function(context) {
                var ulhokkaido = mainland([126.01320483689143, 41.621090310215585]);
                var urhokkaido = mainland([133.04304387025903, 42.15087523707186]);
                var ldhokkaido = mainland([133.3021766080688, 37.43975444725098]);
                var llhokkaido = mainland([126.87889168628224, 36.95488945159779]);
                var llokinawa = mainland([132.9, 29.8]);
                var lmokinawa = mainland([134, 33]);
                var lrokinawa = mainland([139.3, 33.2]);
                var llrokinawa = mainland([139.16, 30.5]);
                context.moveTo(ulhokkaido[0], ulhokkaido[1]);
                context.lineTo(urhokkaido[0], urhokkaido[1]);
                context.lineTo(ldhokkaido[0], ldhokkaido[1]);
                context.lineTo(llhokkaido[0], llhokkaido[1]);
                context.closePath();
                context.moveTo(llokinawa[0], llokinawa[1]);
                context.lineTo(lmokinawa[0], lmokinawa[1]);
                context.lineTo(lrokinawa[0], lrokinawa[1]);
                context.lineTo(llrokinawa[0], llrokinawa[1]);
              };
              conicEquidistantJapan2.getCompositionBorders = function() {
                var context = d3Path.path();
                this.drawCompositionBorders(context);
                return context.toString();
              };
              return conicEquidistantJapan2.scale(2200);
            }
            function multiplex$7(streams) {
              var n = streams.length;
              return {
                point: function(x, y) {
                  var i = -1;
                  while (++i < n) {
                    streams[i].point(x, y);
                  }
                },
                sphere: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].sphere();
                  }
                },
                lineStart: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].lineStart();
                  }
                },
                lineEnd: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].lineEnd();
                  }
                },
                polygonStart: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].polygonStart();
                  }
                },
                polygonEnd: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].polygonEnd();
                  }
                }
              };
            }
            function conicConformalFrance() {
              var cache, cacheStream, europe = d3Geo.geoConicConformal().rotate([-3, -46.2]).parallels([0, 60]), europePoint, guyane = d3Geo.geoMercator().center([-53.2, 3.9]), guyanePoint, martinique = d3Geo.geoMercator().center([-61.03, 14.67]), martiniquePoint, guadeloupe = d3Geo.geoMercator().center([-61.46, 16.14]), guadeloupePoint, saintBarthelemy = d3Geo.geoMercator().center([-62.85, 17.92]), saintBarthelemyPoint, stPierreMiquelon = d3Geo.geoMercator().center([-56.23, 46.93]), stPierreMiquelonPoint, mayotte = d3Geo.geoMercator().center([45.16, -12.8]), mayottePoint, reunion = d3Geo.geoMercator().center([55.52, -21.13]), reunionPoint, nouvelleCaledonie = d3Geo.geoMercator().center([165.8, -21.07]), nouvelleCaledoniePoint, wallisFutuna = d3Geo.geoMercator().center([-178.1, -14.3]), wallisFutunaPoint, polynesie = d3Geo.geoMercator().center([-150.55, -17.11]), polynesiePoint, polynesie2 = d3Geo.geoMercator().center([-150.55, -17.11]), polynesie2Point, point, pointStream = { point: function(x, y) {
                point = [x, y];
              } };
              function conicConformalFrance2(coordinates) {
                var x = coordinates[0], y = coordinates[1];
                return point = null, (europePoint.point(x, y), point) || (guyanePoint.point(x, y), point) || (martiniquePoint.point(x, y), point) || (guadeloupePoint.point(x, y), point) || (saintBarthelemyPoint.point(x, y), point) || (stPierreMiquelonPoint.point(x, y), point) || (mayottePoint.point(x, y), point) || (reunionPoint.point(x, y), point) || (nouvelleCaledoniePoint.point(x, y), point) || (wallisFutunaPoint.point(x, y), point) || (polynesiePoint.point(x, y), point) || (polynesie2Point.point(x, y), point);
              }
              conicConformalFrance2.invert = function(coordinates) {
                var k = europe.scale(), t = europe.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
                return (y >= 0.029 && y < 0.0864 && x >= -0.14 && x < -0.0996 ? guyane : y >= 0 && y < 0.029 && x >= -0.14 && x < -0.0996 ? martinique : y >= -0.032 && y < 0 && x >= -0.14 && x < -0.0996 ? guadeloupe : y >= -0.052 && y < -0.032 && x >= -0.14 && x < -0.0996 ? saintBarthelemy : y >= -0.076 && y < 0.052 && x >= -0.14 && x < -0.0996 ? stPierreMiquelon : y >= -0.076 && y < -0.052 && x >= 0.0967 && x < 0.1371 ? mayotte : y >= -0.052 && y < -0.02 && x >= 0.0967 && x < 0.1371 ? reunion : y >= -0.02 && y < 0.012 && x >= 0.0967 && x < 0.1371 ? nouvelleCaledonie : y >= 0.012 && y < 0.033 && x >= 0.0967 && x < 0.1371 ? wallisFutuna : y >= 0.033 && y < 0.0864 && x >= 0.0967 && x < 0.1371 ? polynesie : europe).invert(coordinates);
              };
              conicConformalFrance2.stream = function(stream) {
                return cache && cacheStream === stream ? cache : cache = multiplex$7([europe.stream(cacheStream = stream), guyane.stream(stream), martinique.stream(stream), guadeloupe.stream(stream), saintBarthelemy.stream(stream), stPierreMiquelon.stream(stream), mayotte.stream(stream), reunion.stream(stream), nouvelleCaledonie.stream(stream), wallisFutuna.stream(stream), polynesie.stream(stream), polynesie2.stream(stream)]);
              };
              conicConformalFrance2.precision = function(_) {
                if (!arguments.length) {
                  return europe.precision();
                }
                europe.precision(_);
                guyane.precision(_);
                martinique.precision(_);
                guadeloupe.precision(_);
                saintBarthelemy.precision(_);
                stPierreMiquelon.precision(_);
                mayotte.precision(_);
                reunion.precision(_);
                nouvelleCaledonie.precision(_);
                wallisFutuna.precision(_);
                polynesie.precision(_);
                polynesie2.precision(_);
                return reset();
              };
              conicConformalFrance2.scale = function(_) {
                if (!arguments.length) {
                  return europe.scale();
                }
                europe.scale(_);
                guyane.scale(_ * 0.6);
                martinique.scale(_ * 1.6);
                guadeloupe.scale(_ * 1.4);
                saintBarthelemy.scale(_ * 5);
                stPierreMiquelon.scale(_ * 1.3);
                mayotte.scale(_ * 1.6);
                reunion.scale(_ * 1.2);
                nouvelleCaledonie.scale(_ * 0.3);
                wallisFutuna.scale(_ * 2.7);
                polynesie.scale(_ * 0.5);
                polynesie2.scale(_ * 0.06);
                return conicConformalFrance2.translate(europe.translate());
              };
              conicConformalFrance2.translate = function(_) {
                if (!arguments.length) {
                  return europe.translate();
                }
                var k = europe.scale(), x = +_[0], y = +_[1];
                europePoint = europe.translate(_).clipExtent([[x - 0.0996 * k, y - 0.0908 * k], [x + 0.0967 * k, y + 0.0864 * k]]).stream(pointStream);
                guyanePoint = guyane.translate([x - 0.12 * k, y + 0.0575 * k]).clipExtent([[x - 0.14 * k + epsilon, y + 0.029 * k + epsilon], [x - 0.0996 * k - epsilon, y + 0.0864 * k - epsilon]]).stream(pointStream);
                martiniquePoint = martinique.translate([x - 0.12 * k, y + 0.013 * k]).clipExtent([[x - 0.14 * k + epsilon, y + 0 * k + epsilon], [x - 0.0996 * k - epsilon, y + 0.029 * k - epsilon]]).stream(pointStream);
                guadeloupePoint = guadeloupe.translate([x - 0.12 * k, y - 0.014 * k]).clipExtent([[x - 0.14 * k + epsilon, y - 0.032 * k + epsilon], [x - 0.0996 * k - epsilon, y + 0 * k - epsilon]]).stream(pointStream);
                saintBarthelemyPoint = saintBarthelemy.translate([x - 0.12 * k, y - 0.044 * k]).clipExtent([[x - 0.14 * k + epsilon, y - 0.052 * k + epsilon], [x - 0.0996 * k - epsilon, y - 0.032 * k - epsilon]]).stream(pointStream);
                stPierreMiquelonPoint = stPierreMiquelon.translate([x - 0.12 * k, y - 0.065 * k]).clipExtent([[x - 0.14 * k + epsilon, y - 0.076 * k + epsilon], [x - 0.0996 * k - epsilon, y - 0.052 * k - epsilon]]).stream(pointStream);
                mayottePoint = mayotte.translate([x + 0.117 * k, y - 0.064 * k]).clipExtent([[x + 0.0967 * k + epsilon, y - 0.076 * k + epsilon], [x + 0.1371 * k - epsilon, y - 0.052 * k - epsilon]]).stream(pointStream);
                reunionPoint = reunion.translate([x + 0.116 * k, y - 0.0355 * k]).clipExtent([[x + 0.0967 * k + epsilon, y - 0.052 * k + epsilon], [x + 0.1371 * k - epsilon, y - 0.02 * k - epsilon]]).stream(pointStream);
                nouvelleCaledoniePoint = nouvelleCaledonie.translate([x + 0.116 * k, y - 48e-4 * k]).clipExtent([[x + 0.0967 * k + epsilon, y - 0.02 * k + epsilon], [x + 0.1371 * k - epsilon, y + 0.012 * k - epsilon]]).stream(pointStream);
                wallisFutunaPoint = wallisFutuna.translate([x + 0.116 * k, y + 0.022 * k]).clipExtent([[x + 0.0967 * k + epsilon, y + 0.012 * k + epsilon], [x + 0.1371 * k - epsilon, y + 0.033 * k - epsilon]]).stream(pointStream);
                polynesie2Point = polynesie2.translate([x + 0.11 * k, y + 0.045 * k]).clipExtent([[x + 0.0967 * k + epsilon, y + 0.033 * k + epsilon], [x + 0.1371 * k - epsilon, y + 0.06 * k - epsilon]]).stream(pointStream);
                polynesiePoint = polynesie.translate([x + 0.115 * k, y + 0.075 * k]).clipExtent([[x + 0.0967 * k + epsilon, y + 0.06 * k + epsilon], [x + 0.1371 * k - epsilon, y + 0.0864 * k - epsilon]]).stream(pointStream);
                return reset();
              };
              conicConformalFrance2.fitExtent = function(extent, object) {
                return fitExtent(conicConformalFrance2, extent, object);
              };
              conicConformalFrance2.fitSize = function(size, object) {
                return fitSize(conicConformalFrance2, size, object);
              };
              function reset() {
                cache = cacheStream = null;
                return conicConformalFrance2;
              }
              conicConformalFrance2.drawCompositionBorders = function(context) {
                var ul, ur, ld, ll;
                ul = europe([-7.938886725111036, 43.7219460918835]);
                ur = europe([-4.832080896458295, 44.12930268549372]);
                ld = europe([-4.205299743793263, 40.98096346967365]);
                ll = europe([-7.071796453126152, 40.610037319181444]);
                context.moveTo(ul[0], ul[1]);
                context.lineTo(ur[0], ur[1]);
                context.lineTo(ld[0], ld[1]);
                context.lineTo(ll[0], ll[1]);
                context.closePath();
                ul = europe([-8.42751373617692, 45.32889452553031]);
                ur = europe([-5.18599305777107, 45.7566442062976]);
                ld = europe([-4.832080905154431, 44.129302726751426]);
                ll = europe([-7.938886737126192, 43.72194613263854]);
                context.moveTo(ul[0], ul[1]);
                context.lineTo(ur[0], ur[1]);
                context.lineTo(ld[0], ld[1]);
                context.lineTo(ll[0], ll[1]);
                context.closePath();
                ul = europe([-9.012656899657046, 47.127733821030176]);
                ur = europe([-5.6105244772793155, 47.579777861410626]);
                ld = europe([-5.185993067168585, 45.756644248170346]);
                ll = europe([-8.427513749141811, 45.32889456686326]);
                context.moveTo(ul[0], ul[1]);
                context.lineTo(ur[0], ur[1]);
                context.lineTo(ld[0], ld[1]);
                context.lineTo(ll[0], ll[1]);
                context.closePath();
                ul = europe([-9.405747558985553, 48.26506375557457]);
                ur = europe([-5.896175018439575, 48.733352850851624]);
                ld = europe([-5.610524487556043, 47.57977790393761]);
                ll = europe([-9.012656913808351, 47.127733862971255]);
                context.moveTo(ul[0], ul[1]);
                context.lineTo(ur[0], ur[1]);
                context.lineTo(ld[0], ld[1]);
                context.lineTo(ll[0], ll[1]);
                context.closePath();
                ul = europe([-9.908436061346974, 49.642448789505856]);
                ur = europe([-6.262026716233124, 50.131426841787174]);
                ld = europe([-5.896175029331232, 48.73335289377258]);
                ll = europe([-9.40574757396393, 48.26506379787767]);
                context.moveTo(ul[0], ul[1]);
                context.lineTo(ur[0], ur[1]);
                context.lineTo(ld[0], ld[1]);
                context.lineTo(ll[0], ll[1]);
                context.closePath();
                ul = europe([11.996907706504462, 50.16039028163579]);
                ur = europe([15.649907879773343, 49.68279246765253]);
                ld = europe([15.156712840526632, 48.30371557625831]);
                ll = europe([11.64122661754411, 48.761078240546816]);
                context.moveTo(ul[0], ul[1]);
                context.lineTo(ur[0], ur[1]);
                context.lineTo(ld[0], ld[1]);
                context.lineTo(ll[0], ll[1]);
                context.closePath();
                ul = europe([11.641226606955788, 48.7610781975889]);
                ur = europe([15.156712825832164, 48.30371553390465]);
                ld = europe([14.549932166241172, 46.4866532486199]);
                ll = europe([11.204443787952183, 46.91899233914248]);
                context.moveTo(ul[0], ul[1]);
                context.lineTo(ur[0], ur[1]);
                context.lineTo(ld[0], ld[1]);
                context.lineTo(ll[0], ll[1]);
                context.closePath();
                ul = europe([11.204443778297161, 46.918992296823646]);
                ur = europe([14.549932152815039, 46.486653206856396]);
                ld = europe([13.994409796764009, 44.695833444323256]);
                ll = europe([10.805306599253848, 45.105133870684924]);
                context.moveTo(ul[0], ul[1]);
                context.lineTo(ur[0], ur[1]);
                context.lineTo(ld[0], ld[1]);
                context.lineTo(ll[0], ll[1]);
                context.closePath();
                ul = europe([10.805306590412085, 45.10513382903308]);
                ur = europe([13.99440978444733, 44.695833403183606]);
                ld = europe([13.654633799024392, 43.53552468558152]);
                ll = europe([10.561516803980956, 43.930671459798624]);
                context.moveTo(ul[0], ul[1]);
                context.lineTo(ur[0], ur[1]);
                context.lineTo(ld[0], ld[1]);
                context.lineTo(ll[0], ll[1]);
                context.closePath();
                ul = europe([10.561516795617383, 43.93067141859757]);
                ur = europe([13.654633787361952, 43.5355246448671]);
                ld = europe([12.867691604239901, 40.640701985019405]);
                ll = europe([9.997809515987688, 41.00288343254471]);
                context.moveTo(ul[0], ul[1]);
                context.lineTo(ur[0], ur[1]);
                context.lineTo(ld[0], ld[1]);
                context.lineTo(ll[0], ll[1]);
                context.closePath();
                ul = europe([10.8, 42.4]);
                ur = europe([12.8, 42.13]);
                context.moveTo(ul[0], ul[1]);
                context.lineTo(ur[0], ur[1]);
              };
              conicConformalFrance2.getCompositionBorders = function() {
                var context = d3Path.path();
                this.drawCompositionBorders(context);
                return context.toString();
              };
              return conicConformalFrance2.scale(2700);
            }
            function multiplex$8(streams) {
              var n = streams.length;
              return {
                point: function(x, y) {
                  var i = -1;
                  while (++i < n) {
                    streams[i].point(x, y);
                  }
                },
                sphere: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].sphere();
                  }
                },
                lineStart: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].lineStart();
                  }
                },
                lineEnd: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].lineEnd();
                  }
                },
                polygonStart: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].polygonStart();
                  }
                },
                polygonEnd: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].polygonEnd();
                  }
                }
              };
            }
            function conicConformalEurope() {
              var cache, cacheStream, europe = d3Geo.geoConicConformal().rotate([-10, -53]).parallels([0, 60]), europePoint, guadeloupe = d3Geo.geoMercator().center([-61.46, 16.14]), guadeloupePoint, guyane = d3Geo.geoMercator().center([-53.2, 3.9]), guyanePoint, azores = d3Geo.geoConicConformal().rotate([27.8, -38.9]).parallels([0, 60]), azoresPoint, azores2 = d3Geo.geoConicConformal().rotate([25.43, -37.398]).parallels([0, 60]), azores2Point, azores3 = d3Geo.geoConicConformal().rotate([31.17, -39.539]).parallels([0, 60]), azores3Point, madeira = d3Geo.geoConicConformal().rotate([17, -32.7]).parallels([0, 60]), madeiraPoint, canaryIslands = d3Geo.geoConicConformal().rotate([16, -28.5]).parallels([0, 60]), canaryIslandsPoint, martinique = d3Geo.geoMercator().center([-61.03, 14.67]), martiniquePoint, mayotte = d3Geo.geoMercator().center([45.16, -12.8]), mayottePoint, reunion = d3Geo.geoMercator().center([55.52, -21.13]), reunionPoint, malta = d3Geo.geoConicConformal().rotate([-14.4, -35.95]).parallels([0, 60]), maltaPoint, point, pointStream = { point: function(x, y) {
                point = [x, y];
              } };
              function conicConformalEurope2(coordinates) {
                var x = coordinates[0], y = coordinates[1];
                return point = null, (europePoint.point(x, y), point) || (guyanePoint.point(x, y), point) || (martiniquePoint.point(x, y), point) || (guadeloupePoint.point(x, y), point) || (canaryIslandsPoint.point(x, y), point) || (madeiraPoint.point(x, y), point) || (mayottePoint.point(x, y), point) || (reunionPoint.point(x, y), point) || (maltaPoint.point(x, y), point) || (azoresPoint.point(x, y), point) || (azores2Point.point(x, y), point) || (azores3Point.point(x, y), point);
              }
              conicConformalEurope2.invert = function(coordinates) {
                var k = europe.scale(), t = europe.translate(), x = (coordinates[0] - (t[0] + 0.08 * k)) / k, y = (coordinates[1] - t[1]) / k;
                return (y >= -0.31 && y < -0.24 && x >= 0.14 && x < 0.24 ? guadeloupe : y >= -0.24 && y < -0.17 && x >= 0.14 && x < 0.24 ? guyane : y >= -0.17 && y < -0.12 && x >= 0.21 && x < 0.24 ? azores2 : y >= -0.17 && y < -0.14 && x >= 0.14 && x < 0.165 ? azores3 : y >= -0.17 && y < -0.1 && x >= 0.14 && x < 0.24 ? azores : y >= -0.1 && y < -0.03 && x >= 0.14 && x < 0.24 ? madeira : y >= -0.03 && y < 0.04 && x >= 0.14 && x < 0.24 ? canaryIslands : y >= -0.31 && y < -0.24 && x >= 0.24 && x < 0.34 ? martinique : y >= -0.24 && y < -0.17 && x >= 0.24 && x < 0.34 ? mayotte : y >= -0.17 && y < -0.1 && x >= 0.24 && x < 0.34 ? reunion : y >= -0.1 && y < -0.03 && x >= 0.24 && x < 0.34 ? malta : europe).invert(coordinates);
              };
              conicConformalEurope2.stream = function(stream) {
                return cache && cacheStream === stream ? cache : cache = multiplex$8([europe.stream(cacheStream = stream), guyane.stream(stream), martinique.stream(stream), guadeloupe.stream(stream), canaryIslands.stream(stream), madeira.stream(stream), mayotte.stream(stream), reunion.stream(stream), malta.stream(stream), azores.stream(stream), azores2.stream(stream), azores3.stream(stream)]);
              };
              conicConformalEurope2.precision = function(_) {
                if (!arguments.length) {
                  return europe.precision();
                }
                europe.precision(_);
                guyane.precision(_);
                martinique.precision(_);
                guadeloupe.precision(_);
                canaryIslands.precision(_);
                madeira.precision(_);
                mayotte.precision(_);
                reunion.precision(_);
                malta.precision(_);
                azores.precision(_);
                azores2.precision(_);
                azores3.precision(_);
                return reset();
              };
              conicConformalEurope2.scale = function(_) {
                if (!arguments.length) {
                  return europe.scale();
                }
                europe.scale(_);
                guadeloupe.scale(_ * 3);
                guyane.scale(_ * 0.8);
                martinique.scale(_ * 3.5);
                reunion.scale(_ * 2.7);
                azores.scale(_ * 2);
                azores2.scale(_ * 2);
                azores3.scale(_ * 2);
                madeira.scale(_ * 3);
                canaryIslands.scale(_);
                mayotte.scale(_ * 5.5);
                malta.scale(_ * 6);
                return conicConformalEurope2.translate(europe.translate());
              };
              conicConformalEurope2.translate = function(_) {
                if (!arguments.length) {
                  return europe.translate();
                }
                var k = europe.scale(), x = +_[0], y = +_[1];
                europePoint = europe.translate([x - 0.08 * k, y]).clipExtent([[x - 0.51 * k, y - 0.33 * k], [x + 0.5 * k, y + 0.33 * k]]).stream(pointStream);
                guadeloupePoint = guadeloupe.translate([x + 0.19 * k, y - 0.275 * k]).clipExtent([[x + 0.14 * k + epsilon, y - 0.31 * k + epsilon], [x + 0.24 * k - epsilon, y - 0.24 * k - epsilon]]).stream(pointStream);
                guyanePoint = guyane.translate([x + 0.19 * k, y - 0.205 * k]).clipExtent([[x + 0.14 * k + epsilon, y - 0.24 * k + epsilon], [x + 0.24 * k - epsilon, y - 0.17 * k - epsilon]]).stream(pointStream);
                azoresPoint = azores.translate([x + 0.19 * k, y - 0.135 * k]).clipExtent([[x + 0.14 * k + epsilon, y - 0.17 * k + epsilon], [x + 0.24 * k - epsilon, y - 0.1 * k - epsilon]]).stream(pointStream);
                azores2Point = azores2.translate([x + 0.225 * k, y - 0.147 * k]).clipExtent([[x + 0.21 * k + epsilon, y - 0.17 * k + epsilon], [x + 0.24 * k - epsilon, y - 0.12 * k - epsilon]]).stream(pointStream);
                azores3Point = azores3.translate([x + 0.153 * k, y - 0.15 * k]).clipExtent([[x + 0.14 * k + epsilon, y - 0.17 * k + epsilon], [x + 0.165 * k - epsilon, y - 0.14 * k - epsilon]]).stream(pointStream);
                madeiraPoint = madeira.translate([x + 0.19 * k, y - 0.065 * k]).clipExtent([[x + 0.14 * k + epsilon, y - 0.1 * k + epsilon], [x + 0.24 * k - epsilon, y - 0.03 * k - epsilon]]).stream(pointStream);
                canaryIslandsPoint = canaryIslands.translate([x + 0.19 * k, y + 5e-3 * k]).clipExtent([[x + 0.14 * k + epsilon, y - 0.03 * k + epsilon], [x + 0.24 * k - epsilon, y + 0.04 * k - epsilon]]).stream(pointStream);
                martiniquePoint = martinique.translate([x + 0.29 * k, y - 0.275 * k]).clipExtent([[x + 0.24 * k + epsilon, y - 0.31 * k + epsilon], [x + 0.34 * k - epsilon, y - 0.24 * k - epsilon]]).stream(pointStream);
                mayottePoint = mayotte.translate([x + 0.29 * k, y - 0.205 * k]).clipExtent([[x + 0.24 * k + epsilon, y - 0.24 * k + epsilon], [x + 0.34 * k - epsilon, y - 0.17 * k - epsilon]]).stream(pointStream);
                reunionPoint = reunion.translate([x + 0.29 * k, y - 0.135 * k]).clipExtent([[x + 0.24 * k + epsilon, y - 0.17 * k + epsilon], [x + 0.34 * k - epsilon, y - 0.1 * k - epsilon]]).stream(pointStream);
                maltaPoint = malta.translate([x + 0.29 * k, y - 0.065 * k]).clipExtent([[x + 0.24 * k + epsilon, y - 0.1 * k + epsilon], [x + 0.34 * k - epsilon, y - 0.03 * k - epsilon]]).stream(pointStream);
                return reset();
              };
              conicConformalEurope2.fitExtent = function(extent, object) {
                return fitExtent(conicConformalEurope2, extent, object);
              };
              conicConformalEurope2.fitSize = function(size, object) {
                return fitSize(conicConformalEurope2, size, object);
              };
              function reset() {
                cache = cacheStream = null;
                return conicConformalEurope2;
              }
              conicConformalEurope2.drawCompositionBorders = function(context) {
                var ul, ur, ld, ll;
                ul = europe([42.45755610828648, 63.343658547914934]);
                ur = europe([52.65837266667029, 59.35045080290929]);
                ld = europe([47.19754502247785, 56.12653496548117]);
                ll = europe([37.673034273363044, 59.61638268506111]);
                context.moveTo(ul[0], ul[1]);
                context.lineTo(ur[0], ur[1]);
                context.lineTo(ld[0], ld[1]);
                context.lineTo(ll[0], ll[1]);
                context.closePath();
                ul = europe([59.41110754003403, 62.35069727399336]);
                ur = europe([66.75050228640794, 57.11797303636038]);
                ld = europe([60.236065725110436, 54.63331433818992]);
                ll = europe([52.65837313153311, 59.350450804599355]);
                context.moveTo(ul[0], ul[1]);
                context.lineTo(ur[0], ur[1]);
                context.lineTo(ld[0], ld[1]);
                context.lineTo(ll[0], ll[1]);
                context.closePath();
                ul = europe([48.81091130080243, 66.93353402634641]);
                ur = europe([59.41110730654679, 62.35069740653086]);
                ld = europe([52.6583728974441, 59.3504509222445]);
                ll = europe([42.45755631675751, 63.34365868805821]);
                context.moveTo(ul[0], ul[1]);
                context.lineTo(ur[0], ur[1]);
                context.lineTo(ld[0], ld[1]);
                context.lineTo(ll[0], ll[1]);
                context.closePath();
                ul = europe([31.054198418446475, 52.1080673766184]);
                ur = europe([39.09869284884117, 49.400700047190554]);
                ld = europe([36.0580811499175, 46.02944174908498]);
                ll = europe([28.690508588835726, 48.433126979386415]);
                context.moveTo(ul[0], ul[1]);
                context.lineTo(ur[0], ur[1]);
                context.lineTo(ld[0], ld[1]);
                context.lineTo(ll[0], ll[1]);
                context.closePath();
                ul = europe([33.977877745912025, 55.849945501331]);
                ur = europe([42.75328432167726, 52.78455122462353]);
                ld = europe([39.09869297540224, 49.400700176148625]);
                ll = europe([31.05419851807008, 52.10806751810923]);
                context.moveTo(ul[0], ul[1]);
                context.lineTo(ur[0], ur[1]);
                context.lineTo(ld[0], ld[1]);
                context.lineTo(ll[0], ll[1]);
                context.closePath();
                ul = europe([52.658372900759296, 59.35045068526415]);
                ur = europe([60.23606549583304, 54.63331423800264]);
                ld = europe([54.6756370953122, 51.892298789399455]);
                ll = europe([47.19754524788189, 56.126534861222794]);
                context.moveTo(ul[0], ul[1]);
                context.lineTo(ur[0], ur[1]);
                context.lineTo(ld[0], ld[1]);
                context.lineTo(ll[0], ll[1]);
                context.closePath();
                ul = europe([47.19754506082455, 56.126534735591456]);
                ur = europe([54.675636900123514, 51.892298681337095]);
                ld = europe([49.94448648951486, 48.98775484983285]);
                ll = europe([42.75328468716108, 52.78455126060818]);
                context.moveTo(ul[0], ul[1]);
                context.lineTo(ur[0], ur[1]);
                context.lineTo(ld[0], ld[1]);
                context.lineTo(ll[0], ll[1]);
                context.closePath();
                ul = europe([42.75328453416769, 52.78455113209101]);
                ur = europe([49.94448632339758, 48.98775473706457]);
                ld = europe([45.912339990394315, 45.99361784987003]);
                ll = europe([39.09869317356607, 49.40070009378711]);
                context.moveTo(ul[0], ul[1]);
                context.lineTo(ur[0], ur[1]);
                context.lineTo(ld[0], ld[1]);
                context.lineTo(ll[0], ll[1]);
                context.closePath();
                ul = europe([37.673034114296634, 59.61638254183119]);
                ur = europe([47.197544835420544, 56.126534839849846]);
                ld = europe([42.75328447467064, 52.78455135314068]);
                ll = europe([33.977877870363905, 55.849945644671145]);
                context.moveTo(ul[0], ul[1]);
                context.lineTo(ur[0], ur[1]);
                context.lineTo(ld[0], ld[1]);
                context.lineTo(ll[0], ll[1]);
                context.closePath();
                ul = europe([44.56748486446032, 57.26489367845818]);
                ld = europe([43.9335791193588, 53.746540942601726]);
                ll = europe([43, 56]);
                context.moveTo(ul[0], ul[1]);
                context.lineTo(ur[0], ur[1]);
                context.lineTo(ld[0], ld[1]);
                context.lineTo(ll[0], ll[1]);
                context.closePath();
                ul = europe([37.673034114296634, 59.61638254183119]);
                ur = europe([40.25902691953466, 58.83002044222639]);
                ld = europe([38.458270492742024, 57.26232178028002]);
                ll = europe([35.97754948030156, 58.00266637992386]);
                context.moveTo(ul[0], ul[1]);
                context.lineTo(ur[0], ur[1]);
                context.lineTo(ld[0], ld[1]);
                context.lineTo(ll[0], ll[1]);
                context.closePath();
              };
              conicConformalEurope2.getCompositionBorders = function() {
                var context = d3Path.path();
                this.drawCompositionBorders(context);
                return context.toString();
              };
              return conicConformalEurope2.scale(750);
            }
            function multiplex$9(streams) {
              var n = streams.length;
              return {
                point: function(x, y) {
                  var i = -1;
                  while (++i < n) {
                    streams[i].point(x, y);
                  }
                },
                sphere: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].sphere();
                  }
                },
                lineStart: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].lineStart();
                  }
                },
                lineEnd: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].lineEnd();
                  }
                },
                polygonStart: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].polygonStart();
                  }
                },
                polygonEnd: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].polygonEnd();
                  }
                }
              };
            }
            function conicConformalNetherlands() {
              var cache, cacheStream, netherlandsMainland = d3Geo.geoConicConformal().rotate([-5.5, -52.2]).parallels([0, 60]), netherlandsMainlandPoint, bonaire = d3Geo.geoMercator().center([-68.25, 12.2]), bonairePoint, sabaSintEustatius = d3Geo.geoMercator().center([-63.1, 17.5]), sabaSintEustatiusPoint, point, pointStream = {
                point: function(x, y) {
                  point = [x, y];
                }
              };
              function conicConformalNetherlands2(coordinates) {
                var _a = tslib_1.__read(coordinates, 2), x = _a[0], y = _a[1];
                return point = null, (netherlandsMainlandPoint.point(x, y), point) || (bonairePoint.point(x, y), point) || (sabaSintEustatiusPoint.point(x, y), point);
              }
              conicConformalNetherlands2.invert = function(coordinates) {
                var k = netherlandsMainland.scale(), t = netherlandsMainland.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
                return (y >= -67e-4 && y < 15e-4 && x >= -0.0232 && x < -0.0154 ? bonaire : y >= -0.022 && y < -0.014 && x >= -0.023 && x < -0.014 ? sabaSintEustatius : netherlandsMainland).invert(coordinates);
              };
              conicConformalNetherlands2.stream = function(stream) {
                return cache && cacheStream === stream ? cache : cache = multiplex$9([
                  netherlandsMainland.stream(cacheStream = stream),
                  bonaire.stream(stream),
                  sabaSintEustatius.stream(stream)
                ]);
              };
              conicConformalNetherlands2.precision = function(_) {
                if (!arguments.length)
                  return netherlandsMainland.precision();
                netherlandsMainland.precision(_);
                bonaire.precision(_);
                sabaSintEustatius.precision(_);
                return reset();
              };
              conicConformalNetherlands2.scale = function(_) {
                if (!arguments.length)
                  return netherlandsMainland.scale();
                netherlandsMainland.scale(_);
                bonaire.scale(_);
                sabaSintEustatius.scale(_);
                return conicConformalNetherlands2.translate(netherlandsMainland.translate());
              };
              conicConformalNetherlands2.translate = function(_) {
                if (!arguments.length)
                  return netherlandsMainland.translate();
                var k = netherlandsMainland.scale(), x = +_[0], y = +_[1];
                netherlandsMainlandPoint = netherlandsMainland.translate(_).clipExtent([
                  [x - 0.0245 * k, y - 0.026 * k],
                  [x + 0.023 * k, y + 0.026 * k]
                ]).stream(pointStream);
                bonairePoint = bonaire.translate([x - 0.0186 * k, y - 325e-5 * k]).clipExtent([
                  [x - 0.0232 * k + epsilon, y - 67e-4 * k + epsilon],
                  [x - 0.0154 * k - epsilon, y + 15e-4 * k - epsilon]
                ]).stream(pointStream);
                sabaSintEustatiusPoint = sabaSintEustatius.translate([x - 0.0185 * k, y - 0.017 * k]).clipExtent([
                  [x - 0.023 * k + epsilon, y - 0.022 * k + epsilon],
                  [x - 0.014 * k - epsilon, y - 0.014 * k - epsilon]
                ]).stream(pointStream);
                return reset();
              };
              conicConformalNetherlands2.fitExtent = function(extent, object) {
                return fitExtent(conicConformalNetherlands2, extent, object);
              };
              conicConformalNetherlands2.fitSize = function(size, object) {
                return fitSize(conicConformalNetherlands2, size, object);
              };
              function reset() {
                cache = cacheStream = null;
                return conicConformalNetherlands2;
              }
              conicConformalNetherlands2.drawCompositionBorders = function(context) {
                var ulbonaire = netherlandsMainland([3.30573, 52.5562]);
                var urbonaire = netherlandsMainland([4.043, 52.572]);
                var ldbonaire = netherlandsMainland([4.0646, 52.1017]);
                var llbonaire = netherlandsMainland([3.3382, 52.0861]);
                var ulsabaSintEustatius = netherlandsMainland([3.262, 53.439]);
                var ursabaSintEustatius = netherlandsMainland([4.1373, 53.4571]);
                var ldsabaSintEustatius = netherlandsMainland([4.1574, 52.9946]);
                var llsabaSintEustatius = netherlandsMainland([3.2951, 52.9768]);
                context.moveTo(ulbonaire[0], ulbonaire[1]);
                context.lineTo(urbonaire[0], urbonaire[1]);
                context.lineTo(ldbonaire[0], ldbonaire[1]);
                context.lineTo(ldbonaire[0], ldbonaire[1]);
                context.lineTo(llbonaire[0], llbonaire[1]);
                context.closePath();
                context.moveTo(ulsabaSintEustatius[0], ulsabaSintEustatius[1]);
                context.lineTo(ursabaSintEustatius[0], ursabaSintEustatius[1]);
                context.lineTo(ldsabaSintEustatius[0], ldsabaSintEustatius[1]);
                context.lineTo(ldsabaSintEustatius[0], ldsabaSintEustatius[1]);
                context.lineTo(llsabaSintEustatius[0], llsabaSintEustatius[1]);
                context.closePath();
              };
              conicConformalNetherlands2.getCompositionBorders = function() {
                var context = d3Path.path();
                this.drawCompositionBorders(context);
                return context.toString();
              };
              return conicConformalNetherlands2.scale(4200);
            }
            function multiplex$a(streams) {
              var n = streams.length;
              return {
                point: function(x, y) {
                  var i = -1;
                  while (++i < n) {
                    streams[i].point(x, y);
                  }
                },
                sphere: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].sphere();
                  }
                },
                lineStart: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].lineStart();
                  }
                },
                lineEnd: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].lineEnd();
                  }
                },
                polygonStart: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].polygonStart();
                  }
                },
                polygonEnd: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].polygonEnd();
                  }
                }
              };
            }
            function mercatorMalaysia() {
              var cache, cacheStream, peninsular = d3Geo.geoMercator().center([105.25, 4]), peninsularPoint, borneo = d3Geo.geoMercator().center([118.65, 2.86]), borneoPoint, point, pointStream = { point: function(x, y) {
                point = [x, y];
              } };
              function mercatorMalaysia2(coordinates) {
                var x = coordinates[0], y = coordinates[1];
                return point = null, (peninsularPoint.point(x, y), point) || (borneoPoint.point(x, y), point);
              }
              mercatorMalaysia2.invert = function(coordinates) {
                var k = peninsular.scale(), t = peninsular.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
                return (y >= -0.0521 && y < 0.0229 && x >= -0.0111 && x < 0.1 ? borneo : peninsular).invert(coordinates);
              };
              mercatorMalaysia2.stream = function(stream) {
                return cache && cacheStream === stream ? cache : cache = multiplex$a([peninsular.stream(cacheStream = stream), borneo.stream(stream)]);
              };
              mercatorMalaysia2.precision = function(_) {
                if (!arguments.length) {
                  return peninsular.precision();
                }
                peninsular.precision(_);
                borneo.precision(_);
                return reset();
              };
              mercatorMalaysia2.scale = function(_) {
                if (!arguments.length) {
                  return peninsular.scale();
                }
                peninsular.scale(_);
                borneo.scale(_ * 0.615);
                return mercatorMalaysia2.translate(peninsular.translate());
              };
              mercatorMalaysia2.translate = function(_) {
                if (!arguments.length) {
                  return peninsular.translate();
                }
                var k = peninsular.scale(), x = +_[0], y = +_[1];
                peninsularPoint = peninsular.translate(_).clipExtent([[x - 0.11 * k, y - 0.0521 * k], [x - 0.0111 * k, y + 0.0521 * k]]).stream(pointStream);
                borneoPoint = borneo.translate([x + 0.09 * k, y - 0 * k]).clipExtent([[x - 0.0111 * k + epsilon, y - 0.0521 * k + epsilon], [x + 0.1 * k - epsilon, y + 0.024 * k - epsilon]]).stream(pointStream);
                return reset();
              };
              mercatorMalaysia2.fitExtent = function(extent, object) {
                return fitExtent(mercatorMalaysia2, extent, object);
              };
              mercatorMalaysia2.fitSize = function(size, object) {
                return fitSize(mercatorMalaysia2, size, object);
              };
              function reset() {
                cache = cacheStream = null;
                return mercatorMalaysia2;
              }
              mercatorMalaysia2.drawCompositionBorders = function(context) {
                var llbor = peninsular([106.3214, 2.0228]);
                var lmbor = peninsular([105.1843, 2.3761]);
                var lrbor = peninsular([104.2151, 3.3618]);
                var llrbor = peninsular([104.215, 4.5651]);
                context.moveTo(llbor[0], llbor[1]);
                context.lineTo(lmbor[0], lmbor[1]);
                context.lineTo(lrbor[0], lrbor[1]);
                context.lineTo(llrbor[0], llrbor[1]);
              };
              mercatorMalaysia2.getCompositionBorders = function() {
                var context = d3Path.path();
                this.drawCompositionBorders(context);
                return context.toString();
              };
              return mercatorMalaysia2.scale(4800);
            }
            function multiplex$b(streams) {
              var n = streams.length;
              return {
                point: function(x, y) {
                  var i = -1;
                  while (++i < n) {
                    streams[i].point(x, y);
                  }
                },
                sphere: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].sphere();
                  }
                },
                lineStart: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].lineStart();
                  }
                },
                lineEnd: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].lineEnd();
                  }
                },
                polygonStart: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].polygonStart();
                  }
                },
                polygonEnd: function() {
                  var i = -1;
                  while (++i < n) {
                    streams[i].polygonEnd();
                  }
                }
              };
            }
            function mercatorEquatorialGuinea() {
              var cache, cacheStream, continent = d3Geo.geoMercator().rotate([-9.5, -1.5]), continentPoint, bioko = d3Geo.geoMercator().rotate([-8.6, -3.5]), biokoPoint, annobon = d3Geo.geoMercator().rotate([-5.6, 1.45]), annobonPoint, point, pointStream = { point: function(x, y) {
                point = [x, y];
              } };
              function mercatorEquatorialGuinea2(coordinates) {
                var x = coordinates[0], y = coordinates[1];
                return point = null, (continentPoint.point(x, y), point) || (biokoPoint.point(x, y), point) || (annobonPoint.point(x, y), point);
              }
              mercatorEquatorialGuinea2.invert = function(coordinates) {
                var k = continent.scale(), t = continent.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
                return (y >= -0.02 && y < 0 && x >= -0.038 && x < -5e-3 ? bioko : y >= 0 && y < 0.02 && x >= -0.038 && x < -5e-3 ? annobon : continent).invert(coordinates);
              };
              mercatorEquatorialGuinea2.stream = function(stream) {
                return cache && cacheStream === stream ? cache : cache = multiplex$b([continent.stream(cacheStream = stream), bioko.stream(stream), annobon.stream(stream)]);
              };
              mercatorEquatorialGuinea2.precision = function(_) {
                if (!arguments.length) {
                  return continent.precision();
                }
                continent.precision(_);
                bioko.precision(_);
                annobon.precision(_);
                return reset();
              };
              mercatorEquatorialGuinea2.scale = function(_) {
                if (!arguments.length) {
                  return continent.scale();
                }
                continent.scale(_);
                bioko.scale(_ * 1.5);
                annobon.scale(_ * 4);
                return mercatorEquatorialGuinea2.translate(continent.translate());
              };
              mercatorEquatorialGuinea2.translate = function(_) {
                if (!arguments.length) {
                  return continent.translate();
                }
                var k = continent.scale(), x = +_[0], y = +_[1];
                continentPoint = continent.translate(_).clipExtent([[x - 5e-3 * k, y - 0.02 * k], [x + 0.038 * k, y + 0.02 * k]]).stream(pointStream);
                biokoPoint = bioko.translate([x - 0.025 * k, y - 0.01 * k]).clipExtent([[x - 0.038 * k + epsilon, y - 0.02 * k + epsilon], [x - 5e-3 * k - epsilon, y + 0 * k - epsilon]]).stream(pointStream);
                annobonPoint = annobon.translate([x - 0.025 * k, y + 0.01 * k]).clipExtent([[x - 0.038 * k + epsilon, y - 0 * k + epsilon], [x - 5e-3 * k - epsilon, y + 0.02 * k - epsilon]]).stream(pointStream);
                return reset();
              };
              mercatorEquatorialGuinea2.fitExtent = function(extent, object) {
                return fitExtent(mercatorEquatorialGuinea2, extent, object);
              };
              mercatorEquatorialGuinea2.fitSize = function(size, object) {
                return fitSize(mercatorEquatorialGuinea2, size, object);
              };
              function reset() {
                cache = cacheStream = null;
                return mercatorEquatorialGuinea2;
              }
              mercatorEquatorialGuinea2.drawCompositionBorders = function(context) {
                var ul, ur, ld, ll;
                ul = continent([9.21327272751682, 2.645820439454123]);
                ur = continent([11.679126293239872, 2.644755519268689]);
                ld = continent([11.676845389029227, 0.35307824637606433]);
                ll = continent([9.213572917774014, 0.35414205204417754]);
                context.moveTo(ul[0], ul[1]);
                context.lineTo(ur[0], ur[1]);
                context.lineTo(ld[0], ld[1]);
                context.lineTo(ll[0], ll[1]);
                context.closePath();
                ul = continent([7.320873711543669, 2.64475551449975]);
                ur = continent([9.213272722738658, 2.645820434679803]);
                ld = continent([9.213422896480349, 1.4999812505283054]);
                ll = continent([7.322014760520787, 1.4989168878985566]);
                context.moveTo(ul[0], ul[1]);
                context.lineTo(ur[0], ur[1]);
                context.lineTo(ld[0], ld[1]);
                context.lineTo(ll[0], ll[1]);
                context.closePath();
                ul = continent([7.3220147605302905, 1.4989168783492766]);
                ur = continent([9.213422896481598, 1.499981240979021]);
                ld = continent([9.213572912999604, 0.354142056817247]);
                ll = continent([7.323154615739809, 0.353078251154504]);
                context.moveTo(ul[0], ul[1]);
                context.lineTo(ur[0], ur[1]);
                context.lineTo(ld[0], ld[1]);
                context.lineTo(ll[0], ll[1]);
                context.closePath();
              };
              mercatorEquatorialGuinea2.getCompositionBorders = function() {
                var context = d3Path.path();
                this.drawCompositionBorders(context);
                return context.toString();
              };
              return mercatorEquatorialGuinea2.scale(12e3);
            }
            function multiplex$c(streams) {
              var n = streams.length;
              return {
                point: function(x, y) {
                  var i = -1;
                  while (++i < n)
                    streams[i].point(x, y);
                },
                sphere: function() {
                  var i = -1;
                  while (++i < n)
                    streams[i].sphere();
                },
                lineStart: function() {
                  var i = -1;
                  while (++i < n)
                    streams[i].lineStart();
                },
                lineEnd: function() {
                  var i = -1;
                  while (++i < n)
                    streams[i].lineEnd();
                },
                polygonStart: function() {
                  var i = -1;
                  while (++i < n)
                    streams[i].polygonStart();
                },
                polygonEnd: function() {
                  var i = -1;
                  while (++i < n)
                    streams[i].polygonEnd();
                }
              };
            }
            function albersUk() {
              var cache, cacheStream, main = d3Geo.geoAlbers().rotate([4.4, 0.8]).center([0, 55.4]).parallels([50, 60]), mainPoint, shetland = d3Geo.geoAlbers().rotate([4.4, 0.8]).center([0, 55.4]).parallels([50, 60]), shetlandPoint, point, pointStream = {
                point: function(x, y) {
                  point = [x, y];
                }
              };
              function albersUk2(coordinates) {
                var x = coordinates[0], y = coordinates[1];
                return point = null, (mainPoint.point(x, y), point) || (shetlandPoint.point(x, y), point);
              }
              albersUk2.invert = function(coordinates) {
                var k = main.scale(), t = main.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
                return (y >= -0.089 && y < 0.06 && x >= 0.029 && x < 0.046 ? shetland : main).invert(coordinates);
              };
              albersUk2.stream = function(stream) {
                return cache && cacheStream === stream ? cache : cache = multiplex$c([
                  main.stream(cacheStream = stream),
                  shetland.stream(stream)
                ]);
              };
              albersUk2.precision = function(_) {
                if (!arguments.length)
                  return main.precision();
                main.precision(_), shetland.precision(_);
                return reset();
              };
              albersUk2.scale = function(_) {
                if (!arguments.length)
                  return main.scale();
                main.scale(_), shetland.scale(_);
                return albersUk2.translate(main.translate());
              };
              albersUk2.translate = function(_) {
                if (!arguments.length)
                  return main.translate();
                var k = main.scale(), x = +_[0], y = +_[1];
                mainPoint = main.translate(_).clipExtent([
                  [x - 0.065 * k, y - 0.089 * k],
                  [x + 0.075 * k, y + 0.089 * k]
                ]).stream(pointStream);
                shetlandPoint = shetland.translate([x + 0.01 * k, y + 0.025 * k]).clipExtent([
                  [x + 0.029 * k + epsilon, y - 0.089 * k + epsilon],
                  [x + 0.046 * k - epsilon, y - 0.06 * k - epsilon]
                ]).stream(pointStream);
                return reset();
              };
              albersUk2.fitExtent = function(extent, object) {
                return fitExtent(albersUk2, extent, object);
              };
              albersUk2.fitSize = function(size, object) {
                return fitSize(albersUk2, size, object);
              };
              function reset() {
                cache = cacheStream = null;
                return albersUk2;
              }
              albersUk2.drawCompositionBorders = function(context) {
                var ul, ur, ld, ll;
                ul = main([-1.113205870242365, 59.64920050773357]);
                ur = main([0.807899092399606, 59.59085836472269]);
                ld = main([0.5778611961420386, 57.93467822832577]);
                ll = main([-1.25867782078448, 57.99029450085142]);
                context.moveTo(ul[0], ul[1]);
                context.lineTo(ur[0], ur[1]);
                context.lineTo(ld[0], ld[1]);
                context.lineTo(ll[0], ll[1]);
                context.closePath();
              };
              albersUk2.getCompositionBorders = function() {
                var context = d3Path.path();
                this.drawCompositionBorders(context);
                return context.toString();
              };
              return albersUk2.scale(2800);
            }
            exports3.geoAlbersUk = albersUk;
            exports3.geoAlbersUsa = albersUsa;
            exports3.geoAlbersUsaTerritories = albersUsaTerritories;
            exports3.geoConicConformalEurope = conicConformalEurope;
            exports3.geoConicConformalFrance = conicConformalFrance;
            exports3.geoConicConformalNetherlands = conicConformalNetherlands;
            exports3.geoConicConformalPortugal = conicConformalPortugal;
            exports3.geoConicConformalSpain = conicConformalSpain;
            exports3.geoConicEquidistantJapan = conicEquidistantJapan;
            exports3.geoMercatorEcuador = mercatorEcuador;
            exports3.geoMercatorEquatorialGuinea = mercatorEquatorialGuinea;
            exports3.geoMercatorMalaysia = mercatorMalaysia;
            exports3.geoTransverseMercatorChile = transverseMercatorChile;
            Object.defineProperty(exports3, "__esModule", { value: true });
          });
        },
        "./node_modules/_d3-dsv@1.2.0@d3-dsv/dist/d3-dsv.js": function(module2, exports2, __webpack_require__) {
          (function(global, factory) {
            true ? factory(exports2) : void 0;
          })(this, function(exports3) {
            "use strict";
            var EOL = {}, EOF = {}, QUOTE = 34, NEWLINE = 10, RETURN = 13;
            function objectConverter(columns) {
              return new Function("d", "return {" + columns.map(function(name, i) {
                return JSON.stringify(name) + ": d[" + i + '] || ""';
              }).join(",") + "}");
            }
            function customConverter(columns, f) {
              var object = objectConverter(columns);
              return function(row, i) {
                return f(object(row), i, columns);
              };
            }
            function inferColumns(rows) {
              var columnSet = /* @__PURE__ */ Object.create(null), columns = [];
              rows.forEach(function(row) {
                for (var column in row) {
                  if (!(column in columnSet)) {
                    columns.push(columnSet[column] = column);
                  }
                }
              });
              return columns;
            }
            function pad(value, width) {
              var s = value + "", length = s.length;
              return length < width ? new Array(width - length + 1).join(0) + s : s;
            }
            function formatYear(year) {
              return year < 0 ? "-" + pad(-year, 6) : year > 9999 ? "+" + pad(year, 6) : pad(year, 4);
            }
            function formatDate(date) {
              var hours = date.getUTCHours(), minutes = date.getUTCMinutes(), seconds = date.getUTCSeconds(), milliseconds = date.getUTCMilliseconds();
              return isNaN(date) ? "Invalid Date" : formatYear(date.getUTCFullYear()) + "-" + pad(date.getUTCMonth() + 1, 2) + "-" + pad(date.getUTCDate(), 2) + (milliseconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "." + pad(milliseconds, 3) + "Z" : seconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "Z" : minutes || hours ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + "Z" : "");
            }
            function dsv(delimiter) {
              var reFormat = new RegExp('["' + delimiter + "\n\r]"), DELIMITER = delimiter.charCodeAt(0);
              function parse(text, f) {
                var convert, columns, rows = parseRows(text, function(row, i) {
                  if (convert)
                    return convert(row, i - 1);
                  columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
                });
                rows.columns = columns || [];
                return rows;
              }
              function parseRows(text, f) {
                var rows = [], N = text.length, I = 0, n = 0, t, eof = N <= 0, eol = false;
                if (text.charCodeAt(N - 1) === NEWLINE)
                  --N;
                if (text.charCodeAt(N - 1) === RETURN)
                  --N;
                function token() {
                  if (eof)
                    return EOF;
                  if (eol)
                    return eol = false, EOL;
                  var i, j = I, c;
                  if (text.charCodeAt(j) === QUOTE) {
                    while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE)
                      ;
                    if ((i = I) >= N)
                      eof = true;
                    else if ((c = text.charCodeAt(I++)) === NEWLINE)
                      eol = true;
                    else if (c === RETURN) {
                      eol = true;
                      if (text.charCodeAt(I) === NEWLINE)
                        ++I;
                    }
                    return text.slice(j + 1, i - 1).replace(/""/g, '"');
                  }
                  while (I < N) {
                    if ((c = text.charCodeAt(i = I++)) === NEWLINE)
                      eol = true;
                    else if (c === RETURN) {
                      eol = true;
                      if (text.charCodeAt(I) === NEWLINE)
                        ++I;
                    } else if (c !== DELIMITER)
                      continue;
                    return text.slice(j, i);
                  }
                  return eof = true, text.slice(j, N);
                }
                while ((t = token()) !== EOF) {
                  var row = [];
                  while (t !== EOL && t !== EOF)
                    row.push(t), t = token();
                  if (f && (row = f(row, n++)) == null)
                    continue;
                  rows.push(row);
                }
                return rows;
              }
              function preformatBody(rows, columns) {
                return rows.map(function(row) {
                  return columns.map(function(column) {
                    return formatValue(row[column]);
                  }).join(delimiter);
                });
              }
              function format(rows, columns) {
                if (columns == null)
                  columns = inferColumns(rows);
                return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
              }
              function formatBody(rows, columns) {
                if (columns == null)
                  columns = inferColumns(rows);
                return preformatBody(rows, columns).join("\n");
              }
              function formatRows(rows) {
                return rows.map(formatRow).join("\n");
              }
              function formatRow(row) {
                return row.map(formatValue).join(delimiter);
              }
              function formatValue(value) {
                return value == null ? "" : value instanceof Date ? formatDate(value) : reFormat.test(value += "") ? '"' + value.replace(/"/g, '""') + '"' : value;
              }
              return {
                parse,
                parseRows,
                format,
                formatBody,
                formatRows,
                formatRow,
                formatValue
              };
            }
            var csv = dsv(",");
            var csvParse = csv.parse;
            var csvParseRows = csv.parseRows;
            var csvFormat = csv.format;
            var csvFormatBody = csv.formatBody;
            var csvFormatRows = csv.formatRows;
            var csvFormatRow = csv.formatRow;
            var csvFormatValue = csv.formatValue;
            var tsv = dsv("	");
            var tsvParse = tsv.parse;
            var tsvParseRows = tsv.parseRows;
            var tsvFormat = tsv.format;
            var tsvFormatBody = tsv.formatBody;
            var tsvFormatRows = tsv.formatRows;
            var tsvFormatRow = tsv.formatRow;
            var tsvFormatValue = tsv.formatValue;
            function autoType(object) {
              for (var key in object) {
                var value = object[key].trim(), number, m;
                if (!value)
                  value = null;
                else if (value === "true")
                  value = true;
                else if (value === "false")
                  value = false;
                else if (value === "NaN")
                  value = NaN;
                else if (!isNaN(number = +value))
                  value = number;
                else if (m = value.match(/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/)) {
                  if (fixtz && !!m[4] && !m[7])
                    value = value.replace(/-/g, "/").replace(/T/, " ");
                  value = new Date(value);
                } else
                  continue;
                object[key] = value;
              }
              return object;
            }
            var fixtz = new Date("2019-01-01T00:00").getHours() || new Date("2019-07-01T00:00").getHours();
            exports3.autoType = autoType;
            exports3.csvFormat = csvFormat;
            exports3.csvFormatBody = csvFormatBody;
            exports3.csvFormatRow = csvFormatRow;
            exports3.csvFormatRows = csvFormatRows;
            exports3.csvFormatValue = csvFormatValue;
            exports3.csvParse = csvParse;
            exports3.csvParseRows = csvParseRows;
            exports3.dsvFormat = dsv;
            exports3.tsvFormat = tsvFormat;
            exports3.tsvFormatBody = tsvFormatBody;
            exports3.tsvFormatRow = tsvFormatRow;
            exports3.tsvFormatRows = tsvFormatRows;
            exports3.tsvFormatValue = tsvFormatValue;
            exports3.tsvParse = tsvParse;
            exports3.tsvParseRows = tsvParseRows;
            Object.defineProperty(exports3, "__esModule", { value: true });
          });
        },
        "./node_modules/_d3-geo-projection@2.1.2@d3-geo-projection/build/d3-geo-projection.js": function(module2, exports2, __webpack_require__) {
          (function(global, factory) {
            true ? factory(exports2, __webpack_require__("./node_modules/_d3-geo@1.12.1@d3-geo/dist/d3-geo.js"), __webpack_require__("./node_modules/_d3-array@1.2.4@d3-array/dist/d3-array.js")) : void 0;
          })(this, function(exports3, d3Geo, d3Array) {
            "use strict";
            var abs = Math.abs;
            var atan = Math.atan;
            var atan2 = Math.atan2;
            var cos = Math.cos;
            var exp = Math.exp;
            var floor = Math.floor;
            var log = Math.log;
            var max = Math.max;
            var min = Math.min;
            var pow = Math.pow;
            var round = Math.round;
            var sign = Math.sign || function(x) {
              return x > 0 ? 1 : x < 0 ? -1 : 0;
            };
            var sin = Math.sin;
            var tan = Math.tan;
            var epsilon = 1e-6;
            var epsilon2 = 1e-12;
            var pi = Math.PI;
            var halfPi = pi / 2;
            var quarterPi = pi / 4;
            var sqrt1_2 = Math.SQRT1_2;
            var sqrt2 = sqrt(2);
            var sqrtPi = sqrt(pi);
            var tau = pi * 2;
            var degrees = 180 / pi;
            var radians = pi / 180;
            function sinci(x) {
              return x ? x / Math.sin(x) : 1;
            }
            function asin(x) {
              return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
            }
            function acos(x) {
              return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
            }
            function sqrt(x) {
              return x > 0 ? Math.sqrt(x) : 0;
            }
            function tanh(x) {
              x = exp(2 * x);
              return (x - 1) / (x + 1);
            }
            function sinh(x) {
              return (exp(x) - exp(-x)) / 2;
            }
            function cosh(x) {
              return (exp(x) + exp(-x)) / 2;
            }
            function arsinh(x) {
              return log(x + sqrt(x * x + 1));
            }
            function arcosh(x) {
              return log(x + sqrt(x * x - 1));
            }
            function airyRaw(beta) {
              var tanBeta_2 = tan(beta / 2), b = 2 * log(cos(beta / 2)) / (tanBeta_2 * tanBeta_2);
              function forward(x, y) {
                var cosx = cos(x), cosy = cos(y), siny = sin(y), cosz = cosy * cosx, k2 = -((1 - cosz ? log((1 + cosz) / 2) / (1 - cosz) : -0.5) + b / (1 + cosz));
                return [k2 * cosy * sin(x), k2 * siny];
              }
              forward.invert = function(x, y) {
                var r = sqrt(x * x + y * y), z = -beta / 2, i = 50, delta;
                if (!r)
                  return [0, 0];
                do {
                  var z_2 = z / 2, cosz_2 = cos(z_2), sinz_2 = sin(z_2), tanz_2 = tan(z_2), lnsecz_2 = log(1 / cosz_2);
                  z -= delta = (2 / tanz_2 * lnsecz_2 - b * tanz_2 - r) / (-lnsecz_2 / (sinz_2 * sinz_2) + 1 - b / (2 * cosz_2 * cosz_2));
                } while (abs(delta) > epsilon && --i > 0);
                var sinz = sin(z);
                return [atan2(x * sinz, r * cos(z)), asin(y * sinz / r)];
              };
              return forward;
            }
            var airy = function() {
              var beta = halfPi, m = d3Geo.geoProjectionMutator(airyRaw), p = m(beta);
              p.radius = function(_) {
                return arguments.length ? m(beta = _ * radians) : beta * degrees;
              };
              return p.scale(179.976).clipAngle(147);
            };
            function aitoffRaw(x, y) {
              var cosy = cos(y), sincia = sinci(acos(cosy * cos(x /= 2)));
              return [2 * cosy * sin(x) * sincia, sin(y) * sincia];
            }
            aitoffRaw.invert = function(x, y) {
              if (x * x + 4 * y * y > pi * pi + epsilon)
                return;
              var x12 = x, y12 = y, i = 25;
              do {
                var sinx = sin(x12), sinx_2 = sin(x12 / 2), cosx_2 = cos(x12 / 2), siny = sin(y12), cosy = cos(y12), sin_2y = sin(2 * y12), sin2y = siny * siny, cos2y = cosy * cosy, sin2x_2 = sinx_2 * sinx_2, c = 1 - cos2y * cosx_2 * cosx_2, e = c ? acos(cosy * cosx_2) * sqrt(f = 1 / c) : f = 0, f, fx = 2 * e * cosy * sinx_2 - x, fy = e * siny - y, dxdx = f * (cos2y * sin2x_2 + e * cosy * cosx_2 * sin2y), dxdy = f * (0.5 * sinx * sin_2y - e * 2 * siny * sinx_2), dydx = f * 0.25 * (sin_2y * sinx_2 - e * siny * cos2y * sinx), dydy = f * (sin2y * cosx_2 + e * sin2x_2 * cosy), z = dxdy * dydx - dydy * dxdx;
                if (!z)
                  break;
                var dx = (fy * dxdy - fx * dydy) / z, dy = (fx * dydx - fy * dxdx) / z;
                x12 -= dx, y12 -= dy;
              } while ((abs(dx) > epsilon || abs(dy) > epsilon) && --i > 0);
              return [x12, y12];
            };
            var aitoff = function() {
              return d3Geo.geoProjection(aitoffRaw).scale(152.63);
            };
            function armadilloRaw(phi02) {
              var sinPhi0 = sin(phi02), cosPhi0 = cos(phi02), sPhi0 = phi02 >= 0 ? 1 : -1, tanPhi0 = tan(sPhi0 * phi02), k2 = (1 + sinPhi0 - cosPhi0) / 2;
              function forward(lambda, phi) {
                var cosPhi = cos(phi), cosLambda = cos(lambda /= 2);
                return [
                  (1 + cosPhi) * sin(lambda),
                  (sPhi0 * phi > -atan2(cosLambda, tanPhi0) - 1e-3 ? 0 : -sPhi0 * 10) + k2 + sin(phi) * cosPhi0 - (1 + cosPhi) * sinPhi0 * cosLambda
                ];
              }
              forward.invert = function(x, y) {
                var lambda = 0, phi = 0, i = 50;
                do {
                  var cosLambda = cos(lambda), sinLambda = sin(lambda), cosPhi = cos(phi), sinPhi = sin(phi), A2 = 1 + cosPhi, fx = A2 * sinLambda - x, fy = k2 + sinPhi * cosPhi0 - A2 * sinPhi0 * cosLambda - y, dxdLambda = A2 * cosLambda / 2, dxdPhi = -sinLambda * sinPhi, dydLambda = sinPhi0 * A2 * sinLambda / 2, dydPhi = cosPhi0 * cosPhi + sinPhi0 * cosLambda * sinPhi, denominator = dxdPhi * dydLambda - dydPhi * dxdLambda, dLambda = (fy * dxdPhi - fx * dydPhi) / denominator / 2, dPhi = (fx * dydLambda - fy * dxdLambda) / denominator;
                  lambda -= dLambda, phi -= dPhi;
                } while ((abs(dLambda) > epsilon || abs(dPhi) > epsilon) && --i > 0);
                return sPhi0 * phi > -atan2(cos(lambda), tanPhi0) - 1e-3 ? [lambda * 2, phi] : null;
              };
              return forward;
            }
            var armadillo = function() {
              var phi02 = 20 * radians, sPhi0 = phi02 >= 0 ? 1 : -1, tanPhi0 = tan(sPhi0 * phi02), m = d3Geo.geoProjectionMutator(armadilloRaw), p = m(phi02), stream_ = p.stream;
              p.parallel = function(_) {
                if (!arguments.length)
                  return phi02 * degrees;
                tanPhi0 = tan((sPhi0 = (phi02 = _ * radians) >= 0 ? 1 : -1) * phi02);
                return m(phi02);
              };
              p.stream = function(stream) {
                var rotate = p.rotate(), rotateStream = stream_(stream), sphereStream = (p.rotate([0, 0]), stream_(stream));
                p.rotate(rotate);
                rotateStream.sphere = function() {
                  sphereStream.polygonStart(), sphereStream.lineStart();
                  for (var lambda = sPhi0 * -180; sPhi0 * lambda < 180; lambda += sPhi0 * 90)
                    sphereStream.point(lambda, sPhi0 * 90);
                  while (sPhi0 * (lambda -= phi02) >= -180) {
                    sphereStream.point(lambda, sPhi0 * -atan2(cos(lambda * radians / 2), tanPhi0) * degrees);
                  }
                  sphereStream.lineEnd(), sphereStream.polygonEnd();
                };
                return rotateStream;
              };
              return p.scale(218.695).center([0, 28.0974]);
            };
            function augustRaw(lambda, phi) {
              var tanPhi = tan(phi / 2), k2 = sqrt(1 - tanPhi * tanPhi), c = 1 + k2 * cos(lambda /= 2), x = sin(lambda) * k2 / c, y = tanPhi / c, x2 = x * x, y2 = y * y;
              return [
                4 / 3 * x * (3 + x2 - 3 * y2),
                4 / 3 * y * (3 + 3 * x2 - y2)
              ];
            }
            augustRaw.invert = function(x, y) {
              x *= 3 / 8, y *= 3 / 8;
              if (!x && abs(y) > 1)
                return null;
              var x2 = x * x, y2 = y * y, s = 1 + x2 + y2, sin3Eta = sqrt((s - sqrt(s * s - 4 * y * y)) / 2), eta = asin(sin3Eta) / 3, xi = sin3Eta ? arcosh(abs(y / sin3Eta)) / 3 : arsinh(abs(x)) / 3, cosEta = cos(eta), coshXi = cosh(xi), d = coshXi * coshXi - cosEta * cosEta;
              return [
                sign(x) * 2 * atan2(sinh(xi) * cosEta, 0.25 - d),
                sign(y) * 2 * atan2(coshXi * sin(eta), 0.25 + d)
              ];
            };
            var august = function() {
              return d3Geo.geoProjection(augustRaw).scale(66.1603);
            };
            var sqrt8 = sqrt(8);
            var phi0 = log(1 + sqrt2);
            function bakerRaw(lambda, phi) {
              var phi02 = abs(phi);
              return phi02 < quarterPi ? [lambda, log(tan(quarterPi + phi / 2))] : [lambda * cos(phi02) * (2 * sqrt2 - 1 / sin(phi02)), sign(phi) * (2 * sqrt2 * (phi02 - quarterPi) - log(tan(phi02 / 2)))];
            }
            bakerRaw.invert = function(x, y) {
              if ((y02 = abs(y)) < phi0)
                return [x, 2 * atan(exp(y)) - halfPi];
              var phi = quarterPi, i = 25, delta, y02;
              do {
                var cosPhi_2 = cos(phi / 2), tanPhi_2 = tan(phi / 2);
                phi -= delta = (sqrt8 * (phi - quarterPi) - log(tanPhi_2) - y02) / (sqrt8 - cosPhi_2 * cosPhi_2 / (2 * tanPhi_2));
              } while (abs(delta) > epsilon2 && --i > 0);
              return [x / (cos(phi) * (sqrt8 - 1 / sin(phi))), sign(y) * phi];
            };
            var baker = function() {
              return d3Geo.geoProjection(bakerRaw).scale(112.314);
            };
            function berghausRaw(lobes2) {
              var k2 = 2 * pi / lobes2;
              function forward(lambda, phi) {
                var p = d3Geo.geoAzimuthalEquidistantRaw(lambda, phi);
                if (abs(lambda) > halfPi) {
                  var theta = atan2(p[1], p[0]), r = sqrt(p[0] * p[0] + p[1] * p[1]), theta0 = k2 * round((theta - halfPi) / k2) + halfPi, alpha = atan2(sin(theta -= theta0), 2 - cos(theta));
                  theta = theta0 + asin(pi / r * sin(alpha)) - alpha;
                  p[0] = r * cos(theta);
                  p[1] = r * sin(theta);
                }
                return p;
              }
              forward.invert = function(x, y) {
                var r = sqrt(x * x + y * y);
                if (r > halfPi) {
                  var theta = atan2(y, x), theta0 = k2 * round((theta - halfPi) / k2) + halfPi, s = theta > theta0 ? -1 : 1, A2 = r * cos(theta0 - theta), cotAlpha = 1 / tan(s * acos((A2 - pi) / sqrt(pi * (pi - 2 * A2) + r * r)));
                  theta = theta0 + 2 * atan((cotAlpha + s * sqrt(cotAlpha * cotAlpha - 3)) / 3);
                  x = r * cos(theta), y = r * sin(theta);
                }
                return d3Geo.geoAzimuthalEquidistantRaw.invert(x, y);
              };
              return forward;
            }
            var berghaus = function() {
              var lobes2 = 5, m = d3Geo.geoProjectionMutator(berghausRaw), p = m(lobes2), projectionStream = p.stream, epsilon$$1 = 0.01, cr = -cos(epsilon$$1 * radians), sr = sin(epsilon$$1 * radians);
              p.lobes = function(_) {
                return arguments.length ? m(lobes2 = +_) : lobes2;
              };
              p.stream = function(stream) {
                var rotate = p.rotate(), rotateStream = projectionStream(stream), sphereStream = (p.rotate([0, 0]), projectionStream(stream));
                p.rotate(rotate);
                rotateStream.sphere = function() {
                  sphereStream.polygonStart(), sphereStream.lineStart();
                  for (var i = 0, delta = 360 / lobes2, delta0 = 2 * pi / lobes2, phi = 90 - 180 / lobes2, phi02 = halfPi; i < lobes2; ++i, phi -= delta, phi02 -= delta0) {
                    sphereStream.point(atan2(sr * cos(phi02), cr) * degrees, asin(sr * sin(phi02)) * degrees);
                    if (phi < -90) {
                      sphereStream.point(-90, -180 - phi - epsilon$$1);
                      sphereStream.point(-90, -180 - phi + epsilon$$1);
                    } else {
                      sphereStream.point(90, phi + epsilon$$1);
                      sphereStream.point(90, phi - epsilon$$1);
                    }
                  }
                  sphereStream.lineEnd(), sphereStream.polygonEnd();
                };
                return rotateStream;
              };
              return p.scale(87.8076).center([0, 17.1875]).clipAngle(180 - 1e-3);
            };
            function mollweideBromleyTheta(cp, phi) {
              var cpsinPhi = cp * sin(phi), i = 30, delta;
              do
                phi -= delta = (phi + sin(phi) - cpsinPhi) / (1 + cos(phi));
              while (abs(delta) > epsilon && --i > 0);
              return phi / 2;
            }
            function mollweideBromleyRaw(cx, cy, cp) {
              function forward(lambda, phi) {
                return [cx * lambda * cos(phi = mollweideBromleyTheta(cp, phi)), cy * sin(phi)];
              }
              forward.invert = function(x, y) {
                return y = asin(y / cy), [x / (cx * cos(y)), asin((2 * y + sin(2 * y)) / cp)];
              };
              return forward;
            }
            var mollweideRaw = mollweideBromleyRaw(sqrt2 / halfPi, sqrt2, pi);
            var mollweide = function() {
              return d3Geo.geoProjection(mollweideRaw).scale(169.529);
            };
            var k = 2.00276;
            var w = 1.11072;
            function boggsRaw(lambda, phi) {
              var theta = mollweideBromleyTheta(pi, phi);
              return [k * lambda / (1 / cos(phi) + w / cos(theta)), (phi + sqrt2 * sin(theta)) / k];
            }
            boggsRaw.invert = function(x, y) {
              var ky = k * y, theta = y < 0 ? -quarterPi : quarterPi, i = 25, delta, phi;
              do {
                phi = ky - sqrt2 * sin(theta);
                theta -= delta = (sin(2 * theta) + 2 * theta - pi * sin(phi)) / (2 * cos(2 * theta) + 2 + pi * cos(phi) * sqrt2 * cos(theta));
              } while (abs(delta) > epsilon && --i > 0);
              phi = ky - sqrt2 * sin(theta);
              return [x * (1 / cos(phi) + w / cos(theta)) / k, phi];
            };
            var boggs = function() {
              return d3Geo.geoProjection(boggsRaw).scale(160.857);
            };
            var parallel1 = function(projectAt) {
              var phi02 = 0, m = d3Geo.geoProjectionMutator(projectAt), p = m(phi02);
              p.parallel = function(_) {
                return arguments.length ? m(phi02 = _ * radians) : phi02 * degrees;
              };
              return p;
            };
            function sinusoidalRaw(lambda, phi) {
              return [lambda * cos(phi), phi];
            }
            sinusoidalRaw.invert = function(x, y) {
              return [x / cos(y), y];
            };
            var sinusoidal = function() {
              return d3Geo.geoProjection(sinusoidalRaw).scale(152.63);
            };
            function bonneRaw(phi02) {
              if (!phi02)
                return sinusoidalRaw;
              var cotPhi0 = 1 / tan(phi02);
              function forward(lambda, phi) {
                var rho = cotPhi0 + phi02 - phi, e = rho ? lambda * cos(phi) / rho : rho;
                return [rho * sin(e), cotPhi0 - rho * cos(e)];
              }
              forward.invert = function(x, y) {
                var rho = sqrt(x * x + (y = cotPhi0 - y) * y), phi = cotPhi0 + phi02 - rho;
                return [rho / cos(phi) * atan2(x, y), phi];
              };
              return forward;
            }
            var bonne = function() {
              return parallel1(bonneRaw).scale(123.082).center([0, 26.1441]).parallel(45);
            };
            function bottomleyRaw(sinPsi) {
              function forward(lambda, phi) {
                var rho = halfPi - phi, eta = rho ? lambda * sinPsi * sin(rho) / rho : rho;
                return [rho * sin(eta) / sinPsi, halfPi - rho * cos(eta)];
              }
              forward.invert = function(x, y) {
                var x12 = x * sinPsi, y12 = halfPi - y, rho = sqrt(x12 * x12 + y12 * y12), eta = atan2(x12, y12);
                return [(rho ? rho / sin(rho) : 1) * eta / sinPsi, halfPi - rho];
              };
              return forward;
            }
            var bottomley = function() {
              var sinPsi = 0.5, m = d3Geo.geoProjectionMutator(bottomleyRaw), p = m(sinPsi);
              p.fraction = function(_) {
                return arguments.length ? m(sinPsi = +_) : sinPsi;
              };
              return p.scale(158.837);
            };
            var bromleyRaw = mollweideBromleyRaw(1, 4 / pi, pi);
            var bromley = function() {
              return d3Geo.geoProjection(bromleyRaw).scale(152.63);
            };
            function distance(dPhi, c1, s1, c2, s2, dLambda) {
              var cosdLambda = cos(dLambda), r;
              if (abs(dPhi) > 1 || abs(dLambda) > 1) {
                r = acos(s1 * s2 + c1 * c2 * cosdLambda);
              } else {
                var sindPhi = sin(dPhi / 2), sindLambda = sin(dLambda / 2);
                r = 2 * asin(sqrt(sindPhi * sindPhi + c1 * c2 * sindLambda * sindLambda));
              }
              return abs(r) > epsilon ? [r, atan2(c2 * sin(dLambda), c1 * s2 - s1 * c2 * cosdLambda)] : [0, 0];
            }
            function angle(b, c, a) {
              return acos((b * b + c * c - a * a) / (2 * b * c));
            }
            function longitude(lambda) {
              return lambda - 2 * pi * floor((lambda + pi) / (2 * pi));
            }
            function chamberlinRaw(p0, p1, p2) {
              var points2 = [
                [p0[0], p0[1], sin(p0[1]), cos(p0[1])],
                [p1[0], p1[1], sin(p1[1]), cos(p1[1])],
                [p2[0], p2[1], sin(p2[1]), cos(p2[1])]
              ];
              for (var a = points2[2], b, i = 0; i < 3; ++i, a = b) {
                b = points2[i];
                a.v = distance(b[1] - a[1], a[3], a[2], b[3], b[2], b[0] - a[0]);
                a.point = [0, 0];
              }
              var beta0 = angle(points2[0].v[0], points2[2].v[0], points2[1].v[0]), beta1 = angle(points2[0].v[0], points2[1].v[0], points2[2].v[0]), beta2 = pi - beta0;
              points2[2].point[1] = 0;
              points2[0].point[0] = -(points2[1].point[0] = points2[0].v[0] / 2);
              var mean = [
                points2[2].point[0] = points2[0].point[0] + points2[2].v[0] * cos(beta0),
                2 * (points2[0].point[1] = points2[1].point[1] = points2[2].v[0] * sin(beta0))
              ];
              function forward(lambda, phi) {
                var sinPhi = sin(phi), cosPhi = cos(phi), v = new Array(3), i2;
                for (i2 = 0; i2 < 3; ++i2) {
                  var p = points2[i2];
                  v[i2] = distance(phi - p[1], p[3], p[2], cosPhi, sinPhi, lambda - p[0]);
                  if (!v[i2][0])
                    return p.point;
                  v[i2][1] = longitude(v[i2][1] - p.v[1]);
                }
                var point = mean.slice();
                for (i2 = 0; i2 < 3; ++i2) {
                  var j = i2 == 2 ? 0 : i2 + 1;
                  var a2 = angle(points2[i2].v[0], v[i2][0], v[j][0]);
                  if (v[i2][1] < 0)
                    a2 = -a2;
                  if (!i2) {
                    point[0] += v[i2][0] * cos(a2);
                    point[1] -= v[i2][0] * sin(a2);
                  } else if (i2 == 1) {
                    a2 = beta1 - a2;
                    point[0] -= v[i2][0] * cos(a2);
                    point[1] -= v[i2][0] * sin(a2);
                  } else {
                    a2 = beta2 - a2;
                    point[0] += v[i2][0] * cos(a2);
                    point[1] += v[i2][0] * sin(a2);
                  }
                }
                point[0] /= 3, point[1] /= 3;
                return point;
              }
              return forward;
            }
            function pointRadians(p) {
              return p[0] *= radians, p[1] *= radians, p;
            }
            function chamberlinAfrica() {
              return chamberlin([0, 22], [45, 22], [22.5, -22]).scale(380).center([22.5, 2]);
            }
            function chamberlin(p0, p1, p2) {
              var c = d3Geo.geoCentroid({ type: "MultiPoint", coordinates: [p0, p1, p2] }), R = [-c[0], -c[1]], r = d3Geo.geoRotation(R), p = d3Geo.geoProjection(chamberlinRaw(pointRadians(r(p0)), pointRadians(r(p1)), pointRadians(r(p2)))).rotate(R), center = p.center;
              delete p.rotate;
              p.center = function(_) {
                return arguments.length ? center(r(_)) : r.invert(center());
              };
              return p.clipAngle(90);
            }
            function collignonRaw(lambda, phi) {
              var alpha = sqrt(1 - sin(phi));
              return [2 / sqrtPi * lambda * alpha, sqrtPi * (1 - alpha)];
            }
            collignonRaw.invert = function(x, y) {
              var lambda = (lambda = y / sqrtPi - 1) * lambda;
              return [lambda > 0 ? x * sqrt(pi / lambda) / 2 : 0, asin(1 - lambda)];
            };
            var collignon = function() {
              return d3Geo.geoProjection(collignonRaw).scale(95.6464).center([0, 30]);
            };
            function craigRaw(phi02) {
              var tanPhi0 = tan(phi02);
              function forward(lambda, phi) {
                return [lambda, (lambda ? lambda / sin(lambda) : 1) * (sin(phi) * cos(lambda) - tanPhi0 * cos(phi))];
              }
              forward.invert = tanPhi0 ? function(x, y) {
                if (x)
                  y *= sin(x) / x;
                var cosLambda = cos(x);
                return [x, 2 * atan2(sqrt(cosLambda * cosLambda + tanPhi0 * tanPhi0 - y * y) - cosLambda, tanPhi0 - y)];
              } : function(x, y) {
                return [x, asin(x ? y * tan(x) / x : y)];
              };
              return forward;
            }
            var craig = function() {
              return parallel1(craigRaw).scale(249.828).clipAngle(90);
            };
            var sqrt3 = sqrt(3);
            function crasterRaw(lambda, phi) {
              return [sqrt3 * lambda * (2 * cos(2 * phi / 3) - 1) / sqrtPi, sqrt3 * sqrtPi * sin(phi / 3)];
            }
            crasterRaw.invert = function(x, y) {
              var phi = 3 * asin(y / (sqrt3 * sqrtPi));
              return [sqrtPi * x / (sqrt3 * (2 * cos(2 * phi / 3) - 1)), phi];
            };
            var craster = function() {
              return d3Geo.geoProjection(crasterRaw).scale(156.19);
            };
            function cylindricalEqualAreaRaw(phi02) {
              var cosPhi0 = cos(phi02);
              function forward(lambda, phi) {
                return [lambda * cosPhi0, sin(phi) / cosPhi0];
              }
              forward.invert = function(x, y) {
                return [x / cosPhi0, asin(y * cosPhi0)];
              };
              return forward;
            }
            var cylindricalEqualArea = function() {
              return parallel1(cylindricalEqualAreaRaw).parallel(38.58).scale(195.044);
            };
            function cylindricalStereographicRaw(phi02) {
              var cosPhi0 = cos(phi02);
              function forward(lambda, phi) {
                return [lambda * cosPhi0, (1 + cosPhi0) * tan(phi / 2)];
              }
              forward.invert = function(x, y) {
                return [x / cosPhi0, atan(y / (1 + cosPhi0)) * 2];
              };
              return forward;
            }
            var cylindricalStereographic = function() {
              return parallel1(cylindricalStereographicRaw).scale(124.75);
            };
            function eckert1Raw(lambda, phi) {
              var alpha = sqrt(8 / (3 * pi));
              return [
                alpha * lambda * (1 - abs(phi) / pi),
                alpha * phi
              ];
            }
            eckert1Raw.invert = function(x, y) {
              var alpha = sqrt(8 / (3 * pi)), phi = y / alpha;
              return [
                x / (alpha * (1 - abs(phi) / pi)),
                phi
              ];
            };
            var eckert1 = function() {
              return d3Geo.geoProjection(eckert1Raw).scale(165.664);
            };
            function eckert2Raw(lambda, phi) {
              var alpha = sqrt(4 - 3 * sin(abs(phi)));
              return [
                2 / sqrt(6 * pi) * lambda * alpha,
                sign(phi) * sqrt(2 * pi / 3) * (2 - alpha)
              ];
            }
            eckert2Raw.invert = function(x, y) {
              var alpha = 2 - abs(y) / sqrt(2 * pi / 3);
              return [
                x * sqrt(6 * pi) / (2 * alpha),
                sign(y) * asin((4 - alpha * alpha) / 3)
              ];
            };
            var eckert2 = function() {
              return d3Geo.geoProjection(eckert2Raw).scale(165.664);
            };
            function eckert3Raw(lambda, phi) {
              var k2 = sqrt(pi * (4 + pi));
              return [
                2 / k2 * lambda * (1 + sqrt(1 - 4 * phi * phi / (pi * pi))),
                4 / k2 * phi
              ];
            }
            eckert3Raw.invert = function(x, y) {
              var k2 = sqrt(pi * (4 + pi)) / 2;
              return [
                x * k2 / (1 + sqrt(1 - y * y * (4 + pi) / (4 * pi))),
                y * k2 / 2
              ];
            };
            var eckert3 = function() {
              return d3Geo.geoProjection(eckert3Raw).scale(180.739);
            };
            function eckert4Raw(lambda, phi) {
              var k2 = (2 + halfPi) * sin(phi);
              phi /= 2;
              for (var i = 0, delta = Infinity; i < 10 && abs(delta) > epsilon; i++) {
                var cosPhi = cos(phi);
                phi -= delta = (phi + sin(phi) * (cosPhi + 2) - k2) / (2 * cosPhi * (1 + cosPhi));
              }
              return [
                2 / sqrt(pi * (4 + pi)) * lambda * (1 + cos(phi)),
                2 * sqrt(pi / (4 + pi)) * sin(phi)
              ];
            }
            eckert4Raw.invert = function(x, y) {
              var A2 = y * sqrt((4 + pi) / pi) / 2, k2 = asin(A2), c = cos(k2);
              return [
                x / (2 / sqrt(pi * (4 + pi)) * (1 + c)),
                asin((k2 + A2 * (c + 2)) / (2 + halfPi))
              ];
            };
            var eckert4 = function() {
              return d3Geo.geoProjection(eckert4Raw).scale(180.739);
            };
            function eckert5Raw(lambda, phi) {
              return [
                lambda * (1 + cos(phi)) / sqrt(2 + pi),
                2 * phi / sqrt(2 + pi)
              ];
            }
            eckert5Raw.invert = function(x, y) {
              var k2 = sqrt(2 + pi), phi = y * k2 / 2;
              return [
                k2 * x / (1 + cos(phi)),
                phi
              ];
            };
            var eckert5 = function() {
              return d3Geo.geoProjection(eckert5Raw).scale(173.044);
            };
            function eckert6Raw(lambda, phi) {
              var k2 = (1 + halfPi) * sin(phi);
              for (var i = 0, delta = Infinity; i < 10 && abs(delta) > epsilon; i++) {
                phi -= delta = (phi + sin(phi) - k2) / (1 + cos(phi));
              }
              k2 = sqrt(2 + pi);
              return [
                lambda * (1 + cos(phi)) / k2,
                2 * phi / k2
              ];
            }
            eckert6Raw.invert = function(x, y) {
              var j = 1 + halfPi, k2 = sqrt(j / 2);
              return [
                x * 2 * k2 / (1 + cos(y *= k2)),
                asin((y + sin(y)) / j)
              ];
            };
            var eckert6 = function() {
              return d3Geo.geoProjection(eckert6Raw).scale(173.044);
            };
            var eisenlohrK = 3 + 2 * sqrt2;
            function eisenlohrRaw(lambda, phi) {
              var s0 = sin(lambda /= 2), c0 = cos(lambda), k2 = sqrt(cos(phi)), c1 = cos(phi /= 2), t = sin(phi) / (c1 + sqrt2 * c0 * k2), c = sqrt(2 / (1 + t * t)), v = sqrt((sqrt2 * c1 + (c0 + s0) * k2) / (sqrt2 * c1 + (c0 - s0) * k2));
              return [
                eisenlohrK * (c * (v - 1 / v) - 2 * log(v)),
                eisenlohrK * (c * t * (v + 1 / v) - 2 * atan(t))
              ];
            }
            eisenlohrRaw.invert = function(x, y) {
              if (!(p = augustRaw.invert(x / 1.2, y * 1.065)))
                return null;
              var lambda = p[0], phi = p[1], i = 20, p;
              x /= eisenlohrK, y /= eisenlohrK;
              do {
                var _0 = lambda / 2, _1 = phi / 2, s0 = sin(_0), c0 = cos(_0), s1 = sin(_1), c1 = cos(_1), cos1 = cos(phi), k2 = sqrt(cos1), t = s1 / (c1 + sqrt2 * c0 * k2), t2 = t * t, c = sqrt(2 / (1 + t2)), v0 = sqrt2 * c1 + (c0 + s0) * k2, v1 = sqrt2 * c1 + (c0 - s0) * k2, v2 = v0 / v1, v = sqrt(v2), vm1v = v - 1 / v, vp1v = v + 1 / v, fx = c * vm1v - 2 * log(v) - x, fy = c * t * vp1v - 2 * atan(t) - y, deltatDeltaLambda = s1 && sqrt1_2 * k2 * s0 * t2 / s1, deltatDeltaPhi = (sqrt2 * c0 * c1 + k2) / (2 * (c1 + sqrt2 * c0 * k2) * (c1 + sqrt2 * c0 * k2) * k2), deltacDeltat = -0.5 * t * c * c * c, deltacDeltaLambda = deltacDeltat * deltatDeltaLambda, deltacDeltaPhi = deltacDeltat * deltatDeltaPhi, A2 = (A2 = 2 * c1 + sqrt2 * k2 * (c0 - s0)) * A2 * v, deltavDeltaLambda = (sqrt2 * c0 * c1 * k2 + cos1) / A2, deltavDeltaPhi = -(sqrt2 * s0 * s1) / (k2 * A2), deltaxDeltaLambda = vm1v * deltacDeltaLambda - 2 * deltavDeltaLambda / v + c * (deltavDeltaLambda + deltavDeltaLambda / v2), deltaxDeltaPhi = vm1v * deltacDeltaPhi - 2 * deltavDeltaPhi / v + c * (deltavDeltaPhi + deltavDeltaPhi / v2), deltayDeltaLambda = t * vp1v * deltacDeltaLambda - 2 * deltatDeltaLambda / (1 + t2) + c * vp1v * deltatDeltaLambda + c * t * (deltavDeltaLambda - deltavDeltaLambda / v2), deltayDeltaPhi = t * vp1v * deltacDeltaPhi - 2 * deltatDeltaPhi / (1 + t2) + c * vp1v * deltatDeltaPhi + c * t * (deltavDeltaPhi - deltavDeltaPhi / v2), denominator = deltaxDeltaPhi * deltayDeltaLambda - deltayDeltaPhi * deltaxDeltaLambda;
                if (!denominator)
                  break;
                var deltaLambda = (fy * deltaxDeltaPhi - fx * deltayDeltaPhi) / denominator, deltaPhi = (fx * deltayDeltaLambda - fy * deltaxDeltaLambda) / denominator;
                lambda -= deltaLambda;
                phi = max(-halfPi, min(halfPi, phi - deltaPhi));
              } while ((abs(deltaLambda) > epsilon || abs(deltaPhi) > epsilon) && --i > 0);
              return abs(abs(phi) - halfPi) < epsilon ? [0, phi] : i && [lambda, phi];
            };
            var eisenlohr = function() {
              return d3Geo.geoProjection(eisenlohrRaw).scale(62.5271);
            };
            var faheyK = cos(35 * radians);
            function faheyRaw(lambda, phi) {
              var t = tan(phi / 2);
              return [lambda * faheyK * sqrt(1 - t * t), (1 + faheyK) * t];
            }
            faheyRaw.invert = function(x, y) {
              var t = y / (1 + faheyK);
              return [x && x / (faheyK * sqrt(1 - t * t)), 2 * atan(t)];
            };
            var fahey = function() {
              return d3Geo.geoProjection(faheyRaw).scale(137.152);
            };
            function foucautRaw(lambda, phi) {
              var k2 = phi / 2, cosk = cos(k2);
              return [2 * lambda / sqrtPi * cos(phi) * cosk * cosk, sqrtPi * tan(k2)];
            }
            foucautRaw.invert = function(x, y) {
              var k2 = atan(y / sqrtPi), cosk = cos(k2), phi = 2 * k2;
              return [x * sqrtPi / 2 / (cos(phi) * cosk * cosk), phi];
            };
            var foucaut = function() {
              return d3Geo.geoProjection(foucautRaw).scale(135.264);
            };
            function gilbertForward(point) {
              return [point[0] / 2, asin(tan(point[1] / 2 * radians)) * degrees];
            }
            function gilbertInvert(point) {
              return [point[0] * 2, 2 * atan(sin(point[1] * radians)) * degrees];
            }
            var gilbert = function(projectionType) {
              if (projectionType == null)
                projectionType = d3Geo.geoOrthographic;
              var projection = projectionType(), equirectangular = d3Geo.geoEquirectangular().scale(degrees).precision(0).clipAngle(null).translate([0, 0]);
              function gilbert2(point) {
                return projection(gilbertForward(point));
              }
              if (projection.invert)
                gilbert2.invert = function(point) {
                  return gilbertInvert(projection.invert(point));
                };
              gilbert2.stream = function(stream) {
                var s1 = projection.stream(stream), s0 = equirectangular.stream({
                  point: function(lambda, phi) {
                    s1.point(lambda / 2, asin(tan(-phi / 2 * radians)) * degrees);
                  },
                  lineStart: function() {
                    s1.lineStart();
                  },
                  lineEnd: function() {
                    s1.lineEnd();
                  },
                  polygonStart: function() {
                    s1.polygonStart();
                  },
                  polygonEnd: function() {
                    s1.polygonEnd();
                  }
                });
                s0.sphere = s1.sphere;
                return s0;
              };
              function property(name) {
                gilbert2[name] = function(_) {
                  return arguments.length ? (projection[name](_), gilbert2) : projection[name]();
                };
              }
              gilbert2.rotate = function(_) {
                return arguments.length ? (equirectangular.rotate(_), gilbert2) : equirectangular.rotate();
              };
              gilbert2.center = function(_) {
                return arguments.length ? (projection.center(gilbertForward(_)), gilbert2) : gilbertInvert(projection.center());
              };
              property("clipAngle");
              property("clipExtent");
              property("scale");
              property("translate");
              property("precision");
              return gilbert2.scale(249.5);
            };
            function gingeryRaw(rho, n) {
              var k2 = 2 * pi / n, rho2 = rho * rho;
              function forward(lambda, phi) {
                var p = d3Geo.geoAzimuthalEquidistantRaw(lambda, phi), x = p[0], y = p[1], r2 = x * x + y * y;
                if (r2 > rho2) {
                  var r = sqrt(r2), theta = atan2(y, x), theta0 = k2 * round(theta / k2), alpha = theta - theta0, rhoCosAlpha = rho * cos(alpha), k_ = (rho * sin(alpha) - alpha * sin(rhoCosAlpha)) / (halfPi - rhoCosAlpha), s_ = gingeryLength(alpha, k_), e = (pi - rho) / gingeryIntegrate(s_, rhoCosAlpha, pi);
                  x = r;
                  var i = 50, delta;
                  do {
                    x -= delta = (rho + gingeryIntegrate(s_, rhoCosAlpha, x) * e - r) / (s_(x) * e);
                  } while (abs(delta) > epsilon && --i > 0);
                  y = alpha * sin(x);
                  if (x < halfPi)
                    y -= k_ * (x - halfPi);
                  var s = sin(theta0), c = cos(theta0);
                  p[0] = x * c - y * s;
                  p[1] = x * s + y * c;
                }
                return p;
              }
              forward.invert = function(x, y) {
                var r2 = x * x + y * y;
                if (r2 > rho2) {
                  var r = sqrt(r2), theta = atan2(y, x), theta0 = k2 * round(theta / k2), dTheta = theta - theta0;
                  x = r * cos(dTheta);
                  y = r * sin(dTheta);
                  var x_halfPi = x - halfPi, sinx = sin(x), alpha = y / sinx, delta = x < halfPi ? Infinity : 0, i = 10;
                  while (true) {
                    var rhosinAlpha = rho * sin(alpha), rhoCosAlpha = rho * cos(alpha), sinRhoCosAlpha = sin(rhoCosAlpha), halfPi_RhoCosAlpha = halfPi - rhoCosAlpha, k_ = (rhosinAlpha - alpha * sinRhoCosAlpha) / halfPi_RhoCosAlpha, s_ = gingeryLength(alpha, k_);
                    if (abs(delta) < epsilon2 || !--i)
                      break;
                    alpha -= delta = (alpha * sinx - k_ * x_halfPi - y) / (sinx - x_halfPi * 2 * (halfPi_RhoCosAlpha * (rhoCosAlpha + alpha * rhosinAlpha * cos(rhoCosAlpha) - sinRhoCosAlpha) - rhosinAlpha * (rhosinAlpha - alpha * sinRhoCosAlpha)) / (halfPi_RhoCosAlpha * halfPi_RhoCosAlpha));
                  }
                  r = rho + gingeryIntegrate(s_, rhoCosAlpha, x) * (pi - rho) / gingeryIntegrate(s_, rhoCosAlpha, pi);
                  theta = theta0 + alpha;
                  x = r * cos(theta);
                  y = r * sin(theta);
                }
                return d3Geo.geoAzimuthalEquidistantRaw.invert(x, y);
              };
              return forward;
            }
            function gingeryLength(alpha, k2) {
              return function(x) {
                var y_ = alpha * cos(x);
                if (x < halfPi)
                  y_ -= k2;
                return sqrt(1 + y_ * y_);
              };
            }
            function gingeryIntegrate(f, a, b) {
              var n = 50, h = (b - a) / n, s = f(a) + f(b);
              for (var i = 1, x = a; i < n; ++i)
                s += 2 * f(x += h);
              return s * 0.5 * h;
            }
            var gingery = function() {
              var n = 6, rho = 30 * radians, cRho = cos(rho), sRho = sin(rho), m = d3Geo.geoProjectionMutator(gingeryRaw), p = m(rho, n), stream_ = p.stream, epsilon$$1 = 0.01, cr = -cos(epsilon$$1 * radians), sr = sin(epsilon$$1 * radians);
              p.radius = function(_) {
                if (!arguments.length)
                  return rho * degrees;
                cRho = cos(rho = _ * radians);
                sRho = sin(rho);
                return m(rho, n);
              };
              p.lobes = function(_) {
                if (!arguments.length)
                  return n;
                return m(rho, n = +_);
              };
              p.stream = function(stream) {
                var rotate = p.rotate(), rotateStream = stream_(stream), sphereStream = (p.rotate([0, 0]), stream_(stream));
                p.rotate(rotate);
                rotateStream.sphere = function() {
                  sphereStream.polygonStart(), sphereStream.lineStart();
                  for (var i = 0, delta = 2 * pi / n, phi = 0; i < n; ++i, phi -= delta) {
                    sphereStream.point(atan2(sr * cos(phi), cr) * degrees, asin(sr * sin(phi)) * degrees);
                    sphereStream.point(atan2(sRho * cos(phi - delta / 2), cRho) * degrees, asin(sRho * sin(phi - delta / 2)) * degrees);
                  }
                  sphereStream.lineEnd(), sphereStream.polygonEnd();
                };
                return rotateStream;
              };
              return p.rotate([90, -40]).scale(91.7095).clipAngle(180 - 1e-3);
            };
            var ginzburgPolyconicRaw = function(a, b, c, d, e, f, g, h) {
              if (arguments.length < 8)
                h = 0;
              function forward(lambda, phi) {
                if (!phi)
                  return [a * lambda / pi, 0];
                var phi2 = phi * phi, xB = a + phi2 * (b + phi2 * (c + phi2 * d)), yB = phi * (e - 1 + phi2 * (f - h + phi2 * g)), m = (xB * xB + yB * yB) / (2 * yB), alpha = lambda * asin(xB / m) / pi;
                return [m * sin(alpha), phi * (1 + phi2 * h) + m * (1 - cos(alpha))];
              }
              forward.invert = function(x, y) {
                var lambda = pi * x / a, phi = y, deltaLambda, deltaPhi, i = 50;
                do {
                  var phi2 = phi * phi, xB = a + phi2 * (b + phi2 * (c + phi2 * d)), yB = phi * (e - 1 + phi2 * (f - h + phi2 * g)), p = xB * xB + yB * yB, q = 2 * yB, m = p / q, m2 = m * m, dAlphadLambda = asin(xB / m) / pi, alpha = lambda * dAlphadLambda, xB2 = xB * xB, dxBdPhi = (2 * b + phi2 * (4 * c + phi2 * 6 * d)) * phi, dyBdPhi = e + phi2 * (3 * f + phi2 * 5 * g), dpdPhi = 2 * (xB * dxBdPhi + yB * (dyBdPhi - 1)), dqdPhi = 2 * (dyBdPhi - 1), dmdPhi = (dpdPhi * q - p * dqdPhi) / (q * q), cosAlpha = cos(alpha), sinAlpha = sin(alpha), mcosAlpha = m * cosAlpha, msinAlpha = m * sinAlpha, dAlphadPhi = lambda / pi * (1 / sqrt(1 - xB2 / m2)) * (dxBdPhi * m - xB * dmdPhi) / m2, fx = msinAlpha - x, fy = phi * (1 + phi2 * h) + m - mcosAlpha - y, deltaxDeltaPhi = dmdPhi * sinAlpha + mcosAlpha * dAlphadPhi, deltaxDeltaLambda = mcosAlpha * dAlphadLambda, deltayDeltaPhi = 1 + dmdPhi - (dmdPhi * cosAlpha - msinAlpha * dAlphadPhi), deltayDeltaLambda = msinAlpha * dAlphadLambda, denominator = deltaxDeltaPhi * deltayDeltaLambda - deltayDeltaPhi * deltaxDeltaLambda;
                  if (!denominator)
                    break;
                  lambda -= deltaLambda = (fy * deltaxDeltaPhi - fx * deltayDeltaPhi) / denominator;
                  phi -= deltaPhi = (fx * deltayDeltaLambda - fy * deltaxDeltaLambda) / denominator;
                } while ((abs(deltaLambda) > epsilon || abs(deltaPhi) > epsilon) && --i > 0);
                return [lambda, phi];
              };
              return forward;
            };
            var ginzburg4Raw = ginzburgPolyconicRaw(2.8284, -1.6988, 0.75432, -0.18071, 1.76003, -0.38914, 0.042555);
            var ginzburg4 = function() {
              return d3Geo.geoProjection(ginzburg4Raw).scale(149.995);
            };
            var ginzburg5Raw = ginzburgPolyconicRaw(2.583819, -0.835827, 0.170354, -0.038094, 1.543313, -0.411435, 0.082742);
            var ginzburg5 = function() {
              return d3Geo.geoProjection(ginzburg5Raw).scale(153.93);
            };
            var ginzburg6Raw = ginzburgPolyconicRaw(5 / 6 * pi, -0.62636, -0.0344, 0, 1.3493, -0.05524, 0, 0.045);
            var ginzburg6 = function() {
              return d3Geo.geoProjection(ginzburg6Raw).scale(130.945);
            };
            function ginzburg8Raw(lambda, phi) {
              var lambda2 = lambda * lambda, phi2 = phi * phi;
              return [
                lambda * (1 - 0.162388 * phi2) * (0.87 - 952426e-9 * lambda2 * lambda2),
                phi * (1 + phi2 / 12)
              ];
            }
            ginzburg8Raw.invert = function(x, y) {
              var lambda = x, phi = y, i = 50, delta;
              do {
                var phi2 = phi * phi;
                phi -= delta = (phi * (1 + phi2 / 12) - y) / (1 + phi2 / 4);
              } while (abs(delta) > epsilon && --i > 0);
              i = 50;
              x /= 1 - 0.162388 * phi2;
              do {
                var lambda4 = (lambda4 = lambda * lambda) * lambda4;
                lambda -= delta = (lambda * (0.87 - 952426e-9 * lambda4) - x) / (0.87 - 476213e-8 * lambda4);
              } while (abs(delta) > epsilon && --i > 0);
              return [lambda, phi];
            };
            var ginzburg8 = function() {
              return d3Geo.geoProjection(ginzburg8Raw).scale(131.747);
            };
            var ginzburg9Raw = ginzburgPolyconicRaw(2.6516, -0.76534, 0.19123, -0.047094, 1.36289, -0.13965, 0.031762);
            var ginzburg9 = function() {
              return d3Geo.geoProjection(ginzburg9Raw).scale(131.087);
            };
            var squareRaw = function(project) {
              var dx = project(halfPi, 0)[0] - project(-halfPi, 0)[0];
              function projectSquare(lambda, phi) {
                var s = lambda > 0 ? -0.5 : 0.5, point = project(lambda + s * pi, phi);
                point[0] -= s * dx;
                return point;
              }
              if (project.invert)
                projectSquare.invert = function(x, y) {
                  var s = x > 0 ? -0.5 : 0.5, location = project.invert(x + s * dx, y), lambda = location[0] - s * pi;
                  if (lambda < -pi)
                    lambda += 2 * pi;
                  else if (lambda > pi)
                    lambda -= 2 * pi;
                  location[0] = lambda;
                  return location;
                };
              return projectSquare;
            };
            function gringortenRaw(lambda, phi) {
              var sLambda = sign(lambda), sPhi = sign(phi), cosPhi = cos(phi), x = cos(lambda) * cosPhi, y = sin(lambda) * cosPhi, z = sin(sPhi * phi);
              lambda = abs(atan2(y, z));
              phi = asin(x);
              if (abs(lambda - halfPi) > epsilon)
                lambda %= halfPi;
              var point = gringortenHexadecant(lambda > pi / 4 ? halfPi - lambda : lambda, phi);
              if (lambda > pi / 4)
                z = point[0], point[0] = -point[1], point[1] = -z;
              return point[0] *= sLambda, point[1] *= -sPhi, point;
            }
            gringortenRaw.invert = function(x, y) {
              if (abs(x) > 1)
                x = sign(x) * 2 - x;
              if (abs(y) > 1)
                y = sign(y) * 2 - y;
              var sx = sign(x), sy = sign(y), x02 = -sx * x, y02 = -sy * y, t = y02 / x02 < 1, p = gringortenHexadecantInvert(t ? y02 : x02, t ? x02 : y02), lambda = p[0], phi = p[1], cosPhi = cos(phi);
              if (t)
                lambda = -halfPi - lambda;
              return [sx * (atan2(sin(lambda) * cosPhi, -sin(phi)) + pi), sy * asin(cos(lambda) * cosPhi)];
            };
            function gringortenHexadecant(lambda, phi) {
              if (phi === halfPi)
                return [0, 0];
              var sinPhi = sin(phi), r = sinPhi * sinPhi, r2 = r * r, j = 1 + r2, k2 = 1 + 3 * r2, q = 1 - r2, z = asin(1 / sqrt(j)), v = q + r * j * z, p2 = (1 - sinPhi) / v, p = sqrt(p2), a2 = p2 * j, a = sqrt(a2), h = p * q, x, i;
              if (lambda === 0)
                return [0, -(h + r * a)];
              var cosPhi = cos(phi), secPhi = 1 / cosPhi, drdPhi = 2 * sinPhi * cosPhi, dvdPhi = (-3 * r + z * k2) * drdPhi, dp2dPhi = (-v * cosPhi - (1 - sinPhi) * dvdPhi) / (v * v), dpdPhi = 0.5 * dp2dPhi / p, dhdPhi = q * dpdPhi - 2 * r * p * drdPhi, dra2dPhi = r * j * dp2dPhi + p2 * k2 * drdPhi, mu = -secPhi * drdPhi, nu = -secPhi * dra2dPhi, zeta = -2 * secPhi * dhdPhi, lambda1 = 4 * lambda / pi, delta;
              if (lambda > 0.222 * pi || phi < pi / 4 && lambda > 0.175 * pi) {
                x = (h + r * sqrt(a2 * (1 + r2) - h * h)) / (1 + r2);
                if (lambda > pi / 4)
                  return [x, x];
                var x12 = x, x02 = 0.5 * x;
                x = 0.5 * (x02 + x12), i = 50;
                do {
                  var g = sqrt(a2 - x * x), f = x * (zeta + mu * g) + nu * asin(x / a) - lambda1;
                  if (!f)
                    break;
                  if (f < 0)
                    x02 = x;
                  else
                    x12 = x;
                  x = 0.5 * (x02 + x12);
                } while (abs(x12 - x02) > epsilon && --i > 0);
              } else {
                x = epsilon, i = 25;
                do {
                  var x2 = x * x, g2 = sqrt(a2 - x2), zetaMug = zeta + mu * g2, f2 = x * zetaMug + nu * asin(x / a) - lambda1, df = zetaMug + (nu - mu * x2) / g2;
                  x -= delta = g2 ? f2 / df : 0;
                } while (abs(delta) > epsilon && --i > 0);
              }
              return [x, -h - r * sqrt(a2 - x * x)];
            }
            function gringortenHexadecantInvert(x, y) {
              var x02 = 0, x12 = 1, r = 0.5, i = 50;
              while (true) {
                var r2 = r * r, sinPhi = sqrt(r), z = asin(1 / sqrt(1 + r2)), v = 1 - r2 + r * (1 + r2) * z, p2 = (1 - sinPhi) / v, p = sqrt(p2), a2 = p2 * (1 + r2), h = p * (1 - r2), g2 = a2 - x * x, g = sqrt(g2), y02 = y + h + r * g;
                if (abs(x12 - x02) < epsilon2 || --i === 0 || y02 === 0)
                  break;
                if (y02 > 0)
                  x02 = r;
                else
                  x12 = r;
                r = 0.5 * (x02 + x12);
              }
              if (!i)
                return null;
              var phi = asin(sinPhi), cosPhi = cos(phi), secPhi = 1 / cosPhi, drdPhi = 2 * sinPhi * cosPhi, dvdPhi = (-3 * r + z * (1 + 3 * r2)) * drdPhi, dp2dPhi = (-v * cosPhi - (1 - sinPhi) * dvdPhi) / (v * v), dpdPhi = 0.5 * dp2dPhi / p, dhdPhi = (1 - r2) * dpdPhi - 2 * r * p * drdPhi, zeta = -2 * secPhi * dhdPhi, mu = -secPhi * drdPhi, nu = -secPhi * (r * (1 + r2) * dp2dPhi + p2 * (1 + 3 * r2) * drdPhi);
              return [pi / 4 * (x * (zeta + mu * g) + nu * asin(x / sqrt(a2))), phi];
            }
            var gringorten = function() {
              return d3Geo.geoProjection(squareRaw(gringortenRaw)).scale(239.75);
            };
            function ellipticJi(u, v, m) {
              var a, b, c;
              if (!u) {
                b = ellipticJ(v, 1 - m);
                return [
                  [0, b[0] / b[1]],
                  [1 / b[1], 0],
                  [b[2] / b[1], 0]
                ];
              }
              a = ellipticJ(u, m);
              if (!v)
                return [[a[0], 0], [a[1], 0], [a[2], 0]];
              b = ellipticJ(v, 1 - m);
              c = b[1] * b[1] + m * a[0] * a[0] * b[0] * b[0];
              return [
                [a[0] * b[2] / c, a[1] * a[2] * b[0] * b[1] / c],
                [a[1] * b[1] / c, -a[0] * a[2] * b[0] * b[2] / c],
                [a[2] * b[1] * b[2] / c, -m * a[0] * a[1] * b[0] / c]
              ];
            }
            function ellipticJ(u, m) {
              var ai, b, phi, t, twon;
              if (m < epsilon) {
                t = sin(u);
                b = cos(u);
                ai = m * (u - t * b) / 4;
                return [
                  t - ai * b,
                  b + ai * t,
                  1 - m * t * t / 2,
                  u - ai
                ];
              }
              if (m >= 1 - epsilon) {
                ai = (1 - m) / 4;
                b = cosh(u);
                t = tanh(u);
                phi = 1 / b;
                twon = b * sinh(u);
                return [
                  t + ai * (twon - u) / (b * b),
                  phi - ai * t * phi * (twon - u),
                  phi + ai * t * phi * (twon + u),
                  2 * atan(exp(u)) - halfPi + ai * (twon - u) / b
                ];
              }
              var a = [1, 0, 0, 0, 0, 0, 0, 0, 0], c = [sqrt(m), 0, 0, 0, 0, 0, 0, 0, 0], i = 0;
              b = sqrt(1 - m);
              twon = 1;
              while (abs(c[i] / a[i]) > epsilon && i < 8) {
                ai = a[i++];
                c[i] = (ai - b) / 2;
                a[i] = (ai + b) / 2;
                b = sqrt(ai * b);
                twon *= 2;
              }
              phi = twon * a[i] * u;
              do {
                t = c[i] * sin(b = phi) / a[i];
                phi = (asin(t) + phi) / 2;
              } while (--i);
              return [sin(phi), t = cos(phi), t / cos(phi - b), phi];
            }
            function ellipticFi(phi, psi, m) {
              var r = abs(phi), i = abs(psi), sinhPsi = sinh(i);
              if (r) {
                var cscPhi = 1 / sin(r), cotPhi2 = 1 / (tan(r) * tan(r)), b = -(cotPhi2 + m * (sinhPsi * sinhPsi * cscPhi * cscPhi) - 1 + m), c = (m - 1) * cotPhi2, cotLambda2 = (-b + sqrt(b * b - 4 * c)) / 2;
                return [
                  ellipticF(atan(1 / sqrt(cotLambda2)), m) * sign(phi),
                  ellipticF(atan(sqrt((cotLambda2 / cotPhi2 - 1) / m)), 1 - m) * sign(psi)
                ];
              }
              return [
                0,
                ellipticF(atan(sinhPsi), 1 - m) * sign(psi)
              ];
            }
            function ellipticF(phi, m) {
              if (!m)
                return phi;
              if (m === 1)
                return log(tan(phi / 2 + quarterPi));
              var a = 1, b = sqrt(1 - m), c = sqrt(m);
              for (var i = 0; abs(c) > epsilon; i++) {
                if (phi % pi) {
                  var dPhi = atan(b * tan(phi) / a);
                  if (dPhi < 0)
                    dPhi += pi;
                  phi += dPhi + ~~(phi / pi) * pi;
                } else
                  phi += phi;
                c = (a + b) / 2;
                b = sqrt(a * b);
                c = ((a = c) - b) / 2;
              }
              return phi / (pow(2, i) * a);
            }
            function guyouRaw(lambda, phi) {
              var k_ = (sqrt2 - 1) / (sqrt2 + 1), k2 = sqrt(1 - k_ * k_), K2 = ellipticF(halfPi, k2 * k2), f = -1, psi = log(tan(pi / 4 + abs(phi) / 2)), r = exp(f * psi) / sqrt(k_), at = guyouComplexAtan(r * cos(f * lambda), r * sin(f * lambda)), t = ellipticFi(at[0], at[1], k2 * k2);
              return [-t[1], (phi >= 0 ? 1 : -1) * (0.5 * K2 - t[0])];
            }
            function guyouComplexAtan(x, y) {
              var x2 = x * x, y_1 = y + 1, t = 1 - x2 - y * y;
              return [
                0.5 * ((x >= 0 ? halfPi : -halfPi) - atan2(t, 2 * x)),
                -0.25 * log(t * t + 4 * x2) + 0.5 * log(y_1 * y_1 + x2)
              ];
            }
            function guyouComplexDivide(a, b) {
              var denominator = b[0] * b[0] + b[1] * b[1];
              return [
                (a[0] * b[0] + a[1] * b[1]) / denominator,
                (a[1] * b[0] - a[0] * b[1]) / denominator
              ];
            }
            guyouRaw.invert = function(x, y) {
              var k_ = (sqrt2 - 1) / (sqrt2 + 1), k2 = sqrt(1 - k_ * k_), K2 = ellipticF(halfPi, k2 * k2), f = -1, j = ellipticJi(0.5 * K2 - y, -x, k2 * k2), tn = guyouComplexDivide(j[0], j[1]), lambda = atan2(tn[1], tn[0]) / f;
              return [
                lambda,
                2 * atan(exp(0.5 / f * log(k_ * tn[0] * tn[0] + k_ * tn[1] * tn[1]))) - halfPi
              ];
            };
            var guyou = function() {
              return d3Geo.geoProjection(squareRaw(guyouRaw)).scale(151.496);
            };
            function hammerRaw(A2, B2) {
              if (arguments.length < 2)
                B2 = A2;
              if (B2 === 1)
                return d3Geo.geoAzimuthalEqualAreaRaw;
              if (B2 === Infinity)
                return hammerQuarticAuthalicRaw;
              function forward(lambda, phi) {
                var coordinates = d3Geo.geoAzimuthalEqualAreaRaw(lambda / B2, phi);
                coordinates[0] *= A2;
                return coordinates;
              }
              forward.invert = function(x, y) {
                var coordinates = d3Geo.geoAzimuthalEqualAreaRaw.invert(x / A2, y);
                coordinates[0] *= B2;
                return coordinates;
              };
              return forward;
            }
            function hammerQuarticAuthalicRaw(lambda, phi) {
              return [
                lambda * cos(phi) / cos(phi /= 2),
                2 * sin(phi)
              ];
            }
            hammerQuarticAuthalicRaw.invert = function(x, y) {
              var phi = 2 * asin(y / 2);
              return [
                x * cos(phi / 2) / cos(phi),
                phi
              ];
            };
            var hammer = function() {
              var B2 = 2, m = d3Geo.geoProjectionMutator(hammerRaw), p = m(B2);
              p.coefficient = function(_) {
                if (!arguments.length)
                  return B2;
                return m(B2 = +_);
              };
              return p.scale(169.529);
            };
            function hammerRetroazimuthalRaw(phi02) {
              var sinPhi0 = sin(phi02), cosPhi0 = cos(phi02), rotate = hammerRetroazimuthalRotation(phi02);
              rotate.invert = hammerRetroazimuthalRotation(-phi02);
              function forward(lambda, phi) {
                var p = rotate(lambda, phi);
                lambda = p[0], phi = p[1];
                var sinPhi = sin(phi), cosPhi = cos(phi), cosLambda = cos(lambda), z = acos(sinPhi0 * sinPhi + cosPhi0 * cosPhi * cosLambda), sinz = sin(z), K2 = abs(sinz) > epsilon ? z / sinz : 1;
                return [
                  K2 * cosPhi0 * sin(lambda),
                  (abs(lambda) > halfPi ? K2 : -K2) * (sinPhi0 * cosPhi - cosPhi0 * sinPhi * cosLambda)
                ];
              }
              forward.invert = function(x, y) {
                var rho = sqrt(x * x + y * y), sinz = -sin(rho), cosz = cos(rho), a = rho * cosz, b = -y * sinz, c = rho * sinPhi0, d = sqrt(a * a + b * b - c * c), phi = atan2(a * c + b * d, b * c - a * d), lambda = (rho > halfPi ? -1 : 1) * atan2(x * sinz, rho * cos(phi) * cosz + y * sin(phi) * sinz);
                return rotate.invert(lambda, phi);
              };
              return forward;
            }
            function hammerRetroazimuthalRotation(phi02) {
              var sinPhi0 = sin(phi02), cosPhi0 = cos(phi02);
              return function(lambda, phi) {
                var cosPhi = cos(phi), x = cos(lambda) * cosPhi, y = sin(lambda) * cosPhi, z = sin(phi);
                return [
                  atan2(y, x * cosPhi0 - z * sinPhi0),
                  asin(z * cosPhi0 + x * sinPhi0)
                ];
              };
            }
            var hammerRetroazimuthal = function() {
              var phi02 = 0, m = d3Geo.geoProjectionMutator(hammerRetroazimuthalRaw), p = m(phi02), rotate_ = p.rotate, stream_ = p.stream, circle = d3Geo.geoCircle();
              p.parallel = function(_) {
                if (!arguments.length)
                  return phi02 * degrees;
                var r = p.rotate();
                return m(phi02 = _ * radians).rotate(r);
              };
              p.rotate = function(_) {
                if (!arguments.length)
                  return _ = rotate_.call(p), _[1] += phi02 * degrees, _;
                rotate_.call(p, [_[0], _[1] - phi02 * degrees]);
                circle.center([-_[0], -_[1]]);
                return p;
              };
              p.stream = function(stream) {
                stream = stream_(stream);
                stream.sphere = function() {
                  stream.polygonStart();
                  var epsilon$$1 = 0.01, ring = circle.radius(90 - epsilon$$1)().coordinates[0], n = ring.length - 1, i = -1, p2;
                  stream.lineStart();
                  while (++i < n)
                    stream.point((p2 = ring[i])[0], p2[1]);
                  stream.lineEnd();
                  ring = circle.radius(90 + epsilon$$1)().coordinates[0];
                  n = ring.length - 1;
                  stream.lineStart();
                  while (--i >= 0)
                    stream.point((p2 = ring[i])[0], p2[1]);
                  stream.lineEnd();
                  stream.polygonEnd();
                };
                return stream;
              };
              return p.scale(79.4187).parallel(45).clipAngle(180 - 1e-3);
            };
            var healpixParallel = 41 + 48 / 36 + 37 / 3600;
            var healpixLambert = cylindricalEqualAreaRaw(0);
            function healpixRaw(H) {
              var phi02 = healpixParallel * radians, dx = collignonRaw(pi, phi02)[0] - collignonRaw(-pi, phi02)[0], y02 = healpixLambert(0, phi02)[1], y12 = collignonRaw(0, phi02)[1], dy1 = sqrtPi - y12, k2 = tau / H, w2 = 4 / tau, h = y02 + dy1 * dy1 * 4 / tau;
              function forward(lambda, phi) {
                var point, phi2 = abs(phi);
                if (phi2 > phi02) {
                  var i = min(H - 1, max(0, floor((lambda + pi) / k2)));
                  lambda += pi * (H - 1) / H - i * k2;
                  point = collignonRaw(lambda, phi2);
                  point[0] = point[0] * tau / dx - tau * (H - 1) / (2 * H) + i * tau / H;
                  point[1] = y02 + (point[1] - y12) * 4 * dy1 / tau;
                  if (phi < 0)
                    point[1] = -point[1];
                } else {
                  point = healpixLambert(lambda, phi);
                }
                point[0] *= w2, point[1] /= h;
                return point;
              }
              forward.invert = function(x, y) {
                x /= w2, y *= h;
                var y2 = abs(y);
                if (y2 > y02) {
                  var i = min(H - 1, max(0, floor((x + pi) / k2)));
                  x = (x + pi * (H - 1) / H - i * k2) * dx / tau;
                  var point = collignonRaw.invert(x, 0.25 * (y2 - y02) * tau / dy1 + y12);
                  point[0] -= pi * (H - 1) / H - i * k2;
                  if (y < 0)
                    point[1] = -point[1];
                  return point;
                }
                return healpixLambert.invert(x, y);
              };
              return forward;
            }
            function sphere(step) {
              return {
                type: "Polygon",
                coordinates: [
                  d3Array.range(-180, 180 + step / 2, step).map(function(x, i) {
                    return [x, i & 1 ? 90 - 1e-6 : healpixParallel];
                  }).concat(d3Array.range(180, -180 - step / 2, -step).map(function(x, i) {
                    return [x, i & 1 ? -90 + 1e-6 : -healpixParallel];
                  }))
                ]
              };
            }
            var healpix = function() {
              var H = 4, m = d3Geo.geoProjectionMutator(healpixRaw), p = m(H), stream_ = p.stream;
              p.lobes = function(_) {
                return arguments.length ? m(H = +_) : H;
              };
              p.stream = function(stream) {
                var rotate = p.rotate(), rotateStream = stream_(stream), sphereStream = (p.rotate([0, 0]), stream_(stream));
                p.rotate(rotate);
                rotateStream.sphere = function() {
                  d3Geo.geoStream(sphere(180 / H), sphereStream);
                };
                return rotateStream;
              };
              return p.scale(239.75);
            };
            function hillRaw(K2) {
              var L = 1 + K2, sinBt = sin(1 / L), Bt = asin(sinBt), A2 = 2 * sqrt(pi / (B2 = pi + 4 * Bt * L)), B2, rho0 = 0.5 * A2 * (L + sqrt(K2 * (2 + K2))), K22 = K2 * K2, L2 = L * L;
              function forward(lambda, phi) {
                var t = 1 - sin(phi), rho, omega;
                if (t && t < 2) {
                  var theta = halfPi - phi, i = 25, delta;
                  do {
                    var sinTheta = sin(theta), cosTheta = cos(theta), Bt_Bt1 = Bt + atan2(sinTheta, L - cosTheta), C = 1 + L2 - 2 * L * cosTheta;
                    theta -= delta = (theta - K22 * Bt - L * sinTheta + C * Bt_Bt1 - 0.5 * t * B2) / (2 * L * sinTheta * Bt_Bt1);
                  } while (abs(delta) > epsilon2 && --i > 0);
                  rho = A2 * sqrt(C);
                  omega = lambda * Bt_Bt1 / pi;
                } else {
                  rho = A2 * (K2 + t);
                  omega = lambda * Bt / pi;
                }
                return [
                  rho * sin(omega),
                  rho0 - rho * cos(omega)
                ];
              }
              forward.invert = function(x, y) {
                var rho2 = x * x + (y -= rho0) * y, cosTheta = (1 + L2 - rho2 / (A2 * A2)) / (2 * L), theta = acos(cosTheta), sinTheta = sin(theta), Bt_Bt1 = Bt + atan2(sinTheta, L - cosTheta);
                return [
                  asin(x / sqrt(rho2)) * pi / Bt_Bt1,
                  asin(1 - 2 * (theta - K22 * Bt - L * sinTheta + (1 + L2 - 2 * L * cosTheta) * Bt_Bt1) / B2)
                ];
              };
              return forward;
            }
            var hill = function() {
              var K2 = 1, m = d3Geo.geoProjectionMutator(hillRaw), p = m(K2);
              p.ratio = function(_) {
                return arguments.length ? m(K2 = +_) : K2;
              };
              return p.scale(167.774).center([0, 18.67]);
            };
            var sinuMollweidePhi = 0.7109889596207567;
            var sinuMollweideY = 0.0528035274542;
            function sinuMollweideRaw(lambda, phi) {
              return phi > -sinuMollweidePhi ? (lambda = mollweideRaw(lambda, phi), lambda[1] += sinuMollweideY, lambda) : sinusoidalRaw(lambda, phi);
            }
            sinuMollweideRaw.invert = function(x, y) {
              return y > -sinuMollweidePhi ? mollweideRaw.invert(x, y - sinuMollweideY) : sinusoidalRaw.invert(x, y);
            };
            var sinuMollweide = function() {
              return d3Geo.geoProjection(sinuMollweideRaw).rotate([-20, -55]).scale(164.263).center([0, -5.4036]);
            };
            function homolosineRaw(lambda, phi) {
              return abs(phi) > sinuMollweidePhi ? (lambda = mollweideRaw(lambda, phi), lambda[1] -= phi > 0 ? sinuMollweideY : -sinuMollweideY, lambda) : sinusoidalRaw(lambda, phi);
            }
            homolosineRaw.invert = function(x, y) {
              return abs(y) > sinuMollweidePhi ? mollweideRaw.invert(x, y + (y > 0 ? sinuMollweideY : -sinuMollweideY)) : sinusoidalRaw.invert(x, y);
            };
            var homolosine = function() {
              return d3Geo.geoProjection(homolosineRaw).scale(152.63);
            };
            function pointEqual(a, b) {
              return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;
            }
            function interpolateLine(coordinates, m) {
              var i = -1, n = coordinates.length, p0 = coordinates[0], p1, dx, dy, resampled = [];
              while (++i < n) {
                p1 = coordinates[i];
                dx = (p1[0] - p0[0]) / m;
                dy = (p1[1] - p0[1]) / m;
                for (var j = 0; j < m; ++j)
                  resampled.push([p0[0] + j * dx, p0[1] + j * dy]);
                p0 = p1;
              }
              resampled.push(p1);
              return resampled;
            }
            function interpolateSphere(lobes2) {
              var coordinates = [], lobe, lambda0, phi02, phi1, lambda2, phi2, i, n = lobes2[0].length;
              for (i = 0; i < n; ++i) {
                lobe = lobes2[0][i];
                lambda0 = lobe[0][0], phi02 = lobe[0][1], phi1 = lobe[1][1];
                lambda2 = lobe[2][0], phi2 = lobe[2][1];
                coordinates.push(interpolateLine([
                  [lambda0 + epsilon, phi02 + epsilon],
                  [lambda0 + epsilon, phi1 - epsilon],
                  [lambda2 - epsilon, phi1 - epsilon],
                  [lambda2 - epsilon, phi2 + epsilon]
                ], 30));
              }
              for (i = lobes2[1].length - 1; i >= 0; --i) {
                lobe = lobes2[1][i];
                lambda0 = lobe[0][0], phi02 = lobe[0][1], phi1 = lobe[1][1];
                lambda2 = lobe[2][0], phi2 = lobe[2][1];
                coordinates.push(interpolateLine([
                  [lambda2 - epsilon, phi2 - epsilon],
                  [lambda2 - epsilon, phi1 + epsilon],
                  [lambda0 + epsilon, phi1 + epsilon],
                  [lambda0 + epsilon, phi02 - epsilon]
                ], 30));
              }
              return {
                type: "Polygon",
                coordinates: [d3Array.merge(coordinates)]
              };
            }
            var interrupt = function(project, lobes2) {
              var sphere2 = interpolateSphere(lobes2);
              lobes2 = lobes2.map(function(lobe) {
                return lobe.map(function(l) {
                  return [
                    [l[0][0] * radians, l[0][1] * radians],
                    [l[1][0] * radians, l[1][1] * radians],
                    [l[2][0] * radians, l[2][1] * radians]
                  ];
                });
              });
              var bounds = lobes2.map(function(lobe) {
                return lobe.map(function(l) {
                  var x02 = project(l[0][0], l[0][1])[0], x12 = project(l[2][0], l[2][1])[0], y02 = project(l[1][0], l[0][1])[1], y12 = project(l[1][0], l[1][1])[1], t;
                  if (y02 > y12)
                    t = y02, y02 = y12, y12 = t;
                  return [[x02, y02], [x12, y12]];
                });
              });
              function forward(lambda, phi) {
                var sign$$1 = phi < 0 ? -1 : 1, lobe = lobes2[+(phi < 0)];
                for (var i = 0, n = lobe.length - 1; i < n && lambda > lobe[i][2][0]; ++i)
                  ;
                var p2 = project(lambda - lobe[i][1][0], phi);
                p2[0] += project(lobe[i][1][0], sign$$1 * phi > sign$$1 * lobe[i][0][1] ? lobe[i][0][1] : phi)[0];
                return p2;
              }
              if (project.invert)
                forward.invert = function(x, y) {
                  var bound = bounds[+(y < 0)], lobe = lobes2[+(y < 0)];
                  for (var i = 0, n = bound.length; i < n; ++i) {
                    var b = bound[i];
                    if (b[0][0] <= x && x < b[1][0] && b[0][1] <= y && y < b[1][1]) {
                      var p2 = project.invert(x - project(lobe[i][1][0], 0)[0], y);
                      p2[0] += lobe[i][1][0];
                      return pointEqual(forward(p2[0], p2[1]), [x, y]) ? p2 : null;
                    }
                  }
                };
              var p = d3Geo.geoProjection(forward), stream_ = p.stream;
              p.stream = function(stream) {
                var rotate = p.rotate(), rotateStream = stream_(stream), sphereStream = (p.rotate([0, 0]), stream_(stream));
                p.rotate(rotate);
                rotateStream.sphere = function() {
                  d3Geo.geoStream(sphere2, sphereStream);
                };
                return rotateStream;
              };
              return p;
            };
            var lobes = [[
              [[-180, 0], [-100, 90], [-40, 0]],
              [[-40, 0], [30, 90], [180, 0]]
            ], [
              [[-180, 0], [-160, -90], [-100, 0]],
              [[-100, 0], [-60, -90], [-20, 0]],
              [[-20, 0], [20, -90], [80, 0]],
              [[80, 0], [140, -90], [180, 0]]
            ]];
            var boggs$1 = function() {
              return interrupt(boggsRaw, lobes).scale(160.857);
            };
            var lobes$1 = [[
              [[-180, 0], [-100, 90], [-40, 0]],
              [[-40, 0], [30, 90], [180, 0]]
            ], [
              [[-180, 0], [-160, -90], [-100, 0]],
              [[-100, 0], [-60, -90], [-20, 0]],
              [[-20, 0], [20, -90], [80, 0]],
              [[80, 0], [140, -90], [180, 0]]
            ]];
            var homolosine$1 = function() {
              return interrupt(homolosineRaw, lobes$1).scale(152.63);
            };
            var lobes$2 = [[
              [[-180, 0], [-100, 90], [-40, 0]],
              [[-40, 0], [30, 90], [180, 0]]
            ], [
              [[-180, 0], [-160, -90], [-100, 0]],
              [[-100, 0], [-60, -90], [-20, 0]],
              [[-20, 0], [20, -90], [80, 0]],
              [[80, 0], [140, -90], [180, 0]]
            ]];
            var mollweide$1 = function() {
              return interrupt(mollweideRaw, lobes$2).scale(169.529);
            };
            var lobes$3 = [[
              [[-180, 0], [-90, 90], [0, 0]],
              [[0, 0], [90, 90], [180, 0]]
            ], [
              [[-180, 0], [-90, -90], [0, 0]],
              [[0, 0], [90, -90], [180, 0]]
            ]];
            var mollweideHemispheres = function() {
              return interrupt(mollweideRaw, lobes$3).scale(169.529).rotate([20, 0]);
            };
            var lobes$4 = [[
              [[-180, 35], [-30, 90], [0, 35]],
              [[0, 35], [30, 90], [180, 35]]
            ], [
              [[-180, -10], [-102, -90], [-65, -10]],
              [[-65, -10], [5, -90], [77, -10]],
              [[77, -10], [103, -90], [180, -10]]
            ]];
            var sinuMollweide$1 = function() {
              return interrupt(sinuMollweideRaw, lobes$4).rotate([-20, -55]).scale(164.263).center([0, -5.4036]);
            };
            var lobes$5 = [[
              [[-180, 0], [-110, 90], [-40, 0]],
              [[-40, 0], [0, 90], [40, 0]],
              [[40, 0], [110, 90], [180, 0]]
            ], [
              [[-180, 0], [-110, -90], [-40, 0]],
              [[-40, 0], [0, -90], [40, 0]],
              [[40, 0], [110, -90], [180, 0]]
            ]];
            var sinusoidal$1 = function() {
              return interrupt(sinusoidalRaw, lobes$5).scale(152.63).rotate([-20, 0]);
            };
            function kavrayskiy7Raw(lambda, phi) {
              return [3 / tau * lambda * sqrt(pi * pi / 3 - phi * phi), phi];
            }
            kavrayskiy7Raw.invert = function(x, y) {
              return [tau / 3 * x / sqrt(pi * pi / 3 - y * y), y];
            };
            var kavrayskiy7 = function() {
              return d3Geo.geoProjection(kavrayskiy7Raw).scale(158.837);
            };
            function lagrangeRaw(n) {
              function forward(lambda, phi) {
                if (abs(abs(phi) - halfPi) < epsilon)
                  return [0, phi < 0 ? -2 : 2];
                var sinPhi = sin(phi), v = pow((1 + sinPhi) / (1 - sinPhi), n / 2), c = 0.5 * (v + 1 / v) + cos(lambda *= n);
                return [
                  2 * sin(lambda) / c,
                  (v - 1 / v) / c
                ];
              }
              forward.invert = function(x, y) {
                var y02 = abs(y);
                if (abs(y02 - 2) < epsilon)
                  return x ? null : [0, sign(y) * halfPi];
                if (y02 > 2)
                  return null;
                x /= 2, y /= 2;
                var x2 = x * x, y2 = y * y, t = 2 * y / (1 + x2 + y2);
                t = pow((1 + t) / (1 - t), 1 / n);
                return [
                  atan2(2 * x, 1 - x2 - y2) / n,
                  asin((t - 1) / (t + 1))
                ];
              };
              return forward;
            }
            var lagrange = function() {
              var n = 0.5, m = d3Geo.geoProjectionMutator(lagrangeRaw), p = m(n);
              p.spacing = function(_) {
                return arguments.length ? m(n = +_) : n;
              };
              return p.scale(124.75);
            };
            var pi_sqrt2 = pi / sqrt2;
            function larriveeRaw(lambda, phi) {
              return [
                lambda * (1 + sqrt(cos(phi))) / 2,
                phi / (cos(phi / 2) * cos(lambda / 6))
              ];
            }
            larriveeRaw.invert = function(x, y) {
              var x02 = abs(x), y02 = abs(y), lambda = epsilon, phi = halfPi;
              if (y02 < pi_sqrt2)
                phi *= y02 / pi_sqrt2;
              else
                lambda += 6 * acos(pi_sqrt2 / y02);
              for (var i = 0; i < 25; i++) {
                var sinPhi = sin(phi), sqrtcosPhi = sqrt(cos(phi)), sinPhi_2 = sin(phi / 2), cosPhi_2 = cos(phi / 2), sinLambda_6 = sin(lambda / 6), cosLambda_6 = cos(lambda / 6), f0 = 0.5 * lambda * (1 + sqrtcosPhi) - x02, f1 = phi / (cosPhi_2 * cosLambda_6) - y02, df0dPhi = sqrtcosPhi ? -0.25 * lambda * sinPhi / sqrtcosPhi : 0, df0dLambda = 0.5 * (1 + sqrtcosPhi), df1dPhi = (1 + 0.5 * phi * sinPhi_2 / cosPhi_2) / (cosPhi_2 * cosLambda_6), df1dLambda = phi / cosPhi_2 * (sinLambda_6 / 6) / (cosLambda_6 * cosLambda_6), denom = df0dPhi * df1dLambda - df1dPhi * df0dLambda, dPhi = (f0 * df1dLambda - f1 * df0dLambda) / denom, dLambda = (f1 * df0dPhi - f0 * df1dPhi) / denom;
                phi -= dPhi;
                lambda -= dLambda;
                if (abs(dPhi) < epsilon && abs(dLambda) < epsilon)
                  break;
              }
              return [x < 0 ? -lambda : lambda, y < 0 ? -phi : phi];
            };
            var larrivee = function() {
              return d3Geo.geoProjection(larriveeRaw).scale(97.2672);
            };
            function laskowskiRaw(lambda, phi) {
              var lambda2 = lambda * lambda, phi2 = phi * phi;
              return [
                lambda * (0.975534 + phi2 * (-0.119161 + lambda2 * -0.0143059 + phi2 * -0.0547009)),
                phi * (1.00384 + lambda2 * (0.0802894 + phi2 * -0.02855 + lambda2 * 199025e-9) + phi2 * (0.0998909 + phi2 * -0.0491032))
              ];
            }
            laskowskiRaw.invert = function(x, y) {
              var lambda = sign(x) * pi, phi = y / 2, i = 50;
              do {
                var lambda2 = lambda * lambda, phi2 = phi * phi, lambdaPhi = lambda * phi, fx = lambda * (0.975534 + phi2 * (-0.119161 + lambda2 * -0.0143059 + phi2 * -0.0547009)) - x, fy = phi * (1.00384 + lambda2 * (0.0802894 + phi2 * -0.02855 + lambda2 * 199025e-9) + phi2 * (0.0998909 + phi2 * -0.0491032)) - y, deltaxDeltaLambda = 0.975534 - phi2 * (0.119161 + 3 * lambda2 * 0.0143059 + phi2 * 0.0547009), deltaxDeltaPhi = -lambdaPhi * (2 * 0.119161 + 4 * 0.0547009 * phi2 + 2 * 0.0143059 * lambda2), deltayDeltaLambda = lambdaPhi * (2 * 0.0802894 + 4 * 199025e-9 * lambda2 + 2 * -0.02855 * phi2), deltayDeltaPhi = 1.00384 + lambda2 * (0.0802894 + 199025e-9 * lambda2) + phi2 * (3 * (0.0998909 - 0.02855 * lambda2) - 5 * 0.0491032 * phi2), denominator = deltaxDeltaPhi * deltayDeltaLambda - deltayDeltaPhi * deltaxDeltaLambda, deltaLambda = (fy * deltaxDeltaPhi - fx * deltayDeltaPhi) / denominator, deltaPhi = (fx * deltayDeltaLambda - fy * deltaxDeltaLambda) / denominator;
                lambda -= deltaLambda, phi -= deltaPhi;
              } while ((abs(deltaLambda) > epsilon || abs(deltaPhi) > epsilon) && --i > 0);
              return i && [lambda, phi];
            };
            var laskowski = function() {
              return d3Geo.geoProjection(laskowskiRaw).scale(139.98);
            };
            function littrowRaw(lambda, phi) {
              return [
                sin(lambda) / cos(phi),
                tan(phi) * cos(lambda)
              ];
            }
            littrowRaw.invert = function(x, y) {
              var x2 = x * x, y2 = y * y, y2_1 = y2 + 1, cosPhi = x ? sqrt1_2 * sqrt((y2_1 - sqrt(x2 * x2 + 2 * x2 * (y2 - 1) + y2_1 * y2_1)) / x2 + 1) : 1 / sqrt(y2_1);
              return [
                asin(x * cosPhi),
                sign(y) * acos(cosPhi)
              ];
            };
            var littrow = function() {
              return d3Geo.geoProjection(littrowRaw).scale(144.049).clipAngle(90 - 1e-3);
            };
            function loximuthalRaw(phi02) {
              var cosPhi0 = cos(phi02), tanPhi0 = tan(quarterPi + phi02 / 2);
              function forward(lambda, phi) {
                var y = phi - phi02, x = abs(y) < epsilon ? lambda * cosPhi0 : abs(x = quarterPi + phi / 2) < epsilon || abs(abs(x) - halfPi) < epsilon ? 0 : lambda * y / log(tan(x) / tanPhi0);
                return [x, y];
              }
              forward.invert = function(x, y) {
                var lambda, phi = y + phi02;
                return [
                  abs(y) < epsilon ? x / cosPhi0 : abs(lambda = quarterPi + phi / 2) < epsilon || abs(abs(lambda) - halfPi) < epsilon ? 0 : x * log(tan(lambda) / tanPhi0) / y,
                  phi
                ];
              };
              return forward;
            }
            var loximuthal = function() {
              return parallel1(loximuthalRaw).parallel(40).scale(158.837);
            };
            function millerRaw(lambda, phi) {
              return [lambda, 1.25 * log(tan(quarterPi + 0.4 * phi))];
            }
            millerRaw.invert = function(x, y) {
              return [x, 2.5 * atan(exp(0.8 * y)) - 0.625 * pi];
            };
            var miller = function() {
              return d3Geo.geoProjection(millerRaw).scale(108.318);
            };
            function modifiedStereographicRaw(C) {
              var m = C.length - 1;
              function forward(lambda, phi) {
                var cosPhi = cos(phi), k2 = 2 / (1 + cosPhi * cos(lambda)), zr = k2 * cosPhi * sin(lambda), zi = k2 * sin(phi), i = m, w2 = C[i], ar = w2[0], ai = w2[1], t;
                while (--i >= 0) {
                  w2 = C[i];
                  ar = w2[0] + zr * (t = ar) - zi * ai;
                  ai = w2[1] + zr * ai + zi * t;
                }
                ar = zr * (t = ar) - zi * ai;
                ai = zr * ai + zi * t;
                return [ar, ai];
              }
              forward.invert = function(x, y) {
                var i = 20, zr = x, zi = y;
                do {
                  var j = m, w2 = C[j], ar = w2[0], ai = w2[1], br = 0, bi = 0, t;
                  while (--j >= 0) {
                    w2 = C[j];
                    br = ar + zr * (t = br) - zi * bi;
                    bi = ai + zr * bi + zi * t;
                    ar = w2[0] + zr * (t = ar) - zi * ai;
                    ai = w2[1] + zr * ai + zi * t;
                  }
                  br = ar + zr * (t = br) - zi * bi;
                  bi = ai + zr * bi + zi * t;
                  ar = zr * (t = ar) - zi * ai - x;
                  ai = zr * ai + zi * t - y;
                  var denominator = br * br + bi * bi, deltar, deltai;
                  zr -= deltar = (ar * br + ai * bi) / denominator;
                  zi -= deltai = (ai * br - ar * bi) / denominator;
                } while (abs(deltar) + abs(deltai) > epsilon * epsilon && --i > 0);
                if (i) {
                  var rho = sqrt(zr * zr + zi * zi), c = 2 * atan(rho * 0.5), sinc = sin(c);
                  return [atan2(zr * sinc, rho * cos(c)), rho ? asin(zi * sinc / rho) : 0];
                }
              };
              return forward;
            }
            var alaska = [[0.9972523, 0], [52513e-7, -41175e-7], [74606e-7, 48125e-7], [-0.0153783, -0.1968253], [0.0636871, -0.1408027], [0.3660976, -0.2937382]];
            var gs48 = [[0.98879, 0], [0, 0], [-0.050909, 0], [0, 0], [0.075528, 0]];
            var gs50 = [[0.984299, 0], [0.0211642, 37608e-7], [-0.1036018, -0.0575102], [-0.0329095, -0.0320119], [0.0499471, 0.1223335], [0.026046, 0.0899805], [7388e-7, -0.1435792], [75848e-7, -0.1334108], [-0.0216473, 0.0776645], [-0.0225161, 0.0853673]];
            var miller$1 = [[0.9245, 0], [0, 0], [0.01943, 0]];
            var lee = [[0.721316, 0], [0, 0], [-881625e-8, -617325e-8]];
            function modifiedStereographicAlaska() {
              return modifiedStereographic(alaska, [152, -64]).scale(1500).center([-160.908, 62.4864]).clipAngle(25);
            }
            function modifiedStereographicGs48() {
              return modifiedStereographic(gs48, [95, -38]).scale(1e3).clipAngle(55).center([-96.5563, 38.8675]);
            }
            function modifiedStereographicGs50() {
              return modifiedStereographic(gs50, [120, -45]).scale(359.513).clipAngle(55).center([-117.474, 53.0628]);
            }
            function modifiedStereographicMiller() {
              return modifiedStereographic(miller$1, [-20, -18]).scale(209.091).center([20, 16.7214]).clipAngle(82);
            }
            function modifiedStereographicLee() {
              return modifiedStereographic(lee, [165, 10]).scale(250).clipAngle(130).center([-165, -10]);
            }
            function modifiedStereographic(coefficients, rotate) {
              var p = d3Geo.geoProjection(modifiedStereographicRaw(coefficients)).rotate(rotate).clipAngle(90), r = d3Geo.geoRotation(rotate), center = p.center;
              delete p.rotate;
              p.center = function(_) {
                return arguments.length ? center(r(_)) : r.invert(center());
              };
              return p;
            }
            var sqrt6 = sqrt(6);
            var sqrt7 = sqrt(7);
            function mtFlatPolarParabolicRaw(lambda, phi) {
              var theta = asin(7 * sin(phi) / (3 * sqrt6));
              return [
                sqrt6 * lambda * (2 * cos(2 * theta / 3) - 1) / sqrt7,
                9 * sin(theta / 3) / sqrt7
              ];
            }
            mtFlatPolarParabolicRaw.invert = function(x, y) {
              var theta = 3 * asin(y * sqrt7 / 9);
              return [
                x * sqrt7 / (sqrt6 * (2 * cos(2 * theta / 3) - 1)),
                asin(sin(theta) * 3 * sqrt6 / 7)
              ];
            };
            var mtFlatPolarParabolic = function() {
              return d3Geo.geoProjection(mtFlatPolarParabolicRaw).scale(164.859);
            };
            function mtFlatPolarQuarticRaw(lambda, phi) {
              var k2 = (1 + sqrt1_2) * sin(phi), theta = phi;
              for (var i = 0, delta; i < 25; i++) {
                theta -= delta = (sin(theta / 2) + sin(theta) - k2) / (0.5 * cos(theta / 2) + cos(theta));
                if (abs(delta) < epsilon)
                  break;
              }
              return [
                lambda * (1 + 2 * cos(theta) / cos(theta / 2)) / (3 * sqrt2),
                2 * sqrt(3) * sin(theta / 2) / sqrt(2 + sqrt2)
              ];
            }
            mtFlatPolarQuarticRaw.invert = function(x, y) {
              var sinTheta_2 = y * sqrt(2 + sqrt2) / (2 * sqrt(3)), theta = 2 * asin(sinTheta_2);
              return [
                3 * sqrt2 * x / (1 + 2 * cos(theta) / cos(theta / 2)),
                asin((sinTheta_2 + sin(theta)) / (1 + sqrt1_2))
              ];
            };
            var mtFlatPolarQuartic = function() {
              return d3Geo.geoProjection(mtFlatPolarQuarticRaw).scale(188.209);
            };
            function mtFlatPolarSinusoidalRaw(lambda, phi) {
              var A2 = sqrt(6 / (4 + pi)), k2 = (1 + pi / 4) * sin(phi), theta = phi / 2;
              for (var i = 0, delta; i < 25; i++) {
                theta -= delta = (theta / 2 + sin(theta) - k2) / (0.5 + cos(theta));
                if (abs(delta) < epsilon)
                  break;
              }
              return [
                A2 * (0.5 + cos(theta)) * lambda / 1.5,
                A2 * theta
              ];
            }
            mtFlatPolarSinusoidalRaw.invert = function(x, y) {
              var A2 = sqrt(6 / (4 + pi)), theta = y / A2;
              if (abs(abs(theta) - halfPi) < epsilon)
                theta = theta < 0 ? -halfPi : halfPi;
              return [
                1.5 * x / (A2 * (0.5 + cos(theta))),
                asin((theta / 2 + sin(theta)) / (1 + pi / 4))
              ];
            };
            var mtFlatPolarSinusoidal = function() {
              return d3Geo.geoProjection(mtFlatPolarSinusoidalRaw).scale(166.518);
            };
            function naturalEarthRaw(lambda, phi) {
              var phi2 = phi * phi, phi4 = phi2 * phi2;
              return [
                lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (3971e-6 * phi2 - 1529e-6 * phi4))),
                phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 5916e-6 * phi4)))
              ];
            }
            naturalEarthRaw.invert = function(x, y) {
              var phi = y, i = 25, delta;
              do {
                var phi2 = phi * phi, phi4 = phi2 * phi2;
                phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 5916e-6 * phi4))) - y) / (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 5916e-6 * 11 * phi4)));
              } while (abs(delta) > epsilon && --i > 0);
              return [
                x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (3971e-6 - 1529e-6 * phi2)))),
                phi
              ];
            };
            var naturalEarth = function() {
              return d3Geo.geoProjection(naturalEarthRaw).scale(175.295);
            };
            function naturalEarth2Raw(lambda, phi) {
              var phi2 = phi * phi, phi4 = phi2 * phi2, phi6 = phi2 * phi4;
              return [
                lambda * (0.84719 - 0.13063 * phi2 + phi6 * phi6 * (-0.04515 + 0.05494 * phi2 - 0.02326 * phi4 + 331e-5 * phi6)),
                phi * (1.01183 + phi4 * phi4 * (-0.02625 + 0.01926 * phi2 - 396e-5 * phi4))
              ];
            }
            naturalEarth2Raw.invert = function(x, y) {
              var phi = y, i = 25, delta, phi2, phi4, phi6;
              do {
                phi2 = phi * phi;
                phi4 = phi2 * phi2;
                phi -= delta = (phi * (1.01183 + phi4 * phi4 * (-0.02625 + 0.01926 * phi2 - 396e-5 * phi4)) - y) / (1.01183 + phi4 * phi4 * (9 * -0.02625 + 11 * 0.01926 * phi2 + 13 * -396e-5 * phi4));
              } while (abs(delta) > epsilon2 && --i > 0);
              phi2 = phi * phi;
              phi4 = phi2 * phi2;
              phi6 = phi2 * phi4;
              return [
                x / (0.84719 - 0.13063 * phi2 + phi6 * phi6 * (-0.04515 + 0.05494 * phi2 - 0.02326 * phi4 + 331e-5 * phi6)),
                phi
              ];
            };
            var naturalEarth2 = function() {
              return d3Geo.geoProjection(naturalEarth2Raw).scale(175.295);
            };
            function nellHammerRaw(lambda, phi) {
              return [
                lambda * (1 + cos(phi)) / 2,
                2 * (phi - tan(phi / 2))
              ];
            }
            nellHammerRaw.invert = function(x, y) {
              var p = y / 2;
              for (var i = 0, delta = Infinity; i < 10 && abs(delta) > epsilon; ++i) {
                var c = cos(y / 2);
                y -= delta = (y - tan(y / 2) - p) / (1 - 0.5 / (c * c));
              }
              return [
                2 * x / (1 + cos(y)),
                y
              ];
            };
            var nellHammer = function() {
              return d3Geo.geoProjection(nellHammerRaw).scale(152.63);
            };
            var pattersonK1 = 1.0148;
            var pattersonK2 = 0.23185;
            var pattersonK3 = -0.14499;
            var pattersonK4 = 0.02406;
            var pattersonC1 = pattersonK1;
            var pattersonC2 = 5 * pattersonK2;
            var pattersonC3 = 7 * pattersonK3;
            var pattersonC4 = 9 * pattersonK4;
            var pattersonYmax = 1.790857183;
            function pattersonRaw(lambda, phi) {
              var phi2 = phi * phi;
              return [
                lambda,
                phi * (pattersonK1 + phi2 * phi2 * (pattersonK2 + phi2 * (pattersonK3 + pattersonK4 * phi2)))
              ];
            }
            pattersonRaw.invert = function(x, y) {
              if (y > pattersonYmax)
                y = pattersonYmax;
              else if (y < -pattersonYmax)
                y = -pattersonYmax;
              var yc = y, delta;
              do {
                var y2 = yc * yc;
                yc -= delta = (yc * (pattersonK1 + y2 * y2 * (pattersonK2 + y2 * (pattersonK3 + pattersonK4 * y2))) - y) / (pattersonC1 + y2 * y2 * (pattersonC2 + y2 * (pattersonC3 + pattersonC4 * y2)));
              } while (abs(delta) > epsilon);
              return [x, yc];
            };
            var patterson = function() {
              return d3Geo.geoProjection(pattersonRaw).scale(139.319);
            };
            function polyconicRaw(lambda, phi) {
              if (abs(phi) < epsilon)
                return [lambda, 0];
              var tanPhi = tan(phi), k2 = lambda * sin(phi);
              return [
                sin(k2) / tanPhi,
                phi + (1 - cos(k2)) / tanPhi
              ];
            }
            polyconicRaw.invert = function(x, y) {
              if (abs(y) < epsilon)
                return [x, 0];
              var k2 = x * x + y * y, phi = y * 0.5, i = 10, delta;
              do {
                var tanPhi = tan(phi), secPhi = 1 / cos(phi), j = k2 - 2 * y * phi + phi * phi;
                phi -= delta = (tanPhi * j + 2 * (phi - y)) / (2 + j * secPhi * secPhi + 2 * (phi - y) * tanPhi);
              } while (abs(delta) > epsilon && --i > 0);
              tanPhi = tan(phi);
              return [
                (abs(y) < abs(phi + 1 / tanPhi) ? asin(x * tanPhi) : sign(x) * (acos(abs(x * tanPhi)) + halfPi)) / sin(phi),
                phi
              ];
            };
            var polyconic = function() {
              return d3Geo.geoProjection(polyconicRaw).scale(103.74);
            };
            var matrix = function(a, b) {
              var u = subtract(a[1], a[0]), v = subtract(b[1], b[0]), phi = angle$1(u, v), s = length(u) / length(v);
              return multiply([
                1,
                0,
                a[0][0],
                0,
                1,
                a[0][1]
              ], multiply([
                s,
                0,
                0,
                0,
                s,
                0
              ], multiply([
                cos(phi),
                sin(phi),
                0,
                -sin(phi),
                cos(phi),
                0
              ], [
                1,
                0,
                -b[0][0],
                0,
                1,
                -b[0][1]
              ])));
            };
            function inverse(m) {
              var k2 = 1 / (m[0] * m[4] - m[1] * m[3]);
              return [
                k2 * m[4],
                -k2 * m[1],
                k2 * (m[1] * m[5] - m[2] * m[4]),
                -k2 * m[3],
                k2 * m[0],
                k2 * (m[2] * m[3] - m[0] * m[5])
              ];
            }
            function multiply(a, b) {
              return [
                a[0] * b[0] + a[1] * b[3],
                a[0] * b[1] + a[1] * b[4],
                a[0] * b[2] + a[1] * b[5] + a[2],
                a[3] * b[0] + a[4] * b[3],
                a[3] * b[1] + a[4] * b[4],
                a[3] * b[2] + a[4] * b[5] + a[5]
              ];
            }
            function subtract(a, b) {
              return [a[0] - b[0], a[1] - b[1]];
            }
            function length(v) {
              return sqrt(v[0] * v[0] + v[1] * v[1]);
            }
            function angle$1(a, b) {
              return atan2(a[0] * b[1] - a[1] * b[0], a[0] * b[0] + a[1] * b[1]);
            }
            var polyhedral = function(root, face, r) {
              r = r == null ? -pi / 6 : r;
              recurse(root, { transform: [
                cos(r),
                sin(r),
                0,
                -sin(r),
                cos(r),
                0
              ] });
              function recurse(node, parent) {
                node.edges = faceEdges(node.face);
                if (parent.face) {
                  var shared = node.shared = sharedEdge(node.face, parent.face), m = matrix(shared.map(parent.project), shared.map(node.project));
                  node.transform = parent.transform ? multiply(parent.transform, m) : m;
                  var edges = parent.edges;
                  for (var i = 0, n = edges.length; i < n; ++i) {
                    if (pointEqual$1(shared[0], edges[i][1]) && pointEqual$1(shared[1], edges[i][0]))
                      edges[i] = node;
                    if (pointEqual$1(shared[0], edges[i][0]) && pointEqual$1(shared[1], edges[i][1]))
                      edges[i] = node;
                  }
                  edges = node.edges;
                  for (i = 0, n = edges.length; i < n; ++i) {
                    if (pointEqual$1(shared[0], edges[i][0]) && pointEqual$1(shared[1], edges[i][1]))
                      edges[i] = parent;
                    if (pointEqual$1(shared[0], edges[i][1]) && pointEqual$1(shared[1], edges[i][0]))
                      edges[i] = parent;
                  }
                } else {
                  node.transform = parent.transform;
                }
                if (node.children) {
                  node.children.forEach(function(child) {
                    recurse(child, node);
                  });
                }
                return node;
              }
              function forward(lambda, phi) {
                var node = face(lambda, phi), point = node.project([lambda * degrees, phi * degrees]), t;
                if (t = node.transform) {
                  return [
                    t[0] * point[0] + t[1] * point[1] + t[2],
                    -(t[3] * point[0] + t[4] * point[1] + t[5])
                  ];
                }
                point[1] = -point[1];
                return point;
              }
              if (hasInverse(root))
                forward.invert = function(x, y) {
                  var coordinates = faceInvert(root, [x, -y]);
                  return coordinates && (coordinates[0] *= radians, coordinates[1] *= radians, coordinates);
                };
              function faceInvert(node, coordinates) {
                var invert = node.project.invert, t = node.transform, point = coordinates;
                if (t) {
                  t = inverse(t);
                  point = [
                    t[0] * point[0] + t[1] * point[1] + t[2],
                    t[3] * point[0] + t[4] * point[1] + t[5]
                  ];
                }
                if (invert && node === faceDegrees(p = invert(point)))
                  return p;
                var p, children = node.children;
                for (var i = 0, n = children && children.length; i < n; ++i) {
                  if (p = faceInvert(children[i], coordinates))
                    return p;
                }
              }
              function faceDegrees(coordinates) {
                return face(coordinates[0] * radians, coordinates[1] * radians);
              }
              var proj = d3Geo.geoProjection(forward), stream_ = proj.stream;
              proj.stream = function(stream) {
                var rotate = proj.rotate(), rotateStream = stream_(stream), sphereStream = (proj.rotate([0, 0]), stream_(stream));
                proj.rotate(rotate);
                rotateStream.sphere = function() {
                  sphereStream.polygonStart();
                  sphereStream.lineStart();
                  outline(sphereStream, root);
                  sphereStream.lineEnd();
                  sphereStream.polygonEnd();
                };
                return rotateStream;
              };
              return proj;
            };
            function outline(stream, node, parent) {
              var point, edges = node.edges, n = edges.length, edge, multiPoint = { type: "MultiPoint", coordinates: node.face }, notPoles = node.face.filter(function(d) {
                return abs(d[1]) !== 90;
              }), b = d3Geo.geoBounds({ type: "MultiPoint", coordinates: notPoles }), inside = false, j = -1, dx = b[1][0] - b[0][0];
              var c = dx === 180 || dx === 360 ? [(b[0][0] + b[1][0]) / 2, (b[0][1] + b[1][1]) / 2] : d3Geo.geoCentroid(multiPoint);
              if (parent)
                while (++j < n) {
                  if (edges[j] === parent)
                    break;
                }
              ++j;
              for (var i = 0; i < n; ++i) {
                edge = edges[(i + j) % n];
                if (Array.isArray(edge)) {
                  if (!inside) {
                    stream.point((point = d3Geo.geoInterpolate(edge[0], c)(epsilon))[0], point[1]);
                    inside = true;
                  }
                  stream.point((point = d3Geo.geoInterpolate(edge[1], c)(epsilon))[0], point[1]);
                } else {
                  inside = false;
                  if (edge !== parent)
                    outline(stream, edge, node);
                }
              }
            }
            function pointEqual$1(a, b) {
              return a && b && a[0] === b[0] && a[1] === b[1];
            }
            function sharedEdge(a, b) {
              var x, y, n = a.length, found = null;
              for (var i = 0; i < n; ++i) {
                x = a[i];
                for (var j = b.length; --j >= 0; ) {
                  y = b[j];
                  if (x[0] === y[0] && x[1] === y[1]) {
                    if (found)
                      return [found, x];
                    found = x;
                  }
                }
              }
            }
            function faceEdges(face) {
              var n = face.length, edges = [];
              for (var a = face[n - 1], i = 0; i < n; ++i)
                edges.push([a, a = face[i]]);
              return edges;
            }
            function hasInverse(node) {
              return node.project.invert || node.children && node.children.some(hasInverse);
            }
            var octahedron = [
              [0, 90],
              [-90, 0],
              [0, 0],
              [90, 0],
              [180, 0],
              [0, -90]
            ];
            var octahedron$1 = [
              [0, 2, 1],
              [0, 3, 2],
              [5, 1, 2],
              [5, 2, 3],
              [0, 1, 4],
              [0, 4, 3],
              [5, 4, 1],
              [5, 3, 4]
            ].map(function(face) {
              return face.map(function(i) {
                return octahedron[i];
              });
            });
            var butterfly = function(faceProjection) {
              faceProjection = faceProjection || function(face) {
                var c = d3Geo.geoCentroid({ type: "MultiPoint", coordinates: face });
                return d3Geo.geoGnomonic().scale(1).translate([0, 0]).rotate([-c[0], -c[1]]);
              };
              var faces = octahedron$1.map(function(face) {
                return { face, project: faceProjection(face) };
              });
              [-1, 0, 0, 1, 0, 1, 4, 5].forEach(function(d, i) {
                var node = faces[d];
                node && (node.children || (node.children = [])).push(faces[i]);
              });
              return polyhedral(faces[0], function(lambda, phi) {
                return faces[lambda < -pi / 2 ? phi < 0 ? 6 : 4 : lambda < 0 ? phi < 0 ? 2 : 0 : lambda < pi / 2 ? phi < 0 ? 3 : 1 : phi < 0 ? 7 : 5];
              }).scale(101.858).center([0, 45]);
            };
            var kx = 2 / sqrt(3);
            function collignonK(a, b) {
              var p = collignonRaw(a, b);
              return [p[0] * kx, p[1]];
            }
            collignonK.invert = function(x, y) {
              return collignonRaw.invert(x / kx, y);
            };
            var collignon$1 = function(faceProjection) {
              faceProjection = faceProjection || function(face) {
                var c = d3Geo.geoCentroid({ type: "MultiPoint", coordinates: face });
                return d3Geo.geoProjection(collignonK).translate([0, 0]).scale(1).rotate(c[1] > 0 ? [-c[0], 0] : [180 - c[0], 180]);
              };
              var faces = octahedron$1.map(function(face) {
                return { face, project: faceProjection(face) };
              });
              [-1, 0, 0, 1, 0, 1, 4, 5].forEach(function(d, i) {
                var node = faces[d];
                node && (node.children || (node.children = [])).push(faces[i]);
              });
              return polyhedral(faces[0], function(lambda, phi) {
                return faces[lambda < -pi / 2 ? phi < 0 ? 6 : 4 : lambda < 0 ? phi < 0 ? 2 : 0 : lambda < pi / 2 ? phi < 0 ? 3 : 1 : phi < 0 ? 7 : 5];
              }).scale(121.906).center([0, 48.5904]);
            };
            var waterman = function(faceProjection) {
              faceProjection = faceProjection || function(face2) {
                var c = face2.length === 6 ? d3Geo.geoCentroid({ type: "MultiPoint", coordinates: face2 }) : face2[0];
                return d3Geo.geoGnomonic().scale(1).translate([0, 0]).rotate([-c[0], -c[1]]);
              };
              var w5 = octahedron$1.map(function(face2) {
                var xyz = face2.map(cartesian), n = xyz.length, a = xyz[n - 1], b, hexagon = [];
                for (var i = 0; i < n; ++i) {
                  b = xyz[i];
                  hexagon.push(spherical([
                    a[0] * 0.9486832980505138 + b[0] * 0.31622776601683794,
                    a[1] * 0.9486832980505138 + b[1] * 0.31622776601683794,
                    a[2] * 0.9486832980505138 + b[2] * 0.31622776601683794
                  ]), spherical([
                    b[0] * 0.9486832980505138 + a[0] * 0.31622776601683794,
                    b[1] * 0.9486832980505138 + a[1] * 0.31622776601683794,
                    b[2] * 0.9486832980505138 + a[2] * 0.31622776601683794
                  ]));
                  a = b;
                }
                return hexagon;
              });
              var cornerNormals = [];
              var parents = [-1, 0, 0, 1, 0, 1, 4, 5];
              w5.forEach(function(hexagon, j) {
                var face2 = octahedron$1[j], n = face2.length, normals = cornerNormals[j] = [];
                for (var i = 0; i < n; ++i) {
                  w5.push([
                    face2[i],
                    hexagon[(i * 2 + 2) % (2 * n)],
                    hexagon[(i * 2 + 1) % (2 * n)]
                  ]);
                  parents.push(j);
                  normals.push(cross(cartesian(hexagon[(i * 2 + 2) % (2 * n)]), cartesian(hexagon[(i * 2 + 1) % (2 * n)])));
                }
              });
              var faces = w5.map(function(face2) {
                return {
                  project: faceProjection(face2),
                  face: face2
                };
              });
              parents.forEach(function(d, i) {
                var parent = faces[d];
                parent && (parent.children || (parent.children = [])).push(faces[i]);
              });
              function face(lambda, phi) {
                var cosphi = cos(phi), p = [cosphi * cos(lambda), cosphi * sin(lambda), sin(phi)];
                var hexagon = lambda < -pi / 2 ? phi < 0 ? 6 : 4 : lambda < 0 ? phi < 0 ? 2 : 0 : lambda < pi / 2 ? phi < 0 ? 3 : 1 : phi < 0 ? 7 : 5;
                var n = cornerNormals[hexagon];
                return faces[dot(n[0], p) < 0 ? 8 + 3 * hexagon : dot(n[1], p) < 0 ? 8 + 3 * hexagon + 1 : dot(n[2], p) < 0 ? 8 + 3 * hexagon + 2 : hexagon];
              }
              return polyhedral(faces[0], face).scale(110.625).center([0, 45]);
            };
            function dot(a, b) {
              for (var i = 0, n = a.length, s = 0; i < n; ++i)
                s += a[i] * b[i];
              return s;
            }
            function cross(a, b) {
              return [
                a[1] * b[2] - a[2] * b[1],
                a[2] * b[0] - a[0] * b[2],
                a[0] * b[1] - a[1] * b[0]
              ];
            }
            function spherical(cartesian2) {
              return [
                atan2(cartesian2[1], cartesian2[0]) * degrees,
                asin(max(-1, min(1, cartesian2[2]))) * degrees
              ];
            }
            function cartesian(coordinates) {
              var lambda = coordinates[0] * radians, phi = coordinates[1] * radians, cosphi = cos(phi);
              return [
                cosphi * cos(lambda),
                cosphi * sin(lambda),
                sin(phi)
              ];
            }
            var noop = function() {
            };
            var clockwise = function(ring) {
              if ((n = ring.length) < 4)
                return false;
              var i = 0, n, area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
              while (++i < n)
                area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
              return area <= 0;
            };
            var contains = function(ring, point) {
              var x = point[0], y = point[1], contains2 = false;
              for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
                var pi2 = ring[i], xi = pi2[0], yi = pi2[1], pj = ring[j], xj = pj[0], yj = pj[1];
                if (yi > y ^ yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi)
                  contains2 = !contains2;
              }
              return contains2;
            };
            var index = function(object, projection) {
              var stream = projection.stream, project;
              if (!stream)
                throw new Error("invalid projection");
              switch (object && object.type) {
                case "Feature":
                  project = projectFeature;
                  break;
                case "FeatureCollection":
                  project = projectFeatureCollection;
                  break;
                default:
                  project = projectGeometry;
                  break;
              }
              return project(object, stream);
            };
            function projectFeatureCollection(o, stream) {
              return {
                type: "FeatureCollection",
                features: o.features.map(function(f) {
                  return projectFeature(f, stream);
                })
              };
            }
            function projectFeature(o, stream) {
              return {
                type: "Feature",
                id: o.id,
                properties: o.properties,
                geometry: projectGeometry(o.geometry, stream)
              };
            }
            function projectGeometryCollection(o, stream) {
              return {
                type: "GeometryCollection",
                geometries: o.geometries.map(function(o2) {
                  return projectGeometry(o2, stream);
                })
              };
            }
            function projectGeometry(o, stream) {
              if (!o)
                return null;
              if (o.type === "GeometryCollection")
                return projectGeometryCollection(o, stream);
              var sink;
              switch (o.type) {
                case "Point":
                  sink = sinkPoint;
                  break;
                case "MultiPoint":
                  sink = sinkPoint;
                  break;
                case "LineString":
                  sink = sinkLine;
                  break;
                case "MultiLineString":
                  sink = sinkLine;
                  break;
                case "Polygon":
                  sink = sinkPolygon;
                  break;
                case "MultiPolygon":
                  sink = sinkPolygon;
                  break;
                case "Sphere":
                  sink = sinkPolygon;
                  break;
                default:
                  return null;
              }
              d3Geo.geoStream(o, stream(sink));
              return sink.result();
            }
            var points = [];
            var lines = [];
            var sinkPoint = {
              point: function(x, y) {
                points.push([x, y]);
              },
              result: function() {
                var result = !points.length ? null : points.length < 2 ? { type: "Point", coordinates: points[0] } : { type: "MultiPoint", coordinates: points };
                points = [];
                return result;
              }
            };
            var sinkLine = {
              lineStart: noop,
              point: function(x, y) {
                points.push([x, y]);
              },
              lineEnd: function() {
                if (points.length)
                  lines.push(points), points = [];
              },
              result: function() {
                var result = !lines.length ? null : lines.length < 2 ? { type: "LineString", coordinates: lines[0] } : { type: "MultiLineString", coordinates: lines };
                lines = [];
                return result;
              }
            };
            var sinkPolygon = {
              polygonStart: noop,
              lineStart: noop,
              point: function(x, y) {
                points.push([x, y]);
              },
              lineEnd: function() {
                var n = points.length;
                if (n) {
                  do
                    points.push(points[0].slice());
                  while (++n < 4);
                  lines.push(points), points = [];
                }
              },
              polygonEnd: noop,
              result: function() {
                if (!lines.length)
                  return null;
                var polygons = [], holes = [];
                lines.forEach(function(ring) {
                  if (clockwise(ring))
                    polygons.push([ring]);
                  else
                    holes.push(ring);
                });
                holes.forEach(function(hole) {
                  var point = hole[0];
                  polygons.some(function(polygon) {
                    if (contains(polygon[0], point)) {
                      polygon.push(hole);
                      return true;
                    }
                  }) || polygons.push([hole]);
                });
                lines = [];
                return !polygons.length ? null : polygons.length > 1 ? { type: "MultiPolygon", coordinates: polygons } : { type: "Polygon", coordinates: polygons[0] };
              }
            };
            var quincuncial = function(project) {
              var dx = project(halfPi, 0)[0] - project(-halfPi, 0)[0];
              function projectQuincuncial(lambda, phi) {
                var t = abs(lambda) < halfPi, p = project(t ? lambda : lambda > 0 ? lambda - pi : lambda + pi, phi), x = (p[0] - p[1]) * sqrt1_2, y = (p[0] + p[1]) * sqrt1_2;
                if (t)
                  return [x, y];
                var d = dx * sqrt1_2, s = x > 0 ^ y > 0 ? -1 : 1;
                return [s * x - sign(y) * d, s * y - sign(x) * d];
              }
              if (project.invert)
                projectQuincuncial.invert = function(x02, y02) {
                  var x = (x02 + y02) * sqrt1_2, y = (y02 - x02) * sqrt1_2, t = abs(x) < 0.5 * dx && abs(y) < 0.5 * dx;
                  if (!t) {
                    var d = dx * sqrt1_2, s = x > 0 ^ y > 0 ? -1 : 1, x12 = -s * x02 + (y > 0 ? 1 : -1) * d, y12 = -s * y02 + (x > 0 ? 1 : -1) * d;
                    x = (-x12 - y12) * sqrt1_2;
                    y = (x12 - y12) * sqrt1_2;
                  }
                  var p = project.invert(x, y);
                  if (!t)
                    p[0] += x > 0 ? pi : -pi;
                  return p;
                };
              return d3Geo.geoProjection(projectQuincuncial).rotate([-90, -90, 45]).clipAngle(180 - 1e-3);
            };
            var gringorten$1 = function() {
              return quincuncial(gringortenRaw).scale(176.423);
            };
            var peirce = function() {
              return quincuncial(guyouRaw).scale(111.48);
            };
            var quantize = function(input, digits) {
              if (!(0 <= (digits = +digits) && digits <= 20))
                throw new Error("invalid digits");
              function quantizePoint(input2) {
                var n = input2.length, i = 2, output2 = new Array(n);
                output2[0] = +input2[0].toFixed(digits);
                output2[1] = +input2[1].toFixed(digits);
                while (i < n)
                  output2[i] = input2[i], ++i;
                return output2;
              }
              function quantizePoints(input2) {
                return input2.map(quantizePoint);
              }
              function quantizePolygon(input2) {
                return input2.map(quantizePoints);
              }
              function quantizeGeometry(input2) {
                if (input2 == null)
                  return input2;
                var output2;
                switch (input2.type) {
                  case "GeometryCollection":
                    output2 = { type: "GeometryCollection", geometries: input2.geometries.map(quantizeGeometry) };
                    break;
                  case "Point":
                    output2 = { type: "Point", coordinates: quantizePoint(input2.coordinates) };
                    break;
                  case "MultiPoint":
                  case "LineString":
                    output2 = { type: input2.type, coordinates: quantizePoints(input2.coordinates) };
                    break;
                  case "MultiLineString":
                  case "Polygon":
                    output2 = { type: input2.type, coordinates: quantizePolygon(input2.coordinates) };
                    break;
                  case "MultiPolygon":
                    output2 = { type: "MultiPolygon", coordinates: input2.coordinates.map(quantizePolygon) };
                    break;
                  default:
                    return input2;
                }
                if (input2.bbox != null)
                  output2.bbox = input2.bbox;
                return output2;
              }
              function quantizeFeature(input2) {
                var output2 = { type: "Feature", properties: input2.properties, geometry: quantizeGeometry(input2.geometry) };
                if (input2.id != null)
                  output2.id = input2.id;
                if (input2.bbox != null)
                  output2.bbox = input2.bbox;
                return output2;
              }
              if (input != null)
                switch (input.type) {
                  case "Feature":
                    return quantizeFeature(input);
                  case "FeatureCollection": {
                    var output = { type: "FeatureCollection", features: input.features.map(quantizeFeature) };
                    if (input.bbox != null)
                      output.bbox = input.bbox;
                    return output;
                  }
                  default:
                    return quantizeGeometry(input);
                }
              return input;
            };
            function rectangularPolyconicRaw(phi02) {
              var sinPhi0 = sin(phi02);
              function forward(lambda, phi) {
                var A2 = sinPhi0 ? tan(lambda * sinPhi0 / 2) / sinPhi0 : lambda / 2;
                if (!phi)
                  return [2 * A2, -phi02];
                var E = 2 * atan(A2 * sin(phi)), cotPhi = 1 / tan(phi);
                return [
                  sin(E) * cotPhi,
                  phi + (1 - cos(E)) * cotPhi - phi02
                ];
              }
              forward.invert = function(x, y) {
                if (abs(y += phi02) < epsilon)
                  return [sinPhi0 ? 2 * atan(sinPhi0 * x / 2) / sinPhi0 : x, 0];
                var k2 = x * x + y * y, phi = 0, i = 10, delta;
                do {
                  var tanPhi = tan(phi), secPhi = 1 / cos(phi), j = k2 - 2 * y * phi + phi * phi;
                  phi -= delta = (tanPhi * j + 2 * (phi - y)) / (2 + j * secPhi * secPhi + 2 * (phi - y) * tanPhi);
                } while (abs(delta) > epsilon && --i > 0);
                var E = x * (tanPhi = tan(phi)), A2 = tan(abs(y) < abs(phi + 1 / tanPhi) ? asin(E) * 0.5 : acos(E) * 0.5 + pi / 4) / sin(phi);
                return [
                  sinPhi0 ? 2 * atan(sinPhi0 * A2) / sinPhi0 : 2 * A2,
                  phi
                ];
              };
              return forward;
            }
            var rectangularPolyconic = function() {
              return parallel1(rectangularPolyconicRaw).scale(131.215);
            };
            var K = [
              [0.9986, -0.062],
              [1, 0],
              [0.9986, 0.062],
              [0.9954, 0.124],
              [0.99, 0.186],
              [0.9822, 0.248],
              [0.973, 0.31],
              [0.96, 0.372],
              [0.9427, 0.434],
              [0.9216, 0.4958],
              [0.8962, 0.5571],
              [0.8679, 0.6176],
              [0.835, 0.6769],
              [0.7986, 0.7346],
              [0.7597, 0.7903],
              [0.7186, 0.8435],
              [0.6732, 0.8936],
              [0.6213, 0.9394],
              [0.5722, 0.9761],
              [0.5322, 1]
            ];
            K.forEach(function(d) {
              d[1] *= 1.0144;
            });
            function robinsonRaw(lambda, phi) {
              var i = min(18, abs(phi) * 36 / pi), i0 = floor(i), di = i - i0, ax = (k2 = K[i0])[0], ay = k2[1], bx = (k2 = K[++i0])[0], by = k2[1], cx = (k2 = K[min(19, ++i0)])[0], cy = k2[1], k2;
              return [
                lambda * (bx + di * (cx - ax) / 2 + di * di * (cx - 2 * bx + ax) / 2),
                (phi > 0 ? halfPi : -halfPi) * (by + di * (cy - ay) / 2 + di * di * (cy - 2 * by + ay) / 2)
              ];
            }
            robinsonRaw.invert = function(x, y) {
              var yy = y / halfPi, phi = yy * 90, i = min(18, abs(phi / 5)), i0 = max(0, floor(i));
              do {
                var ay = K[i0][1], by = K[i0 + 1][1], cy = K[min(19, i0 + 2)][1], u = cy - ay, v = cy - 2 * by + ay, t = 2 * (abs(yy) - by) / u, c = v / u, di = t * (1 - c * t * (1 - 2 * c * t));
                if (di >= 0 || i0 === 1) {
                  phi = (y >= 0 ? 5 : -5) * (di + i);
                  var j = 50, delta;
                  do {
                    i = min(18, abs(phi) / 5);
                    i0 = floor(i);
                    di = i - i0;
                    ay = K[i0][1];
                    by = K[i0 + 1][1];
                    cy = K[min(19, i0 + 2)][1];
                    phi -= (delta = (y >= 0 ? halfPi : -halfPi) * (by + di * (cy - ay) / 2 + di * di * (cy - 2 * by + ay) / 2) - y) * degrees;
                  } while (abs(delta) > epsilon2 && --j > 0);
                  break;
                }
              } while (--i0 >= 0);
              var ax = K[i0][0], bx = K[i0 + 1][0], cx = K[min(19, i0 + 2)][0];
              return [
                x / (bx + di * (cx - ax) / 2 + di * di * (cx - 2 * bx + ax) / 2),
                phi * radians
              ];
            };
            var robinson = function() {
              return d3Geo.geoProjection(robinsonRaw).scale(152.63);
            };
            function satelliteVerticalRaw(P) {
              function forward(lambda, phi) {
                var cosPhi = cos(phi), k2 = (P - 1) / (P - cosPhi * cos(lambda));
                return [
                  k2 * cosPhi * sin(lambda),
                  k2 * sin(phi)
                ];
              }
              forward.invert = function(x, y) {
                var rho2 = x * x + y * y, rho = sqrt(rho2), sinc = (P - sqrt(1 - rho2 * (P + 1) / (P - 1))) / ((P - 1) / rho + rho / (P - 1));
                return [
                  atan2(x * sinc, rho * sqrt(1 - sinc * sinc)),
                  rho ? asin(y * sinc / rho) : 0
                ];
              };
              return forward;
            }
            function satelliteRaw(P, omega) {
              var vertical = satelliteVerticalRaw(P);
              if (!omega)
                return vertical;
              var cosOmega = cos(omega), sinOmega = sin(omega);
              function forward(lambda, phi) {
                var coordinates = vertical(lambda, phi), y = coordinates[1], A2 = y * sinOmega / (P - 1) + cosOmega;
                return [
                  coordinates[0] * cosOmega / A2,
                  y / A2
                ];
              }
              forward.invert = function(x, y) {
                var k2 = (P - 1) / (P - 1 - y * sinOmega);
                return vertical.invert(k2 * x, k2 * y * cosOmega);
              };
              return forward;
            }
            var satellite = function() {
              var distance2 = 2, omega = 0, m = d3Geo.geoProjectionMutator(satelliteRaw), p = m(distance2, omega);
              p.distance = function(_) {
                if (!arguments.length)
                  return distance2;
                return m(distance2 = +_, omega);
              };
              p.tilt = function(_) {
                if (!arguments.length)
                  return omega * degrees;
                return m(distance2, omega = _ * radians);
              };
              return p.scale(432.147).clipAngle(acos(1 / distance2) * degrees - 1e-6);
            };
            var epsilon$1 = 1e-4;
            var epsilonInverse = 1e4;
            var x0 = -180;
            var x0e = x0 + epsilon$1;
            var x1 = 180;
            var x1e = x1 - epsilon$1;
            var y0 = -90;
            var y0e = y0 + epsilon$1;
            var y1 = 90;
            var y1e = y1 - epsilon$1;
            function nonempty(coordinates) {
              return coordinates.length > 0;
            }
            function quantize$1(x) {
              return Math.floor(x * epsilonInverse) / epsilonInverse;
            }
            function normalizePoint(y) {
              return y === y0 || y === y1 ? [0, y] : [x0, quantize$1(y)];
            }
            function clampPoint(p) {
              var x = p[0], y = p[1], clamped = false;
              if (x <= x0e)
                x = x0, clamped = true;
              else if (x >= x1e)
                x = x1, clamped = true;
              if (y <= y0e)
                y = y0, clamped = true;
              else if (y >= y1e)
                y = y1, clamped = true;
              return clamped ? [x, y] : p;
            }
            function clampPoints(points2) {
              return points2.map(clampPoint);
            }
            function extractFragments(rings, polygon, fragments) {
              for (var j = 0, m = rings.length; j < m; ++j) {
                var ring = rings[j].slice();
                fragments.push({ index: -1, polygon, ring });
                for (var i = 0, n = ring.length; i < n; ++i) {
                  var point = ring[i], x = point[0], y = point[1];
                  if (x <= x0e || x >= x1e || y <= y0e || y >= y1e) {
                    ring[i] = clampPoint(point);
                    for (var k2 = i + 1; k2 < n; ++k2) {
                      var pointk = ring[k2], xk = pointk[0], yk = pointk[1];
                      if (xk > x0e && xk < x1e && yk > y0e && yk < y1e)
                        break;
                    }
                    if (k2 === i + 1)
                      continue;
                    if (i) {
                      var fragmentBefore = { index: -1, polygon, ring: ring.slice(0, i + 1) };
                      fragmentBefore.ring[fragmentBefore.ring.length - 1] = normalizePoint(y);
                      fragments[fragments.length - 1] = fragmentBefore;
                    } else
                      fragments.pop();
                    if (k2 >= n)
                      break;
                    fragments.push({ index: -1, polygon, ring: ring = ring.slice(k2 - 1) });
                    ring[0] = normalizePoint(ring[0][1]);
                    i = -1;
                    n = ring.length;
                  }
                }
              }
            }
            function stitchFragments(fragments) {
              var i, n = fragments.length;
              var fragmentByStart = {}, fragmentByEnd = {}, fragment, start, startFragment, end, endFragment;
              for (i = 0; i < n; ++i) {
                fragment = fragments[i];
                start = fragment.ring[0];
                end = fragment.ring[fragment.ring.length - 1];
                if (start[0] === end[0] && start[1] === end[1]) {
                  fragment.polygon.push(fragment.ring);
                  fragments[i] = null;
                  continue;
                }
                fragment.index = i;
                fragmentByStart[start] = fragmentByEnd[end] = fragment;
              }
              for (i = 0; i < n; ++i) {
                fragment = fragments[i];
                if (fragment) {
                  start = fragment.ring[0];
                  end = fragment.ring[fragment.ring.length - 1];
                  startFragment = fragmentByEnd[start];
                  endFragment = fragmentByStart[end];
                  delete fragmentByStart[start];
                  delete fragmentByEnd[end];
                  if (start[0] === end[0] && start[1] === end[1]) {
                    fragment.polygon.push(fragment.ring);
                    continue;
                  }
                  if (startFragment) {
                    delete fragmentByEnd[start];
                    delete fragmentByStart[startFragment.ring[0]];
                    startFragment.ring.pop();
                    fragments[startFragment.index] = null;
                    fragment = { index: -1, polygon: startFragment.polygon, ring: startFragment.ring.concat(fragment.ring) };
                    if (startFragment === endFragment) {
                      fragment.polygon.push(fragment.ring);
                    } else {
                      fragment.index = n++;
                      fragments.push(fragmentByStart[fragment.ring[0]] = fragmentByEnd[fragment.ring[fragment.ring.length - 1]] = fragment);
                    }
                  } else if (endFragment) {
                    delete fragmentByStart[end];
                    delete fragmentByEnd[endFragment.ring[endFragment.ring.length - 1]];
                    fragment.ring.pop();
                    fragment = { index: n++, polygon: endFragment.polygon, ring: fragment.ring.concat(endFragment.ring) };
                    fragments[endFragment.index] = null;
                    fragments.push(fragmentByStart[fragment.ring[0]] = fragmentByEnd[fragment.ring[fragment.ring.length - 1]] = fragment);
                  } else {
                    fragment.ring.push(fragment.ring[0]);
                    fragment.polygon.push(fragment.ring);
                  }
                }
              }
            }
            function stitchFeature(input) {
              var output = { type: "Feature", geometry: stitchGeometry(input.geometry) };
              if (input.id != null)
                output.id = input.id;
              if (input.bbox != null)
                output.bbox = input.bbox;
              if (input.properties != null)
                output.properties = input.properties;
              return output;
            }
            function stitchGeometry(input) {
              if (input == null)
                return input;
              var output, fragments, i, n;
              switch (input.type) {
                case "GeometryCollection":
                  output = { type: "GeometryCollection", geometries: input.geometries.map(stitchGeometry) };
                  break;
                case "Point":
                  output = { type: "Point", coordinates: clampPoint(input.coordinates) };
                  break;
                case "MultiPoint":
                case "LineString":
                  output = { type: input.type, coordinates: clampPoints(input.coordinates) };
                  break;
                case "MultiLineString":
                  output = { type: "MultiLineString", coordinates: input.coordinates.map(clampPoints) };
                  break;
                case "Polygon": {
                  var polygon = [];
                  extractFragments(input.coordinates, polygon, fragments = []);
                  stitchFragments(fragments);
                  output = { type: "Polygon", coordinates: polygon };
                  break;
                }
                case "MultiPolygon": {
                  fragments = [], i = -1, n = input.coordinates.length;
                  var polygons = new Array(n);
                  while (++i < n)
                    extractFragments(input.coordinates[i], polygons[i] = [], fragments);
                  stitchFragments(fragments);
                  output = { type: "MultiPolygon", coordinates: polygons.filter(nonempty) };
                  break;
                }
                default:
                  return input;
              }
              if (input.bbox != null)
                output.bbox = input.bbox;
              return output;
            }
            var stitch = function(input) {
              if (input == null)
                return input;
              switch (input.type) {
                case "Feature":
                  return stitchFeature(input);
                case "FeatureCollection": {
                  var output = { type: "FeatureCollection", features: input.features.map(stitchFeature) };
                  if (input.bbox != null)
                    output.bbox = input.bbox;
                  return output;
                }
                default:
                  return stitchGeometry(input);
              }
            };
            function timesRaw(lambda, phi) {
              var t = tan(phi / 2), s = sin(quarterPi * t);
              return [
                lambda * (0.74482 - 0.34588 * s * s),
                1.70711 * t
              ];
            }
            timesRaw.invert = function(x, y) {
              var t = y / 1.70711, s = sin(quarterPi * t);
              return [
                x / (0.74482 - 0.34588 * s * s),
                2 * atan(t)
              ];
            };
            var times = function() {
              return d3Geo.geoProjection(timesRaw).scale(146.153);
            };
            var twoPoint = function(raw, p0, p1) {
              var i = d3Geo.geoInterpolate(p0, p1), o = i(0.5), a = d3Geo.geoRotation([-o[0], -o[1]])(p0), b = i.distance / 2, y = -asin(sin(a[1] * radians) / sin(b)), R = [-o[0], -o[1], -(a[0] > 0 ? pi - y : y) * degrees], p = d3Geo.geoProjection(raw(b)).rotate(R), r = d3Geo.geoRotation(R), center = p.center;
              delete p.rotate;
              p.center = function(_) {
                return arguments.length ? center(r(_)) : r.invert(center());
              };
              return p.clipAngle(90);
            };
            function twoPointAzimuthalRaw(d) {
              var cosd = cos(d);
              function forward(lambda, phi) {
                var coordinates = d3Geo.geoGnomonicRaw(lambda, phi);
                coordinates[0] *= cosd;
                return coordinates;
              }
              forward.invert = function(x, y) {
                return d3Geo.geoGnomonicRaw.invert(x / cosd, y);
              };
              return forward;
            }
            function twoPointAzimuthalUsa() {
              return twoPointAzimuthal([-158, 21.5], [-77, 39]).clipAngle(60).scale(400);
            }
            function twoPointAzimuthal(p0, p1) {
              return twoPoint(twoPointAzimuthalRaw, p0, p1);
            }
            function twoPointEquidistantRaw(z0) {
              if (!(z0 *= 2))
                return d3Geo.geoAzimuthalEquidistantRaw;
              var lambdaa = -z0 / 2, lambdab = -lambdaa, z02 = z0 * z0, tanLambda0 = tan(lambdab), S = 0.5 / sin(lambdab);
              function forward(lambda, phi) {
                var za = acos(cos(phi) * cos(lambda - lambdaa)), zb = acos(cos(phi) * cos(lambda - lambdab)), ys = phi < 0 ? -1 : 1;
                za *= za, zb *= zb;
                return [
                  (za - zb) / (2 * z0),
                  ys * sqrt(4 * z02 * zb - (z02 - za + zb) * (z02 - za + zb)) / (2 * z0)
                ];
              }
              forward.invert = function(x, y) {
                var y2 = y * y, cosza = cos(sqrt(y2 + (t = x + lambdaa) * t)), coszb = cos(sqrt(y2 + (t = x + lambdab) * t)), t, d;
                return [
                  atan2(d = cosza - coszb, t = (cosza + coszb) * tanLambda0),
                  (y < 0 ? -1 : 1) * acos(sqrt(t * t + d * d) * S)
                ];
              };
              return forward;
            }
            function twoPointEquidistantUsa() {
              return twoPointEquidistant([-158, 21.5], [-77, 39]).clipAngle(130).scale(122.571);
            }
            function twoPointEquidistant(p0, p1) {
              return twoPoint(twoPointEquidistantRaw, p0, p1);
            }
            function vanDerGrintenRaw(lambda, phi) {
              if (abs(phi) < epsilon)
                return [lambda, 0];
              var sinTheta = abs(phi / halfPi), theta = asin(sinTheta);
              if (abs(lambda) < epsilon || abs(abs(phi) - halfPi) < epsilon)
                return [0, sign(phi) * pi * tan(theta / 2)];
              var cosTheta = cos(theta), A2 = abs(pi / lambda - lambda / pi) / 2, A22 = A2 * A2, G = cosTheta / (sinTheta + cosTheta - 1), P = G * (2 / sinTheta - 1), P2 = P * P, P2_A2 = P2 + A22, G_P2 = G - P2, Q = A22 + G;
              return [
                sign(lambda) * pi * (A2 * G_P2 + sqrt(A22 * G_P2 * G_P2 - P2_A2 * (G * G - P2))) / P2_A2,
                sign(phi) * pi * (P * Q - A2 * sqrt((A22 + 1) * P2_A2 - Q * Q)) / P2_A2
              ];
            }
            vanDerGrintenRaw.invert = function(x, y) {
              if (abs(y) < epsilon)
                return [x, 0];
              if (abs(x) < epsilon)
                return [0, halfPi * sin(2 * atan(y / pi))];
              var x2 = (x /= pi) * x, y2 = (y /= pi) * y, x2_y2 = x2 + y2, z = x2_y2 * x2_y2, c1 = -abs(y) * (1 + x2_y2), c2 = c1 - 2 * y2 + x2, c3 = -2 * c1 + 1 + 2 * y2 + z, d = y2 / c3 + (2 * c2 * c2 * c2 / (c3 * c3 * c3) - 9 * c1 * c2 / (c3 * c3)) / 27, a1 = (c1 - c2 * c2 / (3 * c3)) / c3, m1 = 2 * sqrt(-a1 / 3), theta1 = acos(3 * d / (a1 * m1)) / 3;
              return [
                pi * (x2_y2 - 1 + sqrt(1 + 2 * (x2 - y2) + z)) / (2 * x),
                sign(y) * pi * (-m1 * cos(theta1 + pi / 3) - c2 / (3 * c3))
              ];
            };
            var vanDerGrinten = function() {
              return d3Geo.geoProjection(vanDerGrintenRaw).scale(79.4183);
            };
            function vanDerGrinten2Raw(lambda, phi) {
              if (abs(phi) < epsilon)
                return [lambda, 0];
              var sinTheta = abs(phi / halfPi), theta = asin(sinTheta);
              if (abs(lambda) < epsilon || abs(abs(phi) - halfPi) < epsilon)
                return [0, sign(phi) * pi * tan(theta / 2)];
              var cosTheta = cos(theta), A2 = abs(pi / lambda - lambda / pi) / 2, A22 = A2 * A2, x12 = cosTheta * (sqrt(1 + A22) - A2 * cosTheta) / (1 + A22 * sinTheta * sinTheta);
              return [
                sign(lambda) * pi * x12,
                sign(phi) * pi * sqrt(1 - x12 * (2 * A2 + x12))
              ];
            }
            vanDerGrinten2Raw.invert = function(x, y) {
              if (!x)
                return [0, halfPi * sin(2 * atan(y / pi))];
              var x12 = abs(x / pi), A2 = (1 - x12 * x12 - (y /= pi) * y) / (2 * x12), A22 = A2 * A2, B2 = sqrt(A22 + 1);
              return [
                sign(x) * pi * (B2 - A2),
                sign(y) * halfPi * sin(2 * atan2(sqrt((1 - 2 * A2 * x12) * (A2 + B2) - x12), sqrt(B2 + A2 + x12)))
              ];
            };
            var vanDerGrinten2 = function() {
              return d3Geo.geoProjection(vanDerGrinten2Raw).scale(79.4183);
            };
            function vanDerGrinten3Raw(lambda, phi) {
              if (abs(phi) < epsilon)
                return [lambda, 0];
              var sinTheta = phi / halfPi, theta = asin(sinTheta);
              if (abs(lambda) < epsilon || abs(abs(phi) - halfPi) < epsilon)
                return [0, pi * tan(theta / 2)];
              var A2 = (pi / lambda - lambda / pi) / 2, y12 = sinTheta / (1 + cos(theta));
              return [
                pi * (sign(lambda) * sqrt(A2 * A2 + 1 - y12 * y12) - A2),
                pi * y12
              ];
            }
            vanDerGrinten3Raw.invert = function(x, y) {
              if (!y)
                return [x, 0];
              var y12 = y / pi, A2 = (pi * pi * (1 - y12 * y12) - x * x) / (2 * pi * x);
              return [
                x ? pi * (sign(x) * sqrt(A2 * A2 + 1) - A2) : 0,
                halfPi * sin(2 * atan(y12))
              ];
            };
            var vanDerGrinten3 = function() {
              return d3Geo.geoProjection(vanDerGrinten3Raw).scale(79.4183);
            };
            function vanDerGrinten4Raw(lambda, phi) {
              if (!phi)
                return [lambda, 0];
              var phi02 = abs(phi);
              if (!lambda || phi02 === halfPi)
                return [0, phi];
              var B2 = phi02 / halfPi, B22 = B2 * B2, C = (8 * B2 - B22 * (B22 + 2) - 5) / (2 * B22 * (B2 - 1)), C2 = C * C, BC = B2 * C, B_C2 = B22 + C2 + 2 * BC, B_3C = B2 + 3 * C, lambda0 = lambda / halfPi, lambda1 = lambda0 + 1 / lambda0, D = sign(abs(lambda) - halfPi) * sqrt(lambda1 * lambda1 - 4), D2 = D * D, F = B_C2 * (B22 + C2 * D2 - 1) + (1 - B22) * (B22 * (B_3C * B_3C + 4 * C2) + 12 * BC * C2 + 4 * C2 * C2), x12 = (D * (B_C2 + C2 - 1) + 2 * sqrt(F)) / (4 * B_C2 + D2);
              return [
                sign(lambda) * halfPi * x12,
                sign(phi) * halfPi * sqrt(1 + D * abs(x12) - x12 * x12)
              ];
            }
            vanDerGrinten4Raw.invert = function(x, y) {
              var delta;
              if (!x || !y)
                return [x, y];
              y /= pi;
              var x12 = sign(x) * x / halfPi, D = (x12 * x12 - 1 + 4 * y * y) / abs(x12), D2 = D * D, B2 = 2 * y, i = 50;
              do {
                var B22 = B2 * B2, C = (8 * B2 - B22 * (B22 + 2) - 5) / (2 * B22 * (B2 - 1)), C_ = (3 * B2 - B22 * B2 - 10) / (2 * B22 * B2), C2 = C * C, BC = B2 * C, B_C = B2 + C, B_C2 = B_C * B_C, B_3C = B2 + 3 * C, F = B_C2 * (B22 + C2 * D2 - 1) + (1 - B22) * (B22 * (B_3C * B_3C + 4 * C2) + C2 * (12 * BC + 4 * C2)), F_ = -2 * B_C * (4 * BC * C2 + (1 - 4 * B22 + 3 * B22 * B22) * (1 + C_) + C2 * (-6 + 14 * B22 - D2 + (-8 + 8 * B22 - 2 * D2) * C_) + BC * (-8 + 12 * B22 + (-10 + 10 * B22 - D2) * C_)), sqrtF = sqrt(F), f = D * (B_C2 + C2 - 1) + 2 * sqrtF - x12 * (4 * B_C2 + D2), f_ = D * (2 * C * C_ + 2 * B_C * (1 + C_)) + F_ / sqrtF - 8 * B_C * (D * (-1 + C2 + B_C2) + 2 * sqrtF) * (1 + C_) / (D2 + 4 * B_C2);
                B2 -= delta = f / f_;
              } while (delta > epsilon && --i > 0);
              return [
                sign(x) * (sqrt(D * D + 4) + D) * pi / 4,
                halfPi * B2
              ];
            };
            var vanDerGrinten4 = function() {
              return d3Geo.geoProjection(vanDerGrinten4Raw).scale(127.16);
            };
            var A = 4 * pi + 3 * sqrt(3);
            var B = 2 * sqrt(2 * pi * sqrt(3) / A);
            var wagner4Raw = mollweideBromleyRaw(B * sqrt(3) / pi, B, A / 6);
            var wagner4 = function() {
              return d3Geo.geoProjection(wagner4Raw).scale(176.84);
            };
            function wagner6Raw(lambda, phi) {
              return [lambda * sqrt(1 - 3 * phi * phi / (pi * pi)), phi];
            }
            wagner6Raw.invert = function(x, y) {
              return [x / sqrt(1 - 3 * y * y / (pi * pi)), y];
            };
            var wagner6 = function() {
              return d3Geo.geoProjection(wagner6Raw).scale(152.63);
            };
            function wagner7Raw(lambda, phi) {
              var s = 0.90631 * sin(phi), c0 = sqrt(1 - s * s), c1 = sqrt(2 / (1 + c0 * cos(lambda /= 3)));
              return [
                2.66723 * c0 * c1 * sin(lambda),
                1.24104 * s * c1
              ];
            }
            wagner7Raw.invert = function(x, y) {
              var t1 = x / 2.66723, t2 = y / 1.24104, p = sqrt(t1 * t1 + t2 * t2), c = 2 * asin(p / 2);
              return [
                3 * atan2(x * tan(c), 2.66723 * p),
                p && asin(y * sin(c) / (1.24104 * 0.90631 * p))
              ];
            };
            var wagner7 = function() {
              return d3Geo.geoProjection(wagner7Raw).scale(172.632);
            };
            function wiechelRaw(lambda, phi) {
              var cosPhi = cos(phi), sinPhi = cos(lambda) * cosPhi, sin1_Phi = 1 - sinPhi, cosLambda = cos(lambda = atan2(sin(lambda) * cosPhi, -sin(phi))), sinLambda = sin(lambda);
              cosPhi = sqrt(1 - sinPhi * sinPhi);
              return [
                sinLambda * cosPhi - cosLambda * sin1_Phi,
                -cosLambda * cosPhi - sinLambda * sin1_Phi
              ];
            }
            wiechelRaw.invert = function(x, y) {
              var w2 = (x * x + y * y) / -2, k2 = sqrt(-w2 * (2 + w2)), b = y * w2 + x * k2, a = x * w2 - y * k2, D = sqrt(a * a + b * b);
              return [
                atan2(k2 * b, D * (1 + w2)),
                D ? -asin(k2 * a / D) : 0
              ];
            };
            var wiechel = function() {
              return d3Geo.geoProjection(wiechelRaw).rotate([0, -90, 45]).scale(124.75).clipAngle(180 - 1e-3);
            };
            function winkel3Raw(lambda, phi) {
              var coordinates = aitoffRaw(lambda, phi);
              return [
                (coordinates[0] + lambda / halfPi) / 2,
                (coordinates[1] + phi) / 2
              ];
            }
            winkel3Raw.invert = function(x, y) {
              var lambda = x, phi = y, i = 25;
              do {
                var cosphi = cos(phi), sinphi = sin(phi), sin_2phi = sin(2 * phi), sin2phi = sinphi * sinphi, cos2phi = cosphi * cosphi, sinlambda = sin(lambda), coslambda_2 = cos(lambda / 2), sinlambda_2 = sin(lambda / 2), sin2lambda_2 = sinlambda_2 * sinlambda_2, C = 1 - cos2phi * coslambda_2 * coslambda_2, E = C ? acos(cosphi * coslambda_2) * sqrt(F = 1 / C) : F = 0, F, fx = 0.5 * (2 * E * cosphi * sinlambda_2 + lambda / halfPi) - x, fy = 0.5 * (E * sinphi + phi) - y, dxdlambda = 0.5 * F * (cos2phi * sin2lambda_2 + E * cosphi * coslambda_2 * sin2phi) + 0.5 / halfPi, dxdphi = F * (sinlambda * sin_2phi / 4 - E * sinphi * sinlambda_2), dydlambda = 0.125 * F * (sin_2phi * sinlambda_2 - E * sinphi * cos2phi * sinlambda), dydphi = 0.5 * F * (sin2phi * coslambda_2 + E * sin2lambda_2 * cosphi) + 0.5, denominator = dxdphi * dydlambda - dydphi * dxdlambda, dlambda = (fy * dxdphi - fx * dydphi) / denominator, dphi = (fx * dydlambda - fy * dxdlambda) / denominator;
                lambda -= dlambda, phi -= dphi;
              } while ((abs(dlambda) > epsilon || abs(dphi) > epsilon) && --i > 0);
              return [lambda, phi];
            };
            var winkel3 = function() {
              return d3Geo.geoProjection(winkel3Raw).scale(158.837);
            };
            exports3.geoAiry = airy;
            exports3.geoAiryRaw = airyRaw;
            exports3.geoAitoff = aitoff;
            exports3.geoAitoffRaw = aitoffRaw;
            exports3.geoArmadillo = armadillo;
            exports3.geoArmadilloRaw = armadilloRaw;
            exports3.geoAugust = august;
            exports3.geoAugustRaw = augustRaw;
            exports3.geoBaker = baker;
            exports3.geoBakerRaw = bakerRaw;
            exports3.geoBerghaus = berghaus;
            exports3.geoBerghausRaw = berghausRaw;
            exports3.geoBoggs = boggs;
            exports3.geoBoggsRaw = boggsRaw;
            exports3.geoBonne = bonne;
            exports3.geoBonneRaw = bonneRaw;
            exports3.geoBottomley = bottomley;
            exports3.geoBottomleyRaw = bottomleyRaw;
            exports3.geoBromley = bromley;
            exports3.geoBromleyRaw = bromleyRaw;
            exports3.geoChamberlin = chamberlin;
            exports3.geoChamberlinRaw = chamberlinRaw;
            exports3.geoChamberlinAfrica = chamberlinAfrica;
            exports3.geoCollignon = collignon;
            exports3.geoCollignonRaw = collignonRaw;
            exports3.geoCraig = craig;
            exports3.geoCraigRaw = craigRaw;
            exports3.geoCraster = craster;
            exports3.geoCrasterRaw = crasterRaw;
            exports3.geoCylindricalEqualArea = cylindricalEqualArea;
            exports3.geoCylindricalEqualAreaRaw = cylindricalEqualAreaRaw;
            exports3.geoCylindricalStereographic = cylindricalStereographic;
            exports3.geoCylindricalStereographicRaw = cylindricalStereographicRaw;
            exports3.geoEckert1 = eckert1;
            exports3.geoEckert1Raw = eckert1Raw;
            exports3.geoEckert2 = eckert2;
            exports3.geoEckert2Raw = eckert2Raw;
            exports3.geoEckert3 = eckert3;
            exports3.geoEckert3Raw = eckert3Raw;
            exports3.geoEckert4 = eckert4;
            exports3.geoEckert4Raw = eckert4Raw;
            exports3.geoEckert5 = eckert5;
            exports3.geoEckert5Raw = eckert5Raw;
            exports3.geoEckert6 = eckert6;
            exports3.geoEckert6Raw = eckert6Raw;
            exports3.geoEisenlohr = eisenlohr;
            exports3.geoEisenlohrRaw = eisenlohrRaw;
            exports3.geoFahey = fahey;
            exports3.geoFaheyRaw = faheyRaw;
            exports3.geoFoucaut = foucaut;
            exports3.geoFoucautRaw = foucautRaw;
            exports3.geoGilbert = gilbert;
            exports3.geoGingery = gingery;
            exports3.geoGingeryRaw = gingeryRaw;
            exports3.geoGinzburg4 = ginzburg4;
            exports3.geoGinzburg4Raw = ginzburg4Raw;
            exports3.geoGinzburg5 = ginzburg5;
            exports3.geoGinzburg5Raw = ginzburg5Raw;
            exports3.geoGinzburg6 = ginzburg6;
            exports3.geoGinzburg6Raw = ginzburg6Raw;
            exports3.geoGinzburg8 = ginzburg8;
            exports3.geoGinzburg8Raw = ginzburg8Raw;
            exports3.geoGinzburg9 = ginzburg9;
            exports3.geoGinzburg9Raw = ginzburg9Raw;
            exports3.geoGringorten = gringorten;
            exports3.geoGringortenRaw = gringortenRaw;
            exports3.geoGuyou = guyou;
            exports3.geoGuyouRaw = guyouRaw;
            exports3.geoHammer = hammer;
            exports3.geoHammerRaw = hammerRaw;
            exports3.geoHammerRetroazimuthal = hammerRetroazimuthal;
            exports3.geoHammerRetroazimuthalRaw = hammerRetroazimuthalRaw;
            exports3.geoHealpix = healpix;
            exports3.geoHealpixRaw = healpixRaw;
            exports3.geoHill = hill;
            exports3.geoHillRaw = hillRaw;
            exports3.geoHomolosine = homolosine;
            exports3.geoHomolosineRaw = homolosineRaw;
            exports3.geoInterrupt = interrupt;
            exports3.geoInterruptedBoggs = boggs$1;
            exports3.geoInterruptedHomolosine = homolosine$1;
            exports3.geoInterruptedMollweide = mollweide$1;
            exports3.geoInterruptedMollweideHemispheres = mollweideHemispheres;
            exports3.geoInterruptedSinuMollweide = sinuMollweide$1;
            exports3.geoInterruptedSinusoidal = sinusoidal$1;
            exports3.geoKavrayskiy7 = kavrayskiy7;
            exports3.geoKavrayskiy7Raw = kavrayskiy7Raw;
            exports3.geoLagrange = lagrange;
            exports3.geoLagrangeRaw = lagrangeRaw;
            exports3.geoLarrivee = larrivee;
            exports3.geoLarriveeRaw = larriveeRaw;
            exports3.geoLaskowski = laskowski;
            exports3.geoLaskowskiRaw = laskowskiRaw;
            exports3.geoLittrow = littrow;
            exports3.geoLittrowRaw = littrowRaw;
            exports3.geoLoximuthal = loximuthal;
            exports3.geoLoximuthalRaw = loximuthalRaw;
            exports3.geoMiller = miller;
            exports3.geoMillerRaw = millerRaw;
            exports3.geoModifiedStereographic = modifiedStereographic;
            exports3.geoModifiedStereographicRaw = modifiedStereographicRaw;
            exports3.geoModifiedStereographicAlaska = modifiedStereographicAlaska;
            exports3.geoModifiedStereographicGs48 = modifiedStereographicGs48;
            exports3.geoModifiedStereographicGs50 = modifiedStereographicGs50;
            exports3.geoModifiedStereographicMiller = modifiedStereographicMiller;
            exports3.geoModifiedStereographicLee = modifiedStereographicLee;
            exports3.geoMollweide = mollweide;
            exports3.geoMollweideRaw = mollweideRaw;
            exports3.geoMtFlatPolarParabolic = mtFlatPolarParabolic;
            exports3.geoMtFlatPolarParabolicRaw = mtFlatPolarParabolicRaw;
            exports3.geoMtFlatPolarQuartic = mtFlatPolarQuartic;
            exports3.geoMtFlatPolarQuarticRaw = mtFlatPolarQuarticRaw;
            exports3.geoMtFlatPolarSinusoidal = mtFlatPolarSinusoidal;
            exports3.geoMtFlatPolarSinusoidalRaw = mtFlatPolarSinusoidalRaw;
            exports3.geoNaturalEarth = naturalEarth;
            exports3.geoNaturalEarthRaw = naturalEarthRaw;
            exports3.geoNaturalEarth2 = naturalEarth2;
            exports3.geoNaturalEarth2Raw = naturalEarth2Raw;
            exports3.geoNellHammer = nellHammer;
            exports3.geoNellHammerRaw = nellHammerRaw;
            exports3.geoPatterson = patterson;
            exports3.geoPattersonRaw = pattersonRaw;
            exports3.geoPolyconic = polyconic;
            exports3.geoPolyconicRaw = polyconicRaw;
            exports3.geoPolyhedral = polyhedral;
            exports3.geoPolyhedralButterfly = butterfly;
            exports3.geoPolyhedralCollignon = collignon$1;
            exports3.geoPolyhedralWaterman = waterman;
            exports3.geoProject = index;
            exports3.geoGringortenQuincuncial = gringorten$1;
            exports3.geoPeirceQuincuncial = peirce;
            exports3.geoPierceQuincuncial = peirce;
            exports3.geoQuantize = quantize;
            exports3.geoQuincuncial = quincuncial;
            exports3.geoRectangularPolyconic = rectangularPolyconic;
            exports3.geoRectangularPolyconicRaw = rectangularPolyconicRaw;
            exports3.geoRobinson = robinson;
            exports3.geoRobinsonRaw = robinsonRaw;
            exports3.geoSatellite = satellite;
            exports3.geoSatelliteRaw = satelliteRaw;
            exports3.geoSinuMollweide = sinuMollweide;
            exports3.geoSinuMollweideRaw = sinuMollweideRaw;
            exports3.geoSinusoidal = sinusoidal;
            exports3.geoSinusoidalRaw = sinusoidalRaw;
            exports3.geoStitch = stitch;
            exports3.geoTimes = times;
            exports3.geoTimesRaw = timesRaw;
            exports3.geoTwoPointAzimuthal = twoPointAzimuthal;
            exports3.geoTwoPointAzimuthalRaw = twoPointAzimuthalRaw;
            exports3.geoTwoPointAzimuthalUsa = twoPointAzimuthalUsa;
            exports3.geoTwoPointEquidistant = twoPointEquidistant;
            exports3.geoTwoPointEquidistantRaw = twoPointEquidistantRaw;
            exports3.geoTwoPointEquidistantUsa = twoPointEquidistantUsa;
            exports3.geoVanDerGrinten = vanDerGrinten;
            exports3.geoVanDerGrintenRaw = vanDerGrintenRaw;
            exports3.geoVanDerGrinten2 = vanDerGrinten2;
            exports3.geoVanDerGrinten2Raw = vanDerGrinten2Raw;
            exports3.geoVanDerGrinten3 = vanDerGrinten3;
            exports3.geoVanDerGrinten3Raw = vanDerGrinten3Raw;
            exports3.geoVanDerGrinten4 = vanDerGrinten4;
            exports3.geoVanDerGrinten4Raw = vanDerGrinten4Raw;
            exports3.geoWagner4 = wagner4;
            exports3.geoWagner4Raw = wagner4Raw;
            exports3.geoWagner6 = wagner6;
            exports3.geoWagner6Raw = wagner6Raw;
            exports3.geoWagner7 = wagner7;
            exports3.geoWagner7Raw = wagner7Raw;
            exports3.geoWiechel = wiechel;
            exports3.geoWiechelRaw = wiechelRaw;
            exports3.geoWinkel3 = winkel3;
            exports3.geoWinkel3Raw = winkel3Raw;
            Object.defineProperty(exports3, "__esModule", { value: true });
          });
        },
        "./node_modules/_d3-geo@1.12.1@d3-geo/dist/d3-geo.js": function(module2, exports2, __webpack_require__) {
          (function(global, factory) {
            true ? factory(exports2, __webpack_require__("./node_modules/_d3-array@1.2.4@d3-array/dist/d3-array.js")) : void 0;
          })(this, function(exports3, d3Array) {
            "use strict";
            function adder() {
              return new Adder();
            }
            function Adder() {
              this.reset();
            }
            Adder.prototype = {
              constructor: Adder,
              reset: function() {
                this.s = this.t = 0;
              },
              add: function(y) {
                add(temp, y, this.t);
                add(this, temp.s, this.s);
                if (this.s)
                  this.t += temp.t;
                else
                  this.s = temp.t;
              },
              valueOf: function() {
                return this.s;
              }
            };
            var temp = new Adder();
            function add(adder2, a, b) {
              var x = adder2.s = a + b, bv = x - a, av = x - bv;
              adder2.t = a - av + (b - bv);
            }
            var epsilon = 1e-6;
            var epsilon2 = 1e-12;
            var pi = Math.PI;
            var halfPi = pi / 2;
            var quarterPi = pi / 4;
            var tau = pi * 2;
            var degrees = 180 / pi;
            var radians = pi / 180;
            var abs = Math.abs;
            var atan = Math.atan;
            var atan2 = Math.atan2;
            var cos = Math.cos;
            var ceil = Math.ceil;
            var exp = Math.exp;
            var log = Math.log;
            var pow = Math.pow;
            var sin = Math.sin;
            var sign = Math.sign || function(x) {
              return x > 0 ? 1 : x < 0 ? -1 : 0;
            };
            var sqrt = Math.sqrt;
            var tan = Math.tan;
            function acos(x) {
              return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
            }
            function asin(x) {
              return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
            }
            function haversin(x) {
              return (x = sin(x / 2)) * x;
            }
            function noop() {
            }
            function streamGeometry(geometry, stream) {
              if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
                streamGeometryType[geometry.type](geometry, stream);
              }
            }
            var streamObjectType = {
              Feature: function(object2, stream) {
                streamGeometry(object2.geometry, stream);
              },
              FeatureCollection: function(object2, stream) {
                var features = object2.features, i = -1, n = features.length;
                while (++i < n)
                  streamGeometry(features[i].geometry, stream);
              }
            };
            var streamGeometryType = {
              Sphere: function(object2, stream) {
                stream.sphere();
              },
              Point: function(object2, stream) {
                object2 = object2.coordinates;
                stream.point(object2[0], object2[1], object2[2]);
              },
              MultiPoint: function(object2, stream) {
                var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
                while (++i < n)
                  object2 = coordinates2[i], stream.point(object2[0], object2[1], object2[2]);
              },
              LineString: function(object2, stream) {
                streamLine(object2.coordinates, stream, 0);
              },
              MultiLineString: function(object2, stream) {
                var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
                while (++i < n)
                  streamLine(coordinates2[i], stream, 0);
              },
              Polygon: function(object2, stream) {
                streamPolygon(object2.coordinates, stream);
              },
              MultiPolygon: function(object2, stream) {
                var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
                while (++i < n)
                  streamPolygon(coordinates2[i], stream);
              },
              GeometryCollection: function(object2, stream) {
                var geometries = object2.geometries, i = -1, n = geometries.length;
                while (++i < n)
                  streamGeometry(geometries[i], stream);
              }
            };
            function streamLine(coordinates2, stream, closed) {
              var i = -1, n = coordinates2.length - closed, coordinate;
              stream.lineStart();
              while (++i < n)
                coordinate = coordinates2[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
              stream.lineEnd();
            }
            function streamPolygon(coordinates2, stream) {
              var i = -1, n = coordinates2.length;
              stream.polygonStart();
              while (++i < n)
                streamLine(coordinates2[i], stream, 1);
              stream.polygonEnd();
            }
            function geoStream(object2, stream) {
              if (object2 && streamObjectType.hasOwnProperty(object2.type)) {
                streamObjectType[object2.type](object2, stream);
              } else {
                streamGeometry(object2, stream);
              }
            }
            var areaRingSum = adder();
            var areaSum = adder(), lambda00, phi00, lambda0, cosPhi0, sinPhi0;
            var areaStream = {
              point: noop,
              lineStart: noop,
              lineEnd: noop,
              polygonStart: function() {
                areaRingSum.reset();
                areaStream.lineStart = areaRingStart;
                areaStream.lineEnd = areaRingEnd;
              },
              polygonEnd: function() {
                var areaRing = +areaRingSum;
                areaSum.add(areaRing < 0 ? tau + areaRing : areaRing);
                this.lineStart = this.lineEnd = this.point = noop;
              },
              sphere: function() {
                areaSum.add(tau);
              }
            };
            function areaRingStart() {
              areaStream.point = areaPointFirst;
            }
            function areaRingEnd() {
              areaPoint(lambda00, phi00);
            }
            function areaPointFirst(lambda, phi) {
              areaStream.point = areaPoint;
              lambda00 = lambda, phi00 = phi;
              lambda *= radians, phi *= radians;
              lambda0 = lambda, cosPhi0 = cos(phi = phi / 2 + quarterPi), sinPhi0 = sin(phi);
            }
            function areaPoint(lambda, phi) {
              lambda *= radians, phi *= radians;
              phi = phi / 2 + quarterPi;
              var dLambda = lambda - lambda0, sdLambda = dLambda >= 0 ? 1 : -1, adLambda = sdLambda * dLambda, cosPhi = cos(phi), sinPhi = sin(phi), k = sinPhi0 * sinPhi, u = cosPhi0 * cosPhi + k * cos(adLambda), v = k * sdLambda * sin(adLambda);
              areaRingSum.add(atan2(v, u));
              lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
            }
            function area(object2) {
              areaSum.reset();
              geoStream(object2, areaStream);
              return areaSum * 2;
            }
            function spherical(cartesian2) {
              return [atan2(cartesian2[1], cartesian2[0]), asin(cartesian2[2])];
            }
            function cartesian(spherical2) {
              var lambda = spherical2[0], phi = spherical2[1], cosPhi = cos(phi);
              return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];
            }
            function cartesianDot(a, b) {
              return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
            }
            function cartesianCross(a, b) {
              return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
            }
            function cartesianAddInPlace(a, b) {
              a[0] += b[0], a[1] += b[1], a[2] += b[2];
            }
            function cartesianScale(vector, k) {
              return [vector[0] * k, vector[1] * k, vector[2] * k];
            }
            function cartesianNormalizeInPlace(d) {
              var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
              d[0] /= l, d[1] /= l, d[2] /= l;
            }
            var lambda0$1, phi0, lambda1, phi1, lambda2, lambda00$1, phi00$1, p0, deltaSum = adder(), ranges, range;
            var boundsStream = {
              point: boundsPoint,
              lineStart: boundsLineStart,
              lineEnd: boundsLineEnd,
              polygonStart: function() {
                boundsStream.point = boundsRingPoint;
                boundsStream.lineStart = boundsRingStart;
                boundsStream.lineEnd = boundsRingEnd;
                deltaSum.reset();
                areaStream.polygonStart();
              },
              polygonEnd: function() {
                areaStream.polygonEnd();
                boundsStream.point = boundsPoint;
                boundsStream.lineStart = boundsLineStart;
                boundsStream.lineEnd = boundsLineEnd;
                if (areaRingSum < 0)
                  lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
                else if (deltaSum > epsilon)
                  phi1 = 90;
                else if (deltaSum < -epsilon)
                  phi0 = -90;
                range[0] = lambda0$1, range[1] = lambda1;
              },
              sphere: function() {
                lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
              }
            };
            function boundsPoint(lambda, phi) {
              ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
              if (phi < phi0)
                phi0 = phi;
              if (phi > phi1)
                phi1 = phi;
            }
            function linePoint(lambda, phi) {
              var p = cartesian([lambda * radians, phi * radians]);
              if (p0) {
                var normal = cartesianCross(p0, p), equatorial = [normal[1], -normal[0], 0], inflection = cartesianCross(equatorial, normal);
                cartesianNormalizeInPlace(inflection);
                inflection = spherical(inflection);
                var delta = lambda - lambda2, sign2 = delta > 0 ? 1 : -1, lambdai = inflection[0] * degrees * sign2, phii, antimeridian = abs(delta) > 180;
                if (antimeridian ^ (sign2 * lambda2 < lambdai && lambdai < sign2 * lambda)) {
                  phii = inflection[1] * degrees;
                  if (phii > phi1)
                    phi1 = phii;
                } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign2 * lambda2 < lambdai && lambdai < sign2 * lambda)) {
                  phii = -inflection[1] * degrees;
                  if (phii < phi0)
                    phi0 = phii;
                } else {
                  if (phi < phi0)
                    phi0 = phi;
                  if (phi > phi1)
                    phi1 = phi;
                }
                if (antimeridian) {
                  if (lambda < lambda2) {
                    if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1))
                      lambda1 = lambda;
                  } else {
                    if (angle(lambda, lambda1) > angle(lambda0$1, lambda1))
                      lambda0$1 = lambda;
                  }
                } else {
                  if (lambda1 >= lambda0$1) {
                    if (lambda < lambda0$1)
                      lambda0$1 = lambda;
                    if (lambda > lambda1)
                      lambda1 = lambda;
                  } else {
                    if (lambda > lambda2) {
                      if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1))
                        lambda1 = lambda;
                    } else {
                      if (angle(lambda, lambda1) > angle(lambda0$1, lambda1))
                        lambda0$1 = lambda;
                    }
                  }
                }
              } else {
                ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
              }
              if (phi < phi0)
                phi0 = phi;
              if (phi > phi1)
                phi1 = phi;
              p0 = p, lambda2 = lambda;
            }
            function boundsLineStart() {
              boundsStream.point = linePoint;
            }
            function boundsLineEnd() {
              range[0] = lambda0$1, range[1] = lambda1;
              boundsStream.point = boundsPoint;
              p0 = null;
            }
            function boundsRingPoint(lambda, phi) {
              if (p0) {
                var delta = lambda - lambda2;
                deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
              } else {
                lambda00$1 = lambda, phi00$1 = phi;
              }
              areaStream.point(lambda, phi);
              linePoint(lambda, phi);
            }
            function boundsRingStart() {
              areaStream.lineStart();
            }
            function boundsRingEnd() {
              boundsRingPoint(lambda00$1, phi00$1);
              areaStream.lineEnd();
              if (abs(deltaSum) > epsilon)
                lambda0$1 = -(lambda1 = 180);
              range[0] = lambda0$1, range[1] = lambda1;
              p0 = null;
            }
            function angle(lambda02, lambda12) {
              return (lambda12 -= lambda02) < 0 ? lambda12 + 360 : lambda12;
            }
            function rangeCompare(a, b) {
              return a[0] - b[0];
            }
            function rangeContains(range2, x) {
              return range2[0] <= range2[1] ? range2[0] <= x && x <= range2[1] : x < range2[0] || range2[1] < x;
            }
            function bounds(feature) {
              var i, n, a, b, merged, deltaMax, delta;
              phi1 = lambda1 = -(lambda0$1 = phi0 = Infinity);
              ranges = [];
              geoStream(feature, boundsStream);
              if (n = ranges.length) {
                ranges.sort(rangeCompare);
                for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
                  b = ranges[i];
                  if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
                    if (angle(a[0], b[1]) > angle(a[0], a[1]))
                      a[1] = b[1];
                    if (angle(b[0], a[1]) > angle(a[0], a[1]))
                      a[0] = b[0];
                  } else {
                    merged.push(a = b);
                  }
                }
                for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
                  b = merged[i];
                  if ((delta = angle(a[1], b[0])) > deltaMax)
                    deltaMax = delta, lambda0$1 = b[0], lambda1 = a[1];
                }
              }
              ranges = range = null;
              return lambda0$1 === Infinity || phi0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[lambda0$1, phi0], [lambda1, phi1]];
            }
            var W0, W1, X0, Y0, Z0, X1, Y1, Z1, X2, Y2, Z2, lambda00$2, phi00$2, x0, y0, z0;
            var centroidStream = {
              sphere: noop,
              point: centroidPoint,
              lineStart: centroidLineStart,
              lineEnd: centroidLineEnd,
              polygonStart: function() {
                centroidStream.lineStart = centroidRingStart;
                centroidStream.lineEnd = centroidRingEnd;
              },
              polygonEnd: function() {
                centroidStream.lineStart = centroidLineStart;
                centroidStream.lineEnd = centroidLineEnd;
              }
            };
            function centroidPoint(lambda, phi) {
              lambda *= radians, phi *= radians;
              var cosPhi = cos(phi);
              centroidPointCartesian(cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi));
            }
            function centroidPointCartesian(x, y, z) {
              ++W0;
              X0 += (x - X0) / W0;
              Y0 += (y - Y0) / W0;
              Z0 += (z - Z0) / W0;
            }
            function centroidLineStart() {
              centroidStream.point = centroidLinePointFirst;
            }
            function centroidLinePointFirst(lambda, phi) {
              lambda *= radians, phi *= radians;
              var cosPhi = cos(phi);
              x0 = cosPhi * cos(lambda);
              y0 = cosPhi * sin(lambda);
              z0 = sin(phi);
              centroidStream.point = centroidLinePoint;
              centroidPointCartesian(x0, y0, z0);
            }
            function centroidLinePoint(lambda, phi) {
              lambda *= radians, phi *= radians;
              var cosPhi = cos(phi), x = cosPhi * cos(lambda), y = cosPhi * sin(lambda), z = sin(phi), w = atan2(sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
              W1 += w;
              X1 += w * (x0 + (x0 = x));
              Y1 += w * (y0 + (y0 = y));
              Z1 += w * (z0 + (z0 = z));
              centroidPointCartesian(x0, y0, z0);
            }
            function centroidLineEnd() {
              centroidStream.point = centroidPoint;
            }
            function centroidRingStart() {
              centroidStream.point = centroidRingPointFirst;
            }
            function centroidRingEnd() {
              centroidRingPoint(lambda00$2, phi00$2);
              centroidStream.point = centroidPoint;
            }
            function centroidRingPointFirst(lambda, phi) {
              lambda00$2 = lambda, phi00$2 = phi;
              lambda *= radians, phi *= radians;
              centroidStream.point = centroidRingPoint;
              var cosPhi = cos(phi);
              x0 = cosPhi * cos(lambda);
              y0 = cosPhi * sin(lambda);
              z0 = sin(phi);
              centroidPointCartesian(x0, y0, z0);
            }
            function centroidRingPoint(lambda, phi) {
              lambda *= radians, phi *= radians;
              var cosPhi = cos(phi), x = cosPhi * cos(lambda), y = cosPhi * sin(lambda), z = sin(phi), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = sqrt(cx * cx + cy * cy + cz * cz), w = asin(m), v = m && -w / m;
              X2 += v * cx;
              Y2 += v * cy;
              Z2 += v * cz;
              W1 += w;
              X1 += w * (x0 + (x0 = x));
              Y1 += w * (y0 + (y0 = y));
              Z1 += w * (z0 + (z0 = z));
              centroidPointCartesian(x0, y0, z0);
            }
            function centroid(object2) {
              W0 = W1 = X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2 = Y2 = Z2 = 0;
              geoStream(object2, centroidStream);
              var x = X2, y = Y2, z = Z2, m = x * x + y * y + z * z;
              if (m < epsilon2) {
                x = X1, y = Y1, z = Z1;
                if (W1 < epsilon)
                  x = X0, y = Y0, z = Z0;
                m = x * x + y * y + z * z;
                if (m < epsilon2)
                  return [NaN, NaN];
              }
              return [atan2(y, x) * degrees, asin(z / sqrt(m)) * degrees];
            }
            function constant(x) {
              return function() {
                return x;
              };
            }
            function compose(a, b) {
              function compose2(x, y) {
                return x = a(x, y), b(x[0], x[1]);
              }
              if (a.invert && b.invert)
                compose2.invert = function(x, y) {
                  return x = b.invert(x, y), x && a.invert(x[0], x[1]);
                };
              return compose2;
            }
            function rotationIdentity(lambda, phi) {
              return [abs(lambda) > pi ? lambda + Math.round(-lambda / tau) * tau : lambda, phi];
            }
            rotationIdentity.invert = rotationIdentity;
            function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
              return (deltaLambda %= tau) ? deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
            }
            function forwardRotationLambda(deltaLambda) {
              return function(lambda, phi) {
                return lambda += deltaLambda, [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];
              };
            }
            function rotationLambda(deltaLambda) {
              var rotation2 = forwardRotationLambda(deltaLambda);
              rotation2.invert = forwardRotationLambda(-deltaLambda);
              return rotation2;
            }
            function rotationPhiGamma(deltaPhi, deltaGamma) {
              var cosDeltaPhi = cos(deltaPhi), sinDeltaPhi = sin(deltaPhi), cosDeltaGamma = cos(deltaGamma), sinDeltaGamma = sin(deltaGamma);
              function rotation2(lambda, phi) {
                var cosPhi = cos(phi), x = cos(lambda) * cosPhi, y = sin(lambda) * cosPhi, z = sin(phi), k = z * cosDeltaPhi + x * sinDeltaPhi;
                return [
                  atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
                  asin(k * cosDeltaGamma + y * sinDeltaGamma)
                ];
              }
              rotation2.invert = function(lambda, phi) {
                var cosPhi = cos(phi), x = cos(lambda) * cosPhi, y = sin(lambda) * cosPhi, z = sin(phi), k = z * cosDeltaGamma - y * sinDeltaGamma;
                return [
                  atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
                  asin(k * cosDeltaPhi - x * sinDeltaPhi)
                ];
              };
              return rotation2;
            }
            function rotation(rotate) {
              rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);
              function forward(coordinates2) {
                coordinates2 = rotate(coordinates2[0] * radians, coordinates2[1] * radians);
                return coordinates2[0] *= degrees, coordinates2[1] *= degrees, coordinates2;
              }
              forward.invert = function(coordinates2) {
                coordinates2 = rotate.invert(coordinates2[0] * radians, coordinates2[1] * radians);
                return coordinates2[0] *= degrees, coordinates2[1] *= degrees, coordinates2;
              };
              return forward;
            }
            function circleStream(stream, radius, delta, direction, t0, t1) {
              if (!delta)
                return;
              var cosRadius = cos(radius), sinRadius = sin(radius), step = direction * delta;
              if (t0 == null) {
                t0 = radius + direction * tau;
                t1 = radius - step / 2;
              } else {
                t0 = circleRadius(cosRadius, t0);
                t1 = circleRadius(cosRadius, t1);
                if (direction > 0 ? t0 < t1 : t0 > t1)
                  t0 += direction * tau;
              }
              for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
                point = spherical([cosRadius, -sinRadius * cos(t), -sinRadius * sin(t)]);
                stream.point(point[0], point[1]);
              }
            }
            function circleRadius(cosRadius, point) {
              point = cartesian(point), point[0] -= cosRadius;
              cartesianNormalizeInPlace(point);
              var radius = acos(-point[1]);
              return ((-point[2] < 0 ? -radius : radius) + tau - epsilon) % tau;
            }
            function circle() {
              var center = constant([0, 0]), radius = constant(90), precision = constant(6), ring, rotate, stream = { point };
              function point(x, y) {
                ring.push(x = rotate(x, y));
                x[0] *= degrees, x[1] *= degrees;
              }
              function circle2() {
                var c = center.apply(this, arguments), r = radius.apply(this, arguments) * radians, p = precision.apply(this, arguments) * radians;
                ring = [];
                rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;
                circleStream(stream, r, p, 1);
                c = { type: "Polygon", coordinates: [ring] };
                ring = rotate = null;
                return c;
              }
              circle2.center = function(_) {
                return arguments.length ? (center = typeof _ === "function" ? _ : constant([+_[0], +_[1]]), circle2) : center;
              };
              circle2.radius = function(_) {
                return arguments.length ? (radius = typeof _ === "function" ? _ : constant(+_), circle2) : radius;
              };
              circle2.precision = function(_) {
                return arguments.length ? (precision = typeof _ === "function" ? _ : constant(+_), circle2) : precision;
              };
              return circle2;
            }
            function clipBuffer() {
              var lines = [], line;
              return {
                point: function(x, y, m) {
                  line.push([x, y, m]);
                },
                lineStart: function() {
                  lines.push(line = []);
                },
                lineEnd: noop,
                rejoin: function() {
                  if (lines.length > 1)
                    lines.push(lines.pop().concat(lines.shift()));
                },
                result: function() {
                  var result = lines;
                  lines = [];
                  line = null;
                  return result;
                }
              };
            }
            function pointEqual(a, b) {
              return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;
            }
            function Intersection(point, points, other, entry) {
              this.x = point;
              this.z = points;
              this.o = other;
              this.e = entry;
              this.v = false;
              this.n = this.p = null;
            }
            function clipRejoin(segments, compareIntersection2, startInside, interpolate2, stream) {
              var subject = [], clip2 = [], i, n;
              segments.forEach(function(segment) {
                if ((n2 = segment.length - 1) <= 0)
                  return;
                var n2, p02 = segment[0], p1 = segment[n2], x;
                if (pointEqual(p02, p1)) {
                  if (!p02[2] && !p1[2]) {
                    stream.lineStart();
                    for (i = 0; i < n2; ++i)
                      stream.point((p02 = segment[i])[0], p02[1]);
                    stream.lineEnd();
                    return;
                  }
                  p1[0] += 2 * epsilon;
                }
                subject.push(x = new Intersection(p02, segment, null, true));
                clip2.push(x.o = new Intersection(p02, null, x, false));
                subject.push(x = new Intersection(p1, segment, null, false));
                clip2.push(x.o = new Intersection(p1, null, x, true));
              });
              if (!subject.length)
                return;
              clip2.sort(compareIntersection2);
              link(subject);
              link(clip2);
              for (i = 0, n = clip2.length; i < n; ++i) {
                clip2[i].e = startInside = !startInside;
              }
              var start = subject[0], points, point;
              while (1) {
                var current = start, isSubject = true;
                while (current.v)
                  if ((current = current.n) === start)
                    return;
                points = current.z;
                stream.lineStart();
                do {
                  current.v = current.o.v = true;
                  if (current.e) {
                    if (isSubject) {
                      for (i = 0, n = points.length; i < n; ++i)
                        stream.point((point = points[i])[0], point[1]);
                    } else {
                      interpolate2(current.x, current.n.x, 1, stream);
                    }
                    current = current.n;
                  } else {
                    if (isSubject) {
                      points = current.p.z;
                      for (i = points.length - 1; i >= 0; --i)
                        stream.point((point = points[i])[0], point[1]);
                    } else {
                      interpolate2(current.x, current.p.x, -1, stream);
                    }
                    current = current.p;
                  }
                  current = current.o;
                  points = current.z;
                  isSubject = !isSubject;
                } while (!current.v);
                stream.lineEnd();
              }
            }
            function link(array) {
              if (!(n = array.length))
                return;
              var n, i = 0, a = array[0], b;
              while (++i < n) {
                a.n = b = array[i];
                b.p = a;
                a = b;
              }
              a.n = b = array[0];
              b.p = a;
            }
            var sum = adder();
            function longitude(point) {
              if (abs(point[0]) <= pi)
                return point[0];
              else
                return sign(point[0]) * ((abs(point[0]) + pi) % tau - pi);
            }
            function polygonContains(polygon, point) {
              var lambda = longitude(point), phi = point[1], sinPhi = sin(phi), normal = [sin(lambda), -cos(lambda), 0], angle2 = 0, winding = 0;
              sum.reset();
              if (sinPhi === 1)
                phi = halfPi + epsilon;
              else if (sinPhi === -1)
                phi = -halfPi - epsilon;
              for (var i = 0, n = polygon.length; i < n; ++i) {
                if (!(m = (ring = polygon[i]).length))
                  continue;
                var ring, m, point0 = ring[m - 1], lambda02 = longitude(point0), phi02 = point0[1] / 2 + quarterPi, sinPhi02 = sin(phi02), cosPhi02 = cos(phi02);
                for (var j = 0; j < m; ++j, lambda02 = lambda12, sinPhi02 = sinPhi1, cosPhi02 = cosPhi1, point0 = point1) {
                  var point1 = ring[j], lambda12 = longitude(point1), phi12 = point1[1] / 2 + quarterPi, sinPhi1 = sin(phi12), cosPhi1 = cos(phi12), delta = lambda12 - lambda02, sign2 = delta >= 0 ? 1 : -1, absDelta = sign2 * delta, antimeridian = absDelta > pi, k = sinPhi02 * sinPhi1;
                  sum.add(atan2(k * sign2 * sin(absDelta), cosPhi02 * cosPhi1 + k * cos(absDelta)));
                  angle2 += antimeridian ? delta + sign2 * tau : delta;
                  if (antimeridian ^ lambda02 >= lambda ^ lambda12 >= lambda) {
                    var arc = cartesianCross(cartesian(point0), cartesian(point1));
                    cartesianNormalizeInPlace(arc);
                    var intersection = cartesianCross(normal, arc);
                    cartesianNormalizeInPlace(intersection);
                    var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);
                    if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
                      winding += antimeridian ^ delta >= 0 ? 1 : -1;
                    }
                  }
                }
              }
              return (angle2 < -epsilon || angle2 < epsilon && sum < -epsilon) ^ winding & 1;
            }
            function clip(pointVisible, clipLine2, interpolate2, start) {
              return function(sink) {
                var line = clipLine2(sink), ringBuffer = clipBuffer(), ringSink = clipLine2(ringBuffer), polygonStarted = false, polygon, segments, ring;
                var clip2 = {
                  point,
                  lineStart,
                  lineEnd,
                  polygonStart: function() {
                    clip2.point = pointRing;
                    clip2.lineStart = ringStart;
                    clip2.lineEnd = ringEnd;
                    segments = [];
                    polygon = [];
                  },
                  polygonEnd: function() {
                    clip2.point = point;
                    clip2.lineStart = lineStart;
                    clip2.lineEnd = lineEnd;
                    segments = d3Array.merge(segments);
                    var startInside = polygonContains(polygon, start);
                    if (segments.length) {
                      if (!polygonStarted)
                        sink.polygonStart(), polygonStarted = true;
                      clipRejoin(segments, compareIntersection, startInside, interpolate2, sink);
                    } else if (startInside) {
                      if (!polygonStarted)
                        sink.polygonStart(), polygonStarted = true;
                      sink.lineStart();
                      interpolate2(null, null, 1, sink);
                      sink.lineEnd();
                    }
                    if (polygonStarted)
                      sink.polygonEnd(), polygonStarted = false;
                    segments = polygon = null;
                  },
                  sphere: function() {
                    sink.polygonStart();
                    sink.lineStart();
                    interpolate2(null, null, 1, sink);
                    sink.lineEnd();
                    sink.polygonEnd();
                  }
                };
                function point(lambda, phi) {
                  if (pointVisible(lambda, phi))
                    sink.point(lambda, phi);
                }
                function pointLine(lambda, phi) {
                  line.point(lambda, phi);
                }
                function lineStart() {
                  clip2.point = pointLine;
                  line.lineStart();
                }
                function lineEnd() {
                  clip2.point = point;
                  line.lineEnd();
                }
                function pointRing(lambda, phi) {
                  ring.push([lambda, phi]);
                  ringSink.point(lambda, phi);
                }
                function ringStart() {
                  ringSink.lineStart();
                  ring = [];
                }
                function ringEnd() {
                  pointRing(ring[0][0], ring[0][1]);
                  ringSink.lineEnd();
                  var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i, n = ringSegments.length, m, segment, point2;
                  ring.pop();
                  polygon.push(ring);
                  ring = null;
                  if (!n)
                    return;
                  if (clean & 1) {
                    segment = ringSegments[0];
                    if ((m = segment.length - 1) > 0) {
                      if (!polygonStarted)
                        sink.polygonStart(), polygonStarted = true;
                      sink.lineStart();
                      for (i = 0; i < m; ++i)
                        sink.point((point2 = segment[i])[0], point2[1]);
                      sink.lineEnd();
                    }
                    return;
                  }
                  if (n > 1 && clean & 2)
                    ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
                  segments.push(ringSegments.filter(validSegment));
                }
                return clip2;
              };
            }
            function validSegment(segment) {
              return segment.length > 1;
            }
            function compareIntersection(a, b) {
              return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);
            }
            var clipAntimeridian = clip(function() {
              return true;
            }, clipAntimeridianLine, clipAntimeridianInterpolate, [-pi, -halfPi]);
            function clipAntimeridianLine(stream) {
              var lambda02 = NaN, phi02 = NaN, sign0 = NaN, clean;
              return {
                lineStart: function() {
                  stream.lineStart();
                  clean = 1;
                },
                point: function(lambda12, phi12) {
                  var sign1 = lambda12 > 0 ? pi : -pi, delta = abs(lambda12 - lambda02);
                  if (abs(delta - pi) < epsilon) {
                    stream.point(lambda02, phi02 = (phi02 + phi12) / 2 > 0 ? halfPi : -halfPi);
                    stream.point(sign0, phi02);
                    stream.lineEnd();
                    stream.lineStart();
                    stream.point(sign1, phi02);
                    stream.point(lambda12, phi02);
                    clean = 0;
                  } else if (sign0 !== sign1 && delta >= pi) {
                    if (abs(lambda02 - sign0) < epsilon)
                      lambda02 -= sign0 * epsilon;
                    if (abs(lambda12 - sign1) < epsilon)
                      lambda12 -= sign1 * epsilon;
                    phi02 = clipAntimeridianIntersect(lambda02, phi02, lambda12, phi12);
                    stream.point(sign0, phi02);
                    stream.lineEnd();
                    stream.lineStart();
                    stream.point(sign1, phi02);
                    clean = 0;
                  }
                  stream.point(lambda02 = lambda12, phi02 = phi12);
                  sign0 = sign1;
                },
                lineEnd: function() {
                  stream.lineEnd();
                  lambda02 = phi02 = NaN;
                },
                clean: function() {
                  return 2 - clean;
                }
              };
            }
            function clipAntimeridianIntersect(lambda02, phi02, lambda12, phi12) {
              var cosPhi02, cosPhi1, sinLambda0Lambda1 = sin(lambda02 - lambda12);
              return abs(sinLambda0Lambda1) > epsilon ? atan((sin(phi02) * (cosPhi1 = cos(phi12)) * sin(lambda12) - sin(phi12) * (cosPhi02 = cos(phi02)) * sin(lambda02)) / (cosPhi02 * cosPhi1 * sinLambda0Lambda1)) : (phi02 + phi12) / 2;
            }
            function clipAntimeridianInterpolate(from, to, direction, stream) {
              var phi;
              if (from == null) {
                phi = direction * halfPi;
                stream.point(-pi, phi);
                stream.point(0, phi);
                stream.point(pi, phi);
                stream.point(pi, 0);
                stream.point(pi, -phi);
                stream.point(0, -phi);
                stream.point(-pi, -phi);
                stream.point(-pi, 0);
                stream.point(-pi, phi);
              } else if (abs(from[0] - to[0]) > epsilon) {
                var lambda = from[0] < to[0] ? pi : -pi;
                phi = direction * lambda / 2;
                stream.point(-lambda, phi);
                stream.point(0, phi);
                stream.point(lambda, phi);
              } else {
                stream.point(to[0], to[1]);
              }
            }
            function clipCircle(radius) {
              var cr = cos(radius), delta = 6 * radians, smallRadius = cr > 0, notHemisphere = abs(cr) > epsilon;
              function interpolate2(from, to, direction, stream) {
                circleStream(stream, radius, delta, direction, from, to);
              }
              function visible(lambda, phi) {
                return cos(lambda) * cos(phi) > cr;
              }
              function clipLine2(stream) {
                var point0, c0, v0, v00, clean;
                return {
                  lineStart: function() {
                    v00 = v0 = false;
                    clean = 1;
                  },
                  point: function(lambda, phi) {
                    var point1 = [lambda, phi], point2, v = visible(lambda, phi), c = smallRadius ? v ? 0 : code(lambda, phi) : v ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;
                    if (!point0 && (v00 = v0 = v))
                      stream.lineStart();
                    if (v !== v0) {
                      point2 = intersect(point0, point1);
                      if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2))
                        point1[2] = 1;
                    }
                    if (v !== v0) {
                      clean = 0;
                      if (v) {
                        stream.lineStart();
                        point2 = intersect(point1, point0);
                        stream.point(point2[0], point2[1]);
                      } else {
                        point2 = intersect(point0, point1);
                        stream.point(point2[0], point2[1], 2);
                        stream.lineEnd();
                      }
                      point0 = point2;
                    } else if (notHemisphere && point0 && smallRadius ^ v) {
                      var t;
                      if (!(c & c0) && (t = intersect(point1, point0, true))) {
                        clean = 0;
                        if (smallRadius) {
                          stream.lineStart();
                          stream.point(t[0][0], t[0][1]);
                          stream.point(t[1][0], t[1][1]);
                          stream.lineEnd();
                        } else {
                          stream.point(t[1][0], t[1][1]);
                          stream.lineEnd();
                          stream.lineStart();
                          stream.point(t[0][0], t[0][1], 3);
                        }
                      }
                    }
                    if (v && (!point0 || !pointEqual(point0, point1))) {
                      stream.point(point1[0], point1[1]);
                    }
                    point0 = point1, v0 = v, c0 = c;
                  },
                  lineEnd: function() {
                    if (v0)
                      stream.lineEnd();
                    point0 = null;
                  },
                  clean: function() {
                    return clean | (v00 && v0) << 1;
                  }
                };
              }
              function intersect(a, b, two) {
                var pa = cartesian(a), pb = cartesian(b);
                var n1 = [1, 0, 0], n2 = cartesianCross(pa, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
                if (!determinant)
                  return !two && a;
                var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = cartesianCross(n1, n2), A = cartesianScale(n1, c1), B = cartesianScale(n2, c2);
                cartesianAddInPlace(A, B);
                var u = n1xn2, w = cartesianDot(A, u), uu = cartesianDot(u, u), t2 = w * w - uu * (cartesianDot(A, A) - 1);
                if (t2 < 0)
                  return;
                var t = sqrt(t2), q = cartesianScale(u, (-w - t) / uu);
                cartesianAddInPlace(q, A);
                q = spherical(q);
                if (!two)
                  return q;
                var lambda02 = a[0], lambda12 = b[0], phi02 = a[1], phi12 = b[1], z;
                if (lambda12 < lambda02)
                  z = lambda02, lambda02 = lambda12, lambda12 = z;
                var delta2 = lambda12 - lambda02, polar = abs(delta2 - pi) < epsilon, meridian = polar || delta2 < epsilon;
                if (!polar && phi12 < phi02)
                  z = phi02, phi02 = phi12, phi12 = z;
                if (meridian ? polar ? phi02 + phi12 > 0 ^ q[1] < (abs(q[0] - lambda02) < epsilon ? phi02 : phi12) : phi02 <= q[1] && q[1] <= phi12 : delta2 > pi ^ (lambda02 <= q[0] && q[0] <= lambda12)) {
                  var q1 = cartesianScale(u, (-w + t) / uu);
                  cartesianAddInPlace(q1, A);
                  return [q, spherical(q1)];
                }
              }
              function code(lambda, phi) {
                var r = smallRadius ? radius : pi - radius, code2 = 0;
                if (lambda < -r)
                  code2 |= 1;
                else if (lambda > r)
                  code2 |= 2;
                if (phi < -r)
                  code2 |= 4;
                else if (phi > r)
                  code2 |= 8;
                return code2;
              }
              return clip(visible, clipLine2, interpolate2, smallRadius ? [0, -radius] : [-pi, radius - pi]);
            }
            function clipLine(a, b, x02, y02, x12, y12) {
              var ax = a[0], ay = a[1], bx = b[0], by = b[1], t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
              r = x02 - ax;
              if (!dx && r > 0)
                return;
              r /= dx;
              if (dx < 0) {
                if (r < t0)
                  return;
                if (r < t1)
                  t1 = r;
              } else if (dx > 0) {
                if (r > t1)
                  return;
                if (r > t0)
                  t0 = r;
              }
              r = x12 - ax;
              if (!dx && r < 0)
                return;
              r /= dx;
              if (dx < 0) {
                if (r > t1)
                  return;
                if (r > t0)
                  t0 = r;
              } else if (dx > 0) {
                if (r < t0)
                  return;
                if (r < t1)
                  t1 = r;
              }
              r = y02 - ay;
              if (!dy && r > 0)
                return;
              r /= dy;
              if (dy < 0) {
                if (r < t0)
                  return;
                if (r < t1)
                  t1 = r;
              } else if (dy > 0) {
                if (r > t1)
                  return;
                if (r > t0)
                  t0 = r;
              }
              r = y12 - ay;
              if (!dy && r < 0)
                return;
              r /= dy;
              if (dy < 0) {
                if (r > t1)
                  return;
                if (r > t0)
                  t0 = r;
              } else if (dy > 0) {
                if (r < t0)
                  return;
                if (r < t1)
                  t1 = r;
              }
              if (t0 > 0)
                a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
              if (t1 < 1)
                b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
              return true;
            }
            var clipMax = 1e9, clipMin = -clipMax;
            function clipRectangle(x02, y02, x12, y12) {
              function visible(x, y) {
                return x02 <= x && x <= x12 && y02 <= y && y <= y12;
              }
              function interpolate2(from, to, direction, stream) {
                var a = 0, a1 = 0;
                if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {
                  do
                    stream.point(a === 0 || a === 3 ? x02 : x12, a > 1 ? y12 : y02);
                  while ((a = (a + direction + 4) % 4) !== a1);
                } else {
                  stream.point(to[0], to[1]);
                }
              }
              function corner(p, direction) {
                return abs(p[0] - x02) < epsilon ? direction > 0 ? 0 : 3 : abs(p[0] - x12) < epsilon ? direction > 0 ? 2 : 1 : abs(p[1] - y02) < epsilon ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
              }
              function compareIntersection2(a, b) {
                return comparePoint(a.x, b.x);
              }
              function comparePoint(a, b) {
                var ca = corner(a, 1), cb = corner(b, 1);
                return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
              }
              return function(stream) {
                var activeStream = stream, bufferStream = clipBuffer(), segments, polygon, ring, x__, y__, v__, x_, y_, v_, first, clean;
                var clipStream = {
                  point,
                  lineStart,
                  lineEnd,
                  polygonStart,
                  polygonEnd
                };
                function point(x, y) {
                  if (visible(x, y))
                    activeStream.point(x, y);
                }
                function polygonInside() {
                  var winding = 0;
                  for (var i = 0, n = polygon.length; i < n; ++i) {
                    for (var ring2 = polygon[i], j = 1, m = ring2.length, point2 = ring2[0], a0, a1, b0 = point2[0], b1 = point2[1]; j < m; ++j) {
                      a0 = b0, a1 = b1, point2 = ring2[j], b0 = point2[0], b1 = point2[1];
                      if (a1 <= y12) {
                        if (b1 > y12 && (b0 - a0) * (y12 - a1) > (b1 - a1) * (x02 - a0))
                          ++winding;
                      } else {
                        if (b1 <= y12 && (b0 - a0) * (y12 - a1) < (b1 - a1) * (x02 - a0))
                          --winding;
                      }
                    }
                  }
                  return winding;
                }
                function polygonStart() {
                  activeStream = bufferStream, segments = [], polygon = [], clean = true;
                }
                function polygonEnd() {
                  var startInside = polygonInside(), cleanInside = clean && startInside, visible2 = (segments = d3Array.merge(segments)).length;
                  if (cleanInside || visible2) {
                    stream.polygonStart();
                    if (cleanInside) {
                      stream.lineStart();
                      interpolate2(null, null, 1, stream);
                      stream.lineEnd();
                    }
                    if (visible2) {
                      clipRejoin(segments, compareIntersection2, startInside, interpolate2, stream);
                    }
                    stream.polygonEnd();
                  }
                  activeStream = stream, segments = polygon = ring = null;
                }
                function lineStart() {
                  clipStream.point = linePoint2;
                  if (polygon)
                    polygon.push(ring = []);
                  first = true;
                  v_ = false;
                  x_ = y_ = NaN;
                }
                function lineEnd() {
                  if (segments) {
                    linePoint2(x__, y__);
                    if (v__ && v_)
                      bufferStream.rejoin();
                    segments.push(bufferStream.result());
                  }
                  clipStream.point = point;
                  if (v_)
                    activeStream.lineEnd();
                }
                function linePoint2(x, y) {
                  var v = visible(x, y);
                  if (polygon)
                    ring.push([x, y]);
                  if (first) {
                    x__ = x, y__ = y, v__ = v;
                    first = false;
                    if (v) {
                      activeStream.lineStart();
                      activeStream.point(x, y);
                    }
                  } else {
                    if (v && v_)
                      activeStream.point(x, y);
                    else {
                      var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
                      if (clipLine(a, b, x02, y02, x12, y12)) {
                        if (!v_) {
                          activeStream.lineStart();
                          activeStream.point(a[0], a[1]);
                        }
                        activeStream.point(b[0], b[1]);
                        if (!v)
                          activeStream.lineEnd();
                        clean = false;
                      } else if (v) {
                        activeStream.lineStart();
                        activeStream.point(x, y);
                        clean = false;
                      }
                    }
                  }
                  x_ = x, y_ = y, v_ = v;
                }
                return clipStream;
              };
            }
            function extent() {
              var x02 = 0, y02 = 0, x12 = 960, y12 = 500, cache, cacheStream, clip2;
              return clip2 = {
                stream: function(stream) {
                  return cache && cacheStream === stream ? cache : cache = clipRectangle(x02, y02, x12, y12)(cacheStream = stream);
                },
                extent: function(_) {
                  return arguments.length ? (x02 = +_[0][0], y02 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1], cache = cacheStream = null, clip2) : [[x02, y02], [x12, y12]];
                }
              };
            }
            var lengthSum = adder(), lambda0$2, sinPhi0$1, cosPhi0$1;
            var lengthStream = {
              sphere: noop,
              point: noop,
              lineStart: lengthLineStart,
              lineEnd: noop,
              polygonStart: noop,
              polygonEnd: noop
            };
            function lengthLineStart() {
              lengthStream.point = lengthPointFirst;
              lengthStream.lineEnd = lengthLineEnd;
            }
            function lengthLineEnd() {
              lengthStream.point = lengthStream.lineEnd = noop;
            }
            function lengthPointFirst(lambda, phi) {
              lambda *= radians, phi *= radians;
              lambda0$2 = lambda, sinPhi0$1 = sin(phi), cosPhi0$1 = cos(phi);
              lengthStream.point = lengthPoint;
            }
            function lengthPoint(lambda, phi) {
              lambda *= radians, phi *= radians;
              var sinPhi = sin(phi), cosPhi = cos(phi), delta = abs(lambda - lambda0$2), cosDelta = cos(delta), sinDelta = sin(delta), x = cosPhi * sinDelta, y = cosPhi0$1 * sinPhi - sinPhi0$1 * cosPhi * cosDelta, z = sinPhi0$1 * sinPhi + cosPhi0$1 * cosPhi * cosDelta;
              lengthSum.add(atan2(sqrt(x * x + y * y), z));
              lambda0$2 = lambda, sinPhi0$1 = sinPhi, cosPhi0$1 = cosPhi;
            }
            function length(object2) {
              lengthSum.reset();
              geoStream(object2, lengthStream);
              return +lengthSum;
            }
            var coordinates = [null, null], object = { type: "LineString", coordinates };
            function distance(a, b) {
              coordinates[0] = a;
              coordinates[1] = b;
              return length(object);
            }
            var containsObjectType = {
              Feature: function(object2, point) {
                return containsGeometry(object2.geometry, point);
              },
              FeatureCollection: function(object2, point) {
                var features = object2.features, i = -1, n = features.length;
                while (++i < n)
                  if (containsGeometry(features[i].geometry, point))
                    return true;
                return false;
              }
            };
            var containsGeometryType = {
              Sphere: function() {
                return true;
              },
              Point: function(object2, point) {
                return containsPoint(object2.coordinates, point);
              },
              MultiPoint: function(object2, point) {
                var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
                while (++i < n)
                  if (containsPoint(coordinates2[i], point))
                    return true;
                return false;
              },
              LineString: function(object2, point) {
                return containsLine(object2.coordinates, point);
              },
              MultiLineString: function(object2, point) {
                var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
                while (++i < n)
                  if (containsLine(coordinates2[i], point))
                    return true;
                return false;
              },
              Polygon: function(object2, point) {
                return containsPolygon(object2.coordinates, point);
              },
              MultiPolygon: function(object2, point) {
                var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
                while (++i < n)
                  if (containsPolygon(coordinates2[i], point))
                    return true;
                return false;
              },
              GeometryCollection: function(object2, point) {
                var geometries = object2.geometries, i = -1, n = geometries.length;
                while (++i < n)
                  if (containsGeometry(geometries[i], point))
                    return true;
                return false;
              }
            };
            function containsGeometry(geometry, point) {
              return geometry && containsGeometryType.hasOwnProperty(geometry.type) ? containsGeometryType[geometry.type](geometry, point) : false;
            }
            function containsPoint(coordinates2, point) {
              return distance(coordinates2, point) === 0;
            }
            function containsLine(coordinates2, point) {
              var ao, bo, ab;
              for (var i = 0, n = coordinates2.length; i < n; i++) {
                bo = distance(coordinates2[i], point);
                if (bo === 0)
                  return true;
                if (i > 0) {
                  ab = distance(coordinates2[i], coordinates2[i - 1]);
                  if (ab > 0 && ao <= ab && bo <= ab && (ao + bo - ab) * (1 - Math.pow((ao - bo) / ab, 2)) < epsilon2 * ab)
                    return true;
                }
                ao = bo;
              }
              return false;
            }
            function containsPolygon(coordinates2, point) {
              return !!polygonContains(coordinates2.map(ringRadians), pointRadians(point));
            }
            function ringRadians(ring) {
              return ring = ring.map(pointRadians), ring.pop(), ring;
            }
            function pointRadians(point) {
              return [point[0] * radians, point[1] * radians];
            }
            function contains(object2, point) {
              return (object2 && containsObjectType.hasOwnProperty(object2.type) ? containsObjectType[object2.type] : containsGeometry)(object2, point);
            }
            function graticuleX(y02, y12, dy) {
              var y = d3Array.range(y02, y12 - epsilon, dy).concat(y12);
              return function(x) {
                return y.map(function(y2) {
                  return [x, y2];
                });
              };
            }
            function graticuleY(x02, x12, dx) {
              var x = d3Array.range(x02, x12 - epsilon, dx).concat(x12);
              return function(y) {
                return x.map(function(x2) {
                  return [x2, y];
                });
              };
            }
            function graticule() {
              var x12, x02, X12, X02, y12, y02, Y12, Y02, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;
              function graticule2() {
                return { type: "MultiLineString", coordinates: lines() };
              }
              function lines() {
                return d3Array.range(ceil(X02 / DX) * DX, X12, DX).map(X).concat(d3Array.range(ceil(Y02 / DY) * DY, Y12, DY).map(Y)).concat(d3Array.range(ceil(x02 / dx) * dx, x12, dx).filter(function(x2) {
                  return abs(x2 % DX) > epsilon;
                }).map(x)).concat(d3Array.range(ceil(y02 / dy) * dy, y12, dy).filter(function(y2) {
                  return abs(y2 % DY) > epsilon;
                }).map(y));
              }
              graticule2.lines = function() {
                return lines().map(function(coordinates2) {
                  return { type: "LineString", coordinates: coordinates2 };
                });
              };
              graticule2.outline = function() {
                return {
                  type: "Polygon",
                  coordinates: [
                    X(X02).concat(Y(Y12).slice(1), X(X12).reverse().slice(1), Y(Y02).reverse().slice(1))
                  ]
                };
              };
              graticule2.extent = function(_) {
                if (!arguments.length)
                  return graticule2.extentMinor();
                return graticule2.extentMajor(_).extentMinor(_);
              };
              graticule2.extentMajor = function(_) {
                if (!arguments.length)
                  return [[X02, Y02], [X12, Y12]];
                X02 = +_[0][0], X12 = +_[1][0];
                Y02 = +_[0][1], Y12 = +_[1][1];
                if (X02 > X12)
                  _ = X02, X02 = X12, X12 = _;
                if (Y02 > Y12)
                  _ = Y02, Y02 = Y12, Y12 = _;
                return graticule2.precision(precision);
              };
              graticule2.extentMinor = function(_) {
                if (!arguments.length)
                  return [[x02, y02], [x12, y12]];
                x02 = +_[0][0], x12 = +_[1][0];
                y02 = +_[0][1], y12 = +_[1][1];
                if (x02 > x12)
                  _ = x02, x02 = x12, x12 = _;
                if (y02 > y12)
                  _ = y02, y02 = y12, y12 = _;
                return graticule2.precision(precision);
              };
              graticule2.step = function(_) {
                if (!arguments.length)
                  return graticule2.stepMinor();
                return graticule2.stepMajor(_).stepMinor(_);
              };
              graticule2.stepMajor = function(_) {
                if (!arguments.length)
                  return [DX, DY];
                DX = +_[0], DY = +_[1];
                return graticule2;
              };
              graticule2.stepMinor = function(_) {
                if (!arguments.length)
                  return [dx, dy];
                dx = +_[0], dy = +_[1];
                return graticule2;
              };
              graticule2.precision = function(_) {
                if (!arguments.length)
                  return precision;
                precision = +_;
                x = graticuleX(y02, y12, 90);
                y = graticuleY(x02, x12, precision);
                X = graticuleX(Y02, Y12, 90);
                Y = graticuleY(X02, X12, precision);
                return graticule2;
              };
              return graticule2.extentMajor([[-180, -90 + epsilon], [180, 90 - epsilon]]).extentMinor([[-180, -80 - epsilon], [180, 80 + epsilon]]);
            }
            function graticule10() {
              return graticule()();
            }
            function interpolate(a, b) {
              var x02 = a[0] * radians, y02 = a[1] * radians, x12 = b[0] * radians, y12 = b[1] * radians, cy0 = cos(y02), sy0 = sin(y02), cy1 = cos(y12), sy1 = sin(y12), kx0 = cy0 * cos(x02), ky0 = cy0 * sin(x02), kx1 = cy1 * cos(x12), ky1 = cy1 * sin(x12), d = 2 * asin(sqrt(haversin(y12 - y02) + cy0 * cy1 * haversin(x12 - x02))), k = sin(d);
              var interpolate2 = d ? function(t) {
                var B = sin(t *= d) / k, A = sin(d - t) / k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
                return [
                  atan2(y, x) * degrees,
                  atan2(z, sqrt(x * x + y * y)) * degrees
                ];
              } : function() {
                return [x02 * degrees, y02 * degrees];
              };
              interpolate2.distance = d;
              return interpolate2;
            }
            function identity(x) {
              return x;
            }
            var areaSum$1 = adder(), areaRingSum$1 = adder(), x00, y00, x0$1, y0$1;
            var areaStream$1 = {
              point: noop,
              lineStart: noop,
              lineEnd: noop,
              polygonStart: function() {
                areaStream$1.lineStart = areaRingStart$1;
                areaStream$1.lineEnd = areaRingEnd$1;
              },
              polygonEnd: function() {
                areaStream$1.lineStart = areaStream$1.lineEnd = areaStream$1.point = noop;
                areaSum$1.add(abs(areaRingSum$1));
                areaRingSum$1.reset();
              },
              result: function() {
                var area2 = areaSum$1 / 2;
                areaSum$1.reset();
                return area2;
              }
            };
            function areaRingStart$1() {
              areaStream$1.point = areaPointFirst$1;
            }
            function areaPointFirst$1(x, y) {
              areaStream$1.point = areaPoint$1;
              x00 = x0$1 = x, y00 = y0$1 = y;
            }
            function areaPoint$1(x, y) {
              areaRingSum$1.add(y0$1 * x - x0$1 * y);
              x0$1 = x, y0$1 = y;
            }
            function areaRingEnd$1() {
              areaPoint$1(x00, y00);
            }
            var x0$2 = Infinity, y0$2 = x0$2, x1 = -x0$2, y1 = x1;
            var boundsStream$1 = {
              point: boundsPoint$1,
              lineStart: noop,
              lineEnd: noop,
              polygonStart: noop,
              polygonEnd: noop,
              result: function() {
                var bounds2 = [[x0$2, y0$2], [x1, y1]];
                x1 = y1 = -(y0$2 = x0$2 = Infinity);
                return bounds2;
              }
            };
            function boundsPoint$1(x, y) {
              if (x < x0$2)
                x0$2 = x;
              if (x > x1)
                x1 = x;
              if (y < y0$2)
                y0$2 = y;
              if (y > y1)
                y1 = y;
            }
            var X0$1 = 0, Y0$1 = 0, Z0$1 = 0, X1$1 = 0, Y1$1 = 0, Z1$1 = 0, X2$1 = 0, Y2$1 = 0, Z2$1 = 0, x00$1, y00$1, x0$3, y0$3;
            var centroidStream$1 = {
              point: centroidPoint$1,
              lineStart: centroidLineStart$1,
              lineEnd: centroidLineEnd$1,
              polygonStart: function() {
                centroidStream$1.lineStart = centroidRingStart$1;
                centroidStream$1.lineEnd = centroidRingEnd$1;
              },
              polygonEnd: function() {
                centroidStream$1.point = centroidPoint$1;
                centroidStream$1.lineStart = centroidLineStart$1;
                centroidStream$1.lineEnd = centroidLineEnd$1;
              },
              result: function() {
                var centroid2 = Z2$1 ? [X2$1 / Z2$1, Y2$1 / Z2$1] : Z1$1 ? [X1$1 / Z1$1, Y1$1 / Z1$1] : Z0$1 ? [X0$1 / Z0$1, Y0$1 / Z0$1] : [NaN, NaN];
                X0$1 = Y0$1 = Z0$1 = X1$1 = Y1$1 = Z1$1 = X2$1 = Y2$1 = Z2$1 = 0;
                return centroid2;
              }
            };
            function centroidPoint$1(x, y) {
              X0$1 += x;
              Y0$1 += y;
              ++Z0$1;
            }
            function centroidLineStart$1() {
              centroidStream$1.point = centroidPointFirstLine;
            }
            function centroidPointFirstLine(x, y) {
              centroidStream$1.point = centroidPointLine;
              centroidPoint$1(x0$3 = x, y0$3 = y);
            }
            function centroidPointLine(x, y) {
              var dx = x - x0$3, dy = y - y0$3, z = sqrt(dx * dx + dy * dy);
              X1$1 += z * (x0$3 + x) / 2;
              Y1$1 += z * (y0$3 + y) / 2;
              Z1$1 += z;
              centroidPoint$1(x0$3 = x, y0$3 = y);
            }
            function centroidLineEnd$1() {
              centroidStream$1.point = centroidPoint$1;
            }
            function centroidRingStart$1() {
              centroidStream$1.point = centroidPointFirstRing;
            }
            function centroidRingEnd$1() {
              centroidPointRing(x00$1, y00$1);
            }
            function centroidPointFirstRing(x, y) {
              centroidStream$1.point = centroidPointRing;
              centroidPoint$1(x00$1 = x0$3 = x, y00$1 = y0$3 = y);
            }
            function centroidPointRing(x, y) {
              var dx = x - x0$3, dy = y - y0$3, z = sqrt(dx * dx + dy * dy);
              X1$1 += z * (x0$3 + x) / 2;
              Y1$1 += z * (y0$3 + y) / 2;
              Z1$1 += z;
              z = y0$3 * x - x0$3 * y;
              X2$1 += z * (x0$3 + x);
              Y2$1 += z * (y0$3 + y);
              Z2$1 += z * 3;
              centroidPoint$1(x0$3 = x, y0$3 = y);
            }
            function PathContext(context) {
              this._context = context;
            }
            PathContext.prototype = {
              _radius: 4.5,
              pointRadius: function(_) {
                return this._radius = _, this;
              },
              polygonStart: function() {
                this._line = 0;
              },
              polygonEnd: function() {
                this._line = NaN;
              },
              lineStart: function() {
                this._point = 0;
              },
              lineEnd: function() {
                if (this._line === 0)
                  this._context.closePath();
                this._point = NaN;
              },
              point: function(x, y) {
                switch (this._point) {
                  case 0: {
                    this._context.moveTo(x, y);
                    this._point = 1;
                    break;
                  }
                  case 1: {
                    this._context.lineTo(x, y);
                    break;
                  }
                  default: {
                    this._context.moveTo(x + this._radius, y);
                    this._context.arc(x, y, this._radius, 0, tau);
                    break;
                  }
                }
              },
              result: noop
            };
            var lengthSum$1 = adder(), lengthRing, x00$2, y00$2, x0$4, y0$4;
            var lengthStream$1 = {
              point: noop,
              lineStart: function() {
                lengthStream$1.point = lengthPointFirst$1;
              },
              lineEnd: function() {
                if (lengthRing)
                  lengthPoint$1(x00$2, y00$2);
                lengthStream$1.point = noop;
              },
              polygonStart: function() {
                lengthRing = true;
              },
              polygonEnd: function() {
                lengthRing = null;
              },
              result: function() {
                var length2 = +lengthSum$1;
                lengthSum$1.reset();
                return length2;
              }
            };
            function lengthPointFirst$1(x, y) {
              lengthStream$1.point = lengthPoint$1;
              x00$2 = x0$4 = x, y00$2 = y0$4 = y;
            }
            function lengthPoint$1(x, y) {
              x0$4 -= x, y0$4 -= y;
              lengthSum$1.add(sqrt(x0$4 * x0$4 + y0$4 * y0$4));
              x0$4 = x, y0$4 = y;
            }
            function PathString() {
              this._string = [];
            }
            PathString.prototype = {
              _radius: 4.5,
              _circle: circle$1(4.5),
              pointRadius: function(_) {
                if ((_ = +_) !== this._radius)
                  this._radius = _, this._circle = null;
                return this;
              },
              polygonStart: function() {
                this._line = 0;
              },
              polygonEnd: function() {
                this._line = NaN;
              },
              lineStart: function() {
                this._point = 0;
              },
              lineEnd: function() {
                if (this._line === 0)
                  this._string.push("Z");
                this._point = NaN;
              },
              point: function(x, y) {
                switch (this._point) {
                  case 0: {
                    this._string.push("M", x, ",", y);
                    this._point = 1;
                    break;
                  }
                  case 1: {
                    this._string.push("L", x, ",", y);
                    break;
                  }
                  default: {
                    if (this._circle == null)
                      this._circle = circle$1(this._radius);
                    this._string.push("M", x, ",", y, this._circle);
                    break;
                  }
                }
              },
              result: function() {
                if (this._string.length) {
                  var result = this._string.join("");
                  this._string = [];
                  return result;
                } else {
                  return null;
                }
              }
            };
            function circle$1(radius) {
              return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
            }
            function index(projection2, context) {
              var pointRadius = 4.5, projectionStream, contextStream;
              function path(object2) {
                if (object2) {
                  if (typeof pointRadius === "function")
                    contextStream.pointRadius(+pointRadius.apply(this, arguments));
                  geoStream(object2, projectionStream(contextStream));
                }
                return contextStream.result();
              }
              path.area = function(object2) {
                geoStream(object2, projectionStream(areaStream$1));
                return areaStream$1.result();
              };
              path.measure = function(object2) {
                geoStream(object2, projectionStream(lengthStream$1));
                return lengthStream$1.result();
              };
              path.bounds = function(object2) {
                geoStream(object2, projectionStream(boundsStream$1));
                return boundsStream$1.result();
              };
              path.centroid = function(object2) {
                geoStream(object2, projectionStream(centroidStream$1));
                return centroidStream$1.result();
              };
              path.projection = function(_) {
                return arguments.length ? (projectionStream = _ == null ? (projection2 = null, identity) : (projection2 = _).stream, path) : projection2;
              };
              path.context = function(_) {
                if (!arguments.length)
                  return context;
                contextStream = _ == null ? (context = null, new PathString()) : new PathContext(context = _);
                if (typeof pointRadius !== "function")
                  contextStream.pointRadius(pointRadius);
                return path;
              };
              path.pointRadius = function(_) {
                if (!arguments.length)
                  return pointRadius;
                pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
                return path;
              };
              return path.projection(projection2).context(context);
            }
            function transform(methods) {
              return {
                stream: transformer(methods)
              };
            }
            function transformer(methods) {
              return function(stream) {
                var s = new TransformStream();
                for (var key in methods)
                  s[key] = methods[key];
                s.stream = stream;
                return s;
              };
            }
            function TransformStream() {
            }
            TransformStream.prototype = {
              constructor: TransformStream,
              point: function(x, y) {
                this.stream.point(x, y);
              },
              sphere: function() {
                this.stream.sphere();
              },
              lineStart: function() {
                this.stream.lineStart();
              },
              lineEnd: function() {
                this.stream.lineEnd();
              },
              polygonStart: function() {
                this.stream.polygonStart();
              },
              polygonEnd: function() {
                this.stream.polygonEnd();
              }
            };
            function fit(projection2, fitBounds, object2) {
              var clip2 = projection2.clipExtent && projection2.clipExtent();
              projection2.scale(150).translate([0, 0]);
              if (clip2 != null)
                projection2.clipExtent(null);
              geoStream(object2, projection2.stream(boundsStream$1));
              fitBounds(boundsStream$1.result());
              if (clip2 != null)
                projection2.clipExtent(clip2);
              return projection2;
            }
            function fitExtent(projection2, extent2, object2) {
              return fit(projection2, function(b) {
                var w = extent2[1][0] - extent2[0][0], h = extent2[1][1] - extent2[0][1], k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])), x = +extent2[0][0] + (w - k * (b[1][0] + b[0][0])) / 2, y = +extent2[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
                projection2.scale(150 * k).translate([x, y]);
              }, object2);
            }
            function fitSize(projection2, size, object2) {
              return fitExtent(projection2, [[0, 0], size], object2);
            }
            function fitWidth(projection2, width, object2) {
              return fit(projection2, function(b) {
                var w = +width, k = w / (b[1][0] - b[0][0]), x = (w - k * (b[1][0] + b[0][0])) / 2, y = -k * b[0][1];
                projection2.scale(150 * k).translate([x, y]);
              }, object2);
            }
            function fitHeight(projection2, height, object2) {
              return fit(projection2, function(b) {
                var h = +height, k = h / (b[1][1] - b[0][1]), x = -k * b[0][0], y = (h - k * (b[1][1] + b[0][1])) / 2;
                projection2.scale(150 * k).translate([x, y]);
              }, object2);
            }
            var maxDepth = 16, cosMinDistance = cos(30 * radians);
            function resample(project, delta2) {
              return +delta2 ? resample$1(project, delta2) : resampleNone(project);
            }
            function resampleNone(project) {
              return transformer({
                point: function(x, y) {
                  x = project(x, y);
                  this.stream.point(x[0], x[1]);
                }
              });
            }
            function resample$1(project, delta2) {
              function resampleLineTo(x02, y02, lambda02, a0, b0, c0, x12, y12, lambda12, a1, b1, c1, depth, stream) {
                var dx = x12 - x02, dy = y12 - y02, d2 = dx * dx + dy * dy;
                if (d2 > 4 * delta2 && depth--) {
                  var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = sqrt(a * a + b * b + c * c), phi2 = asin(c /= m), lambda22 = abs(abs(c) - 1) < epsilon || abs(lambda02 - lambda12) < epsilon ? (lambda02 + lambda12) / 2 : atan2(b, a), p = project(lambda22, phi2), x2 = p[0], y2 = p[1], dx2 = x2 - x02, dy2 = y2 - y02, dz = dy * dx2 - dx * dy2;
                  if (dz * dz / d2 > delta2 || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
                    resampleLineTo(x02, y02, lambda02, a0, b0, c0, x2, y2, lambda22, a /= m, b /= m, c, depth, stream);
                    stream.point(x2, y2);
                    resampleLineTo(x2, y2, lambda22, a, b, c, x12, y12, lambda12, a1, b1, c1, depth, stream);
                  }
                }
              }
              return function(stream) {
                var lambda002, x002, y002, a00, b00, c00, lambda02, x02, y02, a0, b0, c0;
                var resampleStream = {
                  point,
                  lineStart,
                  lineEnd,
                  polygonStart: function() {
                    stream.polygonStart();
                    resampleStream.lineStart = ringStart;
                  },
                  polygonEnd: function() {
                    stream.polygonEnd();
                    resampleStream.lineStart = lineStart;
                  }
                };
                function point(x, y) {
                  x = project(x, y);
                  stream.point(x[0], x[1]);
                }
                function lineStart() {
                  x02 = NaN;
                  resampleStream.point = linePoint2;
                  stream.lineStart();
                }
                function linePoint2(lambda, phi) {
                  var c = cartesian([lambda, phi]), p = project(lambda, phi);
                  resampleLineTo(x02, y02, lambda02, a0, b0, c0, x02 = p[0], y02 = p[1], lambda02 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
                  stream.point(x02, y02);
                }
                function lineEnd() {
                  resampleStream.point = point;
                  stream.lineEnd();
                }
                function ringStart() {
                  lineStart();
                  resampleStream.point = ringPoint;
                  resampleStream.lineEnd = ringEnd;
                }
                function ringPoint(lambda, phi) {
                  linePoint2(lambda002 = lambda, phi), x002 = x02, y002 = y02, a00 = a0, b00 = b0, c00 = c0;
                  resampleStream.point = linePoint2;
                }
                function ringEnd() {
                  resampleLineTo(x02, y02, lambda02, a0, b0, c0, x002, y002, lambda002, a00, b00, c00, maxDepth, stream);
                  resampleStream.lineEnd = lineEnd;
                  lineEnd();
                }
                return resampleStream;
              };
            }
            var transformRadians = transformer({
              point: function(x, y) {
                this.stream.point(x * radians, y * radians);
              }
            });
            function transformRotate(rotate) {
              return transformer({
                point: function(x, y) {
                  var r = rotate(x, y);
                  return this.stream.point(r[0], r[1]);
                }
              });
            }
            function scaleTranslate(k, dx, dy, sx, sy) {
              function transform2(x, y) {
                x *= sx;
                y *= sy;
                return [dx + k * x, dy - k * y];
              }
              transform2.invert = function(x, y) {
                return [(x - dx) / k * sx, (dy - y) / k * sy];
              };
              return transform2;
            }
            function scaleTranslateRotate(k, dx, dy, sx, sy, alpha) {
              var cosAlpha = cos(alpha), sinAlpha = sin(alpha), a = cosAlpha * k, b = sinAlpha * k, ai = cosAlpha / k, bi = sinAlpha / k, ci = (sinAlpha * dy - cosAlpha * dx) / k, fi = (sinAlpha * dx + cosAlpha * dy) / k;
              function transform2(x, y) {
                x *= sx;
                y *= sy;
                return [a * x - b * y + dx, dy - b * x - a * y];
              }
              transform2.invert = function(x, y) {
                return [sx * (ai * x - bi * y + ci), sy * (fi - bi * x - ai * y)];
              };
              return transform2;
            }
            function projection(project) {
              return projectionMutator(function() {
                return project;
              })();
            }
            function projectionMutator(projectAt) {
              var project, k = 150, x = 480, y = 250, lambda = 0, phi = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, alpha = 0, sx = 1, sy = 1, theta = null, preclip = clipAntimeridian, x02 = null, y02, x12, y12, postclip = identity, delta2 = 0.5, projectResample, projectTransform, projectRotateTransform, cache, cacheStream;
              function projection2(point) {
                return projectRotateTransform(point[0] * radians, point[1] * radians);
              }
              function invert(point) {
                point = projectRotateTransform.invert(point[0], point[1]);
                return point && [point[0] * degrees, point[1] * degrees];
              }
              projection2.stream = function(stream) {
                return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
              };
              projection2.preclip = function(_) {
                return arguments.length ? (preclip = _, theta = void 0, reset()) : preclip;
              };
              projection2.postclip = function(_) {
                return arguments.length ? (postclip = _, x02 = y02 = x12 = y12 = null, reset()) : postclip;
              };
              projection2.clipAngle = function(_) {
                return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees;
              };
              projection2.clipExtent = function(_) {
                return arguments.length ? (postclip = _ == null ? (x02 = y02 = x12 = y12 = null, identity) : clipRectangle(x02 = +_[0][0], y02 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reset()) : x02 == null ? null : [[x02, y02], [x12, y12]];
              };
              projection2.scale = function(_) {
                return arguments.length ? (k = +_, recenter()) : k;
              };
              projection2.translate = function(_) {
                return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
              };
              projection2.center = function(_) {
                return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];
              };
              projection2.rotate = function(_) {
                return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
              };
              projection2.angle = function(_) {
                return arguments.length ? (alpha = _ % 360 * radians, recenter()) : alpha * degrees;
              };
              projection2.reflectX = function(_) {
                return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;
              };
              projection2.reflectY = function(_) {
                return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;
              };
              projection2.precision = function(_) {
                return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);
              };
              projection2.fitExtent = function(extent2, object2) {
                return fitExtent(projection2, extent2, object2);
              };
              projection2.fitSize = function(size, object2) {
                return fitSize(projection2, size, object2);
              };
              projection2.fitWidth = function(width, object2) {
                return fitWidth(projection2, width, object2);
              };
              projection2.fitHeight = function(height, object2) {
                return fitHeight(projection2, height, object2);
              };
              function recenter() {
                var center = scaleTranslateRotate(k, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi)), transform2 = (alpha ? scaleTranslateRotate : scaleTranslate)(k, x - center[0], y - center[1], sx, sy, alpha);
                rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
                projectTransform = compose(project, transform2);
                projectRotateTransform = compose(rotate, projectTransform);
                projectResample = resample(projectTransform, delta2);
                return reset();
              }
              function reset() {
                cache = cacheStream = null;
                return projection2;
              }
              return function() {
                project = projectAt.apply(this, arguments);
                projection2.invert = project.invert && invert;
                return recenter();
              };
            }
            function conicProjection(projectAt) {
              var phi02 = 0, phi12 = pi / 3, m = projectionMutator(projectAt), p = m(phi02, phi12);
              p.parallels = function(_) {
                return arguments.length ? m(phi02 = _[0] * radians, phi12 = _[1] * radians) : [phi02 * degrees, phi12 * degrees];
              };
              return p;
            }
            function cylindricalEqualAreaRaw(phi02) {
              var cosPhi02 = cos(phi02);
              function forward(lambda, phi) {
                return [lambda * cosPhi02, sin(phi) / cosPhi02];
              }
              forward.invert = function(x, y) {
                return [x / cosPhi02, asin(y * cosPhi02)];
              };
              return forward;
            }
            function conicEqualAreaRaw(y02, y12) {
              var sy0 = sin(y02), n = (sy0 + sin(y12)) / 2;
              if (abs(n) < epsilon)
                return cylindricalEqualAreaRaw(y02);
              var c = 1 + sy0 * (2 * n - sy0), r0 = sqrt(c) / n;
              function project(x, y) {
                var r = sqrt(c - 2 * n * sin(y)) / n;
                return [r * sin(x *= n), r0 - r * cos(x)];
              }
              project.invert = function(x, y) {
                var r0y = r0 - y, l = atan2(x, abs(r0y)) * sign(r0y);
                if (r0y * n < 0)
                  l -= pi * sign(x) * sign(r0y);
                return [l / n, asin((c - (x * x + r0y * r0y) * n * n) / (2 * n))];
              };
              return project;
            }
            function conicEqualArea() {
              return conicProjection(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
            }
            function albers() {
              return conicEqualArea().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
            }
            function multiplex(streams) {
              var n = streams.length;
              return {
                point: function(x, y) {
                  var i = -1;
                  while (++i < n)
                    streams[i].point(x, y);
                },
                sphere: function() {
                  var i = -1;
                  while (++i < n)
                    streams[i].sphere();
                },
                lineStart: function() {
                  var i = -1;
                  while (++i < n)
                    streams[i].lineStart();
                },
                lineEnd: function() {
                  var i = -1;
                  while (++i < n)
                    streams[i].lineEnd();
                },
                polygonStart: function() {
                  var i = -1;
                  while (++i < n)
                    streams[i].polygonStart();
                },
                polygonEnd: function() {
                  var i = -1;
                  while (++i < n)
                    streams[i].polygonEnd();
                }
              };
            }
            function albersUsa() {
              var cache, cacheStream, lower48 = albers(), lower48Point, alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, point, pointStream = { point: function(x, y) {
                point = [x, y];
              } };
              function albersUsa2(coordinates2) {
                var x = coordinates2[0], y = coordinates2[1];
                return point = null, (lower48Point.point(x, y), point) || (alaskaPoint.point(x, y), point) || (hawaiiPoint.point(x, y), point);
              }
              albersUsa2.invert = function(coordinates2) {
                var k = lower48.scale(), t = lower48.translate(), x = (coordinates2[0] - t[0]) / k, y = (coordinates2[1] - t[1]) / k;
                return (y >= 0.12 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii : lower48).invert(coordinates2);
              };
              albersUsa2.stream = function(stream) {
                return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
              };
              albersUsa2.precision = function(_) {
                if (!arguments.length)
                  return lower48.precision();
                lower48.precision(_), alaska.precision(_), hawaii.precision(_);
                return reset();
              };
              albersUsa2.scale = function(_) {
                if (!arguments.length)
                  return lower48.scale();
                lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
                return albersUsa2.translate(lower48.translate());
              };
              albersUsa2.translate = function(_) {
                if (!arguments.length)
                  return lower48.translate();
                var k = lower48.scale(), x = +_[0], y = +_[1];
                lower48Point = lower48.translate(_).clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]]).stream(pointStream);
                alaskaPoint = alaska.translate([x - 0.307 * k, y + 0.201 * k]).clipExtent([[x - 0.425 * k + epsilon, y + 0.12 * k + epsilon], [x - 0.214 * k - epsilon, y + 0.234 * k - epsilon]]).stream(pointStream);
                hawaiiPoint = hawaii.translate([x - 0.205 * k, y + 0.212 * k]).clipExtent([[x - 0.214 * k + epsilon, y + 0.166 * k + epsilon], [x - 0.115 * k - epsilon, y + 0.234 * k - epsilon]]).stream(pointStream);
                return reset();
              };
              albersUsa2.fitExtent = function(extent2, object2) {
                return fitExtent(albersUsa2, extent2, object2);
              };
              albersUsa2.fitSize = function(size, object2) {
                return fitSize(albersUsa2, size, object2);
              };
              albersUsa2.fitWidth = function(width, object2) {
                return fitWidth(albersUsa2, width, object2);
              };
              albersUsa2.fitHeight = function(height, object2) {
                return fitHeight(albersUsa2, height, object2);
              };
              function reset() {
                cache = cacheStream = null;
                return albersUsa2;
              }
              return albersUsa2.scale(1070);
            }
            function azimuthalRaw(scale) {
              return function(x, y) {
                var cx = cos(x), cy = cos(y), k = scale(cx * cy);
                return [
                  k * cy * sin(x),
                  k * sin(y)
                ];
              };
            }
            function azimuthalInvert(angle2) {
              return function(x, y) {
                var z = sqrt(x * x + y * y), c = angle2(z), sc = sin(c), cc = cos(c);
                return [
                  atan2(x * sc, z * cc),
                  asin(z && y * sc / z)
                ];
              };
            }
            var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
              return sqrt(2 / (1 + cxcy));
            });
            azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
              return 2 * asin(z / 2);
            });
            function azimuthalEqualArea() {
              return projection(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
            }
            var azimuthalEquidistantRaw = azimuthalRaw(function(c) {
              return (c = acos(c)) && c / sin(c);
            });
            azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
              return z;
            });
            function azimuthalEquidistant() {
              return projection(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
            }
            function mercatorRaw(lambda, phi) {
              return [lambda, log(tan((halfPi + phi) / 2))];
            }
            mercatorRaw.invert = function(x, y) {
              return [x, 2 * atan(exp(y)) - halfPi];
            };
            function mercator() {
              return mercatorProjection(mercatorRaw).scale(961 / tau);
            }
            function mercatorProjection(project) {
              var m = projection(project), center = m.center, scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, x02 = null, y02, x12, y12;
              m.scale = function(_) {
                return arguments.length ? (scale(_), reclip()) : scale();
              };
              m.translate = function(_) {
                return arguments.length ? (translate(_), reclip()) : translate();
              };
              m.center = function(_) {
                return arguments.length ? (center(_), reclip()) : center();
              };
              m.clipExtent = function(_) {
                return arguments.length ? (_ == null ? x02 = y02 = x12 = y12 = null : (x02 = +_[0][0], y02 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reclip()) : x02 == null ? null : [[x02, y02], [x12, y12]];
              };
              function reclip() {
                var k = pi * scale(), t = m(rotation(m.rotate()).invert([0, 0]));
                return clipExtent(x02 == null ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw ? [[Math.max(t[0] - k, x02), y02], [Math.min(t[0] + k, x12), y12]] : [[x02, Math.max(t[1] - k, y02)], [x12, Math.min(t[1] + k, y12)]]);
              }
              return reclip();
            }
            function tany(y) {
              return tan((halfPi + y) / 2);
            }
            function conicConformalRaw(y02, y12) {
              var cy0 = cos(y02), n = y02 === y12 ? sin(y02) : log(cy0 / cos(y12)) / log(tany(y12) / tany(y02)), f = cy0 * pow(tany(y02), n) / n;
              if (!n)
                return mercatorRaw;
              function project(x, y) {
                if (f > 0) {
                  if (y < -halfPi + epsilon)
                    y = -halfPi + epsilon;
                } else {
                  if (y > halfPi - epsilon)
                    y = halfPi - epsilon;
                }
                var r = f / pow(tany(y), n);
                return [r * sin(n * x), f - r * cos(n * x)];
              }
              project.invert = function(x, y) {
                var fy = f - y, r = sign(n) * sqrt(x * x + fy * fy), l = atan2(x, abs(fy)) * sign(fy);
                if (fy * n < 0)
                  l -= pi * sign(x) * sign(fy);
                return [l / n, 2 * atan(pow(f / r, 1 / n)) - halfPi];
              };
              return project;
            }
            function conicConformal() {
              return conicProjection(conicConformalRaw).scale(109.5).parallels([30, 30]);
            }
            function equirectangularRaw(lambda, phi) {
              return [lambda, phi];
            }
            equirectangularRaw.invert = equirectangularRaw;
            function equirectangular() {
              return projection(equirectangularRaw).scale(152.63);
            }
            function conicEquidistantRaw(y02, y12) {
              var cy0 = cos(y02), n = y02 === y12 ? sin(y02) : (cy0 - cos(y12)) / (y12 - y02), g = cy0 / n + y02;
              if (abs(n) < epsilon)
                return equirectangularRaw;
              function project(x, y) {
                var gy = g - y, nx = n * x;
                return [gy * sin(nx), g - gy * cos(nx)];
              }
              project.invert = function(x, y) {
                var gy = g - y, l = atan2(x, abs(gy)) * sign(gy);
                if (gy * n < 0)
                  l -= pi * sign(x) * sign(gy);
                return [l / n, g - sign(n) * sqrt(x * x + gy * gy)];
              };
              return project;
            }
            function conicEquidistant() {
              return conicProjection(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
            }
            var A1 = 1.340264, A2 = -0.081106, A3 = 893e-6, A4 = 3796e-6, M = sqrt(3) / 2, iterations = 12;
            function equalEarthRaw(lambda, phi) {
              var l = asin(M * sin(phi)), l2 = l * l, l6 = l2 * l2 * l2;
              return [
                lambda * cos(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),
                l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))
              ];
            }
            equalEarthRaw.invert = function(x, y) {
              var l = y, l2 = l * l, l6 = l2 * l2 * l2;
              for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
                fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y;
                fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);
                l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;
                if (abs(delta) < epsilon2)
                  break;
              }
              return [
                M * x * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos(l),
                asin(sin(l) / M)
              ];
            };
            function equalEarth() {
              return projection(equalEarthRaw).scale(177.158);
            }
            function gnomonicRaw(x, y) {
              var cy = cos(y), k = cos(x) * cy;
              return [cy * sin(x) / k, sin(y) / k];
            }
            gnomonicRaw.invert = azimuthalInvert(atan);
            function gnomonic() {
              return projection(gnomonicRaw).scale(144.049).clipAngle(60);
            }
            function identity$1() {
              var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, alpha = 0, ca, sa, x02 = null, y02, x12, y12, kx = 1, ky = 1, transform2 = transformer({
                point: function(x, y) {
                  var p = projection2([x, y]);
                  this.stream.point(p[0], p[1]);
                }
              }), postclip = identity, cache, cacheStream;
              function reset() {
                kx = k * sx;
                ky = k * sy;
                cache = cacheStream = null;
                return projection2;
              }
              function projection2(p) {
                var x = p[0] * kx, y = p[1] * ky;
                if (alpha) {
                  var t = y * ca - x * sa;
                  x = x * ca + y * sa;
                  y = t;
                }
                return [x + tx, y + ty];
              }
              projection2.invert = function(p) {
                var x = p[0] - tx, y = p[1] - ty;
                if (alpha) {
                  var t = y * ca + x * sa;
                  x = x * ca - y * sa;
                  y = t;
                }
                return [x / kx, y / ky];
              };
              projection2.stream = function(stream) {
                return cache && cacheStream === stream ? cache : cache = transform2(postclip(cacheStream = stream));
              };
              projection2.postclip = function(_) {
                return arguments.length ? (postclip = _, x02 = y02 = x12 = y12 = null, reset()) : postclip;
              };
              projection2.clipExtent = function(_) {
                return arguments.length ? (postclip = _ == null ? (x02 = y02 = x12 = y12 = null, identity) : clipRectangle(x02 = +_[0][0], y02 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reset()) : x02 == null ? null : [[x02, y02], [x12, y12]];
              };
              projection2.scale = function(_) {
                return arguments.length ? (k = +_, reset()) : k;
              };
              projection2.translate = function(_) {
                return arguments.length ? (tx = +_[0], ty = +_[1], reset()) : [tx, ty];
              };
              projection2.angle = function(_) {
                return arguments.length ? (alpha = _ % 360 * radians, sa = sin(alpha), ca = cos(alpha), reset()) : alpha * degrees;
              };
              projection2.reflectX = function(_) {
                return arguments.length ? (sx = _ ? -1 : 1, reset()) : sx < 0;
              };
              projection2.reflectY = function(_) {
                return arguments.length ? (sy = _ ? -1 : 1, reset()) : sy < 0;
              };
              projection2.fitExtent = function(extent2, object2) {
                return fitExtent(projection2, extent2, object2);
              };
              projection2.fitSize = function(size, object2) {
                return fitSize(projection2, size, object2);
              };
              projection2.fitWidth = function(width, object2) {
                return fitWidth(projection2, width, object2);
              };
              projection2.fitHeight = function(height, object2) {
                return fitHeight(projection2, height, object2);
              };
              return projection2;
            }
            function naturalEarth1Raw(lambda, phi) {
              var phi2 = phi * phi, phi4 = phi2 * phi2;
              return [
                lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (3971e-6 * phi2 - 1529e-6 * phi4))),
                phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 5916e-6 * phi4)))
              ];
            }
            naturalEarth1Raw.invert = function(x, y) {
              var phi = y, i = 25, delta;
              do {
                var phi2 = phi * phi, phi4 = phi2 * phi2;
                phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 5916e-6 * phi4))) - y) / (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 5916e-6 * 11 * phi4)));
              } while (abs(delta) > epsilon && --i > 0);
              return [
                x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (3971e-6 - 1529e-6 * phi2)))),
                phi
              ];
            };
            function naturalEarth1() {
              return projection(naturalEarth1Raw).scale(175.295);
            }
            function orthographicRaw(x, y) {
              return [cos(y) * sin(x), sin(y)];
            }
            orthographicRaw.invert = azimuthalInvert(asin);
            function orthographic() {
              return projection(orthographicRaw).scale(249.5).clipAngle(90 + epsilon);
            }
            function stereographicRaw(x, y) {
              var cy = cos(y), k = 1 + cos(x) * cy;
              return [cy * sin(x) / k, sin(y) / k];
            }
            stereographicRaw.invert = azimuthalInvert(function(z) {
              return 2 * atan(z);
            });
            function stereographic() {
              return projection(stereographicRaw).scale(250).clipAngle(142);
            }
            function transverseMercatorRaw(lambda, phi) {
              return [log(tan((halfPi + phi) / 2)), -lambda];
            }
            transverseMercatorRaw.invert = function(x, y) {
              return [-y, 2 * atan(exp(x)) - halfPi];
            };
            function transverseMercator() {
              var m = mercatorProjection(transverseMercatorRaw), center = m.center, rotate = m.rotate;
              m.center = function(_) {
                return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
              };
              m.rotate = function(_) {
                return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
              };
              return rotate([0, 0, 90]).scale(159.155);
            }
            exports3.geoAlbers = albers;
            exports3.geoAlbersUsa = albersUsa;
            exports3.geoArea = area;
            exports3.geoAzimuthalEqualArea = azimuthalEqualArea;
            exports3.geoAzimuthalEqualAreaRaw = azimuthalEqualAreaRaw;
            exports3.geoAzimuthalEquidistant = azimuthalEquidistant;
            exports3.geoAzimuthalEquidistantRaw = azimuthalEquidistantRaw;
            exports3.geoBounds = bounds;
            exports3.geoCentroid = centroid;
            exports3.geoCircle = circle;
            exports3.geoClipAntimeridian = clipAntimeridian;
            exports3.geoClipCircle = clipCircle;
            exports3.geoClipExtent = extent;
            exports3.geoClipRectangle = clipRectangle;
            exports3.geoConicConformal = conicConformal;
            exports3.geoConicConformalRaw = conicConformalRaw;
            exports3.geoConicEqualArea = conicEqualArea;
            exports3.geoConicEqualAreaRaw = conicEqualAreaRaw;
            exports3.geoConicEquidistant = conicEquidistant;
            exports3.geoConicEquidistantRaw = conicEquidistantRaw;
            exports3.geoContains = contains;
            exports3.geoDistance = distance;
            exports3.geoEqualEarth = equalEarth;
            exports3.geoEqualEarthRaw = equalEarthRaw;
            exports3.geoEquirectangular = equirectangular;
            exports3.geoEquirectangularRaw = equirectangularRaw;
            exports3.geoGnomonic = gnomonic;
            exports3.geoGnomonicRaw = gnomonicRaw;
            exports3.geoGraticule = graticule;
            exports3.geoGraticule10 = graticule10;
            exports3.geoIdentity = identity$1;
            exports3.geoInterpolate = interpolate;
            exports3.geoLength = length;
            exports3.geoMercator = mercator;
            exports3.geoMercatorRaw = mercatorRaw;
            exports3.geoNaturalEarth1 = naturalEarth1;
            exports3.geoNaturalEarth1Raw = naturalEarth1Raw;
            exports3.geoOrthographic = orthographic;
            exports3.geoOrthographicRaw = orthographicRaw;
            exports3.geoPath = index;
            exports3.geoProjection = projection;
            exports3.geoProjectionMutator = projectionMutator;
            exports3.geoRotation = rotation;
            exports3.geoStereographic = stereographic;
            exports3.geoStereographicRaw = stereographicRaw;
            exports3.geoStream = geoStream;
            exports3.geoTransform = transform;
            exports3.geoTransverseMercator = transverseMercator;
            exports3.geoTransverseMercatorRaw = transverseMercatorRaw;
            Object.defineProperty(exports3, "__esModule", { value: true });
          });
        },
        "./node_modules/_d3-geo@1.6.4@d3-geo/build/d3-geo.js": function(module2, exports2, __webpack_require__) {
          (function(global, factory) {
            true ? factory(exports2, __webpack_require__("./node_modules/_d3-array@1.2.4@d3-array/dist/d3-array.js")) : void 0;
          })(this, function(exports3, d3Array) {
            "use strict";
            var adder = function() {
              return new Adder();
            };
            function Adder() {
              this.reset();
            }
            Adder.prototype = {
              constructor: Adder,
              reset: function() {
                this.s = this.t = 0;
              },
              add: function(y) {
                add(temp, y, this.t);
                add(this, temp.s, this.s);
                if (this.s)
                  this.t += temp.t;
                else
                  this.s = temp.t;
              },
              valueOf: function() {
                return this.s;
              }
            };
            var temp = new Adder();
            function add(adder2, a, b) {
              var x = adder2.s = a + b, bv = x - a, av = x - bv;
              adder2.t = a - av + (b - bv);
            }
            var epsilon = 1e-6;
            var epsilon2 = 1e-12;
            var pi = Math.PI;
            var halfPi = pi / 2;
            var quarterPi = pi / 4;
            var tau = pi * 2;
            var degrees = 180 / pi;
            var radians = pi / 180;
            var abs = Math.abs;
            var atan = Math.atan;
            var atan2 = Math.atan2;
            var cos = Math.cos;
            var ceil = Math.ceil;
            var exp = Math.exp;
            var log = Math.log;
            var pow = Math.pow;
            var sin = Math.sin;
            var sign = Math.sign || function(x) {
              return x > 0 ? 1 : x < 0 ? -1 : 0;
            };
            var sqrt = Math.sqrt;
            var tan = Math.tan;
            function acos(x) {
              return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
            }
            function asin(x) {
              return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
            }
            function haversin(x) {
              return (x = sin(x / 2)) * x;
            }
            function noop() {
            }
            function streamGeometry(geometry, stream) {
              if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
                streamGeometryType[geometry.type](geometry, stream);
              }
            }
            var streamObjectType = {
              Feature: function(object2, stream) {
                streamGeometry(object2.geometry, stream);
              },
              FeatureCollection: function(object2, stream) {
                var features = object2.features, i = -1, n = features.length;
                while (++i < n)
                  streamGeometry(features[i].geometry, stream);
              }
            };
            var streamGeometryType = {
              Sphere: function(object2, stream) {
                stream.sphere();
              },
              Point: function(object2, stream) {
                object2 = object2.coordinates;
                stream.point(object2[0], object2[1], object2[2]);
              },
              MultiPoint: function(object2, stream) {
                var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
                while (++i < n)
                  object2 = coordinates2[i], stream.point(object2[0], object2[1], object2[2]);
              },
              LineString: function(object2, stream) {
                streamLine(object2.coordinates, stream, 0);
              },
              MultiLineString: function(object2, stream) {
                var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
                while (++i < n)
                  streamLine(coordinates2[i], stream, 0);
              },
              Polygon: function(object2, stream) {
                streamPolygon(object2.coordinates, stream);
              },
              MultiPolygon: function(object2, stream) {
                var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
                while (++i < n)
                  streamPolygon(coordinates2[i], stream);
              },
              GeometryCollection: function(object2, stream) {
                var geometries = object2.geometries, i = -1, n = geometries.length;
                while (++i < n)
                  streamGeometry(geometries[i], stream);
              }
            };
            function streamLine(coordinates2, stream, closed) {
              var i = -1, n = coordinates2.length - closed, coordinate;
              stream.lineStart();
              while (++i < n)
                coordinate = coordinates2[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
              stream.lineEnd();
            }
            function streamPolygon(coordinates2, stream) {
              var i = -1, n = coordinates2.length;
              stream.polygonStart();
              while (++i < n)
                streamLine(coordinates2[i], stream, 1);
              stream.polygonEnd();
            }
            var geoStream = function(object2, stream) {
              if (object2 && streamObjectType.hasOwnProperty(object2.type)) {
                streamObjectType[object2.type](object2, stream);
              } else {
                streamGeometry(object2, stream);
              }
            };
            var areaRingSum = adder();
            var areaSum = adder();
            var lambda00;
            var phi00;
            var lambda0;
            var cosPhi0;
            var sinPhi0;
            var areaStream = {
              point: noop,
              lineStart: noop,
              lineEnd: noop,
              polygonStart: function() {
                areaRingSum.reset();
                areaStream.lineStart = areaRingStart;
                areaStream.lineEnd = areaRingEnd;
              },
              polygonEnd: function() {
                var areaRing = +areaRingSum;
                areaSum.add(areaRing < 0 ? tau + areaRing : areaRing);
                this.lineStart = this.lineEnd = this.point = noop;
              },
              sphere: function() {
                areaSum.add(tau);
              }
            };
            function areaRingStart() {
              areaStream.point = areaPointFirst;
            }
            function areaRingEnd() {
              areaPoint(lambda00, phi00);
            }
            function areaPointFirst(lambda, phi) {
              areaStream.point = areaPoint;
              lambda00 = lambda, phi00 = phi;
              lambda *= radians, phi *= radians;
              lambda0 = lambda, cosPhi0 = cos(phi = phi / 2 + quarterPi), sinPhi0 = sin(phi);
            }
            function areaPoint(lambda, phi) {
              lambda *= radians, phi *= radians;
              phi = phi / 2 + quarterPi;
              var dLambda = lambda - lambda0, sdLambda = dLambda >= 0 ? 1 : -1, adLambda = sdLambda * dLambda, cosPhi = cos(phi), sinPhi = sin(phi), k = sinPhi0 * sinPhi, u = cosPhi0 * cosPhi + k * cos(adLambda), v = k * sdLambda * sin(adLambda);
              areaRingSum.add(atan2(v, u));
              lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
            }
            var area = function(object2) {
              areaSum.reset();
              geoStream(object2, areaStream);
              return areaSum * 2;
            };
            function spherical(cartesian2) {
              return [atan2(cartesian2[1], cartesian2[0]), asin(cartesian2[2])];
            }
            function cartesian(spherical2) {
              var lambda = spherical2[0], phi = spherical2[1], cosPhi = cos(phi);
              return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];
            }
            function cartesianDot(a, b) {
              return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
            }
            function cartesianCross(a, b) {
              return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
            }
            function cartesianAddInPlace(a, b) {
              a[0] += b[0], a[1] += b[1], a[2] += b[2];
            }
            function cartesianScale(vector, k) {
              return [vector[0] * k, vector[1] * k, vector[2] * k];
            }
            function cartesianNormalizeInPlace(d) {
              var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
              d[0] /= l, d[1] /= l, d[2] /= l;
            }
            var lambda0$1;
            var phi0;
            var lambda1;
            var phi1;
            var lambda2;
            var lambda00$1;
            var phi00$1;
            var p0;
            var deltaSum = adder();
            var ranges;
            var range$1;
            var boundsStream = {
              point: boundsPoint,
              lineStart: boundsLineStart,
              lineEnd: boundsLineEnd,
              polygonStart: function() {
                boundsStream.point = boundsRingPoint;
                boundsStream.lineStart = boundsRingStart;
                boundsStream.lineEnd = boundsRingEnd;
                deltaSum.reset();
                areaStream.polygonStart();
              },
              polygonEnd: function() {
                areaStream.polygonEnd();
                boundsStream.point = boundsPoint;
                boundsStream.lineStart = boundsLineStart;
                boundsStream.lineEnd = boundsLineEnd;
                if (areaRingSum < 0)
                  lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
                else if (deltaSum > epsilon)
                  phi1 = 90;
                else if (deltaSum < -epsilon)
                  phi0 = -90;
                range$1[0] = lambda0$1, range$1[1] = lambda1;
              }
            };
            function boundsPoint(lambda, phi) {
              ranges.push(range$1 = [lambda0$1 = lambda, lambda1 = lambda]);
              if (phi < phi0)
                phi0 = phi;
              if (phi > phi1)
                phi1 = phi;
            }
            function linePoint(lambda, phi) {
              var p = cartesian([lambda * radians, phi * radians]);
              if (p0) {
                var normal = cartesianCross(p0, p), equatorial = [normal[1], -normal[0], 0], inflection = cartesianCross(equatorial, normal);
                cartesianNormalizeInPlace(inflection);
                inflection = spherical(inflection);
                var delta = lambda - lambda2, sign$$1 = delta > 0 ? 1 : -1, lambdai = inflection[0] * degrees * sign$$1, phii, antimeridian = abs(delta) > 180;
                if (antimeridian ^ (sign$$1 * lambda2 < lambdai && lambdai < sign$$1 * lambda)) {
                  phii = inflection[1] * degrees;
                  if (phii > phi1)
                    phi1 = phii;
                } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign$$1 * lambda2 < lambdai && lambdai < sign$$1 * lambda)) {
                  phii = -inflection[1] * degrees;
                  if (phii < phi0)
                    phi0 = phii;
                } else {
                  if (phi < phi0)
                    phi0 = phi;
                  if (phi > phi1)
                    phi1 = phi;
                }
                if (antimeridian) {
                  if (lambda < lambda2) {
                    if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1))
                      lambda1 = lambda;
                  } else {
                    if (angle(lambda, lambda1) > angle(lambda0$1, lambda1))
                      lambda0$1 = lambda;
                  }
                } else {
                  if (lambda1 >= lambda0$1) {
                    if (lambda < lambda0$1)
                      lambda0$1 = lambda;
                    if (lambda > lambda1)
                      lambda1 = lambda;
                  } else {
                    if (lambda > lambda2) {
                      if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1))
                        lambda1 = lambda;
                    } else {
                      if (angle(lambda, lambda1) > angle(lambda0$1, lambda1))
                        lambda0$1 = lambda;
                    }
                  }
                }
              } else {
                ranges.push(range$1 = [lambda0$1 = lambda, lambda1 = lambda]);
              }
              if (phi < phi0)
                phi0 = phi;
              if (phi > phi1)
                phi1 = phi;
              p0 = p, lambda2 = lambda;
            }
            function boundsLineStart() {
              boundsStream.point = linePoint;
            }
            function boundsLineEnd() {
              range$1[0] = lambda0$1, range$1[1] = lambda1;
              boundsStream.point = boundsPoint;
              p0 = null;
            }
            function boundsRingPoint(lambda, phi) {
              if (p0) {
                var delta = lambda - lambda2;
                deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
              } else {
                lambda00$1 = lambda, phi00$1 = phi;
              }
              areaStream.point(lambda, phi);
              linePoint(lambda, phi);
            }
            function boundsRingStart() {
              areaStream.lineStart();
            }
            function boundsRingEnd() {
              boundsRingPoint(lambda00$1, phi00$1);
              areaStream.lineEnd();
              if (abs(deltaSum) > epsilon)
                lambda0$1 = -(lambda1 = 180);
              range$1[0] = lambda0$1, range$1[1] = lambda1;
              p0 = null;
            }
            function angle(lambda02, lambda12) {
              return (lambda12 -= lambda02) < 0 ? lambda12 + 360 : lambda12;
            }
            function rangeCompare(a, b) {
              return a[0] - b[0];
            }
            function rangeContains(range$$1, x) {
              return range$$1[0] <= range$$1[1] ? range$$1[0] <= x && x <= range$$1[1] : x < range$$1[0] || range$$1[1] < x;
            }
            var bounds = function(feature) {
              var i, n, a, b, merged, deltaMax, delta;
              phi1 = lambda1 = -(lambda0$1 = phi0 = Infinity);
              ranges = [];
              geoStream(feature, boundsStream);
              if (n = ranges.length) {
                ranges.sort(rangeCompare);
                for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
                  b = ranges[i];
                  if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
                    if (angle(a[0], b[1]) > angle(a[0], a[1]))
                      a[1] = b[1];
                    if (angle(b[0], a[1]) > angle(a[0], a[1]))
                      a[0] = b[0];
                  } else {
                    merged.push(a = b);
                  }
                }
                for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
                  b = merged[i];
                  if ((delta = angle(a[1], b[0])) > deltaMax)
                    deltaMax = delta, lambda0$1 = b[0], lambda1 = a[1];
                }
              }
              ranges = range$1 = null;
              return lambda0$1 === Infinity || phi0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[lambda0$1, phi0], [lambda1, phi1]];
            };
            var W0;
            var W1;
            var X0;
            var Y0;
            var Z0;
            var X1;
            var Y1;
            var Z1;
            var X2;
            var Y2;
            var Z2;
            var lambda00$2;
            var phi00$2;
            var x0;
            var y0;
            var z0;
            var centroidStream = {
              sphere: noop,
              point: centroidPoint,
              lineStart: centroidLineStart,
              lineEnd: centroidLineEnd,
              polygonStart: function() {
                centroidStream.lineStart = centroidRingStart;
                centroidStream.lineEnd = centroidRingEnd;
              },
              polygonEnd: function() {
                centroidStream.lineStart = centroidLineStart;
                centroidStream.lineEnd = centroidLineEnd;
              }
            };
            function centroidPoint(lambda, phi) {
              lambda *= radians, phi *= radians;
              var cosPhi = cos(phi);
              centroidPointCartesian(cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi));
            }
            function centroidPointCartesian(x, y, z) {
              ++W0;
              X0 += (x - X0) / W0;
              Y0 += (y - Y0) / W0;
              Z0 += (z - Z0) / W0;
            }
            function centroidLineStart() {
              centroidStream.point = centroidLinePointFirst;
            }
            function centroidLinePointFirst(lambda, phi) {
              lambda *= radians, phi *= radians;
              var cosPhi = cos(phi);
              x0 = cosPhi * cos(lambda);
              y0 = cosPhi * sin(lambda);
              z0 = sin(phi);
              centroidStream.point = centroidLinePoint;
              centroidPointCartesian(x0, y0, z0);
            }
            function centroidLinePoint(lambda, phi) {
              lambda *= radians, phi *= radians;
              var cosPhi = cos(phi), x = cosPhi * cos(lambda), y = cosPhi * sin(lambda), z = sin(phi), w = atan2(sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
              W1 += w;
              X1 += w * (x0 + (x0 = x));
              Y1 += w * (y0 + (y0 = y));
              Z1 += w * (z0 + (z0 = z));
              centroidPointCartesian(x0, y0, z0);
            }
            function centroidLineEnd() {
              centroidStream.point = centroidPoint;
            }
            function centroidRingStart() {
              centroidStream.point = centroidRingPointFirst;
            }
            function centroidRingEnd() {
              centroidRingPoint(lambda00$2, phi00$2);
              centroidStream.point = centroidPoint;
            }
            function centroidRingPointFirst(lambda, phi) {
              lambda00$2 = lambda, phi00$2 = phi;
              lambda *= radians, phi *= radians;
              centroidStream.point = centroidRingPoint;
              var cosPhi = cos(phi);
              x0 = cosPhi * cos(lambda);
              y0 = cosPhi * sin(lambda);
              z0 = sin(phi);
              centroidPointCartesian(x0, y0, z0);
            }
            function centroidRingPoint(lambda, phi) {
              lambda *= radians, phi *= radians;
              var cosPhi = cos(phi), x = cosPhi * cos(lambda), y = cosPhi * sin(lambda), z = sin(phi), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = sqrt(cx * cx + cy * cy + cz * cz), w = asin(m), v = m && -w / m;
              X2 += v * cx;
              Y2 += v * cy;
              Z2 += v * cz;
              W1 += w;
              X1 += w * (x0 + (x0 = x));
              Y1 += w * (y0 + (y0 = y));
              Z1 += w * (z0 + (z0 = z));
              centroidPointCartesian(x0, y0, z0);
            }
            var centroid = function(object2) {
              W0 = W1 = X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2 = Y2 = Z2 = 0;
              geoStream(object2, centroidStream);
              var x = X2, y = Y2, z = Z2, m = x * x + y * y + z * z;
              if (m < epsilon2) {
                x = X1, y = Y1, z = Z1;
                if (W1 < epsilon)
                  x = X0, y = Y0, z = Z0;
                m = x * x + y * y + z * z;
                if (m < epsilon2)
                  return [NaN, NaN];
              }
              return [atan2(y, x) * degrees, asin(z / sqrt(m)) * degrees];
            };
            var constant = function(x) {
              return function() {
                return x;
              };
            };
            var compose = function(a, b) {
              function compose2(x, y) {
                return x = a(x, y), b(x[0], x[1]);
              }
              if (a.invert && b.invert)
                compose2.invert = function(x, y) {
                  return x = b.invert(x, y), x && a.invert(x[0], x[1]);
                };
              return compose2;
            };
            function rotationIdentity(lambda, phi) {
              return [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];
            }
            rotationIdentity.invert = rotationIdentity;
            function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
              return (deltaLambda %= tau) ? deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
            }
            function forwardRotationLambda(deltaLambda) {
              return function(lambda, phi) {
                return lambda += deltaLambda, [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];
              };
            }
            function rotationLambda(deltaLambda) {
              var rotation2 = forwardRotationLambda(deltaLambda);
              rotation2.invert = forwardRotationLambda(-deltaLambda);
              return rotation2;
            }
            function rotationPhiGamma(deltaPhi, deltaGamma) {
              var cosDeltaPhi = cos(deltaPhi), sinDeltaPhi = sin(deltaPhi), cosDeltaGamma = cos(deltaGamma), sinDeltaGamma = sin(deltaGamma);
              function rotation2(lambda, phi) {
                var cosPhi = cos(phi), x = cos(lambda) * cosPhi, y = sin(lambda) * cosPhi, z = sin(phi), k = z * cosDeltaPhi + x * sinDeltaPhi;
                return [
                  atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
                  asin(k * cosDeltaGamma + y * sinDeltaGamma)
                ];
              }
              rotation2.invert = function(lambda, phi) {
                var cosPhi = cos(phi), x = cos(lambda) * cosPhi, y = sin(lambda) * cosPhi, z = sin(phi), k = z * cosDeltaGamma - y * sinDeltaGamma;
                return [
                  atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
                  asin(k * cosDeltaPhi - x * sinDeltaPhi)
                ];
              };
              return rotation2;
            }
            var rotation = function(rotate) {
              rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);
              function forward(coordinates2) {
                coordinates2 = rotate(coordinates2[0] * radians, coordinates2[1] * radians);
                return coordinates2[0] *= degrees, coordinates2[1] *= degrees, coordinates2;
              }
              forward.invert = function(coordinates2) {
                coordinates2 = rotate.invert(coordinates2[0] * radians, coordinates2[1] * radians);
                return coordinates2[0] *= degrees, coordinates2[1] *= degrees, coordinates2;
              };
              return forward;
            };
            function circleStream(stream, radius, delta, direction, t0, t1) {
              if (!delta)
                return;
              var cosRadius = cos(radius), sinRadius = sin(radius), step = direction * delta;
              if (t0 == null) {
                t0 = radius + direction * tau;
                t1 = radius - step / 2;
              } else {
                t0 = circleRadius(cosRadius, t0);
                t1 = circleRadius(cosRadius, t1);
                if (direction > 0 ? t0 < t1 : t0 > t1)
                  t0 += direction * tau;
              }
              for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
                point = spherical([cosRadius, -sinRadius * cos(t), -sinRadius * sin(t)]);
                stream.point(point[0], point[1]);
              }
            }
            function circleRadius(cosRadius, point) {
              point = cartesian(point), point[0] -= cosRadius;
              cartesianNormalizeInPlace(point);
              var radius = acos(-point[1]);
              return ((-point[2] < 0 ? -radius : radius) + tau - epsilon) % tau;
            }
            var circle = function() {
              var center = constant([0, 0]), radius = constant(90), precision = constant(6), ring, rotate, stream = { point };
              function point(x, y) {
                ring.push(x = rotate(x, y));
                x[0] *= degrees, x[1] *= degrees;
              }
              function circle2() {
                var c = center.apply(this, arguments), r = radius.apply(this, arguments) * radians, p = precision.apply(this, arguments) * radians;
                ring = [];
                rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;
                circleStream(stream, r, p, 1);
                c = { type: "Polygon", coordinates: [ring] };
                ring = rotate = null;
                return c;
              }
              circle2.center = function(_) {
                return arguments.length ? (center = typeof _ === "function" ? _ : constant([+_[0], +_[1]]), circle2) : center;
              };
              circle2.radius = function(_) {
                return arguments.length ? (radius = typeof _ === "function" ? _ : constant(+_), circle2) : radius;
              };
              circle2.precision = function(_) {
                return arguments.length ? (precision = typeof _ === "function" ? _ : constant(+_), circle2) : precision;
              };
              return circle2;
            };
            var clipBuffer = function() {
              var lines = [], line;
              return {
                point: function(x, y) {
                  line.push([x, y]);
                },
                lineStart: function() {
                  lines.push(line = []);
                },
                lineEnd: noop,
                rejoin: function() {
                  if (lines.length > 1)
                    lines.push(lines.pop().concat(lines.shift()));
                },
                result: function() {
                  var result = lines;
                  lines = [];
                  line = null;
                  return result;
                }
              };
            };
            var clipLine = function(a, b, x02, y02, x12, y12) {
              var ax = a[0], ay = a[1], bx = b[0], by = b[1], t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
              r = x02 - ax;
              if (!dx && r > 0)
                return;
              r /= dx;
              if (dx < 0) {
                if (r < t0)
                  return;
                if (r < t1)
                  t1 = r;
              } else if (dx > 0) {
                if (r > t1)
                  return;
                if (r > t0)
                  t0 = r;
              }
              r = x12 - ax;
              if (!dx && r < 0)
                return;
              r /= dx;
              if (dx < 0) {
                if (r > t1)
                  return;
                if (r > t0)
                  t0 = r;
              } else if (dx > 0) {
                if (r < t0)
                  return;
                if (r < t1)
                  t1 = r;
              }
              r = y02 - ay;
              if (!dy && r > 0)
                return;
              r /= dy;
              if (dy < 0) {
                if (r < t0)
                  return;
                if (r < t1)
                  t1 = r;
              } else if (dy > 0) {
                if (r > t1)
                  return;
                if (r > t0)
                  t0 = r;
              }
              r = y12 - ay;
              if (!dy && r < 0)
                return;
              r /= dy;
              if (dy < 0) {
                if (r > t1)
                  return;
                if (r > t0)
                  t0 = r;
              } else if (dy > 0) {
                if (r < t0)
                  return;
                if (r < t1)
                  t1 = r;
              }
              if (t0 > 0)
                a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
              if (t1 < 1)
                b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
              return true;
            };
            var pointEqual = function(a, b) {
              return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;
            };
            function Intersection(point, points, other, entry) {
              this.x = point;
              this.z = points;
              this.o = other;
              this.e = entry;
              this.v = false;
              this.n = this.p = null;
            }
            var clipPolygon = function(segments, compareIntersection2, startInside, interpolate2, stream) {
              var subject = [], clip2 = [], i, n;
              segments.forEach(function(segment) {
                if ((n2 = segment.length - 1) <= 0)
                  return;
                var n2, p02 = segment[0], p1 = segment[n2], x;
                if (pointEqual(p02, p1)) {
                  stream.lineStart();
                  for (i = 0; i < n2; ++i)
                    stream.point((p02 = segment[i])[0], p02[1]);
                  stream.lineEnd();
                  return;
                }
                subject.push(x = new Intersection(p02, segment, null, true));
                clip2.push(x.o = new Intersection(p02, null, x, false));
                subject.push(x = new Intersection(p1, segment, null, false));
                clip2.push(x.o = new Intersection(p1, null, x, true));
              });
              if (!subject.length)
                return;
              clip2.sort(compareIntersection2);
              link(subject);
              link(clip2);
              for (i = 0, n = clip2.length; i < n; ++i) {
                clip2[i].e = startInside = !startInside;
              }
              var start = subject[0], points, point;
              while (1) {
                var current = start, isSubject = true;
                while (current.v)
                  if ((current = current.n) === start)
                    return;
                points = current.z;
                stream.lineStart();
                do {
                  current.v = current.o.v = true;
                  if (current.e) {
                    if (isSubject) {
                      for (i = 0, n = points.length; i < n; ++i)
                        stream.point((point = points[i])[0], point[1]);
                    } else {
                      interpolate2(current.x, current.n.x, 1, stream);
                    }
                    current = current.n;
                  } else {
                    if (isSubject) {
                      points = current.p.z;
                      for (i = points.length - 1; i >= 0; --i)
                        stream.point((point = points[i])[0], point[1]);
                    } else {
                      interpolate2(current.x, current.p.x, -1, stream);
                    }
                    current = current.p;
                  }
                  current = current.o;
                  points = current.z;
                  isSubject = !isSubject;
                } while (!current.v);
                stream.lineEnd();
              }
            };
            function link(array) {
              if (!(n = array.length))
                return;
              var n, i = 0, a = array[0], b;
              while (++i < n) {
                a.n = b = array[i];
                b.p = a;
                a = b;
              }
              a.n = b = array[0];
              b.p = a;
            }
            var clipMax = 1e9;
            var clipMin = -clipMax;
            function clipExtent(x02, y02, x12, y12) {
              function visible(x, y) {
                return x02 <= x && x <= x12 && y02 <= y && y <= y12;
              }
              function interpolate2(from, to, direction, stream) {
                var a = 0, a1 = 0;
                if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {
                  do
                    stream.point(a === 0 || a === 3 ? x02 : x12, a > 1 ? y12 : y02);
                  while ((a = (a + direction + 4) % 4) !== a1);
                } else {
                  stream.point(to[0], to[1]);
                }
              }
              function corner(p, direction) {
                return abs(p[0] - x02) < epsilon ? direction > 0 ? 0 : 3 : abs(p[0] - x12) < epsilon ? direction > 0 ? 2 : 1 : abs(p[1] - y02) < epsilon ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
              }
              function compareIntersection2(a, b) {
                return comparePoint(a.x, b.x);
              }
              function comparePoint(a, b) {
                var ca = corner(a, 1), cb = corner(b, 1);
                return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
              }
              return function(stream) {
                var activeStream = stream, bufferStream = clipBuffer(), segments, polygon, ring, x__, y__, v__, x_, y_, v_, first, clean;
                var clipStream = {
                  point,
                  lineStart,
                  lineEnd,
                  polygonStart,
                  polygonEnd
                };
                function point(x, y) {
                  if (visible(x, y))
                    activeStream.point(x, y);
                }
                function polygonInside() {
                  var winding = 0;
                  for (var i = 0, n = polygon.length; i < n; ++i) {
                    for (var ring2 = polygon[i], j = 1, m = ring2.length, point2 = ring2[0], a0, a1, b0 = point2[0], b1 = point2[1]; j < m; ++j) {
                      a0 = b0, a1 = b1, point2 = ring2[j], b0 = point2[0], b1 = point2[1];
                      if (a1 <= y12) {
                        if (b1 > y12 && (b0 - a0) * (y12 - a1) > (b1 - a1) * (x02 - a0))
                          ++winding;
                      } else {
                        if (b1 <= y12 && (b0 - a0) * (y12 - a1) < (b1 - a1) * (x02 - a0))
                          --winding;
                      }
                    }
                  }
                  return winding;
                }
                function polygonStart() {
                  activeStream = bufferStream, segments = [], polygon = [], clean = true;
                }
                function polygonEnd() {
                  var startInside = polygonInside(), cleanInside = clean && startInside, visible2 = (segments = d3Array.merge(segments)).length;
                  if (cleanInside || visible2) {
                    stream.polygonStart();
                    if (cleanInside) {
                      stream.lineStart();
                      interpolate2(null, null, 1, stream);
                      stream.lineEnd();
                    }
                    if (visible2) {
                      clipPolygon(segments, compareIntersection2, startInside, interpolate2, stream);
                    }
                    stream.polygonEnd();
                  }
                  activeStream = stream, segments = polygon = ring = null;
                }
                function lineStart() {
                  clipStream.point = linePoint2;
                  if (polygon)
                    polygon.push(ring = []);
                  first = true;
                  v_ = false;
                  x_ = y_ = NaN;
                }
                function lineEnd() {
                  if (segments) {
                    linePoint2(x__, y__);
                    if (v__ && v_)
                      bufferStream.rejoin();
                    segments.push(bufferStream.result());
                  }
                  clipStream.point = point;
                  if (v_)
                    activeStream.lineEnd();
                }
                function linePoint2(x, y) {
                  var v = visible(x, y);
                  if (polygon)
                    ring.push([x, y]);
                  if (first) {
                    x__ = x, y__ = y, v__ = v;
                    first = false;
                    if (v) {
                      activeStream.lineStart();
                      activeStream.point(x, y);
                    }
                  } else {
                    if (v && v_)
                      activeStream.point(x, y);
                    else {
                      var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
                      if (clipLine(a, b, x02, y02, x12, y12)) {
                        if (!v_) {
                          activeStream.lineStart();
                          activeStream.point(a[0], a[1]);
                        }
                        activeStream.point(b[0], b[1]);
                        if (!v)
                          activeStream.lineEnd();
                        clean = false;
                      } else if (v) {
                        activeStream.lineStart();
                        activeStream.point(x, y);
                        clean = false;
                      }
                    }
                  }
                  x_ = x, y_ = y, v_ = v;
                }
                return clipStream;
              };
            }
            var extent = function() {
              var x02 = 0, y02 = 0, x12 = 960, y12 = 500, cache, cacheStream, clip2;
              return clip2 = {
                stream: function(stream) {
                  return cache && cacheStream === stream ? cache : cache = clipExtent(x02, y02, x12, y12)(cacheStream = stream);
                },
                extent: function(_) {
                  return arguments.length ? (x02 = +_[0][0], y02 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1], cache = cacheStream = null, clip2) : [[x02, y02], [x12, y12]];
                }
              };
            };
            var sum = adder();
            var polygonContains = function(polygon, point) {
              var lambda = point[0], phi = point[1], normal = [sin(lambda), -cos(lambda), 0], angle2 = 0, winding = 0;
              sum.reset();
              for (var i = 0, n = polygon.length; i < n; ++i) {
                if (!(m = (ring = polygon[i]).length))
                  continue;
                var ring, m, point0 = ring[m - 1], lambda02 = point0[0], phi02 = point0[1] / 2 + quarterPi, sinPhi02 = sin(phi02), cosPhi02 = cos(phi02);
                for (var j = 0; j < m; ++j, lambda02 = lambda12, sinPhi02 = sinPhi1, cosPhi02 = cosPhi1, point0 = point1) {
                  var point1 = ring[j], lambda12 = point1[0], phi12 = point1[1] / 2 + quarterPi, sinPhi1 = sin(phi12), cosPhi1 = cos(phi12), delta = lambda12 - lambda02, sign$$1 = delta >= 0 ? 1 : -1, absDelta = sign$$1 * delta, antimeridian = absDelta > pi, k = sinPhi02 * sinPhi1;
                  sum.add(atan2(k * sign$$1 * sin(absDelta), cosPhi02 * cosPhi1 + k * cos(absDelta)));
                  angle2 += antimeridian ? delta + sign$$1 * tau : delta;
                  if (antimeridian ^ lambda02 >= lambda ^ lambda12 >= lambda) {
                    var arc = cartesianCross(cartesian(point0), cartesian(point1));
                    cartesianNormalizeInPlace(arc);
                    var intersection = cartesianCross(normal, arc);
                    cartesianNormalizeInPlace(intersection);
                    var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);
                    if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
                      winding += antimeridian ^ delta >= 0 ? 1 : -1;
                    }
                  }
                }
              }
              return (angle2 < -epsilon || angle2 < epsilon && sum < -epsilon) ^ winding & 1;
            };
            var lengthSum = adder();
            var lambda0$2;
            var sinPhi0$1;
            var cosPhi0$1;
            var lengthStream = {
              sphere: noop,
              point: noop,
              lineStart: lengthLineStart,
              lineEnd: noop,
              polygonStart: noop,
              polygonEnd: noop
            };
            function lengthLineStart() {
              lengthStream.point = lengthPointFirst;
              lengthStream.lineEnd = lengthLineEnd;
            }
            function lengthLineEnd() {
              lengthStream.point = lengthStream.lineEnd = noop;
            }
            function lengthPointFirst(lambda, phi) {
              lambda *= radians, phi *= radians;
              lambda0$2 = lambda, sinPhi0$1 = sin(phi), cosPhi0$1 = cos(phi);
              lengthStream.point = lengthPoint;
            }
            function lengthPoint(lambda, phi) {
              lambda *= radians, phi *= radians;
              var sinPhi = sin(phi), cosPhi = cos(phi), delta = abs(lambda - lambda0$2), cosDelta = cos(delta), sinDelta = sin(delta), x = cosPhi * sinDelta, y = cosPhi0$1 * sinPhi - sinPhi0$1 * cosPhi * cosDelta, z = sinPhi0$1 * sinPhi + cosPhi0$1 * cosPhi * cosDelta;
              lengthSum.add(atan2(sqrt(x * x + y * y), z));
              lambda0$2 = lambda, sinPhi0$1 = sinPhi, cosPhi0$1 = cosPhi;
            }
            var length = function(object2) {
              lengthSum.reset();
              geoStream(object2, lengthStream);
              return +lengthSum;
            };
            var coordinates = [null, null];
            var object = { type: "LineString", coordinates };
            var distance = function(a, b) {
              coordinates[0] = a;
              coordinates[1] = b;
              return length(object);
            };
            var containsObjectType = {
              Feature: function(object2, point) {
                return containsGeometry(object2.geometry, point);
              },
              FeatureCollection: function(object2, point) {
                var features = object2.features, i = -1, n = features.length;
                while (++i < n)
                  if (containsGeometry(features[i].geometry, point))
                    return true;
                return false;
              }
            };
            var containsGeometryType = {
              Sphere: function() {
                return true;
              },
              Point: function(object2, point) {
                return containsPoint(object2.coordinates, point);
              },
              MultiPoint: function(object2, point) {
                var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
                while (++i < n)
                  if (containsPoint(coordinates2[i], point))
                    return true;
                return false;
              },
              LineString: function(object2, point) {
                return containsLine(object2.coordinates, point);
              },
              MultiLineString: function(object2, point) {
                var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
                while (++i < n)
                  if (containsLine(coordinates2[i], point))
                    return true;
                return false;
              },
              Polygon: function(object2, point) {
                return containsPolygon(object2.coordinates, point);
              },
              MultiPolygon: function(object2, point) {
                var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
                while (++i < n)
                  if (containsPolygon(coordinates2[i], point))
                    return true;
                return false;
              },
              GeometryCollection: function(object2, point) {
                var geometries = object2.geometries, i = -1, n = geometries.length;
                while (++i < n)
                  if (containsGeometry(geometries[i], point))
                    return true;
                return false;
              }
            };
            function containsGeometry(geometry, point) {
              return geometry && containsGeometryType.hasOwnProperty(geometry.type) ? containsGeometryType[geometry.type](geometry, point) : false;
            }
            function containsPoint(coordinates2, point) {
              return distance(coordinates2, point) === 0;
            }
            function containsLine(coordinates2, point) {
              var ab = distance(coordinates2[0], coordinates2[1]), ao = distance(coordinates2[0], point), ob = distance(point, coordinates2[1]);
              return ao + ob <= ab + epsilon;
            }
            function containsPolygon(coordinates2, point) {
              return !!polygonContains(coordinates2.map(ringRadians), pointRadians(point));
            }
            function ringRadians(ring) {
              return ring = ring.map(pointRadians), ring.pop(), ring;
            }
            function pointRadians(point) {
              return [point[0] * radians, point[1] * radians];
            }
            var contains = function(object2, point) {
              return (object2 && containsObjectType.hasOwnProperty(object2.type) ? containsObjectType[object2.type] : containsGeometry)(object2, point);
            };
            function graticuleX(y02, y12, dy) {
              var y = d3Array.range(y02, y12 - epsilon, dy).concat(y12);
              return function(x) {
                return y.map(function(y2) {
                  return [x, y2];
                });
              };
            }
            function graticuleY(x02, x12, dx) {
              var x = d3Array.range(x02, x12 - epsilon, dx).concat(x12);
              return function(y) {
                return x.map(function(x2) {
                  return [x2, y];
                });
              };
            }
            function graticule() {
              var x12, x02, X12, X02, y12, y02, Y12, Y02, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;
              function graticule2() {
                return { type: "MultiLineString", coordinates: lines() };
              }
              function lines() {
                return d3Array.range(ceil(X02 / DX) * DX, X12, DX).map(X).concat(d3Array.range(ceil(Y02 / DY) * DY, Y12, DY).map(Y)).concat(d3Array.range(ceil(x02 / dx) * dx, x12, dx).filter(function(x2) {
                  return abs(x2 % DX) > epsilon;
                }).map(x)).concat(d3Array.range(ceil(y02 / dy) * dy, y12, dy).filter(function(y2) {
                  return abs(y2 % DY) > epsilon;
                }).map(y));
              }
              graticule2.lines = function() {
                return lines().map(function(coordinates2) {
                  return { type: "LineString", coordinates: coordinates2 };
                });
              };
              graticule2.outline = function() {
                return {
                  type: "Polygon",
                  coordinates: [
                    X(X02).concat(Y(Y12).slice(1), X(X12).reverse().slice(1), Y(Y02).reverse().slice(1))
                  ]
                };
              };
              graticule2.extent = function(_) {
                if (!arguments.length)
                  return graticule2.extentMinor();
                return graticule2.extentMajor(_).extentMinor(_);
              };
              graticule2.extentMajor = function(_) {
                if (!arguments.length)
                  return [[X02, Y02], [X12, Y12]];
                X02 = +_[0][0], X12 = +_[1][0];
                Y02 = +_[0][1], Y12 = +_[1][1];
                if (X02 > X12)
                  _ = X02, X02 = X12, X12 = _;
                if (Y02 > Y12)
                  _ = Y02, Y02 = Y12, Y12 = _;
                return graticule2.precision(precision);
              };
              graticule2.extentMinor = function(_) {
                if (!arguments.length)
                  return [[x02, y02], [x12, y12]];
                x02 = +_[0][0], x12 = +_[1][0];
                y02 = +_[0][1], y12 = +_[1][1];
                if (x02 > x12)
                  _ = x02, x02 = x12, x12 = _;
                if (y02 > y12)
                  _ = y02, y02 = y12, y12 = _;
                return graticule2.precision(precision);
              };
              graticule2.step = function(_) {
                if (!arguments.length)
                  return graticule2.stepMinor();
                return graticule2.stepMajor(_).stepMinor(_);
              };
              graticule2.stepMajor = function(_) {
                if (!arguments.length)
                  return [DX, DY];
                DX = +_[0], DY = +_[1];
                return graticule2;
              };
              graticule2.stepMinor = function(_) {
                if (!arguments.length)
                  return [dx, dy];
                dx = +_[0], dy = +_[1];
                return graticule2;
              };
              graticule2.precision = function(_) {
                if (!arguments.length)
                  return precision;
                precision = +_;
                x = graticuleX(y02, y12, 90);
                y = graticuleY(x02, x12, precision);
                X = graticuleX(Y02, Y12, 90);
                Y = graticuleY(X02, X12, precision);
                return graticule2;
              };
              return graticule2.extentMajor([[-180, -90 + epsilon], [180, 90 - epsilon]]).extentMinor([[-180, -80 - epsilon], [180, 80 + epsilon]]);
            }
            function graticule10() {
              return graticule()();
            }
            var interpolate = function(a, b) {
              var x02 = a[0] * radians, y02 = a[1] * radians, x12 = b[0] * radians, y12 = b[1] * radians, cy0 = cos(y02), sy0 = sin(y02), cy1 = cos(y12), sy1 = sin(y12), kx0 = cy0 * cos(x02), ky0 = cy0 * sin(x02), kx1 = cy1 * cos(x12), ky1 = cy1 * sin(x12), d = 2 * asin(sqrt(haversin(y12 - y02) + cy0 * cy1 * haversin(x12 - x02))), k = sin(d);
              var interpolate2 = d ? function(t) {
                var B = sin(t *= d) / k, A = sin(d - t) / k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
                return [
                  atan2(y, x) * degrees,
                  atan2(z, sqrt(x * x + y * y)) * degrees
                ];
              } : function() {
                return [x02 * degrees, y02 * degrees];
              };
              interpolate2.distance = d;
              return interpolate2;
            };
            var identity = function(x) {
              return x;
            };
            var areaSum$1 = adder();
            var areaRingSum$1 = adder();
            var x00;
            var y00;
            var x0$1;
            var y0$1;
            var areaStream$1 = {
              point: noop,
              lineStart: noop,
              lineEnd: noop,
              polygonStart: function() {
                areaStream$1.lineStart = areaRingStart$1;
                areaStream$1.lineEnd = areaRingEnd$1;
              },
              polygonEnd: function() {
                areaStream$1.lineStart = areaStream$1.lineEnd = areaStream$1.point = noop;
                areaSum$1.add(abs(areaRingSum$1));
                areaRingSum$1.reset();
              },
              result: function() {
                var area2 = areaSum$1 / 2;
                areaSum$1.reset();
                return area2;
              }
            };
            function areaRingStart$1() {
              areaStream$1.point = areaPointFirst$1;
            }
            function areaPointFirst$1(x, y) {
              areaStream$1.point = areaPoint$1;
              x00 = x0$1 = x, y00 = y0$1 = y;
            }
            function areaPoint$1(x, y) {
              areaRingSum$1.add(y0$1 * x - x0$1 * y);
              x0$1 = x, y0$1 = y;
            }
            function areaRingEnd$1() {
              areaPoint$1(x00, y00);
            }
            var x0$2 = Infinity;
            var y0$2 = x0$2;
            var x1 = -x0$2;
            var y1 = x1;
            var boundsStream$1 = {
              point: boundsPoint$1,
              lineStart: noop,
              lineEnd: noop,
              polygonStart: noop,
              polygonEnd: noop,
              result: function() {
                var bounds2 = [[x0$2, y0$2], [x1, y1]];
                x1 = y1 = -(y0$2 = x0$2 = Infinity);
                return bounds2;
              }
            };
            function boundsPoint$1(x, y) {
              if (x < x0$2)
                x0$2 = x;
              if (x > x1)
                x1 = x;
              if (y < y0$2)
                y0$2 = y;
              if (y > y1)
                y1 = y;
            }
            var X0$1 = 0;
            var Y0$1 = 0;
            var Z0$1 = 0;
            var X1$1 = 0;
            var Y1$1 = 0;
            var Z1$1 = 0;
            var X2$1 = 0;
            var Y2$1 = 0;
            var Z2$1 = 0;
            var x00$1;
            var y00$1;
            var x0$3;
            var y0$3;
            var centroidStream$1 = {
              point: centroidPoint$1,
              lineStart: centroidLineStart$1,
              lineEnd: centroidLineEnd$1,
              polygonStart: function() {
                centroidStream$1.lineStart = centroidRingStart$1;
                centroidStream$1.lineEnd = centroidRingEnd$1;
              },
              polygonEnd: function() {
                centroidStream$1.point = centroidPoint$1;
                centroidStream$1.lineStart = centroidLineStart$1;
                centroidStream$1.lineEnd = centroidLineEnd$1;
              },
              result: function() {
                var centroid2 = Z2$1 ? [X2$1 / Z2$1, Y2$1 / Z2$1] : Z1$1 ? [X1$1 / Z1$1, Y1$1 / Z1$1] : Z0$1 ? [X0$1 / Z0$1, Y0$1 / Z0$1] : [NaN, NaN];
                X0$1 = Y0$1 = Z0$1 = X1$1 = Y1$1 = Z1$1 = X2$1 = Y2$1 = Z2$1 = 0;
                return centroid2;
              }
            };
            function centroidPoint$1(x, y) {
              X0$1 += x;
              Y0$1 += y;
              ++Z0$1;
            }
            function centroidLineStart$1() {
              centroidStream$1.point = centroidPointFirstLine;
            }
            function centroidPointFirstLine(x, y) {
              centroidStream$1.point = centroidPointLine;
              centroidPoint$1(x0$3 = x, y0$3 = y);
            }
            function centroidPointLine(x, y) {
              var dx = x - x0$3, dy = y - y0$3, z = sqrt(dx * dx + dy * dy);
              X1$1 += z * (x0$3 + x) / 2;
              Y1$1 += z * (y0$3 + y) / 2;
              Z1$1 += z;
              centroidPoint$1(x0$3 = x, y0$3 = y);
            }
            function centroidLineEnd$1() {
              centroidStream$1.point = centroidPoint$1;
            }
            function centroidRingStart$1() {
              centroidStream$1.point = centroidPointFirstRing;
            }
            function centroidRingEnd$1() {
              centroidPointRing(x00$1, y00$1);
            }
            function centroidPointFirstRing(x, y) {
              centroidStream$1.point = centroidPointRing;
              centroidPoint$1(x00$1 = x0$3 = x, y00$1 = y0$3 = y);
            }
            function centroidPointRing(x, y) {
              var dx = x - x0$3, dy = y - y0$3, z = sqrt(dx * dx + dy * dy);
              X1$1 += z * (x0$3 + x) / 2;
              Y1$1 += z * (y0$3 + y) / 2;
              Z1$1 += z;
              z = y0$3 * x - x0$3 * y;
              X2$1 += z * (x0$3 + x);
              Y2$1 += z * (y0$3 + y);
              Z2$1 += z * 3;
              centroidPoint$1(x0$3 = x, y0$3 = y);
            }
            function PathContext(context) {
              this._context = context;
            }
            PathContext.prototype = {
              _radius: 4.5,
              pointRadius: function(_) {
                return this._radius = _, this;
              },
              polygonStart: function() {
                this._line = 0;
              },
              polygonEnd: function() {
                this._line = NaN;
              },
              lineStart: function() {
                this._point = 0;
              },
              lineEnd: function() {
                if (this._line === 0)
                  this._context.closePath();
                this._point = NaN;
              },
              point: function(x, y) {
                switch (this._point) {
                  case 0: {
                    this._context.moveTo(x, y);
                    this._point = 1;
                    break;
                  }
                  case 1: {
                    this._context.lineTo(x, y);
                    break;
                  }
                  default: {
                    this._context.moveTo(x + this._radius, y);
                    this._context.arc(x, y, this._radius, 0, tau);
                    break;
                  }
                }
              },
              result: noop
            };
            var lengthSum$1 = adder();
            var lengthRing;
            var x00$2;
            var y00$2;
            var x0$4;
            var y0$4;
            var lengthStream$1 = {
              point: noop,
              lineStart: function() {
                lengthStream$1.point = lengthPointFirst$1;
              },
              lineEnd: function() {
                if (lengthRing)
                  lengthPoint$1(x00$2, y00$2);
                lengthStream$1.point = noop;
              },
              polygonStart: function() {
                lengthRing = true;
              },
              polygonEnd: function() {
                lengthRing = null;
              },
              result: function() {
                var length2 = +lengthSum$1;
                lengthSum$1.reset();
                return length2;
              }
            };
            function lengthPointFirst$1(x, y) {
              lengthStream$1.point = lengthPoint$1;
              x00$2 = x0$4 = x, y00$2 = y0$4 = y;
            }
            function lengthPoint$1(x, y) {
              x0$4 -= x, y0$4 -= y;
              lengthSum$1.add(sqrt(x0$4 * x0$4 + y0$4 * y0$4));
              x0$4 = x, y0$4 = y;
            }
            function PathString() {
              this._string = [];
            }
            PathString.prototype = {
              _radius: 4.5,
              _circle: circle$1(4.5),
              pointRadius: function(_) {
                if ((_ = +_) !== this._radius)
                  this._radius = _, this._circle = null;
                return this;
              },
              polygonStart: function() {
                this._line = 0;
              },
              polygonEnd: function() {
                this._line = NaN;
              },
              lineStart: function() {
                this._point = 0;
              },
              lineEnd: function() {
                if (this._line === 0)
                  this._string.push("Z");
                this._point = NaN;
              },
              point: function(x, y) {
                switch (this._point) {
                  case 0: {
                    this._string.push("M", x, ",", y);
                    this._point = 1;
                    break;
                  }
                  case 1: {
                    this._string.push("L", x, ",", y);
                    break;
                  }
                  default: {
                    if (this._circle == null)
                      this._circle = circle$1(this._radius);
                    this._string.push("M", x, ",", y, this._circle);
                    break;
                  }
                }
              },
              result: function() {
                if (this._string.length) {
                  var result = this._string.join("");
                  this._string = [];
                  return result;
                } else {
                  return null;
                }
              }
            };
            function circle$1(radius) {
              return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
            }
            var index = function(projection2, context) {
              var pointRadius = 4.5, projectionStream, contextStream;
              function path(object2) {
                if (object2) {
                  if (typeof pointRadius === "function")
                    contextStream.pointRadius(+pointRadius.apply(this, arguments));
                  geoStream(object2, projectionStream(contextStream));
                }
                return contextStream.result();
              }
              path.area = function(object2) {
                geoStream(object2, projectionStream(areaStream$1));
                return areaStream$1.result();
              };
              path.measure = function(object2) {
                geoStream(object2, projectionStream(lengthStream$1));
                return lengthStream$1.result();
              };
              path.bounds = function(object2) {
                geoStream(object2, projectionStream(boundsStream$1));
                return boundsStream$1.result();
              };
              path.centroid = function(object2) {
                geoStream(object2, projectionStream(centroidStream$1));
                return centroidStream$1.result();
              };
              path.projection = function(_) {
                return arguments.length ? (projectionStream = _ == null ? (projection2 = null, identity) : (projection2 = _).stream, path) : projection2;
              };
              path.context = function(_) {
                if (!arguments.length)
                  return context;
                contextStream = _ == null ? (context = null, new PathString()) : new PathContext(context = _);
                if (typeof pointRadius !== "function")
                  contextStream.pointRadius(pointRadius);
                return path;
              };
              path.pointRadius = function(_) {
                if (!arguments.length)
                  return pointRadius;
                pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
                return path;
              };
              return path.projection(projection2).context(context);
            };
            var clip = function(pointVisible, clipLine2, interpolate2, start) {
              return function(rotate, sink) {
                var line = clipLine2(sink), rotatedStart = rotate.invert(start[0], start[1]), ringBuffer = clipBuffer(), ringSink = clipLine2(ringBuffer), polygonStarted = false, polygon, segments, ring;
                var clip2 = {
                  point,
                  lineStart,
                  lineEnd,
                  polygonStart: function() {
                    clip2.point = pointRing;
                    clip2.lineStart = ringStart;
                    clip2.lineEnd = ringEnd;
                    segments = [];
                    polygon = [];
                  },
                  polygonEnd: function() {
                    clip2.point = point;
                    clip2.lineStart = lineStart;
                    clip2.lineEnd = lineEnd;
                    segments = d3Array.merge(segments);
                    var startInside = polygonContains(polygon, rotatedStart);
                    if (segments.length) {
                      if (!polygonStarted)
                        sink.polygonStart(), polygonStarted = true;
                      clipPolygon(segments, compareIntersection, startInside, interpolate2, sink);
                    } else if (startInside) {
                      if (!polygonStarted)
                        sink.polygonStart(), polygonStarted = true;
                      sink.lineStart();
                      interpolate2(null, null, 1, sink);
                      sink.lineEnd();
                    }
                    if (polygonStarted)
                      sink.polygonEnd(), polygonStarted = false;
                    segments = polygon = null;
                  },
                  sphere: function() {
                    sink.polygonStart();
                    sink.lineStart();
                    interpolate2(null, null, 1, sink);
                    sink.lineEnd();
                    sink.polygonEnd();
                  }
                };
                function point(lambda, phi) {
                  var point2 = rotate(lambda, phi);
                  if (pointVisible(lambda = point2[0], phi = point2[1]))
                    sink.point(lambda, phi);
                }
                function pointLine(lambda, phi) {
                  var point2 = rotate(lambda, phi);
                  line.point(point2[0], point2[1]);
                }
                function lineStart() {
                  clip2.point = pointLine;
                  line.lineStart();
                }
                function lineEnd() {
                  clip2.point = point;
                  line.lineEnd();
                }
                function pointRing(lambda, phi) {
                  ring.push([lambda, phi]);
                  var point2 = rotate(lambda, phi);
                  ringSink.point(point2[0], point2[1]);
                }
                function ringStart() {
                  ringSink.lineStart();
                  ring = [];
                }
                function ringEnd() {
                  pointRing(ring[0][0], ring[0][1]);
                  ringSink.lineEnd();
                  var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i, n = ringSegments.length, m, segment, point2;
                  ring.pop();
                  polygon.push(ring);
                  ring = null;
                  if (!n)
                    return;
                  if (clean & 1) {
                    segment = ringSegments[0];
                    if ((m = segment.length - 1) > 0) {
                      if (!polygonStarted)
                        sink.polygonStart(), polygonStarted = true;
                      sink.lineStart();
                      for (i = 0; i < m; ++i)
                        sink.point((point2 = segment[i])[0], point2[1]);
                      sink.lineEnd();
                    }
                    return;
                  }
                  if (n > 1 && clean & 2)
                    ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
                  segments.push(ringSegments.filter(validSegment));
                }
                return clip2;
              };
            };
            function validSegment(segment) {
              return segment.length > 1;
            }
            function compareIntersection(a, b) {
              return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);
            }
            var clipAntimeridian = clip(function() {
              return true;
            }, clipAntimeridianLine, clipAntimeridianInterpolate, [-pi, -halfPi]);
            function clipAntimeridianLine(stream) {
              var lambda02 = NaN, phi02 = NaN, sign0 = NaN, clean;
              return {
                lineStart: function() {
                  stream.lineStart();
                  clean = 1;
                },
                point: function(lambda12, phi12) {
                  var sign1 = lambda12 > 0 ? pi : -pi, delta = abs(lambda12 - lambda02);
                  if (abs(delta - pi) < epsilon) {
                    stream.point(lambda02, phi02 = (phi02 + phi12) / 2 > 0 ? halfPi : -halfPi);
                    stream.point(sign0, phi02);
                    stream.lineEnd();
                    stream.lineStart();
                    stream.point(sign1, phi02);
                    stream.point(lambda12, phi02);
                    clean = 0;
                  } else if (sign0 !== sign1 && delta >= pi) {
                    if (abs(lambda02 - sign0) < epsilon)
                      lambda02 -= sign0 * epsilon;
                    if (abs(lambda12 - sign1) < epsilon)
                      lambda12 -= sign1 * epsilon;
                    phi02 = clipAntimeridianIntersect(lambda02, phi02, lambda12, phi12);
                    stream.point(sign0, phi02);
                    stream.lineEnd();
                    stream.lineStart();
                    stream.point(sign1, phi02);
                    clean = 0;
                  }
                  stream.point(lambda02 = lambda12, phi02 = phi12);
                  sign0 = sign1;
                },
                lineEnd: function() {
                  stream.lineEnd();
                  lambda02 = phi02 = NaN;
                },
                clean: function() {
                  return 2 - clean;
                }
              };
            }
            function clipAntimeridianIntersect(lambda02, phi02, lambda12, phi12) {
              var cosPhi02, cosPhi1, sinLambda0Lambda1 = sin(lambda02 - lambda12);
              return abs(sinLambda0Lambda1) > epsilon ? atan((sin(phi02) * (cosPhi1 = cos(phi12)) * sin(lambda12) - sin(phi12) * (cosPhi02 = cos(phi02)) * sin(lambda02)) / (cosPhi02 * cosPhi1 * sinLambda0Lambda1)) : (phi02 + phi12) / 2;
            }
            function clipAntimeridianInterpolate(from, to, direction, stream) {
              var phi;
              if (from == null) {
                phi = direction * halfPi;
                stream.point(-pi, phi);
                stream.point(0, phi);
                stream.point(pi, phi);
                stream.point(pi, 0);
                stream.point(pi, -phi);
                stream.point(0, -phi);
                stream.point(-pi, -phi);
                stream.point(-pi, 0);
                stream.point(-pi, phi);
              } else if (abs(from[0] - to[0]) > epsilon) {
                var lambda = from[0] < to[0] ? pi : -pi;
                phi = direction * lambda / 2;
                stream.point(-lambda, phi);
                stream.point(0, phi);
                stream.point(lambda, phi);
              } else {
                stream.point(to[0], to[1]);
              }
            }
            var clipCircle = function(radius, delta) {
              var cr = cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > epsilon;
              function interpolate2(from, to, direction, stream) {
                circleStream(stream, radius, delta, direction, from, to);
              }
              function visible(lambda, phi) {
                return cos(lambda) * cos(phi) > cr;
              }
              function clipLine2(stream) {
                var point0, c0, v0, v00, clean;
                return {
                  lineStart: function() {
                    v00 = v0 = false;
                    clean = 1;
                  },
                  point: function(lambda, phi) {
                    var point1 = [lambda, phi], point2, v = visible(lambda, phi), c = smallRadius ? v ? 0 : code(lambda, phi) : v ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;
                    if (!point0 && (v00 = v0 = v))
                      stream.lineStart();
                    if (v !== v0) {
                      point2 = intersect(point0, point1);
                      if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2)) {
                        point1[0] += epsilon;
                        point1[1] += epsilon;
                        v = visible(point1[0], point1[1]);
                      }
                    }
                    if (v !== v0) {
                      clean = 0;
                      if (v) {
                        stream.lineStart();
                        point2 = intersect(point1, point0);
                        stream.point(point2[0], point2[1]);
                      } else {
                        point2 = intersect(point0, point1);
                        stream.point(point2[0], point2[1]);
                        stream.lineEnd();
                      }
                      point0 = point2;
                    } else if (notHemisphere && point0 && smallRadius ^ v) {
                      var t;
                      if (!(c & c0) && (t = intersect(point1, point0, true))) {
                        clean = 0;
                        if (smallRadius) {
                          stream.lineStart();
                          stream.point(t[0][0], t[0][1]);
                          stream.point(t[1][0], t[1][1]);
                          stream.lineEnd();
                        } else {
                          stream.point(t[1][0], t[1][1]);
                          stream.lineEnd();
                          stream.lineStart();
                          stream.point(t[0][0], t[0][1]);
                        }
                      }
                    }
                    if (v && (!point0 || !pointEqual(point0, point1))) {
                      stream.point(point1[0], point1[1]);
                    }
                    point0 = point1, v0 = v, c0 = c;
                  },
                  lineEnd: function() {
                    if (v0)
                      stream.lineEnd();
                    point0 = null;
                  },
                  clean: function() {
                    return clean | (v00 && v0) << 1;
                  }
                };
              }
              function intersect(a, b, two) {
                var pa = cartesian(a), pb = cartesian(b);
                var n1 = [1, 0, 0], n2 = cartesianCross(pa, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
                if (!determinant)
                  return !two && a;
                var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = cartesianCross(n1, n2), A = cartesianScale(n1, c1), B = cartesianScale(n2, c2);
                cartesianAddInPlace(A, B);
                var u = n1xn2, w = cartesianDot(A, u), uu = cartesianDot(u, u), t2 = w * w - uu * (cartesianDot(A, A) - 1);
                if (t2 < 0)
                  return;
                var t = sqrt(t2), q = cartesianScale(u, (-w - t) / uu);
                cartesianAddInPlace(q, A);
                q = spherical(q);
                if (!two)
                  return q;
                var lambda02 = a[0], lambda12 = b[0], phi02 = a[1], phi12 = b[1], z;
                if (lambda12 < lambda02)
                  z = lambda02, lambda02 = lambda12, lambda12 = z;
                var delta2 = lambda12 - lambda02, polar = abs(delta2 - pi) < epsilon, meridian = polar || delta2 < epsilon;
                if (!polar && phi12 < phi02)
                  z = phi02, phi02 = phi12, phi12 = z;
                if (meridian ? polar ? phi02 + phi12 > 0 ^ q[1] < (abs(q[0] - lambda02) < epsilon ? phi02 : phi12) : phi02 <= q[1] && q[1] <= phi12 : delta2 > pi ^ (lambda02 <= q[0] && q[0] <= lambda12)) {
                  var q1 = cartesianScale(u, (-w + t) / uu);
                  cartesianAddInPlace(q1, A);
                  return [q, spherical(q1)];
                }
              }
              function code(lambda, phi) {
                var r = smallRadius ? radius : pi - radius, code2 = 0;
                if (lambda < -r)
                  code2 |= 1;
                else if (lambda > r)
                  code2 |= 2;
                if (phi < -r)
                  code2 |= 4;
                else if (phi > r)
                  code2 |= 8;
                return code2;
              }
              return clip(visible, clipLine2, interpolate2, smallRadius ? [0, -radius] : [-pi, radius - pi]);
            };
            var transform = function(methods) {
              return {
                stream: transformer(methods)
              };
            };
            function transformer(methods) {
              return function(stream) {
                var s = new TransformStream();
                for (var key in methods)
                  s[key] = methods[key];
                s.stream = stream;
                return s;
              };
            }
            function TransformStream() {
            }
            TransformStream.prototype = {
              constructor: TransformStream,
              point: function(x, y) {
                this.stream.point(x, y);
              },
              sphere: function() {
                this.stream.sphere();
              },
              lineStart: function() {
                this.stream.lineStart();
              },
              lineEnd: function() {
                this.stream.lineEnd();
              },
              polygonStart: function() {
                this.stream.polygonStart();
              },
              polygonEnd: function() {
                this.stream.polygonEnd();
              }
            };
            function fitExtent(projection2, extent2, object2) {
              var w = extent2[1][0] - extent2[0][0], h = extent2[1][1] - extent2[0][1], clip2 = projection2.clipExtent && projection2.clipExtent();
              projection2.scale(150).translate([0, 0]);
              if (clip2 != null)
                projection2.clipExtent(null);
              geoStream(object2, projection2.stream(boundsStream$1));
              var b = boundsStream$1.result(), k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])), x = +extent2[0][0] + (w - k * (b[1][0] + b[0][0])) / 2, y = +extent2[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
              if (clip2 != null)
                projection2.clipExtent(clip2);
              return projection2.scale(k * 150).translate([x, y]);
            }
            function fitSize(projection2, size, object2) {
              return fitExtent(projection2, [[0, 0], size], object2);
            }
            var maxDepth = 16;
            var cosMinDistance = cos(30 * radians);
            var resample = function(project, delta2) {
              return +delta2 ? resample$1(project, delta2) : resampleNone(project);
            };
            function resampleNone(project) {
              return transformer({
                point: function(x, y) {
                  x = project(x, y);
                  this.stream.point(x[0], x[1]);
                }
              });
            }
            function resample$1(project, delta2) {
              function resampleLineTo(x02, y02, lambda02, a0, b0, c0, x12, y12, lambda12, a1, b1, c1, depth, stream) {
                var dx = x12 - x02, dy = y12 - y02, d2 = dx * dx + dy * dy;
                if (d2 > 4 * delta2 && depth--) {
                  var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = sqrt(a * a + b * b + c * c), phi2 = asin(c /= m), lambda22 = abs(abs(c) - 1) < epsilon || abs(lambda02 - lambda12) < epsilon ? (lambda02 + lambda12) / 2 : atan2(b, a), p = project(lambda22, phi2), x2 = p[0], y2 = p[1], dx2 = x2 - x02, dy2 = y2 - y02, dz = dy * dx2 - dx * dy2;
                  if (dz * dz / d2 > delta2 || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
                    resampleLineTo(x02, y02, lambda02, a0, b0, c0, x2, y2, lambda22, a /= m, b /= m, c, depth, stream);
                    stream.point(x2, y2);
                    resampleLineTo(x2, y2, lambda22, a, b, c, x12, y12, lambda12, a1, b1, c1, depth, stream);
                  }
                }
              }
              return function(stream) {
                var lambda002, x002, y002, a00, b00, c00, lambda02, x02, y02, a0, b0, c0;
                var resampleStream = {
                  point,
                  lineStart,
                  lineEnd,
                  polygonStart: function() {
                    stream.polygonStart();
                    resampleStream.lineStart = ringStart;
                  },
                  polygonEnd: function() {
                    stream.polygonEnd();
                    resampleStream.lineStart = lineStart;
                  }
                };
                function point(x, y) {
                  x = project(x, y);
                  stream.point(x[0], x[1]);
                }
                function lineStart() {
                  x02 = NaN;
                  resampleStream.point = linePoint2;
                  stream.lineStart();
                }
                function linePoint2(lambda, phi) {
                  var c = cartesian([lambda, phi]), p = project(lambda, phi);
                  resampleLineTo(x02, y02, lambda02, a0, b0, c0, x02 = p[0], y02 = p[1], lambda02 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
                  stream.point(x02, y02);
                }
                function lineEnd() {
                  resampleStream.point = point;
                  stream.lineEnd();
                }
                function ringStart() {
                  lineStart();
                  resampleStream.point = ringPoint;
                  resampleStream.lineEnd = ringEnd;
                }
                function ringPoint(lambda, phi) {
                  linePoint2(lambda002 = lambda, phi), x002 = x02, y002 = y02, a00 = a0, b00 = b0, c00 = c0;
                  resampleStream.point = linePoint2;
                }
                function ringEnd() {
                  resampleLineTo(x02, y02, lambda02, a0, b0, c0, x002, y002, lambda002, a00, b00, c00, maxDepth, stream);
                  resampleStream.lineEnd = lineEnd;
                  lineEnd();
                }
                return resampleStream;
              };
            }
            var transformRadians = transformer({
              point: function(x, y) {
                this.stream.point(x * radians, y * radians);
              }
            });
            function projection(project) {
              return projectionMutator(function() {
                return project;
              })();
            }
            function projectionMutator(projectAt) {
              var project, k = 150, x = 480, y = 250, dx, dy, lambda = 0, phi = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, projectRotate, theta = null, preclip = clipAntimeridian, x02 = null, y02, x12, y12, postclip = identity, delta2 = 0.5, projectResample = resample(projectTransform, delta2), cache, cacheStream;
              function projection2(point) {
                point = projectRotate(point[0] * radians, point[1] * radians);
                return [point[0] * k + dx, dy - point[1] * k];
              }
              function invert(point) {
                point = projectRotate.invert((point[0] - dx) / k, (dy - point[1]) / k);
                return point && [point[0] * degrees, point[1] * degrees];
              }
              function projectTransform(x2, y2) {
                return x2 = project(x2, y2), [x2[0] * k + dx, dy - x2[1] * k];
              }
              projection2.stream = function(stream) {
                return cache && cacheStream === stream ? cache : cache = transformRadians(preclip(rotate, projectResample(postclip(cacheStream = stream))));
              };
              projection2.clipAngle = function(_) {
                return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians, 6 * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees;
              };
              projection2.clipExtent = function(_) {
                return arguments.length ? (postclip = _ == null ? (x02 = y02 = x12 = y12 = null, identity) : clipExtent(x02 = +_[0][0], y02 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reset()) : x02 == null ? null : [[x02, y02], [x12, y12]];
              };
              projection2.scale = function(_) {
                return arguments.length ? (k = +_, recenter()) : k;
              };
              projection2.translate = function(_) {
                return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
              };
              projection2.center = function(_) {
                return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];
              };
              projection2.rotate = function(_) {
                return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
              };
              projection2.precision = function(_) {
                return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);
              };
              projection2.fitExtent = function(extent2, object2) {
                return fitExtent(projection2, extent2, object2);
              };
              projection2.fitSize = function(size, object2) {
                return fitSize(projection2, size, object2);
              };
              function recenter() {
                projectRotate = compose(rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma), project);
                var center = project(lambda, phi);
                dx = x - center[0] * k;
                dy = y + center[1] * k;
                return reset();
              }
              function reset() {
                cache = cacheStream = null;
                return projection2;
              }
              return function() {
                project = projectAt.apply(this, arguments);
                projection2.invert = project.invert && invert;
                return recenter();
              };
            }
            function conicProjection(projectAt) {
              var phi02 = 0, phi12 = pi / 3, m = projectionMutator(projectAt), p = m(phi02, phi12);
              p.parallels = function(_) {
                return arguments.length ? m(phi02 = _[0] * radians, phi12 = _[1] * radians) : [phi02 * degrees, phi12 * degrees];
              };
              return p;
            }
            function cylindricalEqualAreaRaw(phi02) {
              var cosPhi02 = cos(phi02);
              function forward(lambda, phi) {
                return [lambda * cosPhi02, sin(phi) / cosPhi02];
              }
              forward.invert = function(x, y) {
                return [x / cosPhi02, asin(y * cosPhi02)];
              };
              return forward;
            }
            function conicEqualAreaRaw(y02, y12) {
              var sy0 = sin(y02), n = (sy0 + sin(y12)) / 2;
              if (abs(n) < epsilon)
                return cylindricalEqualAreaRaw(y02);
              var c = 1 + sy0 * (2 * n - sy0), r0 = sqrt(c) / n;
              function project(x, y) {
                var r = sqrt(c - 2 * n * sin(y)) / n;
                return [r * sin(x *= n), r0 - r * cos(x)];
              }
              project.invert = function(x, y) {
                var r0y = r0 - y;
                return [atan2(x, abs(r0y)) / n * sign(r0y), asin((c - (x * x + r0y * r0y) * n * n) / (2 * n))];
              };
              return project;
            }
            var conicEqualArea = function() {
              return conicProjection(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
            };
            var albers = function() {
              return conicEqualArea().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
            };
            function multiplex(streams) {
              var n = streams.length;
              return {
                point: function(x, y) {
                  var i = -1;
                  while (++i < n)
                    streams[i].point(x, y);
                },
                sphere: function() {
                  var i = -1;
                  while (++i < n)
                    streams[i].sphere();
                },
                lineStart: function() {
                  var i = -1;
                  while (++i < n)
                    streams[i].lineStart();
                },
                lineEnd: function() {
                  var i = -1;
                  while (++i < n)
                    streams[i].lineEnd();
                },
                polygonStart: function() {
                  var i = -1;
                  while (++i < n)
                    streams[i].polygonStart();
                },
                polygonEnd: function() {
                  var i = -1;
                  while (++i < n)
                    streams[i].polygonEnd();
                }
              };
            }
            var albersUsa = function() {
              var cache, cacheStream, lower48 = albers(), lower48Point, alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, point, pointStream = { point: function(x, y) {
                point = [x, y];
              } };
              function albersUsa2(coordinates2) {
                var x = coordinates2[0], y = coordinates2[1];
                return point = null, (lower48Point.point(x, y), point) || (alaskaPoint.point(x, y), point) || (hawaiiPoint.point(x, y), point);
              }
              albersUsa2.invert = function(coordinates2) {
                var k = lower48.scale(), t = lower48.translate(), x = (coordinates2[0] - t[0]) / k, y = (coordinates2[1] - t[1]) / k;
                return (y >= 0.12 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii : lower48).invert(coordinates2);
              };
              albersUsa2.stream = function(stream) {
                return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
              };
              albersUsa2.precision = function(_) {
                if (!arguments.length)
                  return lower48.precision();
                lower48.precision(_), alaska.precision(_), hawaii.precision(_);
                return reset();
              };
              albersUsa2.scale = function(_) {
                if (!arguments.length)
                  return lower48.scale();
                lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
                return albersUsa2.translate(lower48.translate());
              };
              albersUsa2.translate = function(_) {
                if (!arguments.length)
                  return lower48.translate();
                var k = lower48.scale(), x = +_[0], y = +_[1];
                lower48Point = lower48.translate(_).clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]]).stream(pointStream);
                alaskaPoint = alaska.translate([x - 0.307 * k, y + 0.201 * k]).clipExtent([[x - 0.425 * k + epsilon, y + 0.12 * k + epsilon], [x - 0.214 * k - epsilon, y + 0.234 * k - epsilon]]).stream(pointStream);
                hawaiiPoint = hawaii.translate([x - 0.205 * k, y + 0.212 * k]).clipExtent([[x - 0.214 * k + epsilon, y + 0.166 * k + epsilon], [x - 0.115 * k - epsilon, y + 0.234 * k - epsilon]]).stream(pointStream);
                return reset();
              };
              albersUsa2.fitExtent = function(extent2, object2) {
                return fitExtent(albersUsa2, extent2, object2);
              };
              albersUsa2.fitSize = function(size, object2) {
                return fitSize(albersUsa2, size, object2);
              };
              function reset() {
                cache = cacheStream = null;
                return albersUsa2;
              }
              return albersUsa2.scale(1070);
            };
            function azimuthalRaw(scale) {
              return function(x, y) {
                var cx = cos(x), cy = cos(y), k = scale(cx * cy);
                return [
                  k * cy * sin(x),
                  k * sin(y)
                ];
              };
            }
            function azimuthalInvert(angle2) {
              return function(x, y) {
                var z = sqrt(x * x + y * y), c = angle2(z), sc = sin(c), cc = cos(c);
                return [
                  atan2(x * sc, z * cc),
                  asin(z && y * sc / z)
                ];
              };
            }
            var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
              return sqrt(2 / (1 + cxcy));
            });
            azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
              return 2 * asin(z / 2);
            });
            var azimuthalEqualArea = function() {
              return projection(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
            };
            var azimuthalEquidistantRaw = azimuthalRaw(function(c) {
              return (c = acos(c)) && c / sin(c);
            });
            azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
              return z;
            });
            var azimuthalEquidistant = function() {
              return projection(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
            };
            function mercatorRaw(lambda, phi) {
              return [lambda, log(tan((halfPi + phi) / 2))];
            }
            mercatorRaw.invert = function(x, y) {
              return [x, 2 * atan(exp(y)) - halfPi];
            };
            var mercator = function() {
              return mercatorProjection(mercatorRaw).scale(961 / tau);
            };
            function mercatorProjection(project) {
              var m = projection(project), center = m.center, scale = m.scale, translate = m.translate, clipExtent2 = m.clipExtent, x02 = null, y02, x12, y12;
              m.scale = function(_) {
                return arguments.length ? (scale(_), reclip()) : scale();
              };
              m.translate = function(_) {
                return arguments.length ? (translate(_), reclip()) : translate();
              };
              m.center = function(_) {
                return arguments.length ? (center(_), reclip()) : center();
              };
              m.clipExtent = function(_) {
                return arguments.length ? (_ == null ? x02 = y02 = x12 = y12 = null : (x02 = +_[0][0], y02 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reclip()) : x02 == null ? null : [[x02, y02], [x12, y12]];
              };
              function reclip() {
                var k = pi * scale(), t = m(rotation(m.rotate()).invert([0, 0]));
                return clipExtent2(x02 == null ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw ? [[Math.max(t[0] - k, x02), y02], [Math.min(t[0] + k, x12), y12]] : [[x02, Math.max(t[1] - k, y02)], [x12, Math.min(t[1] + k, y12)]]);
              }
              return reclip();
            }
            function tany(y) {
              return tan((halfPi + y) / 2);
            }
            function conicConformalRaw(y02, y12) {
              var cy0 = cos(y02), n = y02 === y12 ? sin(y02) : log(cy0 / cos(y12)) / log(tany(y12) / tany(y02)), f = cy0 * pow(tany(y02), n) / n;
              if (!n)
                return mercatorRaw;
              function project(x, y) {
                if (f > 0) {
                  if (y < -halfPi + epsilon)
                    y = -halfPi + epsilon;
                } else {
                  if (y > halfPi - epsilon)
                    y = halfPi - epsilon;
                }
                var r = f / pow(tany(y), n);
                return [r * sin(n * x), f - r * cos(n * x)];
              }
              project.invert = function(x, y) {
                var fy = f - y, r = sign(n) * sqrt(x * x + fy * fy);
                return [atan2(x, abs(fy)) / n * sign(fy), 2 * atan(pow(f / r, 1 / n)) - halfPi];
              };
              return project;
            }
            var conicConformal = function() {
              return conicProjection(conicConformalRaw).scale(109.5).parallels([30, 30]);
            };
            function equirectangularRaw(lambda, phi) {
              return [lambda, phi];
            }
            equirectangularRaw.invert = equirectangularRaw;
            var equirectangular = function() {
              return projection(equirectangularRaw).scale(152.63);
            };
            function conicEquidistantRaw(y02, y12) {
              var cy0 = cos(y02), n = y02 === y12 ? sin(y02) : (cy0 - cos(y12)) / (y12 - y02), g = cy0 / n + y02;
              if (abs(n) < epsilon)
                return equirectangularRaw;
              function project(x, y) {
                var gy = g - y, nx = n * x;
                return [gy * sin(nx), g - gy * cos(nx)];
              }
              project.invert = function(x, y) {
                var gy = g - y;
                return [atan2(x, abs(gy)) / n * sign(gy), g - sign(n) * sqrt(x * x + gy * gy)];
              };
              return project;
            }
            var conicEquidistant = function() {
              return conicProjection(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
            };
            function gnomonicRaw(x, y) {
              var cy = cos(y), k = cos(x) * cy;
              return [cy * sin(x) / k, sin(y) / k];
            }
            gnomonicRaw.invert = azimuthalInvert(atan);
            var gnomonic = function() {
              return projection(gnomonicRaw).scale(144.049).clipAngle(60);
            };
            function scaleTranslate(kx, ky, tx, ty) {
              return kx === 1 && ky === 1 && tx === 0 && ty === 0 ? identity : transformer({
                point: function(x, y) {
                  this.stream.point(x * kx + tx, y * ky + ty);
                }
              });
            }
            var identity$1 = function() {
              var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, transform2 = identity, x02 = null, y02, x12, y12, clip2 = identity, cache, cacheStream, projection2;
              function reset() {
                cache = cacheStream = null;
                return projection2;
              }
              return projection2 = {
                stream: function(stream) {
                  return cache && cacheStream === stream ? cache : cache = transform2(clip2(cacheStream = stream));
                },
                clipExtent: function(_) {
                  return arguments.length ? (clip2 = _ == null ? (x02 = y02 = x12 = y12 = null, identity) : clipExtent(x02 = +_[0][0], y02 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reset()) : x02 == null ? null : [[x02, y02], [x12, y12]];
                },
                scale: function(_) {
                  return arguments.length ? (transform2 = scaleTranslate((k = +_) * sx, k * sy, tx, ty), reset()) : k;
                },
                translate: function(_) {
                  return arguments.length ? (transform2 = scaleTranslate(k * sx, k * sy, tx = +_[0], ty = +_[1]), reset()) : [tx, ty];
                },
                reflectX: function(_) {
                  return arguments.length ? (transform2 = scaleTranslate(k * (sx = _ ? -1 : 1), k * sy, tx, ty), reset()) : sx < 0;
                },
                reflectY: function(_) {
                  return arguments.length ? (transform2 = scaleTranslate(k * sx, k * (sy = _ ? -1 : 1), tx, ty), reset()) : sy < 0;
                },
                fitExtent: function(extent2, object2) {
                  return fitExtent(projection2, extent2, object2);
                },
                fitSize: function(size, object2) {
                  return fitSize(projection2, size, object2);
                }
              };
            };
            function orthographicRaw(x, y) {
              return [cos(y) * sin(x), sin(y)];
            }
            orthographicRaw.invert = azimuthalInvert(asin);
            var orthographic = function() {
              return projection(orthographicRaw).scale(249.5).clipAngle(90 + epsilon);
            };
            function stereographicRaw(x, y) {
              var cy = cos(y), k = 1 + cos(x) * cy;
              return [cy * sin(x) / k, sin(y) / k];
            }
            stereographicRaw.invert = azimuthalInvert(function(z) {
              return 2 * atan(z);
            });
            var stereographic = function() {
              return projection(stereographicRaw).scale(250).clipAngle(142);
            };
            function transverseMercatorRaw(lambda, phi) {
              return [log(tan((halfPi + phi) / 2)), -lambda];
            }
            transverseMercatorRaw.invert = function(x, y) {
              return [-y, 2 * atan(exp(x)) - halfPi];
            };
            var transverseMercator = function() {
              var m = mercatorProjection(transverseMercatorRaw), center = m.center, rotate = m.rotate;
              m.center = function(_) {
                return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
              };
              m.rotate = function(_) {
                return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
              };
              return rotate([0, 0, 90]).scale(159.155);
            };
            exports3.geoArea = area;
            exports3.geoBounds = bounds;
            exports3.geoCentroid = centroid;
            exports3.geoCircle = circle;
            exports3.geoClipExtent = extent;
            exports3.geoContains = contains;
            exports3.geoDistance = distance;
            exports3.geoGraticule = graticule;
            exports3.geoGraticule10 = graticule10;
            exports3.geoInterpolate = interpolate;
            exports3.geoLength = length;
            exports3.geoPath = index;
            exports3.geoAlbers = albers;
            exports3.geoAlbersUsa = albersUsa;
            exports3.geoAzimuthalEqualArea = azimuthalEqualArea;
            exports3.geoAzimuthalEqualAreaRaw = azimuthalEqualAreaRaw;
            exports3.geoAzimuthalEquidistant = azimuthalEquidistant;
            exports3.geoAzimuthalEquidistantRaw = azimuthalEquidistantRaw;
            exports3.geoConicConformal = conicConformal;
            exports3.geoConicConformalRaw = conicConformalRaw;
            exports3.geoConicEqualArea = conicEqualArea;
            exports3.geoConicEqualAreaRaw = conicEqualAreaRaw;
            exports3.geoConicEquidistant = conicEquidistant;
            exports3.geoConicEquidistantRaw = conicEquidistantRaw;
            exports3.geoEquirectangular = equirectangular;
            exports3.geoEquirectangularRaw = equirectangularRaw;
            exports3.geoGnomonic = gnomonic;
            exports3.geoGnomonicRaw = gnomonicRaw;
            exports3.geoIdentity = identity$1;
            exports3.geoProjection = projection;
            exports3.geoProjectionMutator = projectionMutator;
            exports3.geoMercator = mercator;
            exports3.geoMercatorRaw = mercatorRaw;
            exports3.geoOrthographic = orthographic;
            exports3.geoOrthographicRaw = orthographicRaw;
            exports3.geoStereographic = stereographic;
            exports3.geoStereographicRaw = stereographicRaw;
            exports3.geoTransverseMercator = transverseMercator;
            exports3.geoTransverseMercatorRaw = transverseMercatorRaw;
            exports3.geoRotation = rotation;
            exports3.geoStream = geoStream;
            exports3.geoTransform = transform;
            Object.defineProperty(exports3, "__esModule", { value: true });
          });
        },
        "./node_modules/_d3-geo@2.0.1@d3-geo/dist/d3-geo.js": function(module2, exports2, __webpack_require__) {
          (function(global, factory) {
            true ? factory(exports2, __webpack_require__("./node_modules/_d3-array@2.11.0@d3-array/dist/d3-array.js")) : void 0;
          })(this, function(exports3, d3Array) {
            "use strict";
            var epsilon = 1e-6;
            var epsilon2 = 1e-12;
            var pi = Math.PI;
            var halfPi = pi / 2;
            var quarterPi = pi / 4;
            var tau = pi * 2;
            var degrees = 180 / pi;
            var radians = pi / 180;
            var abs = Math.abs;
            var atan = Math.atan;
            var atan2 = Math.atan2;
            var cos = Math.cos;
            var ceil = Math.ceil;
            var exp = Math.exp;
            var hypot = Math.hypot;
            var log = Math.log;
            var pow = Math.pow;
            var sin = Math.sin;
            var sign = Math.sign || function(x) {
              return x > 0 ? 1 : x < 0 ? -1 : 0;
            };
            var sqrt = Math.sqrt;
            var tan = Math.tan;
            function acos(x) {
              return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
            }
            function asin(x) {
              return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
            }
            function haversin(x) {
              return (x = sin(x / 2)) * x;
            }
            function noop() {
            }
            function streamGeometry(geometry, stream) {
              if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
                streamGeometryType[geometry.type](geometry, stream);
              }
            }
            var streamObjectType = {
              Feature: function(object2, stream) {
                streamGeometry(object2.geometry, stream);
              },
              FeatureCollection: function(object2, stream) {
                var features = object2.features, i = -1, n = features.length;
                while (++i < n)
                  streamGeometry(features[i].geometry, stream);
              }
            };
            var streamGeometryType = {
              Sphere: function(object2, stream) {
                stream.sphere();
              },
              Point: function(object2, stream) {
                object2 = object2.coordinates;
                stream.point(object2[0], object2[1], object2[2]);
              },
              MultiPoint: function(object2, stream) {
                var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
                while (++i < n)
                  object2 = coordinates2[i], stream.point(object2[0], object2[1], object2[2]);
              },
              LineString: function(object2, stream) {
                streamLine(object2.coordinates, stream, 0);
              },
              MultiLineString: function(object2, stream) {
                var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
                while (++i < n)
                  streamLine(coordinates2[i], stream, 0);
              },
              Polygon: function(object2, stream) {
                streamPolygon(object2.coordinates, stream);
              },
              MultiPolygon: function(object2, stream) {
                var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
                while (++i < n)
                  streamPolygon(coordinates2[i], stream);
              },
              GeometryCollection: function(object2, stream) {
                var geometries = object2.geometries, i = -1, n = geometries.length;
                while (++i < n)
                  streamGeometry(geometries[i], stream);
              }
            };
            function streamLine(coordinates2, stream, closed) {
              var i = -1, n = coordinates2.length - closed, coordinate;
              stream.lineStart();
              while (++i < n)
                coordinate = coordinates2[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
              stream.lineEnd();
            }
            function streamPolygon(coordinates2, stream) {
              var i = -1, n = coordinates2.length;
              stream.polygonStart();
              while (++i < n)
                streamLine(coordinates2[i], stream, 1);
              stream.polygonEnd();
            }
            function geoStream(object2, stream) {
              if (object2 && streamObjectType.hasOwnProperty(object2.type)) {
                streamObjectType[object2.type](object2, stream);
              } else {
                streamGeometry(object2, stream);
              }
            }
            var areaRingSum = new d3Array.Adder();
            var areaSum = new d3Array.Adder(), lambda00, phi00, lambda0, cosPhi0, sinPhi0;
            var areaStream = {
              point: noop,
              lineStart: noop,
              lineEnd: noop,
              polygonStart: function() {
                areaRingSum = new d3Array.Adder();
                areaStream.lineStart = areaRingStart;
                areaStream.lineEnd = areaRingEnd;
              },
              polygonEnd: function() {
                var areaRing = +areaRingSum;
                areaSum.add(areaRing < 0 ? tau + areaRing : areaRing);
                this.lineStart = this.lineEnd = this.point = noop;
              },
              sphere: function() {
                areaSum.add(tau);
              }
            };
            function areaRingStart() {
              areaStream.point = areaPointFirst;
            }
            function areaRingEnd() {
              areaPoint(lambda00, phi00);
            }
            function areaPointFirst(lambda, phi) {
              areaStream.point = areaPoint;
              lambda00 = lambda, phi00 = phi;
              lambda *= radians, phi *= radians;
              lambda0 = lambda, cosPhi0 = cos(phi = phi / 2 + quarterPi), sinPhi0 = sin(phi);
            }
            function areaPoint(lambda, phi) {
              lambda *= radians, phi *= radians;
              phi = phi / 2 + quarterPi;
              var dLambda = lambda - lambda0, sdLambda = dLambda >= 0 ? 1 : -1, adLambda = sdLambda * dLambda, cosPhi = cos(phi), sinPhi = sin(phi), k = sinPhi0 * sinPhi, u = cosPhi0 * cosPhi + k * cos(adLambda), v = k * sdLambda * sin(adLambda);
              areaRingSum.add(atan2(v, u));
              lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
            }
            function area(object2) {
              areaSum = new d3Array.Adder();
              geoStream(object2, areaStream);
              return areaSum * 2;
            }
            function spherical(cartesian2) {
              return [atan2(cartesian2[1], cartesian2[0]), asin(cartesian2[2])];
            }
            function cartesian(spherical2) {
              var lambda = spherical2[0], phi = spherical2[1], cosPhi = cos(phi);
              return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];
            }
            function cartesianDot(a, b) {
              return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
            }
            function cartesianCross(a, b) {
              return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
            }
            function cartesianAddInPlace(a, b) {
              a[0] += b[0], a[1] += b[1], a[2] += b[2];
            }
            function cartesianScale(vector, k) {
              return [vector[0] * k, vector[1] * k, vector[2] * k];
            }
            function cartesianNormalizeInPlace(d) {
              var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
              d[0] /= l, d[1] /= l, d[2] /= l;
            }
            var lambda0$1, phi0, lambda1, phi1, lambda2, lambda00$1, phi00$1, p0, deltaSum, ranges, range;
            var boundsStream = {
              point: boundsPoint,
              lineStart: boundsLineStart,
              lineEnd: boundsLineEnd,
              polygonStart: function() {
                boundsStream.point = boundsRingPoint;
                boundsStream.lineStart = boundsRingStart;
                boundsStream.lineEnd = boundsRingEnd;
                deltaSum = new d3Array.Adder();
                areaStream.polygonStart();
              },
              polygonEnd: function() {
                areaStream.polygonEnd();
                boundsStream.point = boundsPoint;
                boundsStream.lineStart = boundsLineStart;
                boundsStream.lineEnd = boundsLineEnd;
                if (areaRingSum < 0)
                  lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
                else if (deltaSum > epsilon)
                  phi1 = 90;
                else if (deltaSum < -epsilon)
                  phi0 = -90;
                range[0] = lambda0$1, range[1] = lambda1;
              },
              sphere: function() {
                lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
              }
            };
            function boundsPoint(lambda, phi) {
              ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
              if (phi < phi0)
                phi0 = phi;
              if (phi > phi1)
                phi1 = phi;
            }
            function linePoint(lambda, phi) {
              var p = cartesian([lambda * radians, phi * radians]);
              if (p0) {
                var normal = cartesianCross(p0, p), equatorial = [normal[1], -normal[0], 0], inflection = cartesianCross(equatorial, normal);
                cartesianNormalizeInPlace(inflection);
                inflection = spherical(inflection);
                var delta = lambda - lambda2, sign2 = delta > 0 ? 1 : -1, lambdai = inflection[0] * degrees * sign2, phii, antimeridian = abs(delta) > 180;
                if (antimeridian ^ (sign2 * lambda2 < lambdai && lambdai < sign2 * lambda)) {
                  phii = inflection[1] * degrees;
                  if (phii > phi1)
                    phi1 = phii;
                } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign2 * lambda2 < lambdai && lambdai < sign2 * lambda)) {
                  phii = -inflection[1] * degrees;
                  if (phii < phi0)
                    phi0 = phii;
                } else {
                  if (phi < phi0)
                    phi0 = phi;
                  if (phi > phi1)
                    phi1 = phi;
                }
                if (antimeridian) {
                  if (lambda < lambda2) {
                    if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1))
                      lambda1 = lambda;
                  } else {
                    if (angle(lambda, lambda1) > angle(lambda0$1, lambda1))
                      lambda0$1 = lambda;
                  }
                } else {
                  if (lambda1 >= lambda0$1) {
                    if (lambda < lambda0$1)
                      lambda0$1 = lambda;
                    if (lambda > lambda1)
                      lambda1 = lambda;
                  } else {
                    if (lambda > lambda2) {
                      if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1))
                        lambda1 = lambda;
                    } else {
                      if (angle(lambda, lambda1) > angle(lambda0$1, lambda1))
                        lambda0$1 = lambda;
                    }
                  }
                }
              } else {
                ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
              }
              if (phi < phi0)
                phi0 = phi;
              if (phi > phi1)
                phi1 = phi;
              p0 = p, lambda2 = lambda;
            }
            function boundsLineStart() {
              boundsStream.point = linePoint;
            }
            function boundsLineEnd() {
              range[0] = lambda0$1, range[1] = lambda1;
              boundsStream.point = boundsPoint;
              p0 = null;
            }
            function boundsRingPoint(lambda, phi) {
              if (p0) {
                var delta = lambda - lambda2;
                deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
              } else {
                lambda00$1 = lambda, phi00$1 = phi;
              }
              areaStream.point(lambda, phi);
              linePoint(lambda, phi);
            }
            function boundsRingStart() {
              areaStream.lineStart();
            }
            function boundsRingEnd() {
              boundsRingPoint(lambda00$1, phi00$1);
              areaStream.lineEnd();
              if (abs(deltaSum) > epsilon)
                lambda0$1 = -(lambda1 = 180);
              range[0] = lambda0$1, range[1] = lambda1;
              p0 = null;
            }
            function angle(lambda02, lambda12) {
              return (lambda12 -= lambda02) < 0 ? lambda12 + 360 : lambda12;
            }
            function rangeCompare(a, b) {
              return a[0] - b[0];
            }
            function rangeContains(range2, x) {
              return range2[0] <= range2[1] ? range2[0] <= x && x <= range2[1] : x < range2[0] || range2[1] < x;
            }
            function bounds(feature) {
              var i, n, a, b, merged, deltaMax, delta;
              phi1 = lambda1 = -(lambda0$1 = phi0 = Infinity);
              ranges = [];
              geoStream(feature, boundsStream);
              if (n = ranges.length) {
                ranges.sort(rangeCompare);
                for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
                  b = ranges[i];
                  if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
                    if (angle(a[0], b[1]) > angle(a[0], a[1]))
                      a[1] = b[1];
                    if (angle(b[0], a[1]) > angle(a[0], a[1]))
                      a[0] = b[0];
                  } else {
                    merged.push(a = b);
                  }
                }
                for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
                  b = merged[i];
                  if ((delta = angle(a[1], b[0])) > deltaMax)
                    deltaMax = delta, lambda0$1 = b[0], lambda1 = a[1];
                }
              }
              ranges = range = null;
              return lambda0$1 === Infinity || phi0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[lambda0$1, phi0], [lambda1, phi1]];
            }
            var W0, W1, X0, Y0, Z0, X1, Y1, Z1, X2, Y2, Z2, lambda00$2, phi00$2, x0, y0, z0;
            var centroidStream = {
              sphere: noop,
              point: centroidPoint,
              lineStart: centroidLineStart,
              lineEnd: centroidLineEnd,
              polygonStart: function() {
                centroidStream.lineStart = centroidRingStart;
                centroidStream.lineEnd = centroidRingEnd;
              },
              polygonEnd: function() {
                centroidStream.lineStart = centroidLineStart;
                centroidStream.lineEnd = centroidLineEnd;
              }
            };
            function centroidPoint(lambda, phi) {
              lambda *= radians, phi *= radians;
              var cosPhi = cos(phi);
              centroidPointCartesian(cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi));
            }
            function centroidPointCartesian(x, y, z) {
              ++W0;
              X0 += (x - X0) / W0;
              Y0 += (y - Y0) / W0;
              Z0 += (z - Z0) / W0;
            }
            function centroidLineStart() {
              centroidStream.point = centroidLinePointFirst;
            }
            function centroidLinePointFirst(lambda, phi) {
              lambda *= radians, phi *= radians;
              var cosPhi = cos(phi);
              x0 = cosPhi * cos(lambda);
              y0 = cosPhi * sin(lambda);
              z0 = sin(phi);
              centroidStream.point = centroidLinePoint;
              centroidPointCartesian(x0, y0, z0);
            }
            function centroidLinePoint(lambda, phi) {
              lambda *= radians, phi *= radians;
              var cosPhi = cos(phi), x = cosPhi * cos(lambda), y = cosPhi * sin(lambda), z = sin(phi), w = atan2(sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
              W1 += w;
              X1 += w * (x0 + (x0 = x));
              Y1 += w * (y0 + (y0 = y));
              Z1 += w * (z0 + (z0 = z));
              centroidPointCartesian(x0, y0, z0);
            }
            function centroidLineEnd() {
              centroidStream.point = centroidPoint;
            }
            function centroidRingStart() {
              centroidStream.point = centroidRingPointFirst;
            }
            function centroidRingEnd() {
              centroidRingPoint(lambda00$2, phi00$2);
              centroidStream.point = centroidPoint;
            }
            function centroidRingPointFirst(lambda, phi) {
              lambda00$2 = lambda, phi00$2 = phi;
              lambda *= radians, phi *= radians;
              centroidStream.point = centroidRingPoint;
              var cosPhi = cos(phi);
              x0 = cosPhi * cos(lambda);
              y0 = cosPhi * sin(lambda);
              z0 = sin(phi);
              centroidPointCartesian(x0, y0, z0);
            }
            function centroidRingPoint(lambda, phi) {
              lambda *= radians, phi *= radians;
              var cosPhi = cos(phi), x = cosPhi * cos(lambda), y = cosPhi * sin(lambda), z = sin(phi), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = hypot(cx, cy, cz), w = asin(m), v = m && -w / m;
              X2.add(v * cx);
              Y2.add(v * cy);
              Z2.add(v * cz);
              W1 += w;
              X1 += w * (x0 + (x0 = x));
              Y1 += w * (y0 + (y0 = y));
              Z1 += w * (z0 + (z0 = z));
              centroidPointCartesian(x0, y0, z0);
            }
            function centroid(object2) {
              W0 = W1 = X0 = Y0 = Z0 = X1 = Y1 = Z1 = 0;
              X2 = new d3Array.Adder();
              Y2 = new d3Array.Adder();
              Z2 = new d3Array.Adder();
              geoStream(object2, centroidStream);
              var x = +X2, y = +Y2, z = +Z2, m = hypot(x, y, z);
              if (m < epsilon2) {
                x = X1, y = Y1, z = Z1;
                if (W1 < epsilon)
                  x = X0, y = Y0, z = Z0;
                m = hypot(x, y, z);
                if (m < epsilon2)
                  return [NaN, NaN];
              }
              return [atan2(y, x) * degrees, asin(z / m) * degrees];
            }
            function constant(x) {
              return function() {
                return x;
              };
            }
            function compose(a, b) {
              function compose2(x, y) {
                return x = a(x, y), b(x[0], x[1]);
              }
              if (a.invert && b.invert)
                compose2.invert = function(x, y) {
                  return x = b.invert(x, y), x && a.invert(x[0], x[1]);
                };
              return compose2;
            }
            function rotationIdentity(lambda, phi) {
              return [abs(lambda) > pi ? lambda + Math.round(-lambda / tau) * tau : lambda, phi];
            }
            rotationIdentity.invert = rotationIdentity;
            function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
              return (deltaLambda %= tau) ? deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
            }
            function forwardRotationLambda(deltaLambda) {
              return function(lambda, phi) {
                return lambda += deltaLambda, [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];
              };
            }
            function rotationLambda(deltaLambda) {
              var rotation2 = forwardRotationLambda(deltaLambda);
              rotation2.invert = forwardRotationLambda(-deltaLambda);
              return rotation2;
            }
            function rotationPhiGamma(deltaPhi, deltaGamma) {
              var cosDeltaPhi = cos(deltaPhi), sinDeltaPhi = sin(deltaPhi), cosDeltaGamma = cos(deltaGamma), sinDeltaGamma = sin(deltaGamma);
              function rotation2(lambda, phi) {
                var cosPhi = cos(phi), x = cos(lambda) * cosPhi, y = sin(lambda) * cosPhi, z = sin(phi), k = z * cosDeltaPhi + x * sinDeltaPhi;
                return [
                  atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
                  asin(k * cosDeltaGamma + y * sinDeltaGamma)
                ];
              }
              rotation2.invert = function(lambda, phi) {
                var cosPhi = cos(phi), x = cos(lambda) * cosPhi, y = sin(lambda) * cosPhi, z = sin(phi), k = z * cosDeltaGamma - y * sinDeltaGamma;
                return [
                  atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
                  asin(k * cosDeltaPhi - x * sinDeltaPhi)
                ];
              };
              return rotation2;
            }
            function rotation(rotate) {
              rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);
              function forward(coordinates2) {
                coordinates2 = rotate(coordinates2[0] * radians, coordinates2[1] * radians);
                return coordinates2[0] *= degrees, coordinates2[1] *= degrees, coordinates2;
              }
              forward.invert = function(coordinates2) {
                coordinates2 = rotate.invert(coordinates2[0] * radians, coordinates2[1] * radians);
                return coordinates2[0] *= degrees, coordinates2[1] *= degrees, coordinates2;
              };
              return forward;
            }
            function circleStream(stream, radius, delta, direction, t0, t1) {
              if (!delta)
                return;
              var cosRadius = cos(radius), sinRadius = sin(radius), step = direction * delta;
              if (t0 == null) {
                t0 = radius + direction * tau;
                t1 = radius - step / 2;
              } else {
                t0 = circleRadius(cosRadius, t0);
                t1 = circleRadius(cosRadius, t1);
                if (direction > 0 ? t0 < t1 : t0 > t1)
                  t0 += direction * tau;
              }
              for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
                point = spherical([cosRadius, -sinRadius * cos(t), -sinRadius * sin(t)]);
                stream.point(point[0], point[1]);
              }
            }
            function circleRadius(cosRadius, point) {
              point = cartesian(point), point[0] -= cosRadius;
              cartesianNormalizeInPlace(point);
              var radius = acos(-point[1]);
              return ((-point[2] < 0 ? -radius : radius) + tau - epsilon) % tau;
            }
            function circle() {
              var center = constant([0, 0]), radius = constant(90), precision = constant(6), ring, rotate, stream = { point };
              function point(x, y) {
                ring.push(x = rotate(x, y));
                x[0] *= degrees, x[1] *= degrees;
              }
              function circle2() {
                var c = center.apply(this, arguments), r = radius.apply(this, arguments) * radians, p = precision.apply(this, arguments) * radians;
                ring = [];
                rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;
                circleStream(stream, r, p, 1);
                c = { type: "Polygon", coordinates: [ring] };
                ring = rotate = null;
                return c;
              }
              circle2.center = function(_) {
                return arguments.length ? (center = typeof _ === "function" ? _ : constant([+_[0], +_[1]]), circle2) : center;
              };
              circle2.radius = function(_) {
                return arguments.length ? (radius = typeof _ === "function" ? _ : constant(+_), circle2) : radius;
              };
              circle2.precision = function(_) {
                return arguments.length ? (precision = typeof _ === "function" ? _ : constant(+_), circle2) : precision;
              };
              return circle2;
            }
            function clipBuffer() {
              var lines = [], line;
              return {
                point: function(x, y, m) {
                  line.push([x, y, m]);
                },
                lineStart: function() {
                  lines.push(line = []);
                },
                lineEnd: noop,
                rejoin: function() {
                  if (lines.length > 1)
                    lines.push(lines.pop().concat(lines.shift()));
                },
                result: function() {
                  var result = lines;
                  lines = [];
                  line = null;
                  return result;
                }
              };
            }
            function pointEqual(a, b) {
              return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;
            }
            function Intersection(point, points, other, entry) {
              this.x = point;
              this.z = points;
              this.o = other;
              this.e = entry;
              this.v = false;
              this.n = this.p = null;
            }
            function clipRejoin(segments, compareIntersection2, startInside, interpolate2, stream) {
              var subject = [], clip2 = [], i, n;
              segments.forEach(function(segment) {
                if ((n2 = segment.length - 1) <= 0)
                  return;
                var n2, p02 = segment[0], p1 = segment[n2], x;
                if (pointEqual(p02, p1)) {
                  if (!p02[2] && !p1[2]) {
                    stream.lineStart();
                    for (i = 0; i < n2; ++i)
                      stream.point((p02 = segment[i])[0], p02[1]);
                    stream.lineEnd();
                    return;
                  }
                  p1[0] += 2 * epsilon;
                }
                subject.push(x = new Intersection(p02, segment, null, true));
                clip2.push(x.o = new Intersection(p02, null, x, false));
                subject.push(x = new Intersection(p1, segment, null, false));
                clip2.push(x.o = new Intersection(p1, null, x, true));
              });
              if (!subject.length)
                return;
              clip2.sort(compareIntersection2);
              link(subject);
              link(clip2);
              for (i = 0, n = clip2.length; i < n; ++i) {
                clip2[i].e = startInside = !startInside;
              }
              var start = subject[0], points, point;
              while (1) {
                var current = start, isSubject = true;
                while (current.v)
                  if ((current = current.n) === start)
                    return;
                points = current.z;
                stream.lineStart();
                do {
                  current.v = current.o.v = true;
                  if (current.e) {
                    if (isSubject) {
                      for (i = 0, n = points.length; i < n; ++i)
                        stream.point((point = points[i])[0], point[1]);
                    } else {
                      interpolate2(current.x, current.n.x, 1, stream);
                    }
                    current = current.n;
                  } else {
                    if (isSubject) {
                      points = current.p.z;
                      for (i = points.length - 1; i >= 0; --i)
                        stream.point((point = points[i])[0], point[1]);
                    } else {
                      interpolate2(current.x, current.p.x, -1, stream);
                    }
                    current = current.p;
                  }
                  current = current.o;
                  points = current.z;
                  isSubject = !isSubject;
                } while (!current.v);
                stream.lineEnd();
              }
            }
            function link(array) {
              if (!(n = array.length))
                return;
              var n, i = 0, a = array[0], b;
              while (++i < n) {
                a.n = b = array[i];
                b.p = a;
                a = b;
              }
              a.n = b = array[0];
              b.p = a;
            }
            function longitude(point) {
              if (abs(point[0]) <= pi)
                return point[0];
              else
                return sign(point[0]) * ((abs(point[0]) + pi) % tau - pi);
            }
            function polygonContains(polygon, point) {
              var lambda = longitude(point), phi = point[1], sinPhi = sin(phi), normal = [sin(lambda), -cos(lambda), 0], angle2 = 0, winding = 0;
              var sum = new d3Array.Adder();
              if (sinPhi === 1)
                phi = halfPi + epsilon;
              else if (sinPhi === -1)
                phi = -halfPi - epsilon;
              for (var i = 0, n = polygon.length; i < n; ++i) {
                if (!(m = (ring = polygon[i]).length))
                  continue;
                var ring, m, point0 = ring[m - 1], lambda02 = longitude(point0), phi02 = point0[1] / 2 + quarterPi, sinPhi02 = sin(phi02), cosPhi02 = cos(phi02);
                for (var j = 0; j < m; ++j, lambda02 = lambda12, sinPhi02 = sinPhi1, cosPhi02 = cosPhi1, point0 = point1) {
                  var point1 = ring[j], lambda12 = longitude(point1), phi12 = point1[1] / 2 + quarterPi, sinPhi1 = sin(phi12), cosPhi1 = cos(phi12), delta = lambda12 - lambda02, sign2 = delta >= 0 ? 1 : -1, absDelta = sign2 * delta, antimeridian = absDelta > pi, k = sinPhi02 * sinPhi1;
                  sum.add(atan2(k * sign2 * sin(absDelta), cosPhi02 * cosPhi1 + k * cos(absDelta)));
                  angle2 += antimeridian ? delta + sign2 * tau : delta;
                  if (antimeridian ^ lambda02 >= lambda ^ lambda12 >= lambda) {
                    var arc = cartesianCross(cartesian(point0), cartesian(point1));
                    cartesianNormalizeInPlace(arc);
                    var intersection = cartesianCross(normal, arc);
                    cartesianNormalizeInPlace(intersection);
                    var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);
                    if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
                      winding += antimeridian ^ delta >= 0 ? 1 : -1;
                    }
                  }
                }
              }
              return (angle2 < -epsilon || angle2 < epsilon && sum < -epsilon2) ^ winding & 1;
            }
            function clip(pointVisible, clipLine2, interpolate2, start) {
              return function(sink) {
                var line = clipLine2(sink), ringBuffer = clipBuffer(), ringSink = clipLine2(ringBuffer), polygonStarted = false, polygon, segments, ring;
                var clip2 = {
                  point,
                  lineStart,
                  lineEnd,
                  polygonStart: function() {
                    clip2.point = pointRing;
                    clip2.lineStart = ringStart;
                    clip2.lineEnd = ringEnd;
                    segments = [];
                    polygon = [];
                  },
                  polygonEnd: function() {
                    clip2.point = point;
                    clip2.lineStart = lineStart;
                    clip2.lineEnd = lineEnd;
                    segments = d3Array.merge(segments);
                    var startInside = polygonContains(polygon, start);
                    if (segments.length) {
                      if (!polygonStarted)
                        sink.polygonStart(), polygonStarted = true;
                      clipRejoin(segments, compareIntersection, startInside, interpolate2, sink);
                    } else if (startInside) {
                      if (!polygonStarted)
                        sink.polygonStart(), polygonStarted = true;
                      sink.lineStart();
                      interpolate2(null, null, 1, sink);
                      sink.lineEnd();
                    }
                    if (polygonStarted)
                      sink.polygonEnd(), polygonStarted = false;
                    segments = polygon = null;
                  },
                  sphere: function() {
                    sink.polygonStart();
                    sink.lineStart();
                    interpolate2(null, null, 1, sink);
                    sink.lineEnd();
                    sink.polygonEnd();
                  }
                };
                function point(lambda, phi) {
                  if (pointVisible(lambda, phi))
                    sink.point(lambda, phi);
                }
                function pointLine(lambda, phi) {
                  line.point(lambda, phi);
                }
                function lineStart() {
                  clip2.point = pointLine;
                  line.lineStart();
                }
                function lineEnd() {
                  clip2.point = point;
                  line.lineEnd();
                }
                function pointRing(lambda, phi) {
                  ring.push([lambda, phi]);
                  ringSink.point(lambda, phi);
                }
                function ringStart() {
                  ringSink.lineStart();
                  ring = [];
                }
                function ringEnd() {
                  pointRing(ring[0][0], ring[0][1]);
                  ringSink.lineEnd();
                  var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i, n = ringSegments.length, m, segment, point2;
                  ring.pop();
                  polygon.push(ring);
                  ring = null;
                  if (!n)
                    return;
                  if (clean & 1) {
                    segment = ringSegments[0];
                    if ((m = segment.length - 1) > 0) {
                      if (!polygonStarted)
                        sink.polygonStart(), polygonStarted = true;
                      sink.lineStart();
                      for (i = 0; i < m; ++i)
                        sink.point((point2 = segment[i])[0], point2[1]);
                      sink.lineEnd();
                    }
                    return;
                  }
                  if (n > 1 && clean & 2)
                    ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
                  segments.push(ringSegments.filter(validSegment));
                }
                return clip2;
              };
            }
            function validSegment(segment) {
              return segment.length > 1;
            }
            function compareIntersection(a, b) {
              return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);
            }
            var clipAntimeridian = clip(function() {
              return true;
            }, clipAntimeridianLine, clipAntimeridianInterpolate, [-pi, -halfPi]);
            function clipAntimeridianLine(stream) {
              var lambda02 = NaN, phi02 = NaN, sign0 = NaN, clean;
              return {
                lineStart: function() {
                  stream.lineStart();
                  clean = 1;
                },
                point: function(lambda12, phi12) {
                  var sign1 = lambda12 > 0 ? pi : -pi, delta = abs(lambda12 - lambda02);
                  if (abs(delta - pi) < epsilon) {
                    stream.point(lambda02, phi02 = (phi02 + phi12) / 2 > 0 ? halfPi : -halfPi);
                    stream.point(sign0, phi02);
                    stream.lineEnd();
                    stream.lineStart();
                    stream.point(sign1, phi02);
                    stream.point(lambda12, phi02);
                    clean = 0;
                  } else if (sign0 !== sign1 && delta >= pi) {
                    if (abs(lambda02 - sign0) < epsilon)
                      lambda02 -= sign0 * epsilon;
                    if (abs(lambda12 - sign1) < epsilon)
                      lambda12 -= sign1 * epsilon;
                    phi02 = clipAntimeridianIntersect(lambda02, phi02, lambda12, phi12);
                    stream.point(sign0, phi02);
                    stream.lineEnd();
                    stream.lineStart();
                    stream.point(sign1, phi02);
                    clean = 0;
                  }
                  stream.point(lambda02 = lambda12, phi02 = phi12);
                  sign0 = sign1;
                },
                lineEnd: function() {
                  stream.lineEnd();
                  lambda02 = phi02 = NaN;
                },
                clean: function() {
                  return 2 - clean;
                }
              };
            }
            function clipAntimeridianIntersect(lambda02, phi02, lambda12, phi12) {
              var cosPhi02, cosPhi1, sinLambda0Lambda1 = sin(lambda02 - lambda12);
              return abs(sinLambda0Lambda1) > epsilon ? atan((sin(phi02) * (cosPhi1 = cos(phi12)) * sin(lambda12) - sin(phi12) * (cosPhi02 = cos(phi02)) * sin(lambda02)) / (cosPhi02 * cosPhi1 * sinLambda0Lambda1)) : (phi02 + phi12) / 2;
            }
            function clipAntimeridianInterpolate(from, to, direction, stream) {
              var phi;
              if (from == null) {
                phi = direction * halfPi;
                stream.point(-pi, phi);
                stream.point(0, phi);
                stream.point(pi, phi);
                stream.point(pi, 0);
                stream.point(pi, -phi);
                stream.point(0, -phi);
                stream.point(-pi, -phi);
                stream.point(-pi, 0);
                stream.point(-pi, phi);
              } else if (abs(from[0] - to[0]) > epsilon) {
                var lambda = from[0] < to[0] ? pi : -pi;
                phi = direction * lambda / 2;
                stream.point(-lambda, phi);
                stream.point(0, phi);
                stream.point(lambda, phi);
              } else {
                stream.point(to[0], to[1]);
              }
            }
            function clipCircle(radius) {
              var cr = cos(radius), delta = 6 * radians, smallRadius = cr > 0, notHemisphere = abs(cr) > epsilon;
              function interpolate2(from, to, direction, stream) {
                circleStream(stream, radius, delta, direction, from, to);
              }
              function visible(lambda, phi) {
                return cos(lambda) * cos(phi) > cr;
              }
              function clipLine2(stream) {
                var point0, c0, v0, v00, clean;
                return {
                  lineStart: function() {
                    v00 = v0 = false;
                    clean = 1;
                  },
                  point: function(lambda, phi) {
                    var point1 = [lambda, phi], point2, v = visible(lambda, phi), c = smallRadius ? v ? 0 : code(lambda, phi) : v ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;
                    if (!point0 && (v00 = v0 = v))
                      stream.lineStart();
                    if (v !== v0) {
                      point2 = intersect(point0, point1);
                      if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2))
                        point1[2] = 1;
                    }
                    if (v !== v0) {
                      clean = 0;
                      if (v) {
                        stream.lineStart();
                        point2 = intersect(point1, point0);
                        stream.point(point2[0], point2[1]);
                      } else {
                        point2 = intersect(point0, point1);
                        stream.point(point2[0], point2[1], 2);
                        stream.lineEnd();
                      }
                      point0 = point2;
                    } else if (notHemisphere && point0 && smallRadius ^ v) {
                      var t;
                      if (!(c & c0) && (t = intersect(point1, point0, true))) {
                        clean = 0;
                        if (smallRadius) {
                          stream.lineStart();
                          stream.point(t[0][0], t[0][1]);
                          stream.point(t[1][0], t[1][1]);
                          stream.lineEnd();
                        } else {
                          stream.point(t[1][0], t[1][1]);
                          stream.lineEnd();
                          stream.lineStart();
                          stream.point(t[0][0], t[0][1], 3);
                        }
                      }
                    }
                    if (v && (!point0 || !pointEqual(point0, point1))) {
                      stream.point(point1[0], point1[1]);
                    }
                    point0 = point1, v0 = v, c0 = c;
                  },
                  lineEnd: function() {
                    if (v0)
                      stream.lineEnd();
                    point0 = null;
                  },
                  clean: function() {
                    return clean | (v00 && v0) << 1;
                  }
                };
              }
              function intersect(a, b, two) {
                var pa = cartesian(a), pb = cartesian(b);
                var n1 = [1, 0, 0], n2 = cartesianCross(pa, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
                if (!determinant)
                  return !two && a;
                var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = cartesianCross(n1, n2), A = cartesianScale(n1, c1), B = cartesianScale(n2, c2);
                cartesianAddInPlace(A, B);
                var u = n1xn2, w = cartesianDot(A, u), uu = cartesianDot(u, u), t2 = w * w - uu * (cartesianDot(A, A) - 1);
                if (t2 < 0)
                  return;
                var t = sqrt(t2), q = cartesianScale(u, (-w - t) / uu);
                cartesianAddInPlace(q, A);
                q = spherical(q);
                if (!two)
                  return q;
                var lambda02 = a[0], lambda12 = b[0], phi02 = a[1], phi12 = b[1], z;
                if (lambda12 < lambda02)
                  z = lambda02, lambda02 = lambda12, lambda12 = z;
                var delta2 = lambda12 - lambda02, polar = abs(delta2 - pi) < epsilon, meridian = polar || delta2 < epsilon;
                if (!polar && phi12 < phi02)
                  z = phi02, phi02 = phi12, phi12 = z;
                if (meridian ? polar ? phi02 + phi12 > 0 ^ q[1] < (abs(q[0] - lambda02) < epsilon ? phi02 : phi12) : phi02 <= q[1] && q[1] <= phi12 : delta2 > pi ^ (lambda02 <= q[0] && q[0] <= lambda12)) {
                  var q1 = cartesianScale(u, (-w + t) / uu);
                  cartesianAddInPlace(q1, A);
                  return [q, spherical(q1)];
                }
              }
              function code(lambda, phi) {
                var r = smallRadius ? radius : pi - radius, code2 = 0;
                if (lambda < -r)
                  code2 |= 1;
                else if (lambda > r)
                  code2 |= 2;
                if (phi < -r)
                  code2 |= 4;
                else if (phi > r)
                  code2 |= 8;
                return code2;
              }
              return clip(visible, clipLine2, interpolate2, smallRadius ? [0, -radius] : [-pi, radius - pi]);
            }
            function clipLine(a, b, x02, y02, x12, y12) {
              var ax = a[0], ay = a[1], bx = b[0], by = b[1], t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
              r = x02 - ax;
              if (!dx && r > 0)
                return;
              r /= dx;
              if (dx < 0) {
                if (r < t0)
                  return;
                if (r < t1)
                  t1 = r;
              } else if (dx > 0) {
                if (r > t1)
                  return;
                if (r > t0)
                  t0 = r;
              }
              r = x12 - ax;
              if (!dx && r < 0)
                return;
              r /= dx;
              if (dx < 0) {
                if (r > t1)
                  return;
                if (r > t0)
                  t0 = r;
              } else if (dx > 0) {
                if (r < t0)
                  return;
                if (r < t1)
                  t1 = r;
              }
              r = y02 - ay;
              if (!dy && r > 0)
                return;
              r /= dy;
              if (dy < 0) {
                if (r < t0)
                  return;
                if (r < t1)
                  t1 = r;
              } else if (dy > 0) {
                if (r > t1)
                  return;
                if (r > t0)
                  t0 = r;
              }
              r = y12 - ay;
              if (!dy && r < 0)
                return;
              r /= dy;
              if (dy < 0) {
                if (r > t1)
                  return;
                if (r > t0)
                  t0 = r;
              } else if (dy > 0) {
                if (r < t0)
                  return;
                if (r < t1)
                  t1 = r;
              }
              if (t0 > 0)
                a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
              if (t1 < 1)
                b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
              return true;
            }
            var clipMax = 1e9, clipMin = -clipMax;
            function clipRectangle(x02, y02, x12, y12) {
              function visible(x, y) {
                return x02 <= x && x <= x12 && y02 <= y && y <= y12;
              }
              function interpolate2(from, to, direction, stream) {
                var a = 0, a1 = 0;
                if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {
                  do
                    stream.point(a === 0 || a === 3 ? x02 : x12, a > 1 ? y12 : y02);
                  while ((a = (a + direction + 4) % 4) !== a1);
                } else {
                  stream.point(to[0], to[1]);
                }
              }
              function corner(p, direction) {
                return abs(p[0] - x02) < epsilon ? direction > 0 ? 0 : 3 : abs(p[0] - x12) < epsilon ? direction > 0 ? 2 : 1 : abs(p[1] - y02) < epsilon ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
              }
              function compareIntersection2(a, b) {
                return comparePoint(a.x, b.x);
              }
              function comparePoint(a, b) {
                var ca = corner(a, 1), cb = corner(b, 1);
                return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
              }
              return function(stream) {
                var activeStream = stream, bufferStream = clipBuffer(), segments, polygon, ring, x__, y__, v__, x_, y_, v_, first, clean;
                var clipStream = {
                  point,
                  lineStart,
                  lineEnd,
                  polygonStart,
                  polygonEnd
                };
                function point(x, y) {
                  if (visible(x, y))
                    activeStream.point(x, y);
                }
                function polygonInside() {
                  var winding = 0;
                  for (var i = 0, n = polygon.length; i < n; ++i) {
                    for (var ring2 = polygon[i], j = 1, m = ring2.length, point2 = ring2[0], a0, a1, b0 = point2[0], b1 = point2[1]; j < m; ++j) {
                      a0 = b0, a1 = b1, point2 = ring2[j], b0 = point2[0], b1 = point2[1];
                      if (a1 <= y12) {
                        if (b1 > y12 && (b0 - a0) * (y12 - a1) > (b1 - a1) * (x02 - a0))
                          ++winding;
                      } else {
                        if (b1 <= y12 && (b0 - a0) * (y12 - a1) < (b1 - a1) * (x02 - a0))
                          --winding;
                      }
                    }
                  }
                  return winding;
                }
                function polygonStart() {
                  activeStream = bufferStream, segments = [], polygon = [], clean = true;
                }
                function polygonEnd() {
                  var startInside = polygonInside(), cleanInside = clean && startInside, visible2 = (segments = d3Array.merge(segments)).length;
                  if (cleanInside || visible2) {
                    stream.polygonStart();
                    if (cleanInside) {
                      stream.lineStart();
                      interpolate2(null, null, 1, stream);
                      stream.lineEnd();
                    }
                    if (visible2) {
                      clipRejoin(segments, compareIntersection2, startInside, interpolate2, stream);
                    }
                    stream.polygonEnd();
                  }
                  activeStream = stream, segments = polygon = ring = null;
                }
                function lineStart() {
                  clipStream.point = linePoint2;
                  if (polygon)
                    polygon.push(ring = []);
                  first = true;
                  v_ = false;
                  x_ = y_ = NaN;
                }
                function lineEnd() {
                  if (segments) {
                    linePoint2(x__, y__);
                    if (v__ && v_)
                      bufferStream.rejoin();
                    segments.push(bufferStream.result());
                  }
                  clipStream.point = point;
                  if (v_)
                    activeStream.lineEnd();
                }
                function linePoint2(x, y) {
                  var v = visible(x, y);
                  if (polygon)
                    ring.push([x, y]);
                  if (first) {
                    x__ = x, y__ = y, v__ = v;
                    first = false;
                    if (v) {
                      activeStream.lineStart();
                      activeStream.point(x, y);
                    }
                  } else {
                    if (v && v_)
                      activeStream.point(x, y);
                    else {
                      var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
                      if (clipLine(a, b, x02, y02, x12, y12)) {
                        if (!v_) {
                          activeStream.lineStart();
                          activeStream.point(a[0], a[1]);
                        }
                        activeStream.point(b[0], b[1]);
                        if (!v)
                          activeStream.lineEnd();
                        clean = false;
                      } else if (v) {
                        activeStream.lineStart();
                        activeStream.point(x, y);
                        clean = false;
                      }
                    }
                  }
                  x_ = x, y_ = y, v_ = v;
                }
                return clipStream;
              };
            }
            function extent() {
              var x02 = 0, y02 = 0, x12 = 960, y12 = 500, cache, cacheStream, clip2;
              return clip2 = {
                stream: function(stream) {
                  return cache && cacheStream === stream ? cache : cache = clipRectangle(x02, y02, x12, y12)(cacheStream = stream);
                },
                extent: function(_) {
                  return arguments.length ? (x02 = +_[0][0], y02 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1], cache = cacheStream = null, clip2) : [[x02, y02], [x12, y12]];
                }
              };
            }
            var lengthSum, lambda0$2, sinPhi0$1, cosPhi0$1;
            var lengthStream = {
              sphere: noop,
              point: noop,
              lineStart: lengthLineStart,
              lineEnd: noop,
              polygonStart: noop,
              polygonEnd: noop
            };
            function lengthLineStart() {
              lengthStream.point = lengthPointFirst;
              lengthStream.lineEnd = lengthLineEnd;
            }
            function lengthLineEnd() {
              lengthStream.point = lengthStream.lineEnd = noop;
            }
            function lengthPointFirst(lambda, phi) {
              lambda *= radians, phi *= radians;
              lambda0$2 = lambda, sinPhi0$1 = sin(phi), cosPhi0$1 = cos(phi);
              lengthStream.point = lengthPoint;
            }
            function lengthPoint(lambda, phi) {
              lambda *= radians, phi *= radians;
              var sinPhi = sin(phi), cosPhi = cos(phi), delta = abs(lambda - lambda0$2), cosDelta = cos(delta), sinDelta = sin(delta), x = cosPhi * sinDelta, y = cosPhi0$1 * sinPhi - sinPhi0$1 * cosPhi * cosDelta, z = sinPhi0$1 * sinPhi + cosPhi0$1 * cosPhi * cosDelta;
              lengthSum.add(atan2(sqrt(x * x + y * y), z));
              lambda0$2 = lambda, sinPhi0$1 = sinPhi, cosPhi0$1 = cosPhi;
            }
            function length(object2) {
              lengthSum = new d3Array.Adder();
              geoStream(object2, lengthStream);
              return +lengthSum;
            }
            var coordinates = [null, null], object = { type: "LineString", coordinates };
            function distance(a, b) {
              coordinates[0] = a;
              coordinates[1] = b;
              return length(object);
            }
            var containsObjectType = {
              Feature: function(object2, point) {
                return containsGeometry(object2.geometry, point);
              },
              FeatureCollection: function(object2, point) {
                var features = object2.features, i = -1, n = features.length;
                while (++i < n)
                  if (containsGeometry(features[i].geometry, point))
                    return true;
                return false;
              }
            };
            var containsGeometryType = {
              Sphere: function() {
                return true;
              },
              Point: function(object2, point) {
                return containsPoint(object2.coordinates, point);
              },
              MultiPoint: function(object2, point) {
                var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
                while (++i < n)
                  if (containsPoint(coordinates2[i], point))
                    return true;
                return false;
              },
              LineString: function(object2, point) {
                return containsLine(object2.coordinates, point);
              },
              MultiLineString: function(object2, point) {
                var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
                while (++i < n)
                  if (containsLine(coordinates2[i], point))
                    return true;
                return false;
              },
              Polygon: function(object2, point) {
                return containsPolygon(object2.coordinates, point);
              },
              MultiPolygon: function(object2, point) {
                var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
                while (++i < n)
                  if (containsPolygon(coordinates2[i], point))
                    return true;
                return false;
              },
              GeometryCollection: function(object2, point) {
                var geometries = object2.geometries, i = -1, n = geometries.length;
                while (++i < n)
                  if (containsGeometry(geometries[i], point))
                    return true;
                return false;
              }
            };
            function containsGeometry(geometry, point) {
              return geometry && containsGeometryType.hasOwnProperty(geometry.type) ? containsGeometryType[geometry.type](geometry, point) : false;
            }
            function containsPoint(coordinates2, point) {
              return distance(coordinates2, point) === 0;
            }
            function containsLine(coordinates2, point) {
              var ao, bo, ab;
              for (var i = 0, n = coordinates2.length; i < n; i++) {
                bo = distance(coordinates2[i], point);
                if (bo === 0)
                  return true;
                if (i > 0) {
                  ab = distance(coordinates2[i], coordinates2[i - 1]);
                  if (ab > 0 && ao <= ab && bo <= ab && (ao + bo - ab) * (1 - Math.pow((ao - bo) / ab, 2)) < epsilon2 * ab)
                    return true;
                }
                ao = bo;
              }
              return false;
            }
            function containsPolygon(coordinates2, point) {
              return !!polygonContains(coordinates2.map(ringRadians), pointRadians(point));
            }
            function ringRadians(ring) {
              return ring = ring.map(pointRadians), ring.pop(), ring;
            }
            function pointRadians(point) {
              return [point[0] * radians, point[1] * radians];
            }
            function contains(object2, point) {
              return (object2 && containsObjectType.hasOwnProperty(object2.type) ? containsObjectType[object2.type] : containsGeometry)(object2, point);
            }
            function graticuleX(y02, y12, dy) {
              var y = d3Array.range(y02, y12 - epsilon, dy).concat(y12);
              return function(x) {
                return y.map(function(y2) {
                  return [x, y2];
                });
              };
            }
            function graticuleY(x02, x12, dx) {
              var x = d3Array.range(x02, x12 - epsilon, dx).concat(x12);
              return function(y) {
                return x.map(function(x2) {
                  return [x2, y];
                });
              };
            }
            function graticule() {
              var x12, x02, X12, X02, y12, y02, Y12, Y02, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;
              function graticule2() {
                return { type: "MultiLineString", coordinates: lines() };
              }
              function lines() {
                return d3Array.range(ceil(X02 / DX) * DX, X12, DX).map(X).concat(d3Array.range(ceil(Y02 / DY) * DY, Y12, DY).map(Y)).concat(d3Array.range(ceil(x02 / dx) * dx, x12, dx).filter(function(x2) {
                  return abs(x2 % DX) > epsilon;
                }).map(x)).concat(d3Array.range(ceil(y02 / dy) * dy, y12, dy).filter(function(y2) {
                  return abs(y2 % DY) > epsilon;
                }).map(y));
              }
              graticule2.lines = function() {
                return lines().map(function(coordinates2) {
                  return { type: "LineString", coordinates: coordinates2 };
                });
              };
              graticule2.outline = function() {
                return {
                  type: "Polygon",
                  coordinates: [
                    X(X02).concat(Y(Y12).slice(1), X(X12).reverse().slice(1), Y(Y02).reverse().slice(1))
                  ]
                };
              };
              graticule2.extent = function(_) {
                if (!arguments.length)
                  return graticule2.extentMinor();
                return graticule2.extentMajor(_).extentMinor(_);
              };
              graticule2.extentMajor = function(_) {
                if (!arguments.length)
                  return [[X02, Y02], [X12, Y12]];
                X02 = +_[0][0], X12 = +_[1][0];
                Y02 = +_[0][1], Y12 = +_[1][1];
                if (X02 > X12)
                  _ = X02, X02 = X12, X12 = _;
                if (Y02 > Y12)
                  _ = Y02, Y02 = Y12, Y12 = _;
                return graticule2.precision(precision);
              };
              graticule2.extentMinor = function(_) {
                if (!arguments.length)
                  return [[x02, y02], [x12, y12]];
                x02 = +_[0][0], x12 = +_[1][0];
                y02 = +_[0][1], y12 = +_[1][1];
                if (x02 > x12)
                  _ = x02, x02 = x12, x12 = _;
                if (y02 > y12)
                  _ = y02, y02 = y12, y12 = _;
                return graticule2.precision(precision);
              };
              graticule2.step = function(_) {
                if (!arguments.length)
                  return graticule2.stepMinor();
                return graticule2.stepMajor(_).stepMinor(_);
              };
              graticule2.stepMajor = function(_) {
                if (!arguments.length)
                  return [DX, DY];
                DX = +_[0], DY = +_[1];
                return graticule2;
              };
              graticule2.stepMinor = function(_) {
                if (!arguments.length)
                  return [dx, dy];
                dx = +_[0], dy = +_[1];
                return graticule2;
              };
              graticule2.precision = function(_) {
                if (!arguments.length)
                  return precision;
                precision = +_;
                x = graticuleX(y02, y12, 90);
                y = graticuleY(x02, x12, precision);
                X = graticuleX(Y02, Y12, 90);
                Y = graticuleY(X02, X12, precision);
                return graticule2;
              };
              return graticule2.extentMajor([[-180, -90 + epsilon], [180, 90 - epsilon]]).extentMinor([[-180, -80 - epsilon], [180, 80 + epsilon]]);
            }
            function graticule10() {
              return graticule()();
            }
            function interpolate(a, b) {
              var x02 = a[0] * radians, y02 = a[1] * radians, x12 = b[0] * radians, y12 = b[1] * radians, cy0 = cos(y02), sy0 = sin(y02), cy1 = cos(y12), sy1 = sin(y12), kx0 = cy0 * cos(x02), ky0 = cy0 * sin(x02), kx1 = cy1 * cos(x12), ky1 = cy1 * sin(x12), d = 2 * asin(sqrt(haversin(y12 - y02) + cy0 * cy1 * haversin(x12 - x02))), k = sin(d);
              var interpolate2 = d ? function(t) {
                var B = sin(t *= d) / k, A = sin(d - t) / k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
                return [
                  atan2(y, x) * degrees,
                  atan2(z, sqrt(x * x + y * y)) * degrees
                ];
              } : function() {
                return [x02 * degrees, y02 * degrees];
              };
              interpolate2.distance = d;
              return interpolate2;
            }
            var identity = function(x) {
              return x;
            };
            var areaSum$1 = new d3Array.Adder(), areaRingSum$1 = new d3Array.Adder(), x00, y00, x0$1, y0$1;
            var areaStream$1 = {
              point: noop,
              lineStart: noop,
              lineEnd: noop,
              polygonStart: function() {
                areaStream$1.lineStart = areaRingStart$1;
                areaStream$1.lineEnd = areaRingEnd$1;
              },
              polygonEnd: function() {
                areaStream$1.lineStart = areaStream$1.lineEnd = areaStream$1.point = noop;
                areaSum$1.add(abs(areaRingSum$1));
                areaRingSum$1 = new d3Array.Adder();
              },
              result: function() {
                var area2 = areaSum$1 / 2;
                areaSum$1 = new d3Array.Adder();
                return area2;
              }
            };
            function areaRingStart$1() {
              areaStream$1.point = areaPointFirst$1;
            }
            function areaPointFirst$1(x, y) {
              areaStream$1.point = areaPoint$1;
              x00 = x0$1 = x, y00 = y0$1 = y;
            }
            function areaPoint$1(x, y) {
              areaRingSum$1.add(y0$1 * x - x0$1 * y);
              x0$1 = x, y0$1 = y;
            }
            function areaRingEnd$1() {
              areaPoint$1(x00, y00);
            }
            var x0$2 = Infinity, y0$2 = x0$2, x1 = -x0$2, y1 = x1;
            var boundsStream$1 = {
              point: boundsPoint$1,
              lineStart: noop,
              lineEnd: noop,
              polygonStart: noop,
              polygonEnd: noop,
              result: function() {
                var bounds2 = [[x0$2, y0$2], [x1, y1]];
                x1 = y1 = -(y0$2 = x0$2 = Infinity);
                return bounds2;
              }
            };
            function boundsPoint$1(x, y) {
              if (x < x0$2)
                x0$2 = x;
              if (x > x1)
                x1 = x;
              if (y < y0$2)
                y0$2 = y;
              if (y > y1)
                y1 = y;
            }
            var X0$1 = 0, Y0$1 = 0, Z0$1 = 0, X1$1 = 0, Y1$1 = 0, Z1$1 = 0, X2$1 = 0, Y2$1 = 0, Z2$1 = 0, x00$1, y00$1, x0$3, y0$3;
            var centroidStream$1 = {
              point: centroidPoint$1,
              lineStart: centroidLineStart$1,
              lineEnd: centroidLineEnd$1,
              polygonStart: function() {
                centroidStream$1.lineStart = centroidRingStart$1;
                centroidStream$1.lineEnd = centroidRingEnd$1;
              },
              polygonEnd: function() {
                centroidStream$1.point = centroidPoint$1;
                centroidStream$1.lineStart = centroidLineStart$1;
                centroidStream$1.lineEnd = centroidLineEnd$1;
              },
              result: function() {
                var centroid2 = Z2$1 ? [X2$1 / Z2$1, Y2$1 / Z2$1] : Z1$1 ? [X1$1 / Z1$1, Y1$1 / Z1$1] : Z0$1 ? [X0$1 / Z0$1, Y0$1 / Z0$1] : [NaN, NaN];
                X0$1 = Y0$1 = Z0$1 = X1$1 = Y1$1 = Z1$1 = X2$1 = Y2$1 = Z2$1 = 0;
                return centroid2;
              }
            };
            function centroidPoint$1(x, y) {
              X0$1 += x;
              Y0$1 += y;
              ++Z0$1;
            }
            function centroidLineStart$1() {
              centroidStream$1.point = centroidPointFirstLine;
            }
            function centroidPointFirstLine(x, y) {
              centroidStream$1.point = centroidPointLine;
              centroidPoint$1(x0$3 = x, y0$3 = y);
            }
            function centroidPointLine(x, y) {
              var dx = x - x0$3, dy = y - y0$3, z = sqrt(dx * dx + dy * dy);
              X1$1 += z * (x0$3 + x) / 2;
              Y1$1 += z * (y0$3 + y) / 2;
              Z1$1 += z;
              centroidPoint$1(x0$3 = x, y0$3 = y);
            }
            function centroidLineEnd$1() {
              centroidStream$1.point = centroidPoint$1;
            }
            function centroidRingStart$1() {
              centroidStream$1.point = centroidPointFirstRing;
            }
            function centroidRingEnd$1() {
              centroidPointRing(x00$1, y00$1);
            }
            function centroidPointFirstRing(x, y) {
              centroidStream$1.point = centroidPointRing;
              centroidPoint$1(x00$1 = x0$3 = x, y00$1 = y0$3 = y);
            }
            function centroidPointRing(x, y) {
              var dx = x - x0$3, dy = y - y0$3, z = sqrt(dx * dx + dy * dy);
              X1$1 += z * (x0$3 + x) / 2;
              Y1$1 += z * (y0$3 + y) / 2;
              Z1$1 += z;
              z = y0$3 * x - x0$3 * y;
              X2$1 += z * (x0$3 + x);
              Y2$1 += z * (y0$3 + y);
              Z2$1 += z * 3;
              centroidPoint$1(x0$3 = x, y0$3 = y);
            }
            function PathContext(context) {
              this._context = context;
            }
            PathContext.prototype = {
              _radius: 4.5,
              pointRadius: function(_) {
                return this._radius = _, this;
              },
              polygonStart: function() {
                this._line = 0;
              },
              polygonEnd: function() {
                this._line = NaN;
              },
              lineStart: function() {
                this._point = 0;
              },
              lineEnd: function() {
                if (this._line === 0)
                  this._context.closePath();
                this._point = NaN;
              },
              point: function(x, y) {
                switch (this._point) {
                  case 0: {
                    this._context.moveTo(x, y);
                    this._point = 1;
                    break;
                  }
                  case 1: {
                    this._context.lineTo(x, y);
                    break;
                  }
                  default: {
                    this._context.moveTo(x + this._radius, y);
                    this._context.arc(x, y, this._radius, 0, tau);
                    break;
                  }
                }
              },
              result: noop
            };
            var lengthSum$1 = new d3Array.Adder(), lengthRing, x00$2, y00$2, x0$4, y0$4;
            var lengthStream$1 = {
              point: noop,
              lineStart: function() {
                lengthStream$1.point = lengthPointFirst$1;
              },
              lineEnd: function() {
                if (lengthRing)
                  lengthPoint$1(x00$2, y00$2);
                lengthStream$1.point = noop;
              },
              polygonStart: function() {
                lengthRing = true;
              },
              polygonEnd: function() {
                lengthRing = null;
              },
              result: function() {
                var length2 = +lengthSum$1;
                lengthSum$1 = new d3Array.Adder();
                return length2;
              }
            };
            function lengthPointFirst$1(x, y) {
              lengthStream$1.point = lengthPoint$1;
              x00$2 = x0$4 = x, y00$2 = y0$4 = y;
            }
            function lengthPoint$1(x, y) {
              x0$4 -= x, y0$4 -= y;
              lengthSum$1.add(sqrt(x0$4 * x0$4 + y0$4 * y0$4));
              x0$4 = x, y0$4 = y;
            }
            function PathString() {
              this._string = [];
            }
            PathString.prototype = {
              _radius: 4.5,
              _circle: circle$1(4.5),
              pointRadius: function(_) {
                if ((_ = +_) !== this._radius)
                  this._radius = _, this._circle = null;
                return this;
              },
              polygonStart: function() {
                this._line = 0;
              },
              polygonEnd: function() {
                this._line = NaN;
              },
              lineStart: function() {
                this._point = 0;
              },
              lineEnd: function() {
                if (this._line === 0)
                  this._string.push("Z");
                this._point = NaN;
              },
              point: function(x, y) {
                switch (this._point) {
                  case 0: {
                    this._string.push("M", x, ",", y);
                    this._point = 1;
                    break;
                  }
                  case 1: {
                    this._string.push("L", x, ",", y);
                    break;
                  }
                  default: {
                    if (this._circle == null)
                      this._circle = circle$1(this._radius);
                    this._string.push("M", x, ",", y, this._circle);
                    break;
                  }
                }
              },
              result: function() {
                if (this._string.length) {
                  var result = this._string.join("");
                  this._string = [];
                  return result;
                } else {
                  return null;
                }
              }
            };
            function circle$1(radius) {
              return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
            }
            function index(projection2, context) {
              var pointRadius = 4.5, projectionStream, contextStream;
              function path(object2) {
                if (object2) {
                  if (typeof pointRadius === "function")
                    contextStream.pointRadius(+pointRadius.apply(this, arguments));
                  geoStream(object2, projectionStream(contextStream));
                }
                return contextStream.result();
              }
              path.area = function(object2) {
                geoStream(object2, projectionStream(areaStream$1));
                return areaStream$1.result();
              };
              path.measure = function(object2) {
                geoStream(object2, projectionStream(lengthStream$1));
                return lengthStream$1.result();
              };
              path.bounds = function(object2) {
                geoStream(object2, projectionStream(boundsStream$1));
                return boundsStream$1.result();
              };
              path.centroid = function(object2) {
                geoStream(object2, projectionStream(centroidStream$1));
                return centroidStream$1.result();
              };
              path.projection = function(_) {
                return arguments.length ? (projectionStream = _ == null ? (projection2 = null, identity) : (projection2 = _).stream, path) : projection2;
              };
              path.context = function(_) {
                if (!arguments.length)
                  return context;
                contextStream = _ == null ? (context = null, new PathString()) : new PathContext(context = _);
                if (typeof pointRadius !== "function")
                  contextStream.pointRadius(pointRadius);
                return path;
              };
              path.pointRadius = function(_) {
                if (!arguments.length)
                  return pointRadius;
                pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
                return path;
              };
              return path.projection(projection2).context(context);
            }
            function transform(methods) {
              return {
                stream: transformer(methods)
              };
            }
            function transformer(methods) {
              return function(stream) {
                var s = new TransformStream();
                for (var key in methods)
                  s[key] = methods[key];
                s.stream = stream;
                return s;
              };
            }
            function TransformStream() {
            }
            TransformStream.prototype = {
              constructor: TransformStream,
              point: function(x, y) {
                this.stream.point(x, y);
              },
              sphere: function() {
                this.stream.sphere();
              },
              lineStart: function() {
                this.stream.lineStart();
              },
              lineEnd: function() {
                this.stream.lineEnd();
              },
              polygonStart: function() {
                this.stream.polygonStart();
              },
              polygonEnd: function() {
                this.stream.polygonEnd();
              }
            };
            function fit(projection2, fitBounds, object2) {
              var clip2 = projection2.clipExtent && projection2.clipExtent();
              projection2.scale(150).translate([0, 0]);
              if (clip2 != null)
                projection2.clipExtent(null);
              geoStream(object2, projection2.stream(boundsStream$1));
              fitBounds(boundsStream$1.result());
              if (clip2 != null)
                projection2.clipExtent(clip2);
              return projection2;
            }
            function fitExtent(projection2, extent2, object2) {
              return fit(projection2, function(b) {
                var w = extent2[1][0] - extent2[0][0], h = extent2[1][1] - extent2[0][1], k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])), x = +extent2[0][0] + (w - k * (b[1][0] + b[0][0])) / 2, y = +extent2[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
                projection2.scale(150 * k).translate([x, y]);
              }, object2);
            }
            function fitSize(projection2, size, object2) {
              return fitExtent(projection2, [[0, 0], size], object2);
            }
            function fitWidth(projection2, width, object2) {
              return fit(projection2, function(b) {
                var w = +width, k = w / (b[1][0] - b[0][0]), x = (w - k * (b[1][0] + b[0][0])) / 2, y = -k * b[0][1];
                projection2.scale(150 * k).translate([x, y]);
              }, object2);
            }
            function fitHeight(projection2, height, object2) {
              return fit(projection2, function(b) {
                var h = +height, k = h / (b[1][1] - b[0][1]), x = -k * b[0][0], y = (h - k * (b[1][1] + b[0][1])) / 2;
                projection2.scale(150 * k).translate([x, y]);
              }, object2);
            }
            var maxDepth = 16, cosMinDistance = cos(30 * radians);
            function resample(project, delta2) {
              return +delta2 ? resample$1(project, delta2) : resampleNone(project);
            }
            function resampleNone(project) {
              return transformer({
                point: function(x, y) {
                  x = project(x, y);
                  this.stream.point(x[0], x[1]);
                }
              });
            }
            function resample$1(project, delta2) {
              function resampleLineTo(x02, y02, lambda02, a0, b0, c0, x12, y12, lambda12, a1, b1, c1, depth, stream) {
                var dx = x12 - x02, dy = y12 - y02, d2 = dx * dx + dy * dy;
                if (d2 > 4 * delta2 && depth--) {
                  var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = sqrt(a * a + b * b + c * c), phi2 = asin(c /= m), lambda22 = abs(abs(c) - 1) < epsilon || abs(lambda02 - lambda12) < epsilon ? (lambda02 + lambda12) / 2 : atan2(b, a), p = project(lambda22, phi2), x2 = p[0], y2 = p[1], dx2 = x2 - x02, dy2 = y2 - y02, dz = dy * dx2 - dx * dy2;
                  if (dz * dz / d2 > delta2 || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
                    resampleLineTo(x02, y02, lambda02, a0, b0, c0, x2, y2, lambda22, a /= m, b /= m, c, depth, stream);
                    stream.point(x2, y2);
                    resampleLineTo(x2, y2, lambda22, a, b, c, x12, y12, lambda12, a1, b1, c1, depth, stream);
                  }
                }
              }
              return function(stream) {
                var lambda002, x002, y002, a00, b00, c00, lambda02, x02, y02, a0, b0, c0;
                var resampleStream = {
                  point,
                  lineStart,
                  lineEnd,
                  polygonStart: function() {
                    stream.polygonStart();
                    resampleStream.lineStart = ringStart;
                  },
                  polygonEnd: function() {
                    stream.polygonEnd();
                    resampleStream.lineStart = lineStart;
                  }
                };
                function point(x, y) {
                  x = project(x, y);
                  stream.point(x[0], x[1]);
                }
                function lineStart() {
                  x02 = NaN;
                  resampleStream.point = linePoint2;
                  stream.lineStart();
                }
                function linePoint2(lambda, phi) {
                  var c = cartesian([lambda, phi]), p = project(lambda, phi);
                  resampleLineTo(x02, y02, lambda02, a0, b0, c0, x02 = p[0], y02 = p[1], lambda02 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
                  stream.point(x02, y02);
                }
                function lineEnd() {
                  resampleStream.point = point;
                  stream.lineEnd();
                }
                function ringStart() {
                  lineStart();
                  resampleStream.point = ringPoint;
                  resampleStream.lineEnd = ringEnd;
                }
                function ringPoint(lambda, phi) {
                  linePoint2(lambda002 = lambda, phi), x002 = x02, y002 = y02, a00 = a0, b00 = b0, c00 = c0;
                  resampleStream.point = linePoint2;
                }
                function ringEnd() {
                  resampleLineTo(x02, y02, lambda02, a0, b0, c0, x002, y002, lambda002, a00, b00, c00, maxDepth, stream);
                  resampleStream.lineEnd = lineEnd;
                  lineEnd();
                }
                return resampleStream;
              };
            }
            var transformRadians = transformer({
              point: function(x, y) {
                this.stream.point(x * radians, y * radians);
              }
            });
            function transformRotate(rotate) {
              return transformer({
                point: function(x, y) {
                  var r = rotate(x, y);
                  return this.stream.point(r[0], r[1]);
                }
              });
            }
            function scaleTranslate(k, dx, dy, sx, sy) {
              function transform2(x, y) {
                x *= sx;
                y *= sy;
                return [dx + k * x, dy - k * y];
              }
              transform2.invert = function(x, y) {
                return [(x - dx) / k * sx, (dy - y) / k * sy];
              };
              return transform2;
            }
            function scaleTranslateRotate(k, dx, dy, sx, sy, alpha) {
              if (!alpha)
                return scaleTranslate(k, dx, dy, sx, sy);
              var cosAlpha = cos(alpha), sinAlpha = sin(alpha), a = cosAlpha * k, b = sinAlpha * k, ai = cosAlpha / k, bi = sinAlpha / k, ci = (sinAlpha * dy - cosAlpha * dx) / k, fi = (sinAlpha * dx + cosAlpha * dy) / k;
              function transform2(x, y) {
                x *= sx;
                y *= sy;
                return [a * x - b * y + dx, dy - b * x - a * y];
              }
              transform2.invert = function(x, y) {
                return [sx * (ai * x - bi * y + ci), sy * (fi - bi * x - ai * y)];
              };
              return transform2;
            }
            function projection(project) {
              return projectionMutator(function() {
                return project;
              })();
            }
            function projectionMutator(projectAt) {
              var project, k = 150, x = 480, y = 250, lambda = 0, phi = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, alpha = 0, sx = 1, sy = 1, theta = null, preclip = clipAntimeridian, x02 = null, y02, x12, y12, postclip = identity, delta2 = 0.5, projectResample, projectTransform, projectRotateTransform, cache, cacheStream;
              function projection2(point) {
                return projectRotateTransform(point[0] * radians, point[1] * radians);
              }
              function invert(point) {
                point = projectRotateTransform.invert(point[0], point[1]);
                return point && [point[0] * degrees, point[1] * degrees];
              }
              projection2.stream = function(stream) {
                return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
              };
              projection2.preclip = function(_) {
                return arguments.length ? (preclip = _, theta = void 0, reset()) : preclip;
              };
              projection2.postclip = function(_) {
                return arguments.length ? (postclip = _, x02 = y02 = x12 = y12 = null, reset()) : postclip;
              };
              projection2.clipAngle = function(_) {
                return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees;
              };
              projection2.clipExtent = function(_) {
                return arguments.length ? (postclip = _ == null ? (x02 = y02 = x12 = y12 = null, identity) : clipRectangle(x02 = +_[0][0], y02 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reset()) : x02 == null ? null : [[x02, y02], [x12, y12]];
              };
              projection2.scale = function(_) {
                return arguments.length ? (k = +_, recenter()) : k;
              };
              projection2.translate = function(_) {
                return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
              };
              projection2.center = function(_) {
                return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];
              };
              projection2.rotate = function(_) {
                return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
              };
              projection2.angle = function(_) {
                return arguments.length ? (alpha = _ % 360 * radians, recenter()) : alpha * degrees;
              };
              projection2.reflectX = function(_) {
                return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;
              };
              projection2.reflectY = function(_) {
                return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;
              };
              projection2.precision = function(_) {
                return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);
              };
              projection2.fitExtent = function(extent2, object2) {
                return fitExtent(projection2, extent2, object2);
              };
              projection2.fitSize = function(size, object2) {
                return fitSize(projection2, size, object2);
              };
              projection2.fitWidth = function(width, object2) {
                return fitWidth(projection2, width, object2);
              };
              projection2.fitHeight = function(height, object2) {
                return fitHeight(projection2, height, object2);
              };
              function recenter() {
                var center = scaleTranslateRotate(k, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi)), transform2 = scaleTranslateRotate(k, x - center[0], y - center[1], sx, sy, alpha);
                rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
                projectTransform = compose(project, transform2);
                projectRotateTransform = compose(rotate, projectTransform);
                projectResample = resample(projectTransform, delta2);
                return reset();
              }
              function reset() {
                cache = cacheStream = null;
                return projection2;
              }
              return function() {
                project = projectAt.apply(this, arguments);
                projection2.invert = project.invert && invert;
                return recenter();
              };
            }
            function conicProjection(projectAt) {
              var phi02 = 0, phi12 = pi / 3, m = projectionMutator(projectAt), p = m(phi02, phi12);
              p.parallels = function(_) {
                return arguments.length ? m(phi02 = _[0] * radians, phi12 = _[1] * radians) : [phi02 * degrees, phi12 * degrees];
              };
              return p;
            }
            function cylindricalEqualAreaRaw(phi02) {
              var cosPhi02 = cos(phi02);
              function forward(lambda, phi) {
                return [lambda * cosPhi02, sin(phi) / cosPhi02];
              }
              forward.invert = function(x, y) {
                return [x / cosPhi02, asin(y * cosPhi02)];
              };
              return forward;
            }
            function conicEqualAreaRaw(y02, y12) {
              var sy0 = sin(y02), n = (sy0 + sin(y12)) / 2;
              if (abs(n) < epsilon)
                return cylindricalEqualAreaRaw(y02);
              var c = 1 + sy0 * (2 * n - sy0), r0 = sqrt(c) / n;
              function project(x, y) {
                var r = sqrt(c - 2 * n * sin(y)) / n;
                return [r * sin(x *= n), r0 - r * cos(x)];
              }
              project.invert = function(x, y) {
                var r0y = r0 - y, l = atan2(x, abs(r0y)) * sign(r0y);
                if (r0y * n < 0)
                  l -= pi * sign(x) * sign(r0y);
                return [l / n, asin((c - (x * x + r0y * r0y) * n * n) / (2 * n))];
              };
              return project;
            }
            function conicEqualArea() {
              return conicProjection(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
            }
            function albers() {
              return conicEqualArea().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
            }
            function multiplex(streams) {
              var n = streams.length;
              return {
                point: function(x, y) {
                  var i = -1;
                  while (++i < n)
                    streams[i].point(x, y);
                },
                sphere: function() {
                  var i = -1;
                  while (++i < n)
                    streams[i].sphere();
                },
                lineStart: function() {
                  var i = -1;
                  while (++i < n)
                    streams[i].lineStart();
                },
                lineEnd: function() {
                  var i = -1;
                  while (++i < n)
                    streams[i].lineEnd();
                },
                polygonStart: function() {
                  var i = -1;
                  while (++i < n)
                    streams[i].polygonStart();
                },
                polygonEnd: function() {
                  var i = -1;
                  while (++i < n)
                    streams[i].polygonEnd();
                }
              };
            }
            function albersUsa() {
              var cache, cacheStream, lower48 = albers(), lower48Point, alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, point, pointStream = { point: function(x, y) {
                point = [x, y];
              } };
              function albersUsa2(coordinates2) {
                var x = coordinates2[0], y = coordinates2[1];
                return point = null, (lower48Point.point(x, y), point) || (alaskaPoint.point(x, y), point) || (hawaiiPoint.point(x, y), point);
              }
              albersUsa2.invert = function(coordinates2) {
                var k = lower48.scale(), t = lower48.translate(), x = (coordinates2[0] - t[0]) / k, y = (coordinates2[1] - t[1]) / k;
                return (y >= 0.12 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii : lower48).invert(coordinates2);
              };
              albersUsa2.stream = function(stream) {
                return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
              };
              albersUsa2.precision = function(_) {
                if (!arguments.length)
                  return lower48.precision();
                lower48.precision(_), alaska.precision(_), hawaii.precision(_);
                return reset();
              };
              albersUsa2.scale = function(_) {
                if (!arguments.length)
                  return lower48.scale();
                lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
                return albersUsa2.translate(lower48.translate());
              };
              albersUsa2.translate = function(_) {
                if (!arguments.length)
                  return lower48.translate();
                var k = lower48.scale(), x = +_[0], y = +_[1];
                lower48Point = lower48.translate(_).clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]]).stream(pointStream);
                alaskaPoint = alaska.translate([x - 0.307 * k, y + 0.201 * k]).clipExtent([[x - 0.425 * k + epsilon, y + 0.12 * k + epsilon], [x - 0.214 * k - epsilon, y + 0.234 * k - epsilon]]).stream(pointStream);
                hawaiiPoint = hawaii.translate([x - 0.205 * k, y + 0.212 * k]).clipExtent([[x - 0.214 * k + epsilon, y + 0.166 * k + epsilon], [x - 0.115 * k - epsilon, y + 0.234 * k - epsilon]]).stream(pointStream);
                return reset();
              };
              albersUsa2.fitExtent = function(extent2, object2) {
                return fitExtent(albersUsa2, extent2, object2);
              };
              albersUsa2.fitSize = function(size, object2) {
                return fitSize(albersUsa2, size, object2);
              };
              albersUsa2.fitWidth = function(width, object2) {
                return fitWidth(albersUsa2, width, object2);
              };
              albersUsa2.fitHeight = function(height, object2) {
                return fitHeight(albersUsa2, height, object2);
              };
              function reset() {
                cache = cacheStream = null;
                return albersUsa2;
              }
              return albersUsa2.scale(1070);
            }
            function azimuthalRaw(scale) {
              return function(x, y) {
                var cx = cos(x), cy = cos(y), k = scale(cx * cy);
                if (k === Infinity)
                  return [2, 0];
                return [
                  k * cy * sin(x),
                  k * sin(y)
                ];
              };
            }
            function azimuthalInvert(angle2) {
              return function(x, y) {
                var z = sqrt(x * x + y * y), c = angle2(z), sc = sin(c), cc = cos(c);
                return [
                  atan2(x * sc, z * cc),
                  asin(z && y * sc / z)
                ];
              };
            }
            var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
              return sqrt(2 / (1 + cxcy));
            });
            azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
              return 2 * asin(z / 2);
            });
            function azimuthalEqualArea() {
              return projection(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
            }
            var azimuthalEquidistantRaw = azimuthalRaw(function(c) {
              return (c = acos(c)) && c / sin(c);
            });
            azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
              return z;
            });
            function azimuthalEquidistant() {
              return projection(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
            }
            function mercatorRaw(lambda, phi) {
              return [lambda, log(tan((halfPi + phi) / 2))];
            }
            mercatorRaw.invert = function(x, y) {
              return [x, 2 * atan(exp(y)) - halfPi];
            };
            function mercator() {
              return mercatorProjection(mercatorRaw).scale(961 / tau);
            }
            function mercatorProjection(project) {
              var m = projection(project), center = m.center, scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, x02 = null, y02, x12, y12;
              m.scale = function(_) {
                return arguments.length ? (scale(_), reclip()) : scale();
              };
              m.translate = function(_) {
                return arguments.length ? (translate(_), reclip()) : translate();
              };
              m.center = function(_) {
                return arguments.length ? (center(_), reclip()) : center();
              };
              m.clipExtent = function(_) {
                return arguments.length ? (_ == null ? x02 = y02 = x12 = y12 = null : (x02 = +_[0][0], y02 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reclip()) : x02 == null ? null : [[x02, y02], [x12, y12]];
              };
              function reclip() {
                var k = pi * scale(), t = m(rotation(m.rotate()).invert([0, 0]));
                return clipExtent(x02 == null ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw ? [[Math.max(t[0] - k, x02), y02], [Math.min(t[0] + k, x12), y12]] : [[x02, Math.max(t[1] - k, y02)], [x12, Math.min(t[1] + k, y12)]]);
              }
              return reclip();
            }
            function tany(y) {
              return tan((halfPi + y) / 2);
            }
            function conicConformalRaw(y02, y12) {
              var cy0 = cos(y02), n = y02 === y12 ? sin(y02) : log(cy0 / cos(y12)) / log(tany(y12) / tany(y02)), f = cy0 * pow(tany(y02), n) / n;
              if (!n)
                return mercatorRaw;
              function project(x, y) {
                if (f > 0) {
                  if (y < -halfPi + epsilon)
                    y = -halfPi + epsilon;
                } else {
                  if (y > halfPi - epsilon)
                    y = halfPi - epsilon;
                }
                var r = f / pow(tany(y), n);
                return [r * sin(n * x), f - r * cos(n * x)];
              }
              project.invert = function(x, y) {
                var fy = f - y, r = sign(n) * sqrt(x * x + fy * fy), l = atan2(x, abs(fy)) * sign(fy);
                if (fy * n < 0)
                  l -= pi * sign(x) * sign(fy);
                return [l / n, 2 * atan(pow(f / r, 1 / n)) - halfPi];
              };
              return project;
            }
            function conicConformal() {
              return conicProjection(conicConformalRaw).scale(109.5).parallels([30, 30]);
            }
            function equirectangularRaw(lambda, phi) {
              return [lambda, phi];
            }
            equirectangularRaw.invert = equirectangularRaw;
            function equirectangular() {
              return projection(equirectangularRaw).scale(152.63);
            }
            function conicEquidistantRaw(y02, y12) {
              var cy0 = cos(y02), n = y02 === y12 ? sin(y02) : (cy0 - cos(y12)) / (y12 - y02), g = cy0 / n + y02;
              if (abs(n) < epsilon)
                return equirectangularRaw;
              function project(x, y) {
                var gy = g - y, nx = n * x;
                return [gy * sin(nx), g - gy * cos(nx)];
              }
              project.invert = function(x, y) {
                var gy = g - y, l = atan2(x, abs(gy)) * sign(gy);
                if (gy * n < 0)
                  l -= pi * sign(x) * sign(gy);
                return [l / n, g - sign(n) * sqrt(x * x + gy * gy)];
              };
              return project;
            }
            function conicEquidistant() {
              return conicProjection(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
            }
            var A1 = 1.340264, A2 = -0.081106, A3 = 893e-6, A4 = 3796e-6, M = sqrt(3) / 2, iterations = 12;
            function equalEarthRaw(lambda, phi) {
              var l = asin(M * sin(phi)), l2 = l * l, l6 = l2 * l2 * l2;
              return [
                lambda * cos(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),
                l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))
              ];
            }
            equalEarthRaw.invert = function(x, y) {
              var l = y, l2 = l * l, l6 = l2 * l2 * l2;
              for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
                fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y;
                fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);
                l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;
                if (abs(delta) < epsilon2)
                  break;
              }
              return [
                M * x * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos(l),
                asin(sin(l) / M)
              ];
            };
            function equalEarth() {
              return projection(equalEarthRaw).scale(177.158);
            }
            function gnomonicRaw(x, y) {
              var cy = cos(y), k = cos(x) * cy;
              return [cy * sin(x) / k, sin(y) / k];
            }
            gnomonicRaw.invert = azimuthalInvert(atan);
            function gnomonic() {
              return projection(gnomonicRaw).scale(144.049).clipAngle(60);
            }
            function identity$1() {
              var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, alpha = 0, ca, sa, x02 = null, y02, x12, y12, kx = 1, ky = 1, transform2 = transformer({
                point: function(x, y) {
                  var p = projection2([x, y]);
                  this.stream.point(p[0], p[1]);
                }
              }), postclip = identity, cache, cacheStream;
              function reset() {
                kx = k * sx;
                ky = k * sy;
                cache = cacheStream = null;
                return projection2;
              }
              function projection2(p) {
                var x = p[0] * kx, y = p[1] * ky;
                if (alpha) {
                  var t = y * ca - x * sa;
                  x = x * ca + y * sa;
                  y = t;
                }
                return [x + tx, y + ty];
              }
              projection2.invert = function(p) {
                var x = p[0] - tx, y = p[1] - ty;
                if (alpha) {
                  var t = y * ca + x * sa;
                  x = x * ca - y * sa;
                  y = t;
                }
                return [x / kx, y / ky];
              };
              projection2.stream = function(stream) {
                return cache && cacheStream === stream ? cache : cache = transform2(postclip(cacheStream = stream));
              };
              projection2.postclip = function(_) {
                return arguments.length ? (postclip = _, x02 = y02 = x12 = y12 = null, reset()) : postclip;
              };
              projection2.clipExtent = function(_) {
                return arguments.length ? (postclip = _ == null ? (x02 = y02 = x12 = y12 = null, identity) : clipRectangle(x02 = +_[0][0], y02 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reset()) : x02 == null ? null : [[x02, y02], [x12, y12]];
              };
              projection2.scale = function(_) {
                return arguments.length ? (k = +_, reset()) : k;
              };
              projection2.translate = function(_) {
                return arguments.length ? (tx = +_[0], ty = +_[1], reset()) : [tx, ty];
              };
              projection2.angle = function(_) {
                return arguments.length ? (alpha = _ % 360 * radians, sa = sin(alpha), ca = cos(alpha), reset()) : alpha * degrees;
              };
              projection2.reflectX = function(_) {
                return arguments.length ? (sx = _ ? -1 : 1, reset()) : sx < 0;
              };
              projection2.reflectY = function(_) {
                return arguments.length ? (sy = _ ? -1 : 1, reset()) : sy < 0;
              };
              projection2.fitExtent = function(extent2, object2) {
                return fitExtent(projection2, extent2, object2);
              };
              projection2.fitSize = function(size, object2) {
                return fitSize(projection2, size, object2);
              };
              projection2.fitWidth = function(width, object2) {
                return fitWidth(projection2, width, object2);
              };
              projection2.fitHeight = function(height, object2) {
                return fitHeight(projection2, height, object2);
              };
              return projection2;
            }
            function naturalEarth1Raw(lambda, phi) {
              var phi2 = phi * phi, phi4 = phi2 * phi2;
              return [
                lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (3971e-6 * phi2 - 1529e-6 * phi4))),
                phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 5916e-6 * phi4)))
              ];
            }
            naturalEarth1Raw.invert = function(x, y) {
              var phi = y, i = 25, delta;
              do {
                var phi2 = phi * phi, phi4 = phi2 * phi2;
                phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 5916e-6 * phi4))) - y) / (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 5916e-6 * 11 * phi4)));
              } while (abs(delta) > epsilon && --i > 0);
              return [
                x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (3971e-6 - 1529e-6 * phi2)))),
                phi
              ];
            };
            function naturalEarth1() {
              return projection(naturalEarth1Raw).scale(175.295);
            }
            function orthographicRaw(x, y) {
              return [cos(y) * sin(x), sin(y)];
            }
            orthographicRaw.invert = azimuthalInvert(asin);
            function orthographic() {
              return projection(orthographicRaw).scale(249.5).clipAngle(90 + epsilon);
            }
            function stereographicRaw(x, y) {
              var cy = cos(y), k = 1 + cos(x) * cy;
              return [cy * sin(x) / k, sin(y) / k];
            }
            stereographicRaw.invert = azimuthalInvert(function(z) {
              return 2 * atan(z);
            });
            function stereographic() {
              return projection(stereographicRaw).scale(250).clipAngle(142);
            }
            function transverseMercatorRaw(lambda, phi) {
              return [log(tan((halfPi + phi) / 2)), -lambda];
            }
            transverseMercatorRaw.invert = function(x, y) {
              return [-y, 2 * atan(exp(x)) - halfPi];
            };
            function transverseMercator() {
              var m = mercatorProjection(transverseMercatorRaw), center = m.center, rotate = m.rotate;
              m.center = function(_) {
                return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
              };
              m.rotate = function(_) {
                return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
              };
              return rotate([0, 0, 90]).scale(159.155);
            }
            exports3.geoAlbers = albers;
            exports3.geoAlbersUsa = albersUsa;
            exports3.geoArea = area;
            exports3.geoAzimuthalEqualArea = azimuthalEqualArea;
            exports3.geoAzimuthalEqualAreaRaw = azimuthalEqualAreaRaw;
            exports3.geoAzimuthalEquidistant = azimuthalEquidistant;
            exports3.geoAzimuthalEquidistantRaw = azimuthalEquidistantRaw;
            exports3.geoBounds = bounds;
            exports3.geoCentroid = centroid;
            exports3.geoCircle = circle;
            exports3.geoClipAntimeridian = clipAntimeridian;
            exports3.geoClipCircle = clipCircle;
            exports3.geoClipExtent = extent;
            exports3.geoClipRectangle = clipRectangle;
            exports3.geoConicConformal = conicConformal;
            exports3.geoConicConformalRaw = conicConformalRaw;
            exports3.geoConicEqualArea = conicEqualArea;
            exports3.geoConicEqualAreaRaw = conicEqualAreaRaw;
            exports3.geoConicEquidistant = conicEquidistant;
            exports3.geoConicEquidistantRaw = conicEquidistantRaw;
            exports3.geoContains = contains;
            exports3.geoDistance = distance;
            exports3.geoEqualEarth = equalEarth;
            exports3.geoEqualEarthRaw = equalEarthRaw;
            exports3.geoEquirectangular = equirectangular;
            exports3.geoEquirectangularRaw = equirectangularRaw;
            exports3.geoGnomonic = gnomonic;
            exports3.geoGnomonicRaw = gnomonicRaw;
            exports3.geoGraticule = graticule;
            exports3.geoGraticule10 = graticule10;
            exports3.geoIdentity = identity$1;
            exports3.geoInterpolate = interpolate;
            exports3.geoLength = length;
            exports3.geoMercator = mercator;
            exports3.geoMercatorRaw = mercatorRaw;
            exports3.geoNaturalEarth1 = naturalEarth1;
            exports3.geoNaturalEarth1Raw = naturalEarth1Raw;
            exports3.geoOrthographic = orthographic;
            exports3.geoOrthographicRaw = orthographicRaw;
            exports3.geoPath = index;
            exports3.geoProjection = projection;
            exports3.geoProjectionMutator = projectionMutator;
            exports3.geoRotation = rotation;
            exports3.geoStereographic = stereographic;
            exports3.geoStereographicRaw = stereographicRaw;
            exports3.geoStream = geoStream;
            exports3.geoTransform = transform;
            exports3.geoTransverseMercator = transverseMercator;
            exports3.geoTransverseMercatorRaw = transverseMercatorRaw;
            Object.defineProperty(exports3, "__esModule", { value: true });
          });
        },
        "./node_modules/_d3-hexjson@1.1.1@d3-hexjson/build/d3-hexjson.js": function(module2, exports2, __webpack_require__) {
          (function(global, factory) {
            true ? factory(exports2, __webpack_require__("./node_modules/_d3-array@1.2.4@d3-array/dist/d3-array.js")) : void 0;
          })(this, function(exports3, d3Array) {
            "use strict";
            function renderHexJSON(hexjson, width, height) {
              var layout = hexjson.layout;
              var hexes = [];
              var hexRadius = 0;
              Object.keys(hexjson.hexes).forEach(function(key) {
                hexjson.hexes[key].key = key;
                hexes.push(hexjson.hexes[key]);
              });
              var qmax = d3Array.max(hexes, function(d) {
                return +d.q;
              }), qmin = d3Array.min(hexes, function(d) {
                return +d.q;
              }), rmax = d3Array.max(hexes, function(d) {
                return +d.r;
              }), rmin = d3Array.min(hexes, function(d) {
                return +d.r;
              });
              var qnum = qmax - qmin + 1, rnum = rmax - rmin + 1;
              if (layout === "odd-r" || layout === "even-r") {
                hexRadius = d3Array.min([
                  width / ((qnum + 0.5) * Math.sqrt(3)),
                  height / ((rnum + 1 / 3) * 1.5)
                ]);
              } else {
                hexRadius = d3Array.min([
                  height / ((rnum + 0.5) * Math.sqrt(3)),
                  width / ((qnum + 1 / 3) * 1.5)
                ]);
              }
              var hexWidth = hexRadius * Math.sqrt(3);
              var vertices = getVertices(layout, hexWidth, hexRadius);
              var points = getPoints(vertices);
              hexes.forEach(function(hex) {
                hex.qc = hex.q - qmin;
                hex.rc = rmax - hex.r;
                hex.x = getX(hex, layout, hexWidth, hexRadius);
                hex.y = getY(hex, layout, hexWidth, hexRadius);
                hex.vertices = vertices;
                hex.points = points;
              });
              return hexes;
            }
            function getX(hex, layout, hexWidth, hexRadius) {
              var x = 0, xOffset = 0;
              switch (layout) {
                case "odd-r":
                  xOffset = hex.rc % 2 === 1 ? hexWidth : hexWidth / 2;
                  x = hex.qc * hexWidth + xOffset;
                  break;
                case "even-r":
                  xOffset = hex.rc % 2 === 0 ? hexWidth : hexWidth / 2;
                  x = hex.qc * hexWidth + xOffset;
                  break;
                case "odd-q":
                case "even-q":
                  x = hex.qc * hexRadius * 1.5 + hexRadius;
                  break;
              }
              return x;
            }
            function getY(hex, layout, hexWidth, hexRadius) {
              var y = 0, yOffset = 0;
              switch (layout) {
                case "odd-r":
                case "even-r":
                  y = hex.rc * hexRadius * 1.5 + hexRadius;
                  break;
                case "odd-q":
                  yOffset = hex.qc % 2 === 1 ? hexWidth : hexWidth / 2;
                  y = hex.rc * hexWidth + yOffset;
                  break;
                case "even-q":
                  yOffset = hex.qc % 2 === 0 ? hexWidth : hexWidth / 2;
                  y = hex.rc * hexWidth + yOffset;
                  break;
              }
              return y;
            }
            function getVertices(layout, hexWidth, hexRadius) {
              var vertices = [];
              switch (layout) {
                case "odd-r":
                case "even-r":
                  vertices.push({ x: 0, y: 0 - hexRadius });
                  vertices.push({ x: 0 + hexWidth * 0.5, y: 0 - 0.5 * hexRadius });
                  vertices.push({ x: 0 + hexWidth * 0.5, y: 0 + 0.5 * hexRadius });
                  vertices.push({ x: 0, y: 0 + hexRadius });
                  vertices.push({ x: 0 - hexWidth * 0.5, y: 0 + 0.5 * hexRadius });
                  vertices.push({ x: 0 - hexWidth * 0.5, y: 0 - 0.5 * hexRadius });
                  break;
                case "odd-q":
                case "even-q":
                  vertices.push({ x: 0 - hexRadius, y: 0 });
                  vertices.push({ x: 0 - 0.5 * hexRadius, y: 0 - hexWidth * 0.5 });
                  vertices.push({ x: 0 + 0.5 * hexRadius, y: 0 - hexWidth * 0.5 });
                  vertices.push({ x: 0 + hexRadius, y: 0 });
                  vertices.push({ x: 0 + 0.5 * hexRadius, y: 0 + hexWidth * 0.5 });
                  vertices.push({ x: 0 - 0.5 * hexRadius, y: 0 + hexWidth * 0.5 });
                  break;
              }
              return vertices;
            }
            function getPoints(vertices) {
              var points = "";
              vertices.forEach(function(v) {
                points += v.x + "," + v.y + " ";
              });
              return points.substring(0, points.length - 1);
            }
            function getGridForHexJSON(hexjson) {
              var grid = {};
              grid.layout = hexjson.layout;
              grid.hexes = {};
              var hexes = [];
              Object.keys(hexjson.hexes).forEach(function(key) {
                hexes.push(hexjson.hexes[key]);
              });
              var qmax = d3Array.max(hexes, function(d) {
                return +d.q;
              }), qmin = d3Array.min(hexes, function(d) {
                return +d.q;
              }), rmax = d3Array.max(hexes, function(d) {
                return +d.r;
              }), rmin = d3Array.min(hexes, function(d) {
                return +d.r;
              });
              var i, j, fkey;
              for (i = qmin; i <= qmax; i++) {
                for (j = rmin; j <= rmax; j++) {
                  fkey = "Q" + i + "R" + j;
                  grid.hexes[fkey] = { q: i, r: j };
                }
              }
              return grid;
            }
            function getBoundaryDotsForHexJSON(hexjson, width, height, field) {
              var hexes = [];
              var layout = hexjson.layout;
              Object.keys(hexjson.hexes).forEach(function(key) {
                hexes.push(hexjson.hexes[key]);
              });
              var qmax = d3Array.max(hexes, function(d) {
                return +d.q;
              }), qmin = d3Array.min(hexes, function(d) {
                return +d.q;
              }), rmax = d3Array.max(hexes, function(d) {
                return +d.r;
              }), rmin = d3Array.min(hexes, function(d) {
                return +d.r;
              });
              var qnum = qmax - qmin + 1, rnum = rmax - rmin + 1;
              var hexRadius;
              if (layout === "odd-r" || layout === "even-r") {
                hexRadius = d3Array.min([
                  width / ((qnum + 0.5) * Math.sqrt(3)),
                  height / ((rnum + 1 / 3) * 1.5)
                ]);
              } else {
                hexRadius = d3Array.min([
                  height / ((rnum + 0.5) * Math.sqrt(3)),
                  width / ((qnum + 1 / 3) * 1.5)
                ]);
              }
              var hexWidth = hexRadius * Math.sqrt(3);
              var lines = [];
              var hexRadiusSquared = hexRadius * hexRadius * 4;
              var maxHex = hexes.length;
              if (maxHex > 1) {
                hexes.forEach(function(hex2) {
                  hex2.qc = hex2.q - qmin;
                  hex2.rc = rmax - hex2.r;
                  hex2.x = getX(hex2, layout, hexWidth, hexRadius);
                  hex2.y = getY(hex2, layout, hexWidth, hexRadius);
                });
                for (var i = 0; i < maxHex - 1; i++) {
                  for (var j = i + 1; j < maxHex; j++) {
                    var hex = hexes[i];
                    var otherHex = hexes[j];
                    if (hex[field] !== otherHex[field]) {
                      if (Math.abs(hex.q - otherHex.q) <= 1 && Math.abs(hex.r - otherHex.r) <= 1) {
                        if ((hex.x - otherHex.x) * (hex.x - otherHex.x) + (hex.y - otherHex.y) * (hex.y - otherHex.y) < hexRadiusSquared) {
                          var midpoint = {};
                          midpoint.x = otherHex.x + (hex.x - otherHex.x) / 2;
                          midpoint.y = otherHex.y + (hex.y - otherHex.y) / 2;
                          var perp = {};
                          var denom = Math.sqrt(3) * 4;
                          perp.dx = (hex.y - otherHex.y) / denom;
                          perp.dy = -(hex.x - otherHex.x) / denom;
                          lines.push({ x: midpoint.x - 2 * perp.dx, y: midpoint.y - 2 * perp.dy });
                          lines.push({ x: midpoint.x - perp.dx, y: midpoint.y - perp.dy });
                          lines.push({ x: midpoint.x, y: midpoint.y });
                          lines.push({ x: midpoint.x + perp.dx, y: midpoint.y + perp.dy });
                          lines.push({ x: midpoint.x + 2 * perp.dx, y: midpoint.y + 2 * perp.dy });
                        }
                      }
                    }
                  }
                }
              }
              return lines;
            }
            function getBoundarySegmentsForHexJSON(hexjson, width, height, field) {
              var hexes = [];
              var layout = hexjson.layout;
              Object.keys(hexjson.hexes).forEach(function(key) {
                hexes.push(hexjson.hexes[key]);
              });
              var qmax = d3Array.max(hexes, function(d) {
                return +d.q;
              }), qmin = d3Array.min(hexes, function(d) {
                return +d.q;
              }), rmax = d3Array.max(hexes, function(d) {
                return +d.r;
              }), rmin = d3Array.min(hexes, function(d) {
                return +d.r;
              });
              var qnum = qmax - qmin + 1, rnum = rmax - rmin + 1;
              var hexRadius;
              if (layout === "odd-r" || layout === "even-r") {
                hexRadius = d3Array.min([
                  width / ((qnum + 0.5) * Math.sqrt(3)),
                  height / ((rnum + 1 / 3) * 1.5)
                ]);
              } else {
                hexRadius = d3Array.min([
                  height / ((rnum + 0.5) * Math.sqrt(3)),
                  width / ((qnum + 1 / 3) * 1.5)
                ]);
              }
              var hexWidth = hexRadius * Math.sqrt(3);
              var segments = [];
              var hexRadiusSquared = hexRadius * hexRadius * 4;
              var maxHex = hexes.length;
              if (maxHex > 1) {
                hexes.forEach(function(hex2) {
                  hex2.qc = hex2.q - qmin;
                  hex2.rc = rmax - hex2.r;
                  hex2.x = getX(hex2, layout, hexWidth, hexRadius);
                  hex2.y = getY(hex2, layout, hexWidth, hexRadius);
                });
                for (var i = 0; i < maxHex - 1; i++) {
                  for (var j = i + 1; j < maxHex; j++) {
                    var hex = hexes[i];
                    var otherHex = hexes[j];
                    if (hex[field] !== otherHex[field]) {
                      if (Math.abs(hex.q - otherHex.q) <= 1 && Math.abs(hex.r - otherHex.r) <= 1) {
                        if ((hex.x - otherHex.x) * (hex.x - otherHex.x) + (hex.y - otherHex.y) * (hex.y - otherHex.y) < hexRadiusSquared) {
                          var midpoint = {};
                          midpoint.x = otherHex.x + (hex.x - otherHex.x) / 2;
                          midpoint.y = otherHex.y + (hex.y - otherHex.y) / 2;
                          var perp = {};
                          var direction = 1;
                          if (hex[field] < otherHex[field]) {
                            direction = -1;
                          }
                          var denom = Math.sqrt(3) * 2 * direction;
                          perp.dx = (hex.y - otherHex.y) / denom;
                          perp.dy = -(hex.x - otherHex.x) / denom;
                          segments.push({
                            x1: midpoint.x - perp.dx,
                            y1: midpoint.y - perp.dy,
                            x2: midpoint.x + perp.dx,
                            y2: midpoint.y + perp.dy
                          });
                        }
                      }
                    }
                  }
                }
              }
              return segments;
            }
            exports3.renderHexJSON = renderHexJSON;
            exports3.getGridForHexJSON = getGridForHexJSON;
            exports3.getBoundaryDotsForHexJSON = getBoundaryDotsForHexJSON;
            exports3.getBoundarySegmentsForHexJSON = getBoundarySegmentsForHexJSON;
            Object.defineProperty(exports3, "__esModule", { value: true });
          });
        },
        "./node_modules/_d3-hierarchy@1.1.9@d3-hierarchy/dist/d3-hierarchy.js": function(module2, exports2, __webpack_require__) {
          (function(global, factory) {
            true ? factory(exports2) : void 0;
          })(this, function(exports3) {
            "use strict";
            function defaultSeparation(a, b) {
              return a.parent === b.parent ? 1 : 2;
            }
            function meanX(children) {
              return children.reduce(meanXReduce, 0) / children.length;
            }
            function meanXReduce(x, c) {
              return x + c.x;
            }
            function maxY(children) {
              return 1 + children.reduce(maxYReduce, 0);
            }
            function maxYReduce(y, c) {
              return Math.max(y, c.y);
            }
            function leafLeft(node) {
              var children;
              while (children = node.children)
                node = children[0];
              return node;
            }
            function leafRight(node) {
              var children;
              while (children = node.children)
                node = children[children.length - 1];
              return node;
            }
            function cluster() {
              var separation = defaultSeparation, dx = 1, dy = 1, nodeSize = false;
              function cluster2(root) {
                var previousNode, x = 0;
                root.eachAfter(function(node) {
                  var children = node.children;
                  if (children) {
                    node.x = meanX(children);
                    node.y = maxY(children);
                  } else {
                    node.x = previousNode ? x += separation(node, previousNode) : 0;
                    node.y = 0;
                    previousNode = node;
                  }
                });
                var left = leafLeft(root), right = leafRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
                return root.eachAfter(nodeSize ? function(node) {
                  node.x = (node.x - root.x) * dx;
                  node.y = (root.y - node.y) * dy;
                } : function(node) {
                  node.x = (node.x - x0) / (x1 - x0) * dx;
                  node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;
                });
              }
              cluster2.separation = function(x) {
                return arguments.length ? (separation = x, cluster2) : separation;
              };
              cluster2.size = function(x) {
                return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster2) : nodeSize ? null : [dx, dy];
              };
              cluster2.nodeSize = function(x) {
                return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster2) : nodeSize ? [dx, dy] : null;
              };
              return cluster2;
            }
            function count(node) {
              var sum = 0, children = node.children, i = children && children.length;
              if (!i)
                sum = 1;
              else
                while (--i >= 0)
                  sum += children[i].value;
              node.value = sum;
            }
            function node_count() {
              return this.eachAfter(count);
            }
            function node_each(callback) {
              var node = this, current, next = [node], children, i, n;
              do {
                current = next.reverse(), next = [];
                while (node = current.pop()) {
                  callback(node), children = node.children;
                  if (children)
                    for (i = 0, n = children.length; i < n; ++i) {
                      next.push(children[i]);
                    }
                }
              } while (next.length);
              return this;
            }
            function node_eachBefore(callback) {
              var node = this, nodes = [node], children, i;
              while (node = nodes.pop()) {
                callback(node), children = node.children;
                if (children)
                  for (i = children.length - 1; i >= 0; --i) {
                    nodes.push(children[i]);
                  }
              }
              return this;
            }
            function node_eachAfter(callback) {
              var node = this, nodes = [node], next = [], children, i, n;
              while (node = nodes.pop()) {
                next.push(node), children = node.children;
                if (children)
                  for (i = 0, n = children.length; i < n; ++i) {
                    nodes.push(children[i]);
                  }
              }
              while (node = next.pop()) {
                callback(node);
              }
              return this;
            }
            function node_sum(value) {
              return this.eachAfter(function(node) {
                var sum = +value(node.data) || 0, children = node.children, i = children && children.length;
                while (--i >= 0)
                  sum += children[i].value;
                node.value = sum;
              });
            }
            function node_sort(compare) {
              return this.eachBefore(function(node) {
                if (node.children) {
                  node.children.sort(compare);
                }
              });
            }
            function node_path(end) {
              var start = this, ancestor = leastCommonAncestor(start, end), nodes = [start];
              while (start !== ancestor) {
                start = start.parent;
                nodes.push(start);
              }
              var k = nodes.length;
              while (end !== ancestor) {
                nodes.splice(k, 0, end);
                end = end.parent;
              }
              return nodes;
            }
            function leastCommonAncestor(a, b) {
              if (a === b)
                return a;
              var aNodes = a.ancestors(), bNodes = b.ancestors(), c = null;
              a = aNodes.pop();
              b = bNodes.pop();
              while (a === b) {
                c = a;
                a = aNodes.pop();
                b = bNodes.pop();
              }
              return c;
            }
            function node_ancestors() {
              var node = this, nodes = [node];
              while (node = node.parent) {
                nodes.push(node);
              }
              return nodes;
            }
            function node_descendants() {
              var nodes = [];
              this.each(function(node) {
                nodes.push(node);
              });
              return nodes;
            }
            function node_leaves() {
              var leaves = [];
              this.eachBefore(function(node) {
                if (!node.children) {
                  leaves.push(node);
                }
              });
              return leaves;
            }
            function node_links() {
              var root = this, links = [];
              root.each(function(node) {
                if (node !== root) {
                  links.push({ source: node.parent, target: node });
                }
              });
              return links;
            }
            function hierarchy(data, children) {
              var root = new Node(data), valued = +data.value && (root.value = data.value), node, nodes = [root], child, childs, i, n;
              if (children == null)
                children = defaultChildren;
              while (node = nodes.pop()) {
                if (valued)
                  node.value = +node.data.value;
                if ((childs = children(node.data)) && (n = childs.length)) {
                  node.children = new Array(n);
                  for (i = n - 1; i >= 0; --i) {
                    nodes.push(child = node.children[i] = new Node(childs[i]));
                    child.parent = node;
                    child.depth = node.depth + 1;
                  }
                }
              }
              return root.eachBefore(computeHeight);
            }
            function node_copy() {
              return hierarchy(this).eachBefore(copyData);
            }
            function defaultChildren(d) {
              return d.children;
            }
            function copyData(node) {
              node.data = node.data.data;
            }
            function computeHeight(node) {
              var height = 0;
              do
                node.height = height;
              while ((node = node.parent) && node.height < ++height);
            }
            function Node(data) {
              this.data = data;
              this.depth = this.height = 0;
              this.parent = null;
            }
            Node.prototype = hierarchy.prototype = {
              constructor: Node,
              count: node_count,
              each: node_each,
              eachAfter: node_eachAfter,
              eachBefore: node_eachBefore,
              sum: node_sum,
              sort: node_sort,
              path: node_path,
              ancestors: node_ancestors,
              descendants: node_descendants,
              leaves: node_leaves,
              links: node_links,
              copy: node_copy
            };
            var slice = Array.prototype.slice;
            function shuffle(array) {
              var m = array.length, t, i;
              while (m) {
                i = Math.random() * m-- | 0;
                t = array[m];
                array[m] = array[i];
                array[i] = t;
              }
              return array;
            }
            function enclose(circles) {
              var i = 0, n = (circles = shuffle(slice.call(circles))).length, B = [], p, e;
              while (i < n) {
                p = circles[i];
                if (e && enclosesWeak(e, p))
                  ++i;
                else
                  e = encloseBasis(B = extendBasis(B, p)), i = 0;
              }
              return e;
            }
            function extendBasis(B, p) {
              var i, j;
              if (enclosesWeakAll(p, B))
                return [p];
              for (i = 0; i < B.length; ++i) {
                if (enclosesNot(p, B[i]) && enclosesWeakAll(encloseBasis2(B[i], p), B)) {
                  return [B[i], p];
                }
              }
              for (i = 0; i < B.length - 1; ++i) {
                for (j = i + 1; j < B.length; ++j) {
                  if (enclosesNot(encloseBasis2(B[i], B[j]), p) && enclosesNot(encloseBasis2(B[i], p), B[j]) && enclosesNot(encloseBasis2(B[j], p), B[i]) && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {
                    return [B[i], B[j], p];
                  }
                }
              }
              throw new Error();
            }
            function enclosesNot(a, b) {
              var dr = a.r - b.r, dx = b.x - a.x, dy = b.y - a.y;
              return dr < 0 || dr * dr < dx * dx + dy * dy;
            }
            function enclosesWeak(a, b) {
              var dr = a.r - b.r + 1e-6, dx = b.x - a.x, dy = b.y - a.y;
              return dr > 0 && dr * dr > dx * dx + dy * dy;
            }
            function enclosesWeakAll(a, B) {
              for (var i = 0; i < B.length; ++i) {
                if (!enclosesWeak(a, B[i])) {
                  return false;
                }
              }
              return true;
            }
            function encloseBasis(B) {
              switch (B.length) {
                case 1:
                  return encloseBasis1(B[0]);
                case 2:
                  return encloseBasis2(B[0], B[1]);
                case 3:
                  return encloseBasis3(B[0], B[1], B[2]);
              }
            }
            function encloseBasis1(a) {
              return {
                x: a.x,
                y: a.y,
                r: a.r
              };
            }
            function encloseBasis2(a, b) {
              var x1 = a.x, y1 = a.y, r1 = a.r, x2 = b.x, y2 = b.y, r2 = b.r, x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1, l = Math.sqrt(x21 * x21 + y21 * y21);
              return {
                x: (x1 + x2 + x21 / l * r21) / 2,
                y: (y1 + y2 + y21 / l * r21) / 2,
                r: (l + r1 + r2) / 2
              };
            }
            function encloseBasis3(a, b, c) {
              var x1 = a.x, y1 = a.y, r1 = a.r, x2 = b.x, y2 = b.y, r2 = b.r, x3 = c.x, y3 = c.y, r3 = c.r, a2 = x1 - x2, a3 = x1 - x3, b2 = y1 - y2, b3 = y1 - y3, c2 = r2 - r1, c3 = r3 - r1, d1 = x1 * x1 + y1 * y1 - r1 * r1, d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2, d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3, ab = a3 * b2 - a2 * b3, xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1, xb = (b3 * c2 - b2 * c3) / ab, ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1, yb = (a2 * c3 - a3 * c2) / ab, A = xb * xb + yb * yb - 1, B = 2 * (r1 + xa * xb + ya * yb), C = xa * xa + ya * ya - r1 * r1, r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
              return {
                x: x1 + xa + xb * r,
                y: y1 + ya + yb * r,
                r
              };
            }
            function place(b, a, c) {
              var dx = b.x - a.x, x, a2, dy = b.y - a.y, y, b2, d2 = dx * dx + dy * dy;
              if (d2) {
                a2 = a.r + c.r, a2 *= a2;
                b2 = b.r + c.r, b2 *= b2;
                if (a2 > b2) {
                  x = (d2 + b2 - a2) / (2 * d2);
                  y = Math.sqrt(Math.max(0, b2 / d2 - x * x));
                  c.x = b.x - x * dx - y * dy;
                  c.y = b.y - x * dy + y * dx;
                } else {
                  x = (d2 + a2 - b2) / (2 * d2);
                  y = Math.sqrt(Math.max(0, a2 / d2 - x * x));
                  c.x = a.x + x * dx - y * dy;
                  c.y = a.y + x * dy + y * dx;
                }
              } else {
                c.x = a.x + c.r;
                c.y = a.y;
              }
            }
            function intersects(a, b) {
              var dr = a.r + b.r - 1e-6, dx = b.x - a.x, dy = b.y - a.y;
              return dr > 0 && dr * dr > dx * dx + dy * dy;
            }
            function score(node) {
              var a = node._, b = node.next._, ab = a.r + b.r, dx = (a.x * b.r + b.x * a.r) / ab, dy = (a.y * b.r + b.y * a.r) / ab;
              return dx * dx + dy * dy;
            }
            function Node$1(circle) {
              this._ = circle;
              this.next = null;
              this.previous = null;
            }
            function packEnclose(circles) {
              if (!(n = circles.length))
                return 0;
              var a, b, c, n, aa, ca, i, j, k, sj, sk;
              a = circles[0], a.x = 0, a.y = 0;
              if (!(n > 1))
                return a.r;
              b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
              if (!(n > 2))
                return a.r + b.r;
              place(b, a, c = circles[2]);
              a = new Node$1(a), b = new Node$1(b), c = new Node$1(c);
              a.next = c.previous = b;
              b.next = a.previous = c;
              c.next = b.previous = a;
              pack:
                for (i = 3; i < n; ++i) {
                  place(a._, b._, c = circles[i]), c = new Node$1(c);
                  j = b.next, k = a.previous, sj = b._.r, sk = a._.r;
                  do {
                    if (sj <= sk) {
                      if (intersects(j._, c._)) {
                        b = j, a.next = b, b.previous = a, --i;
                        continue pack;
                      }
                      sj += j._.r, j = j.next;
                    } else {
                      if (intersects(k._, c._)) {
                        a = k, a.next = b, b.previous = a, --i;
                        continue pack;
                      }
                      sk += k._.r, k = k.previous;
                    }
                  } while (j !== k.next);
                  c.previous = a, c.next = b, a.next = b.previous = b = c;
                  aa = score(a);
                  while ((c = c.next) !== b) {
                    if ((ca = score(c)) < aa) {
                      a = c, aa = ca;
                    }
                  }
                  b = a.next;
                }
              a = [b._], c = b;
              while ((c = c.next) !== b)
                a.push(c._);
              c = enclose(a);
              for (i = 0; i < n; ++i)
                a = circles[i], a.x -= c.x, a.y -= c.y;
              return c.r;
            }
            function siblings(circles) {
              packEnclose(circles);
              return circles;
            }
            function optional(f) {
              return f == null ? null : required(f);
            }
            function required(f) {
              if (typeof f !== "function")
                throw new Error();
              return f;
            }
            function constantZero() {
              return 0;
            }
            function constant(x) {
              return function() {
                return x;
              };
            }
            function defaultRadius(d) {
              return Math.sqrt(d.value);
            }
            function index() {
              var radius = null, dx = 1, dy = 1, padding = constantZero;
              function pack(root) {
                root.x = dx / 2, root.y = dy / 2;
                if (radius) {
                  root.eachBefore(radiusLeaf(radius)).eachAfter(packChildren(padding, 0.5)).eachBefore(translateChild(1));
                } else {
                  root.eachBefore(radiusLeaf(defaultRadius)).eachAfter(packChildren(constantZero, 1)).eachAfter(packChildren(padding, root.r / Math.min(dx, dy))).eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
                }
                return root;
              }
              pack.radius = function(x) {
                return arguments.length ? (radius = optional(x), pack) : radius;
              };
              pack.size = function(x) {
                return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];
              };
              pack.padding = function(x) {
                return arguments.length ? (padding = typeof x === "function" ? x : constant(+x), pack) : padding;
              };
              return pack;
            }
            function radiusLeaf(radius) {
              return function(node) {
                if (!node.children) {
                  node.r = Math.max(0, +radius(node) || 0);
                }
              };
            }
            function packChildren(padding, k) {
              return function(node) {
                if (children = node.children) {
                  var children, i, n = children.length, r = padding(node) * k || 0, e;
                  if (r)
                    for (i = 0; i < n; ++i)
                      children[i].r += r;
                  e = packEnclose(children);
                  if (r)
                    for (i = 0; i < n; ++i)
                      children[i].r -= r;
                  node.r = e + r;
                }
              };
            }
            function translateChild(k) {
              return function(node) {
                var parent = node.parent;
                node.r *= k;
                if (parent) {
                  node.x = parent.x + k * node.x;
                  node.y = parent.y + k * node.y;
                }
              };
            }
            function roundNode(node) {
              node.x0 = Math.round(node.x0);
              node.y0 = Math.round(node.y0);
              node.x1 = Math.round(node.x1);
              node.y1 = Math.round(node.y1);
            }
            function treemapDice(parent, x0, y0, x1, y1) {
              var nodes = parent.children, node, i = -1, n = nodes.length, k = parent.value && (x1 - x0) / parent.value;
              while (++i < n) {
                node = nodes[i], node.y0 = y0, node.y1 = y1;
                node.x0 = x0, node.x1 = x0 += node.value * k;
              }
            }
            function partition() {
              var dx = 1, dy = 1, padding = 0, round = false;
              function partition2(root) {
                var n = root.height + 1;
                root.x0 = root.y0 = padding;
                root.x1 = dx;
                root.y1 = dy / n;
                root.eachBefore(positionNode(dy, n));
                if (round)
                  root.eachBefore(roundNode);
                return root;
              }
              function positionNode(dy2, n) {
                return function(node) {
                  if (node.children) {
                    treemapDice(node, node.x0, dy2 * (node.depth + 1) / n, node.x1, dy2 * (node.depth + 2) / n);
                  }
                  var x0 = node.x0, y0 = node.y0, x1 = node.x1 - padding, y1 = node.y1 - padding;
                  if (x1 < x0)
                    x0 = x1 = (x0 + x1) / 2;
                  if (y1 < y0)
                    y0 = y1 = (y0 + y1) / 2;
                  node.x0 = x0;
                  node.y0 = y0;
                  node.x1 = x1;
                  node.y1 = y1;
                };
              }
              partition2.round = function(x) {
                return arguments.length ? (round = !!x, partition2) : round;
              };
              partition2.size = function(x) {
                return arguments.length ? (dx = +x[0], dy = +x[1], partition2) : [dx, dy];
              };
              partition2.padding = function(x) {
                return arguments.length ? (padding = +x, partition2) : padding;
              };
              return partition2;
            }
            var keyPrefix = "$", preroot = { depth: -1 }, ambiguous = {};
            function defaultId(d) {
              return d.id;
            }
            function defaultParentId(d) {
              return d.parentId;
            }
            function stratify() {
              var id = defaultId, parentId = defaultParentId;
              function stratify2(data) {
                var d, i, n = data.length, root, parent, node, nodes = new Array(n), nodeId, nodeKey, nodeByKey = {};
                for (i = 0; i < n; ++i) {
                  d = data[i], node = nodes[i] = new Node(d);
                  if ((nodeId = id(d, i, data)) != null && (nodeId += "")) {
                    nodeKey = keyPrefix + (node.id = nodeId);
                    nodeByKey[nodeKey] = nodeKey in nodeByKey ? ambiguous : node;
                  }
                }
                for (i = 0; i < n; ++i) {
                  node = nodes[i], nodeId = parentId(data[i], i, data);
                  if (nodeId == null || !(nodeId += "")) {
                    if (root)
                      throw new Error("multiple roots");
                    root = node;
                  } else {
                    parent = nodeByKey[keyPrefix + nodeId];
                    if (!parent)
                      throw new Error("missing: " + nodeId);
                    if (parent === ambiguous)
                      throw new Error("ambiguous: " + nodeId);
                    if (parent.children)
                      parent.children.push(node);
                    else
                      parent.children = [node];
                    node.parent = parent;
                  }
                }
                if (!root)
                  throw new Error("no root");
                root.parent = preroot;
                root.eachBefore(function(node2) {
                  node2.depth = node2.parent.depth + 1;
                  --n;
                }).eachBefore(computeHeight);
                root.parent = null;
                if (n > 0)
                  throw new Error("cycle");
                return root;
              }
              stratify2.id = function(x) {
                return arguments.length ? (id = required(x), stratify2) : id;
              };
              stratify2.parentId = function(x) {
                return arguments.length ? (parentId = required(x), stratify2) : parentId;
              };
              return stratify2;
            }
            function defaultSeparation$1(a, b) {
              return a.parent === b.parent ? 1 : 2;
            }
            function nextLeft(v) {
              var children = v.children;
              return children ? children[0] : v.t;
            }
            function nextRight(v) {
              var children = v.children;
              return children ? children[children.length - 1] : v.t;
            }
            function moveSubtree(wm, wp, shift) {
              var change = shift / (wp.i - wm.i);
              wp.c -= change;
              wp.s += shift;
              wm.c += change;
              wp.z += shift;
              wp.m += shift;
            }
            function executeShifts(v) {
              var shift = 0, change = 0, children = v.children, i = children.length, w;
              while (--i >= 0) {
                w = children[i];
                w.z += shift;
                w.m += shift;
                shift += w.s + (change += w.c);
              }
            }
            function nextAncestor(vim, v, ancestor) {
              return vim.a.parent === v.parent ? vim.a : ancestor;
            }
            function TreeNode(node, i) {
              this._ = node;
              this.parent = null;
              this.children = null;
              this.A = null;
              this.a = this;
              this.z = 0;
              this.m = 0;
              this.c = 0;
              this.s = 0;
              this.t = null;
              this.i = i;
            }
            TreeNode.prototype = Object.create(Node.prototype);
            function treeRoot(root) {
              var tree2 = new TreeNode(root, 0), node, nodes = [tree2], child, children, i, n;
              while (node = nodes.pop()) {
                if (children = node._.children) {
                  node.children = new Array(n = children.length);
                  for (i = n - 1; i >= 0; --i) {
                    nodes.push(child = node.children[i] = new TreeNode(children[i], i));
                    child.parent = node;
                  }
                }
              }
              (tree2.parent = new TreeNode(null, 0)).children = [tree2];
              return tree2;
            }
            function tree() {
              var separation = defaultSeparation$1, dx = 1, dy = 1, nodeSize = null;
              function tree2(root) {
                var t = treeRoot(root);
                t.eachAfter(firstWalk), t.parent.m = -t.z;
                t.eachBefore(secondWalk);
                if (nodeSize)
                  root.eachBefore(sizeNode);
                else {
                  var left = root, right = root, bottom = root;
                  root.eachBefore(function(node) {
                    if (node.x < left.x)
                      left = node;
                    if (node.x > right.x)
                      right = node;
                    if (node.depth > bottom.depth)
                      bottom = node;
                  });
                  var s = left === right ? 1 : separation(left, right) / 2, tx = s - left.x, kx = dx / (right.x + s + tx), ky = dy / (bottom.depth || 1);
                  root.eachBefore(function(node) {
                    node.x = (node.x + tx) * kx;
                    node.y = node.depth * ky;
                  });
                }
                return root;
              }
              function firstWalk(v) {
                var children = v.children, siblings2 = v.parent.children, w = v.i ? siblings2[v.i - 1] : null;
                if (children) {
                  executeShifts(v);
                  var midpoint = (children[0].z + children[children.length - 1].z) / 2;
                  if (w) {
                    v.z = w.z + separation(v._, w._);
                    v.m = v.z - midpoint;
                  } else {
                    v.z = midpoint;
                  }
                } else if (w) {
                  v.z = w.z + separation(v._, w._);
                }
                v.parent.A = apportion(v, w, v.parent.A || siblings2[0]);
              }
              function secondWalk(v) {
                v._.x = v.z + v.parent.m;
                v.m += v.parent.m;
              }
              function apportion(v, w, ancestor) {
                if (w) {
                  var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
                  while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
                    vom = nextLeft(vom);
                    vop = nextRight(vop);
                    vop.a = v;
                    shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
                    if (shift > 0) {
                      moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
                      sip += shift;
                      sop += shift;
                    }
                    sim += vim.m;
                    sip += vip.m;
                    som += vom.m;
                    sop += vop.m;
                  }
                  if (vim && !nextRight(vop)) {
                    vop.t = vim;
                    vop.m += sim - sop;
                  }
                  if (vip && !nextLeft(vom)) {
                    vom.t = vip;
                    vom.m += sip - som;
                    ancestor = v;
                  }
                }
                return ancestor;
              }
              function sizeNode(node) {
                node.x *= dx;
                node.y = node.depth * dy;
              }
              tree2.separation = function(x) {
                return arguments.length ? (separation = x, tree2) : separation;
              };
              tree2.size = function(x) {
                return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree2) : nodeSize ? null : [dx, dy];
              };
              tree2.nodeSize = function(x) {
                return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree2) : nodeSize ? [dx, dy] : null;
              };
              return tree2;
            }
            function treemapSlice(parent, x0, y0, x1, y1) {
              var nodes = parent.children, node, i = -1, n = nodes.length, k = parent.value && (y1 - y0) / parent.value;
              while (++i < n) {
                node = nodes[i], node.x0 = x0, node.x1 = x1;
                node.y0 = y0, node.y1 = y0 += node.value * k;
              }
            }
            var phi = (1 + Math.sqrt(5)) / 2;
            function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
              var rows = [], nodes = parent.children, row, nodeValue, i0 = 0, i1 = 0, n = nodes.length, dx, dy, value = parent.value, sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta;
              while (i0 < n) {
                dx = x1 - x0, dy = y1 - y0;
                do
                  sumValue = nodes[i1++].value;
                while (!sumValue && i1 < n);
                minValue = maxValue = sumValue;
                alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
                beta = sumValue * sumValue * alpha;
                minRatio = Math.max(maxValue / beta, beta / minValue);
                for (; i1 < n; ++i1) {
                  sumValue += nodeValue = nodes[i1].value;
                  if (nodeValue < minValue)
                    minValue = nodeValue;
                  if (nodeValue > maxValue)
                    maxValue = nodeValue;
                  beta = sumValue * sumValue * alpha;
                  newRatio = Math.max(maxValue / beta, beta / minValue);
                  if (newRatio > minRatio) {
                    sumValue -= nodeValue;
                    break;
                  }
                  minRatio = newRatio;
                }
                rows.push(row = { value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1) });
                if (row.dice)
                  treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);
                else
                  treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
                value -= sumValue, i0 = i1;
              }
              return rows;
            }
            var squarify = function custom(ratio) {
              function squarify2(parent, x0, y0, x1, y1) {
                squarifyRatio(ratio, parent, x0, y0, x1, y1);
              }
              squarify2.ratio = function(x) {
                return custom((x = +x) > 1 ? x : 1);
              };
              return squarify2;
            }(phi);
            function index$1() {
              var tile = squarify, round = false, dx = 1, dy = 1, paddingStack = [0], paddingInner = constantZero, paddingTop = constantZero, paddingRight = constantZero, paddingBottom = constantZero, paddingLeft = constantZero;
              function treemap(root) {
                root.x0 = root.y0 = 0;
                root.x1 = dx;
                root.y1 = dy;
                root.eachBefore(positionNode);
                paddingStack = [0];
                if (round)
                  root.eachBefore(roundNode);
                return root;
              }
              function positionNode(node) {
                var p = paddingStack[node.depth], x0 = node.x0 + p, y0 = node.y0 + p, x1 = node.x1 - p, y1 = node.y1 - p;
                if (x1 < x0)
                  x0 = x1 = (x0 + x1) / 2;
                if (y1 < y0)
                  y0 = y1 = (y0 + y1) / 2;
                node.x0 = x0;
                node.y0 = y0;
                node.x1 = x1;
                node.y1 = y1;
                if (node.children) {
                  p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
                  x0 += paddingLeft(node) - p;
                  y0 += paddingTop(node) - p;
                  x1 -= paddingRight(node) - p;
                  y1 -= paddingBottom(node) - p;
                  if (x1 < x0)
                    x0 = x1 = (x0 + x1) / 2;
                  if (y1 < y0)
                    y0 = y1 = (y0 + y1) / 2;
                  tile(node, x0, y0, x1, y1);
                }
              }
              treemap.round = function(x) {
                return arguments.length ? (round = !!x, treemap) : round;
              };
              treemap.size = function(x) {
                return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];
              };
              treemap.tile = function(x) {
                return arguments.length ? (tile = required(x), treemap) : tile;
              };
              treemap.padding = function(x) {
                return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();
              };
              treemap.paddingInner = function(x) {
                return arguments.length ? (paddingInner = typeof x === "function" ? x : constant(+x), treemap) : paddingInner;
              };
              treemap.paddingOuter = function(x) {
                return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();
              };
              treemap.paddingTop = function(x) {
                return arguments.length ? (paddingTop = typeof x === "function" ? x : constant(+x), treemap) : paddingTop;
              };
              treemap.paddingRight = function(x) {
                return arguments.length ? (paddingRight = typeof x === "function" ? x : constant(+x), treemap) : paddingRight;
              };
              treemap.paddingBottom = function(x) {
                return arguments.length ? (paddingBottom = typeof x === "function" ? x : constant(+x), treemap) : paddingBottom;
              };
              treemap.paddingLeft = function(x) {
                return arguments.length ? (paddingLeft = typeof x === "function" ? x : constant(+x), treemap) : paddingLeft;
              };
              return treemap;
            }
            function binary(parent, x0, y0, x1, y1) {
              var nodes = parent.children, i, n = nodes.length, sum, sums = new Array(n + 1);
              for (sums[0] = sum = i = 0; i < n; ++i) {
                sums[i + 1] = sum += nodes[i].value;
              }
              partition2(0, n, parent.value, x0, y0, x1, y1);
              function partition2(i2, j, value, x02, y02, x12, y12) {
                if (i2 >= j - 1) {
                  var node = nodes[i2];
                  node.x0 = x02, node.y0 = y02;
                  node.x1 = x12, node.y1 = y12;
                  return;
                }
                var valueOffset = sums[i2], valueTarget = value / 2 + valueOffset, k = i2 + 1, hi = j - 1;
                while (k < hi) {
                  var mid = k + hi >>> 1;
                  if (sums[mid] < valueTarget)
                    k = mid + 1;
                  else
                    hi = mid;
                }
                if (valueTarget - sums[k - 1] < sums[k] - valueTarget && i2 + 1 < k)
                  --k;
                var valueLeft = sums[k] - valueOffset, valueRight = value - valueLeft;
                if (x12 - x02 > y12 - y02) {
                  var xk = (x02 * valueRight + x12 * valueLeft) / value;
                  partition2(i2, k, valueLeft, x02, y02, xk, y12);
                  partition2(k, j, valueRight, xk, y02, x12, y12);
                } else {
                  var yk = (y02 * valueRight + y12 * valueLeft) / value;
                  partition2(i2, k, valueLeft, x02, y02, x12, yk);
                  partition2(k, j, valueRight, x02, yk, x12, y12);
                }
              }
            }
            function sliceDice(parent, x0, y0, x1, y1) {
              (parent.depth & 1 ? treemapSlice : treemapDice)(parent, x0, y0, x1, y1);
            }
            var resquarify = function custom(ratio) {
              function resquarify2(parent, x0, y0, x1, y1) {
                if ((rows = parent._squarify) && rows.ratio === ratio) {
                  var rows, row, nodes, i, j = -1, n, m = rows.length, value = parent.value;
                  while (++j < m) {
                    row = rows[j], nodes = row.children;
                    for (i = row.value = 0, n = nodes.length; i < n; ++i)
                      row.value += nodes[i].value;
                    if (row.dice)
                      treemapDice(row, x0, y0, x1, y0 += (y1 - y0) * row.value / value);
                    else
                      treemapSlice(row, x0, y0, x0 += (x1 - x0) * row.value / value, y1);
                    value -= row.value;
                  }
                } else {
                  parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);
                  rows.ratio = ratio;
                }
              }
              resquarify2.ratio = function(x) {
                return custom((x = +x) > 1 ? x : 1);
              };
              return resquarify2;
            }(phi);
            exports3.cluster = cluster;
            exports3.hierarchy = hierarchy;
            exports3.pack = index;
            exports3.packEnclose = enclose;
            exports3.packSiblings = siblings;
            exports3.partition = partition;
            exports3.stratify = stratify;
            exports3.tree = tree;
            exports3.treemap = index$1;
            exports3.treemapBinary = binary;
            exports3.treemapDice = treemapDice;
            exports3.treemapResquarify = resquarify;
            exports3.treemapSlice = treemapSlice;
            exports3.treemapSliceDice = sliceDice;
            exports3.treemapSquarify = squarify;
            Object.defineProperty(exports3, "__esModule", { value: true });
          });
        },
        "./node_modules/_d3-path@1.0.9@d3-path/dist/d3-path.js": function(module2, exports2, __webpack_require__) {
          (function(global, factory) {
            true ? factory(exports2) : void 0;
          })(this, function(exports3) {
            "use strict";
            var pi = Math.PI, tau = 2 * pi, epsilon = 1e-6, tauEpsilon = tau - epsilon;
            function Path() {
              this._x0 = this._y0 = this._x1 = this._y1 = null;
              this._ = "";
            }
            function path() {
              return new Path();
            }
            Path.prototype = path.prototype = {
              constructor: Path,
              moveTo: function(x, y) {
                this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
              },
              closePath: function() {
                if (this._x1 !== null) {
                  this._x1 = this._x0, this._y1 = this._y0;
                  this._ += "Z";
                }
              },
              lineTo: function(x, y) {
                this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
              },
              quadraticCurveTo: function(x1, y1, x, y) {
                this._ += "Q" + +x1 + "," + +y1 + "," + (this._x1 = +x) + "," + (this._y1 = +y);
              },
              bezierCurveTo: function(x1, y1, x2, y2, x, y) {
                this._ += "C" + +x1 + "," + +y1 + "," + +x2 + "," + +y2 + "," + (this._x1 = +x) + "," + (this._y1 = +y);
              },
              arcTo: function(x1, y1, x2, y2, r) {
                x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
                var x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
                if (r < 0)
                  throw new Error("negative radius: " + r);
                if (this._x1 === null) {
                  this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
                } else if (!(l01_2 > epsilon))
                  ;
                else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
                  this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
                } else {
                  var x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
                  if (Math.abs(t01 - 1) > epsilon) {
                    this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
                  }
                  this._ += "A" + r + "," + r + ",0,0," + +(y01 * x20 > x01 * y20) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
                }
              },
              arc: function(x, y, r, a0, a1, ccw) {
                x = +x, y = +y, r = +r, ccw = !!ccw;
                var dx = r * Math.cos(a0), dy = r * Math.sin(a0), x0 = x + dx, y0 = y + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
                if (r < 0)
                  throw new Error("negative radius: " + r);
                if (this._x1 === null) {
                  this._ += "M" + x0 + "," + y0;
                } else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
                  this._ += "L" + x0 + "," + y0;
                }
                if (!r)
                  return;
                if (da < 0)
                  da = da % tau + tau;
                if (da > tauEpsilon) {
                  this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
                } else if (da > epsilon) {
                  this._ += "A" + r + "," + r + ",0," + +(da >= pi) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
                }
              },
              rect: function(x, y, w, h) {
                this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + +w + "v" + +h + "h" + -w + "Z";
              },
              toString: function() {
                return this._;
              }
            };
            exports3.path = path;
            Object.defineProperty(exports3, "__esModule", { value: true });
          });
        },
        "./node_modules/_d3-path@2.0.0@d3-path/dist/d3-path.js": function(module2, exports2, __webpack_require__) {
          (function(global, factory) {
            true ? factory(exports2) : void 0;
          })(this, function(exports3) {
            "use strict";
            var pi = Math.PI, tau = 2 * pi, epsilon = 1e-6, tauEpsilon = tau - epsilon;
            function Path() {
              this._x0 = this._y0 = this._x1 = this._y1 = null;
              this._ = "";
            }
            function path() {
              return new Path();
            }
            Path.prototype = path.prototype = {
              constructor: Path,
              moveTo: function(x, y) {
                this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
              },
              closePath: function() {
                if (this._x1 !== null) {
                  this._x1 = this._x0, this._y1 = this._y0;
                  this._ += "Z";
                }
              },
              lineTo: function(x, y) {
                this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
              },
              quadraticCurveTo: function(x1, y1, x, y) {
                this._ += "Q" + +x1 + "," + +y1 + "," + (this._x1 = +x) + "," + (this._y1 = +y);
              },
              bezierCurveTo: function(x1, y1, x2, y2, x, y) {
                this._ += "C" + +x1 + "," + +y1 + "," + +x2 + "," + +y2 + "," + (this._x1 = +x) + "," + (this._y1 = +y);
              },
              arcTo: function(x1, y1, x2, y2, r) {
                x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
                var x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
                if (r < 0)
                  throw new Error("negative radius: " + r);
                if (this._x1 === null) {
                  this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
                } else if (!(l01_2 > epsilon))
                  ;
                else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
                  this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
                } else {
                  var x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
                  if (Math.abs(t01 - 1) > epsilon) {
                    this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
                  }
                  this._ += "A" + r + "," + r + ",0,0," + +(y01 * x20 > x01 * y20) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
                }
              },
              arc: function(x, y, r, a0, a1, ccw) {
                x = +x, y = +y, r = +r, ccw = !!ccw;
                var dx = r * Math.cos(a0), dy = r * Math.sin(a0), x0 = x + dx, y0 = y + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
                if (r < 0)
                  throw new Error("negative radius: " + r);
                if (this._x1 === null) {
                  this._ += "M" + x0 + "," + y0;
                } else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
                  this._ += "L" + x0 + "," + y0;
                }
                if (!r)
                  return;
                if (da < 0)
                  da = da % tau + tau;
                if (da > tauEpsilon) {
                  this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
                } else if (da > epsilon) {
                  this._ += "A" + r + "," + r + ",0," + +(da >= pi) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
                }
              },
              rect: function(x, y, w, h) {
                this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + +w + "v" + +h + "h" + -w + "Z";
              },
              toString: function() {
                return this._;
              }
            };
            exports3.path = path;
            Object.defineProperty(exports3, "__esModule", { value: true });
          });
        },
        "./node_modules/_d3-sankey@0.9.1@d3-sankey/dist/d3-sankey.js": function(module2, exports2, __webpack_require__) {
          var tslib_1 = __webpack_require__("./node_modules/_tslib@2.1.0@tslib/tslib.js");
          (function(global, factory) {
            true ? factory(exports2, __webpack_require__("./node_modules/_d3-array@1.2.4@d3-array/dist/d3-array.js"), __webpack_require__("./node_modules/_d3-collection@1.0.7@d3-collection/dist/d3-collection.js"), __webpack_require__("./node_modules/_d3-shape@1.3.7@d3-shape/dist/d3-shape.js")) : void 0;
          })(this, function(exports3, d3Array, d3Collection, d3Shape) {
            "use strict";
            function targetDepth(d) {
              return d.target.depth;
            }
            function left(node) {
              return node.depth;
            }
            function right(node, n) {
              return n - 1 - node.height;
            }
            function justify(node, n) {
              return node.sourceLinks.length ? node.depth : n - 1;
            }
            function center(node) {
              return node.targetLinks.length ? node.depth : node.sourceLinks.length ? d3Array.min(node.sourceLinks, targetDepth) - 1 : 0;
            }
            function constant(x) {
              return function() {
                return x;
              };
            }
            function ascendingSourceBreadth(a, b) {
              return ascendingBreadth(a.source, b.source) || a.index - b.index;
            }
            function ascendingTargetBreadth(a, b) {
              return ascendingBreadth(a.target, b.target) || a.index - b.index;
            }
            function ascendingBreadth(a, b) {
              return a.y0 - b.y0;
            }
            function value(d) {
              return d.value;
            }
            function defaultId(d) {
              return d.index;
            }
            function defaultNodes(graph) {
              return graph.nodes;
            }
            function defaultLinks(graph) {
              return graph.links;
            }
            function find(nodeById, id) {
              var node = nodeById.get(id);
              if (!node)
                throw new Error("missing: " + id);
              return node;
            }
            function Sankey() {
              var x0 = 0, y0 = 0, x1 = 1, y1 = 1, dx = 24, py = 8, id = defaultId, align = justify, sort, nodes = defaultNodes, links = defaultLinks, iterations = 6;
              function sankey() {
                var graph = { nodes: nodes.apply(null, arguments), links: links.apply(null, arguments) };
                computeNodeLinks(graph);
                computeNodeValues(graph);
                computeNodeDepths(graph);
                computeNodeBreadths(graph);
                computeLinkBreadths(graph);
                return graph;
              }
              sankey.update = function(graph) {
                computeLinkBreadths(graph);
                return graph;
              };
              sankey.nodeId = function(_) {
                return arguments.length ? (id = typeof _ === "function" ? _ : constant(_), sankey) : id;
              };
              sankey.nodeAlign = function(_) {
                return arguments.length ? (align = typeof _ === "function" ? _ : constant(_), sankey) : align;
              };
              sankey.nodeSort = function(_) {
                return arguments.length ? (sort = _, sankey) : sort;
              };
              sankey.nodeWidth = function(_) {
                return arguments.length ? (dx = +_, sankey) : dx;
              };
              sankey.nodePadding = function(_) {
                return arguments.length ? (py = +_, sankey) : py;
              };
              sankey.nodes = function(_) {
                return arguments.length ? (nodes = typeof _ === "function" ? _ : constant(_), sankey) : nodes;
              };
              sankey.links = function(_) {
                return arguments.length ? (links = typeof _ === "function" ? _ : constant(_), sankey) : links;
              };
              sankey.size = function(_) {
                return arguments.length ? (x0 = y0 = 0, x1 = +_[0], y1 = +_[1], sankey) : [x1 - x0, y1 - y0];
              };
              sankey.extent = function(_) {
                return arguments.length ? (x0 = +_[0][0], x1 = +_[1][0], y0 = +_[0][1], y1 = +_[1][1], sankey) : [[x0, y0], [x1, y1]];
              };
              sankey.iterations = function(_) {
                return arguments.length ? (iterations = +_, sankey) : iterations;
              };
              function computeNodeLinks(graph) {
                graph.nodes.forEach(function(node, i) {
                  node.index = i;
                  node.sourceLinks = [];
                  node.targetLinks = [];
                });
                var nodeById = d3Collection.map(graph.nodes, id);
                graph.links.forEach(function(link, i) {
                  link.index = i;
                  var source = link.source, target = link.target;
                  if (typeof source !== "object")
                    source = link.source = find(nodeById, source);
                  if (typeof target !== "object")
                    target = link.target = find(nodeById, target);
                  source.sourceLinks.push(link);
                  target.targetLinks.push(link);
                });
              }
              function computeNodeValues(graph) {
                graph.nodes.forEach(function(node) {
                  node.value = Math.max(d3Array.sum(node.sourceLinks, value), d3Array.sum(node.targetLinks, value));
                });
              }
              function computeNodeDepths(graph) {
                var nodes2, next, x, n = graph.nodes.length;
                for (nodes2 = graph.nodes, next = [], x = 0; nodes2.length; ++x, nodes2 = next, next = []) {
                  if (x > n)
                    throw new Error("circular link");
                  nodes2.forEach(function(node) {
                    node.depth = x;
                    node.sourceLinks.forEach(function(link) {
                      if (next.indexOf(link.target) < 0) {
                        next.push(link.target);
                      }
                    });
                  });
                }
                for (nodes2 = graph.nodes, next = [], x = 0; nodes2.length; ++x, nodes2 = next, next = []) {
                  if (x > n)
                    throw new Error("circular link");
                  nodes2.forEach(function(node) {
                    node.height = x;
                    node.targetLinks.forEach(function(link) {
                      if (next.indexOf(link.source) < 0) {
                        next.push(link.source);
                      }
                    });
                  });
                }
                var kx = (x1 - x0 - dx) / (x - 1);
                graph.nodes.forEach(function(node) {
                  node.x1 = (node.x0 = x0 + Math.max(0, Math.min(x - 1, Math.floor(align.call(null, node, x)))) * kx) + dx;
                });
              }
              function computeNodeBreadths(graph) {
                var columns = d3Collection.nest().key(function(d) {
                  return d.x0;
                }).sortKeys(d3Array.ascending).entries(graph.nodes).map(function(d) {
                  return d.values;
                });
                initializeNodeBreadth();
                resolveCollisions();
                for (var alpha = 0.9, n = iterations; n > 0; --n, alpha *= 0.9) {
                  relaxRightToLeft(alpha);
                  resolveCollisions();
                  relaxLeftToRight(alpha);
                  resolveCollisions();
                }
                function initializeNodeBreadth() {
                  var ky = d3Array.min(columns, function(nodes2) {
                    return (y1 - y0 - (nodes2.length - 1) * py) / d3Array.sum(nodes2, value);
                  });
                  columns.forEach(function(nodes2) {
                    if (sort != null)
                      nodes2.sort(sort);
                    nodes2.forEach(function(node, i) {
                      node.y1 = (node.y0 = i) + node.value * ky;
                    });
                  });
                  graph.links.forEach(function(link) {
                    link.width = link.value * ky;
                  });
                }
                function relaxLeftToRight(alpha2) {
                  columns.forEach(function(nodes2) {
                    nodes2.forEach(function(node) {
                      var e_1, _a, e_2, _b;
                      var y = node.y0;
                      try {
                        for (var _c = tslib_1.__values(node.sourceLinks.sort(ascendingTargetBreadth)), _d = _c.next(); !_d.done; _d = _c.next()) {
                          var _e = _d.value, target = _e.target, width = _e.width, value_1 = _e.value;
                          if (value_1 > 0) {
                            var dy = 0;
                            try {
                              for (var _f = (e_2 = void 0, tslib_1.__values(target.targetLinks)), _g = _f.next(); !_g.done; _g = _f.next()) {
                                var _h = _g.value, source = _h.source, width_1 = _h.width;
                                if (source === node)
                                  break;
                                dy += width_1 + py / 2;
                              }
                            } catch (e_2_1) {
                              e_2 = { error: e_2_1 };
                            } finally {
                              try {
                                if (_g && !_g.done && (_b = _f.return))
                                  _b.call(_f);
                              } finally {
                                if (e_2)
                                  throw e_2.error;
                              }
                            }
                            dy = (y - dy - target.y0) * alpha2 * (value_1 / Math.min(node.value, target.value));
                            target.y0 += dy;
                            target.y1 += dy;
                          }
                          y += width + py / 2;
                        }
                      } catch (e_1_1) {
                        e_1 = { error: e_1_1 };
                      } finally {
                        try {
                          if (_d && !_d.done && (_a = _c.return))
                            _a.call(_c);
                        } finally {
                          if (e_1)
                            throw e_1.error;
                        }
                      }
                    });
                  });
                }
                function relaxRightToLeft(alpha2) {
                  columns.slice().reverse().forEach(function(nodes2) {
                    nodes2.forEach(function(node) {
                      var e_3, _a, e_4, _b;
                      var y = node.y0;
                      try {
                        for (var _c = tslib_1.__values(node.targetLinks.sort(ascendingSourceBreadth)), _d = _c.next(); !_d.done; _d = _c.next()) {
                          var _e = _d.value, source = _e.source, width = _e.width, value_2 = _e.value;
                          if (value_2 > 0) {
                            var dy = 0;
                            try {
                              for (var _f = (e_4 = void 0, tslib_1.__values(source.sourceLinks)), _g = _f.next(); !_g.done; _g = _f.next()) {
                                var _h = _g.value, target = _h.target, width_2 = _h.width;
                                if (target === node)
                                  break;
                                dy += width_2 + py / 2;
                              }
                            } catch (e_4_1) {
                              e_4 = { error: e_4_1 };
                            } finally {
                              try {
                                if (_g && !_g.done && (_b = _f.return))
                                  _b.call(_f);
                              } finally {
                                if (e_4)
                                  throw e_4.error;
                              }
                            }
                            dy = (y - dy - source.y0) * alpha2 * (value_2 / Math.min(node.value, source.value));
                            source.y0 += dy;
                            source.y1 += dy;
                          }
                          y += width + py / 2;
                        }
                      } catch (e_3_1) {
                        e_3 = { error: e_3_1 };
                      } finally {
                        try {
                          if (_d && !_d.done && (_a = _c.return))
                            _a.call(_c);
                        } finally {
                          if (e_3)
                            throw e_3.error;
                        }
                      }
                    });
                  });
                }
                function resolveCollisions() {
                  columns.forEach(function(nodes2) {
                    var node, dy, y = y0, n2 = nodes2.length, i;
                    if (sort === void 0)
                      nodes2.sort(ascendingBreadth);
                    for (i = 0; i < n2; ++i) {
                      node = nodes2[i];
                      dy = y - node.y0;
                      if (dy > 0)
                        node.y0 += dy, node.y1 += dy;
                      y = node.y1 + py;
                    }
                    dy = y - py - y1;
                    if (dy > 0) {
                      y = node.y0 -= dy, node.y1 -= dy;
                      for (i = n2 - 2; i >= 0; --i) {
                        node = nodes2[i];
                        dy = node.y1 + py - y;
                        if (dy > 0)
                          node.y0 -= dy, node.y1 -= dy;
                        y = node.y0;
                      }
                    }
                  });
                }
              }
              function computeLinkBreadths(graph) {
                graph.nodes.forEach(function(node) {
                  node.sourceLinks.sort(ascendingTargetBreadth);
                  node.targetLinks.sort(ascendingSourceBreadth);
                });
                graph.nodes.forEach(function(node) {
                  var y02 = node.y0, y12 = y02;
                  node.sourceLinks.forEach(function(link) {
                    link.y0 = y02 + link.width / 2, y02 += link.width;
                  });
                  node.targetLinks.forEach(function(link) {
                    link.y1 = y12 + link.width / 2, y12 += link.width;
                  });
                });
              }
              return sankey;
            }
            function horizontalSource(d) {
              return [d.source.x1, d.y0];
            }
            function horizontalTarget(d) {
              return [d.target.x0, d.y1];
            }
            function sankeyLinkHorizontal() {
              return d3Shape.linkHorizontal().source(horizontalSource).target(horizontalTarget);
            }
            exports3.sankey = Sankey;
            exports3.sankeyCenter = center;
            exports3.sankeyLeft = left;
            exports3.sankeyRight = right;
            exports3.sankeyJustify = justify;
            exports3.sankeyLinkHorizontal = sankeyLinkHorizontal;
            Object.defineProperty(exports3, "__esModule", { value: true });
          });
        },
        "./node_modules/_d3-shape@1.3.7@d3-shape/dist/d3-shape.js": function(module2, exports2, __webpack_require__) {
          (function(global, factory) {
            true ? factory(exports2, __webpack_require__("./node_modules/_d3-path@1.0.9@d3-path/dist/d3-path.js")) : void 0;
          })(this, function(exports3, d3Path) {
            "use strict";
            function constant(x2) {
              return function constant2() {
                return x2;
              };
            }
            var abs = Math.abs;
            var atan2 = Math.atan2;
            var cos = Math.cos;
            var max = Math.max;
            var min = Math.min;
            var sin = Math.sin;
            var sqrt = Math.sqrt;
            var epsilon = 1e-12;
            var pi = Math.PI;
            var halfPi = pi / 2;
            var tau = 2 * pi;
            function acos(x2) {
              return x2 > 1 ? 0 : x2 < -1 ? pi : Math.acos(x2);
            }
            function asin(x2) {
              return x2 >= 1 ? halfPi : x2 <= -1 ? -halfPi : Math.asin(x2);
            }
            function arcInnerRadius(d) {
              return d.innerRadius;
            }
            function arcOuterRadius(d) {
              return d.outerRadius;
            }
            function arcStartAngle(d) {
              return d.startAngle;
            }
            function arcEndAngle(d) {
              return d.endAngle;
            }
            function arcPadAngle(d) {
              return d && d.padAngle;
            }
            function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
              var x10 = x1 - x0, y10 = y1 - y0, x32 = x3 - x2, y32 = y3 - y2, t = y32 * x10 - x32 * y10;
              if (t * t < epsilon)
                return;
              t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
              return [x0 + t * x10, y0 + t * y10];
            }
            function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
              var x01 = x0 - x1, y01 = y0 - y1, lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x0 + ox, y11 = y0 + oy, x10 = x1 + ox, y10 = y1 + oy, x00 = (x11 + x10) / 2, y00 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r = r1 - rc, D = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * sqrt(max(0, r * r * d2 - D * D)), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x00, dy0 = cy0 - y00, dx1 = cx1 - x00, dy1 = cy1 - y00;
              if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1)
                cx0 = cx1, cy0 = cy1;
              return {
                cx: cx0,
                cy: cy0,
                x01: -ox,
                y01: -oy,
                x11: cx0 * (r1 / r - 1),
                y11: cy0 * (r1 / r - 1)
              };
            }
            function arc() {
              var innerRadius = arcInnerRadius, outerRadius = arcOuterRadius, cornerRadius = constant(0), padRadius = null, startAngle = arcStartAngle, endAngle = arcEndAngle, padAngle = arcPadAngle, context = null;
              function arc2() {
                var buffer, r, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi, a1 = endAngle.apply(this, arguments) - halfPi, da = abs(a1 - a0), cw = a1 > a0;
                if (!context)
                  context = buffer = d3Path.path();
                if (r1 < r0)
                  r = r1, r1 = r0, r0 = r;
                if (!(r1 > epsilon))
                  context.moveTo(0, 0);
                else if (da > tau - epsilon) {
                  context.moveTo(r1 * cos(a0), r1 * sin(a0));
                  context.arc(0, 0, r1, a0, a1, !cw);
                  if (r0 > epsilon) {
                    context.moveTo(r0 * cos(a1), r0 * sin(a1));
                    context.arc(0, 0, r0, a1, a0, cw);
                  }
                } else {
                  var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da, da1 = da, ap = padAngle.apply(this, arguments) / 2, rp = ap > epsilon && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)), rc = min(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t0, t1;
                  if (rp > epsilon) {
                    var p0 = asin(rp / r0 * sin(ap)), p1 = asin(rp / r1 * sin(ap));
                    if ((da0 -= p0 * 2) > epsilon)
                      p0 *= cw ? 1 : -1, a00 += p0, a10 -= p0;
                    else
                      da0 = 0, a00 = a10 = (a0 + a1) / 2;
                    if ((da1 -= p1 * 2) > epsilon)
                      p1 *= cw ? 1 : -1, a01 += p1, a11 -= p1;
                    else
                      da1 = 0, a01 = a11 = (a0 + a1) / 2;
                  }
                  var x01 = r1 * cos(a01), y01 = r1 * sin(a01), x10 = r0 * cos(a10), y10 = r0 * sin(a10);
                  if (rc > epsilon) {
                    var x11 = r1 * cos(a11), y11 = r1 * sin(a11), x00 = r0 * cos(a00), y00 = r0 * sin(a00), oc;
                    if (da < pi && (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10))) {
                      var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2), lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
                      rc0 = min(rc, (r0 - lc) / (kc - 1));
                      rc1 = min(rc, (r1 - lc) / (kc + 1));
                    }
                  }
                  if (!(da1 > epsilon))
                    context.moveTo(x01, y01);
                  else if (rc1 > epsilon) {
                    t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
                    t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);
                    context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);
                    if (rc1 < rc)
                      context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);
                    else {
                      context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
                      context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
                      context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
                    }
                  } else
                    context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);
                  if (!(r0 > epsilon) || !(da0 > epsilon))
                    context.lineTo(x10, y10);
                  else if (rc0 > epsilon) {
                    t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
                    t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);
                    context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);
                    if (rc0 < rc)
                      context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);
                    else {
                      context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
                      context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
                      context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
                    }
                  } else
                    context.arc(0, 0, r0, a10, a00, cw);
                }
                context.closePath();
                if (buffer)
                  return context = null, buffer + "" || null;
              }
              arc2.centroid = function() {
                var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a2 = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;
                return [cos(a2) * r, sin(a2) * r];
              };
              arc2.innerRadius = function(_) {
                return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant(+_), arc2) : innerRadius;
              };
              arc2.outerRadius = function(_) {
                return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant(+_), arc2) : outerRadius;
              };
              arc2.cornerRadius = function(_) {
                return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant(+_), arc2) : cornerRadius;
              };
              arc2.padRadius = function(_) {
                return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant(+_), arc2) : padRadius;
              };
              arc2.startAngle = function(_) {
                return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant(+_), arc2) : startAngle;
              };
              arc2.endAngle = function(_) {
                return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant(+_), arc2) : endAngle;
              };
              arc2.padAngle = function(_) {
                return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant(+_), arc2) : padAngle;
              };
              arc2.context = function(_) {
                return arguments.length ? (context = _ == null ? null : _, arc2) : context;
              };
              return arc2;
            }
            function Linear(context) {
              this._context = context;
            }
            Linear.prototype = {
              areaStart: function() {
                this._line = 0;
              },
              areaEnd: function() {
                this._line = NaN;
              },
              lineStart: function() {
                this._point = 0;
              },
              lineEnd: function() {
                if (this._line || this._line !== 0 && this._point === 1)
                  this._context.closePath();
                this._line = 1 - this._line;
              },
              point: function(x2, y2) {
                x2 = +x2, y2 = +y2;
                switch (this._point) {
                  case 0:
                    this._point = 1;
                    this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
                    break;
                  case 1:
                    this._point = 2;
                  default:
                    this._context.lineTo(x2, y2);
                    break;
                }
              }
            };
            function curveLinear(context) {
              return new Linear(context);
            }
            function x(p) {
              return p[0];
            }
            function y(p) {
              return p[1];
            }
            function line() {
              var x$1 = x, y$1 = y, defined = constant(true), context = null, curve = curveLinear, output = null;
              function line2(data) {
                var i, n = data.length, d, defined0 = false, buffer;
                if (context == null)
                  output = curve(buffer = d3Path.path());
                for (i = 0; i <= n; ++i) {
                  if (!(i < n && defined(d = data[i], i, data)) === defined0) {
                    if (defined0 = !defined0)
                      output.lineStart();
                    else
                      output.lineEnd();
                  }
                  if (defined0)
                    output.point(+x$1(d, i, data), +y$1(d, i, data));
                }
                if (buffer)
                  return output = null, buffer + "" || null;
              }
              line2.x = function(_) {
                return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant(+_), line2) : x$1;
              };
              line2.y = function(_) {
                return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant(+_), line2) : y$1;
              };
              line2.defined = function(_) {
                return arguments.length ? (defined = typeof _ === "function" ? _ : constant(!!_), line2) : defined;
              };
              line2.curve = function(_) {
                return arguments.length ? (curve = _, context != null && (output = curve(context)), line2) : curve;
              };
              line2.context = function(_) {
                return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line2) : context;
              };
              return line2;
            }
            function area() {
              var x0 = x, x1 = null, y0 = constant(0), y1 = y, defined = constant(true), context = null, curve = curveLinear, output = null;
              function area2(data) {
                var i, j, k2, n = data.length, d, defined0 = false, buffer, x0z = new Array(n), y0z = new Array(n);
                if (context == null)
                  output = curve(buffer = d3Path.path());
                for (i = 0; i <= n; ++i) {
                  if (!(i < n && defined(d = data[i], i, data)) === defined0) {
                    if (defined0 = !defined0) {
                      j = i;
                      output.areaStart();
                      output.lineStart();
                    } else {
                      output.lineEnd();
                      output.lineStart();
                      for (k2 = i - 1; k2 >= j; --k2) {
                        output.point(x0z[k2], y0z[k2]);
                      }
                      output.lineEnd();
                      output.areaEnd();
                    }
                  }
                  if (defined0) {
                    x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
                    output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
                  }
                }
                if (buffer)
                  return output = null, buffer + "" || null;
              }
              function arealine() {
                return line().defined(defined).curve(curve).context(context);
              }
              area2.x = function(_) {
                return arguments.length ? (x0 = typeof _ === "function" ? _ : constant(+_), x1 = null, area2) : x0;
              };
              area2.x0 = function(_) {
                return arguments.length ? (x0 = typeof _ === "function" ? _ : constant(+_), area2) : x0;
              };
              area2.x1 = function(_) {
                return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant(+_), area2) : x1;
              };
              area2.y = function(_) {
                return arguments.length ? (y0 = typeof _ === "function" ? _ : constant(+_), y1 = null, area2) : y0;
              };
              area2.y0 = function(_) {
                return arguments.length ? (y0 = typeof _ === "function" ? _ : constant(+_), area2) : y0;
              };
              area2.y1 = function(_) {
                return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant(+_), area2) : y1;
              };
              area2.lineX0 = area2.lineY0 = function() {
                return arealine().x(x0).y(y0);
              };
              area2.lineY1 = function() {
                return arealine().x(x0).y(y1);
              };
              area2.lineX1 = function() {
                return arealine().x(x1).y(y0);
              };
              area2.defined = function(_) {
                return arguments.length ? (defined = typeof _ === "function" ? _ : constant(!!_), area2) : defined;
              };
              area2.curve = function(_) {
                return arguments.length ? (curve = _, context != null && (output = curve(context)), area2) : curve;
              };
              area2.context = function(_) {
                return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area2) : context;
              };
              return area2;
            }
            function descending(a2, b) {
              return b < a2 ? -1 : b > a2 ? 1 : b >= a2 ? 0 : NaN;
            }
            function identity(d) {
              return d;
            }
            function pie() {
              var value = identity, sortValues = descending, sort = null, startAngle = constant(0), endAngle = constant(tau), padAngle = constant(0);
              function pie2(data) {
                var i, n = data.length, j, k2, sum2 = 0, index = new Array(n), arcs = new Array(n), a0 = +startAngle.apply(this, arguments), da = Math.min(tau, Math.max(-tau, endAngle.apply(this, arguments) - a0)), a1, p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)), pa = p * (da < 0 ? -1 : 1), v;
                for (i = 0; i < n; ++i) {
                  if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
                    sum2 += v;
                  }
                }
                if (sortValues != null)
                  index.sort(function(i2, j2) {
                    return sortValues(arcs[i2], arcs[j2]);
                  });
                else if (sort != null)
                  index.sort(function(i2, j2) {
                    return sort(data[i2], data[j2]);
                  });
                for (i = 0, k2 = sum2 ? (da - n * pa) / sum2 : 0; i < n; ++i, a0 = a1) {
                  j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k2 : 0) + pa, arcs[j] = {
                    data: data[j],
                    index: i,
                    value: v,
                    startAngle: a0,
                    endAngle: a1,
                    padAngle: p
                  };
                }
                return arcs;
              }
              pie2.value = function(_) {
                return arguments.length ? (value = typeof _ === "function" ? _ : constant(+_), pie2) : value;
              };
              pie2.sortValues = function(_) {
                return arguments.length ? (sortValues = _, sort = null, pie2) : sortValues;
              };
              pie2.sort = function(_) {
                return arguments.length ? (sort = _, sortValues = null, pie2) : sort;
              };
              pie2.startAngle = function(_) {
                return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant(+_), pie2) : startAngle;
              };
              pie2.endAngle = function(_) {
                return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant(+_), pie2) : endAngle;
              };
              pie2.padAngle = function(_) {
                return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant(+_), pie2) : padAngle;
              };
              return pie2;
            }
            var curveRadialLinear = curveRadial(curveLinear);
            function Radial(curve) {
              this._curve = curve;
            }
            Radial.prototype = {
              areaStart: function() {
                this._curve.areaStart();
              },
              areaEnd: function() {
                this._curve.areaEnd();
              },
              lineStart: function() {
                this._curve.lineStart();
              },
              lineEnd: function() {
                this._curve.lineEnd();
              },
              point: function(a2, r) {
                this._curve.point(r * Math.sin(a2), r * -Math.cos(a2));
              }
            };
            function curveRadial(curve) {
              function radial(context) {
                return new Radial(curve(context));
              }
              radial._curve = curve;
              return radial;
            }
            function lineRadial(l) {
              var c2 = l.curve;
              l.angle = l.x, delete l.x;
              l.radius = l.y, delete l.y;
              l.curve = function(_) {
                return arguments.length ? c2(curveRadial(_)) : c2()._curve;
              };
              return l;
            }
            function lineRadial$1() {
              return lineRadial(line().curve(curveRadialLinear));
            }
            function areaRadial() {
              var a2 = area().curve(curveRadialLinear), c2 = a2.curve, x0 = a2.lineX0, x1 = a2.lineX1, y0 = a2.lineY0, y1 = a2.lineY1;
              a2.angle = a2.x, delete a2.x;
              a2.startAngle = a2.x0, delete a2.x0;
              a2.endAngle = a2.x1, delete a2.x1;
              a2.radius = a2.y, delete a2.y;
              a2.innerRadius = a2.y0, delete a2.y0;
              a2.outerRadius = a2.y1, delete a2.y1;
              a2.lineStartAngle = function() {
                return lineRadial(x0());
              }, delete a2.lineX0;
              a2.lineEndAngle = function() {
                return lineRadial(x1());
              }, delete a2.lineX1;
              a2.lineInnerRadius = function() {
                return lineRadial(y0());
              }, delete a2.lineY0;
              a2.lineOuterRadius = function() {
                return lineRadial(y1());
              }, delete a2.lineY1;
              a2.curve = function(_) {
                return arguments.length ? c2(curveRadial(_)) : c2()._curve;
              };
              return a2;
            }
            function pointRadial(x2, y2) {
              return [(y2 = +y2) * Math.cos(x2 -= Math.PI / 2), y2 * Math.sin(x2)];
            }
            var slice = Array.prototype.slice;
            function linkSource(d) {
              return d.source;
            }
            function linkTarget(d) {
              return d.target;
            }
            function link(curve) {
              var source = linkSource, target = linkTarget, x$1 = x, y$1 = y, context = null;
              function link2() {
                var buffer, argv = slice.call(arguments), s2 = source.apply(this, argv), t = target.apply(this, argv);
                if (!context)
                  context = buffer = d3Path.path();
                curve(context, +x$1.apply(this, (argv[0] = s2, argv)), +y$1.apply(this, argv), +x$1.apply(this, (argv[0] = t, argv)), +y$1.apply(this, argv));
                if (buffer)
                  return context = null, buffer + "" || null;
              }
              link2.source = function(_) {
                return arguments.length ? (source = _, link2) : source;
              };
              link2.target = function(_) {
                return arguments.length ? (target = _, link2) : target;
              };
              link2.x = function(_) {
                return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant(+_), link2) : x$1;
              };
              link2.y = function(_) {
                return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant(+_), link2) : y$1;
              };
              link2.context = function(_) {
                return arguments.length ? (context = _ == null ? null : _, link2) : context;
              };
              return link2;
            }
            function curveHorizontal(context, x0, y0, x1, y1) {
              context.moveTo(x0, y0);
              context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);
            }
            function curveVertical(context, x0, y0, x1, y1) {
              context.moveTo(x0, y0);
              context.bezierCurveTo(x0, y0 = (y0 + y1) / 2, x1, y0, x1, y1);
            }
            function curveRadial$1(context, x0, y0, x1, y1) {
              var p0 = pointRadial(x0, y0), p1 = pointRadial(x0, y0 = (y0 + y1) / 2), p2 = pointRadial(x1, y0), p3 = pointRadial(x1, y1);
              context.moveTo(p0[0], p0[1]);
              context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
            }
            function linkHorizontal() {
              return link(curveHorizontal);
            }
            function linkVertical() {
              return link(curveVertical);
            }
            function linkRadial() {
              var l = link(curveRadial$1);
              l.angle = l.x, delete l.x;
              l.radius = l.y, delete l.y;
              return l;
            }
            var circle = {
              draw: function(context, size) {
                var r = Math.sqrt(size / pi);
                context.moveTo(r, 0);
                context.arc(0, 0, r, 0, tau);
              }
            };
            var cross = {
              draw: function(context, size) {
                var r = Math.sqrt(size / 5) / 2;
                context.moveTo(-3 * r, -r);
                context.lineTo(-r, -r);
                context.lineTo(-r, -3 * r);
                context.lineTo(r, -3 * r);
                context.lineTo(r, -r);
                context.lineTo(3 * r, -r);
                context.lineTo(3 * r, r);
                context.lineTo(r, r);
                context.lineTo(r, 3 * r);
                context.lineTo(-r, 3 * r);
                context.lineTo(-r, r);
                context.lineTo(-3 * r, r);
                context.closePath();
              }
            };
            var tan30 = Math.sqrt(1 / 3), tan30_2 = tan30 * 2;
            var diamond = {
              draw: function(context, size) {
                var y2 = Math.sqrt(size / tan30_2), x2 = y2 * tan30;
                context.moveTo(0, -y2);
                context.lineTo(x2, 0);
                context.lineTo(0, y2);
                context.lineTo(-x2, 0);
                context.closePath();
              }
            };
            var ka = 0.8908130915292852, kr = Math.sin(pi / 10) / Math.sin(7 * pi / 10), kx = Math.sin(tau / 10) * kr, ky = -Math.cos(tau / 10) * kr;
            var star = {
              draw: function(context, size) {
                var r = Math.sqrt(size * ka), x2 = kx * r, y2 = ky * r;
                context.moveTo(0, -r);
                context.lineTo(x2, y2);
                for (var i = 1; i < 5; ++i) {
                  var a2 = tau * i / 5, c2 = Math.cos(a2), s2 = Math.sin(a2);
                  context.lineTo(s2 * r, -c2 * r);
                  context.lineTo(c2 * x2 - s2 * y2, s2 * x2 + c2 * y2);
                }
                context.closePath();
              }
            };
            var square = {
              draw: function(context, size) {
                var w = Math.sqrt(size), x2 = -w / 2;
                context.rect(x2, x2, w, w);
              }
            };
            var sqrt3 = Math.sqrt(3);
            var triangle = {
              draw: function(context, size) {
                var y2 = -Math.sqrt(size / (sqrt3 * 3));
                context.moveTo(0, y2 * 2);
                context.lineTo(-sqrt3 * y2, -y2);
                context.lineTo(sqrt3 * y2, -y2);
                context.closePath();
              }
            };
            var c = -0.5, s = Math.sqrt(3) / 2, k = 1 / Math.sqrt(12), a = (k / 2 + 1) * 3;
            var wye = {
              draw: function(context, size) {
                var r = Math.sqrt(size / a), x0 = r / 2, y0 = r * k, x1 = x0, y1 = r * k + r, x2 = -x1, y2 = y1;
                context.moveTo(x0, y0);
                context.lineTo(x1, y1);
                context.lineTo(x2, y2);
                context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
                context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
                context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
                context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
                context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
                context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
                context.closePath();
              }
            };
            var symbols = [
              circle,
              cross,
              diamond,
              square,
              star,
              triangle,
              wye
            ];
            function symbol() {
              var type = constant(circle), size = constant(64), context = null;
              function symbol2() {
                var buffer;
                if (!context)
                  context = buffer = d3Path.path();
                type.apply(this, arguments).draw(context, +size.apply(this, arguments));
                if (buffer)
                  return context = null, buffer + "" || null;
              }
              symbol2.type = function(_) {
                return arguments.length ? (type = typeof _ === "function" ? _ : constant(_), symbol2) : type;
              };
              symbol2.size = function(_) {
                return arguments.length ? (size = typeof _ === "function" ? _ : constant(+_), symbol2) : size;
              };
              symbol2.context = function(_) {
                return arguments.length ? (context = _ == null ? null : _, symbol2) : context;
              };
              return symbol2;
            }
            function noop() {
            }
            function point(that, x2, y2) {
              that._context.bezierCurveTo((2 * that._x0 + that._x1) / 3, (2 * that._y0 + that._y1) / 3, (that._x0 + 2 * that._x1) / 3, (that._y0 + 2 * that._y1) / 3, (that._x0 + 4 * that._x1 + x2) / 6, (that._y0 + 4 * that._y1 + y2) / 6);
            }
            function Basis(context) {
              this._context = context;
            }
            Basis.prototype = {
              areaStart: function() {
                this._line = 0;
              },
              areaEnd: function() {
                this._line = NaN;
              },
              lineStart: function() {
                this._x0 = this._x1 = this._y0 = this._y1 = NaN;
                this._point = 0;
              },
              lineEnd: function() {
                switch (this._point) {
                  case 3:
                    point(this, this._x1, this._y1);
                  case 2:
                    this._context.lineTo(this._x1, this._y1);
                    break;
                }
                if (this._line || this._line !== 0 && this._point === 1)
                  this._context.closePath();
                this._line = 1 - this._line;
              },
              point: function(x2, y2) {
                x2 = +x2, y2 = +y2;
                switch (this._point) {
                  case 0:
                    this._point = 1;
                    this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
                    break;
                  case 1:
                    this._point = 2;
                    break;
                  case 2:
                    this._point = 3;
                    this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
                  default:
                    point(this, x2, y2);
                    break;
                }
                this._x0 = this._x1, this._x1 = x2;
                this._y0 = this._y1, this._y1 = y2;
              }
            };
            function basis(context) {
              return new Basis(context);
            }
            function BasisClosed(context) {
              this._context = context;
            }
            BasisClosed.prototype = {
              areaStart: noop,
              areaEnd: noop,
              lineStart: function() {
                this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
                this._point = 0;
              },
              lineEnd: function() {
                switch (this._point) {
                  case 1: {
                    this._context.moveTo(this._x2, this._y2);
                    this._context.closePath();
                    break;
                  }
                  case 2: {
                    this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
                    this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
                    this._context.closePath();
                    break;
                  }
                  case 3: {
                    this.point(this._x2, this._y2);
                    this.point(this._x3, this._y3);
                    this.point(this._x4, this._y4);
                    break;
                  }
                }
              },
              point: function(x2, y2) {
                x2 = +x2, y2 = +y2;
                switch (this._point) {
                  case 0:
                    this._point = 1;
                    this._x2 = x2, this._y2 = y2;
                    break;
                  case 1:
                    this._point = 2;
                    this._x3 = x2, this._y3 = y2;
                    break;
                  case 2:
                    this._point = 3;
                    this._x4 = x2, this._y4 = y2;
                    this._context.moveTo((this._x0 + 4 * this._x1 + x2) / 6, (this._y0 + 4 * this._y1 + y2) / 6);
                    break;
                  default:
                    point(this, x2, y2);
                    break;
                }
                this._x0 = this._x1, this._x1 = x2;
                this._y0 = this._y1, this._y1 = y2;
              }
            };
            function basisClosed(context) {
              return new BasisClosed(context);
            }
            function BasisOpen(context) {
              this._context = context;
            }
            BasisOpen.prototype = {
              areaStart: function() {
                this._line = 0;
              },
              areaEnd: function() {
                this._line = NaN;
              },
              lineStart: function() {
                this._x0 = this._x1 = this._y0 = this._y1 = NaN;
                this._point = 0;
              },
              lineEnd: function() {
                if (this._line || this._line !== 0 && this._point === 3)
                  this._context.closePath();
                this._line = 1 - this._line;
              },
              point: function(x2, y2) {
                x2 = +x2, y2 = +y2;
                switch (this._point) {
                  case 0:
                    this._point = 1;
                    break;
                  case 1:
                    this._point = 2;
                    break;
                  case 2:
                    this._point = 3;
                    var x0 = (this._x0 + 4 * this._x1 + x2) / 6, y0 = (this._y0 + 4 * this._y1 + y2) / 6;
                    this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0);
                    break;
                  case 3:
                    this._point = 4;
                  default:
                    point(this, x2, y2);
                    break;
                }
                this._x0 = this._x1, this._x1 = x2;
                this._y0 = this._y1, this._y1 = y2;
              }
            };
            function basisOpen(context) {
              return new BasisOpen(context);
            }
            function Bundle(context, beta) {
              this._basis = new Basis(context);
              this._beta = beta;
            }
            Bundle.prototype = {
              lineStart: function() {
                this._x = [];
                this._y = [];
                this._basis.lineStart();
              },
              lineEnd: function() {
                var x2 = this._x, y2 = this._y, j = x2.length - 1;
                if (j > 0) {
                  var x0 = x2[0], y0 = y2[0], dx = x2[j] - x0, dy = y2[j] - y0, i = -1, t;
                  while (++i <= j) {
                    t = i / j;
                    this._basis.point(this._beta * x2[i] + (1 - this._beta) * (x0 + t * dx), this._beta * y2[i] + (1 - this._beta) * (y0 + t * dy));
                  }
                }
                this._x = this._y = null;
                this._basis.lineEnd();
              },
              point: function(x2, y2) {
                this._x.push(+x2);
                this._y.push(+y2);
              }
            };
            var bundle = function custom(beta) {
              function bundle2(context) {
                return beta === 1 ? new Basis(context) : new Bundle(context, beta);
              }
              bundle2.beta = function(beta2) {
                return custom(+beta2);
              };
              return bundle2;
            }(0.85);
            function point$1(that, x2, y2) {
              that._context.bezierCurveTo(that._x1 + that._k * (that._x2 - that._x0), that._y1 + that._k * (that._y2 - that._y0), that._x2 + that._k * (that._x1 - x2), that._y2 + that._k * (that._y1 - y2), that._x2, that._y2);
            }
            function Cardinal(context, tension) {
              this._context = context;
              this._k = (1 - tension) / 6;
            }
            Cardinal.prototype = {
              areaStart: function() {
                this._line = 0;
              },
              areaEnd: function() {
                this._line = NaN;
              },
              lineStart: function() {
                this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
                this._point = 0;
              },
              lineEnd: function() {
                switch (this._point) {
                  case 2:
                    this._context.lineTo(this._x2, this._y2);
                    break;
                  case 3:
                    point$1(this, this._x1, this._y1);
                    break;
                }
                if (this._line || this._line !== 0 && this._point === 1)
                  this._context.closePath();
                this._line = 1 - this._line;
              },
              point: function(x2, y2) {
                x2 = +x2, y2 = +y2;
                switch (this._point) {
                  case 0:
                    this._point = 1;
                    this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
                    break;
                  case 1:
                    this._point = 2;
                    this._x1 = x2, this._y1 = y2;
                    break;
                  case 2:
                    this._point = 3;
                  default:
                    point$1(this, x2, y2);
                    break;
                }
                this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
                this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
              }
            };
            var cardinal = function custom(tension) {
              function cardinal2(context) {
                return new Cardinal(context, tension);
              }
              cardinal2.tension = function(tension2) {
                return custom(+tension2);
              };
              return cardinal2;
            }(0);
            function CardinalClosed(context, tension) {
              this._context = context;
              this._k = (1 - tension) / 6;
            }
            CardinalClosed.prototype = {
              areaStart: noop,
              areaEnd: noop,
              lineStart: function() {
                this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
                this._point = 0;
              },
              lineEnd: function() {
                switch (this._point) {
                  case 1: {
                    this._context.moveTo(this._x3, this._y3);
                    this._context.closePath();
                    break;
                  }
                  case 2: {
                    this._context.lineTo(this._x3, this._y3);
                    this._context.closePath();
                    break;
                  }
                  case 3: {
                    this.point(this._x3, this._y3);
                    this.point(this._x4, this._y4);
                    this.point(this._x5, this._y5);
                    break;
                  }
                }
              },
              point: function(x2, y2) {
                x2 = +x2, y2 = +y2;
                switch (this._point) {
                  case 0:
                    this._point = 1;
                    this._x3 = x2, this._y3 = y2;
                    break;
                  case 1:
                    this._point = 2;
                    this._context.moveTo(this._x4 = x2, this._y4 = y2);
                    break;
                  case 2:
                    this._point = 3;
                    this._x5 = x2, this._y5 = y2;
                    break;
                  default:
                    point$1(this, x2, y2);
                    break;
                }
                this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
                this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
              }
            };
            var cardinalClosed = function custom(tension) {
              function cardinal2(context) {
                return new CardinalClosed(context, tension);
              }
              cardinal2.tension = function(tension2) {
                return custom(+tension2);
              };
              return cardinal2;
            }(0);
            function CardinalOpen(context, tension) {
              this._context = context;
              this._k = (1 - tension) / 6;
            }
            CardinalOpen.prototype = {
              areaStart: function() {
                this._line = 0;
              },
              areaEnd: function() {
                this._line = NaN;
              },
              lineStart: function() {
                this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
                this._point = 0;
              },
              lineEnd: function() {
                if (this._line || this._line !== 0 && this._point === 3)
                  this._context.closePath();
                this._line = 1 - this._line;
              },
              point: function(x2, y2) {
                x2 = +x2, y2 = +y2;
                switch (this._point) {
                  case 0:
                    this._point = 1;
                    break;
                  case 1:
                    this._point = 2;
                    break;
                  case 2:
                    this._point = 3;
                    this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
                    break;
                  case 3:
                    this._point = 4;
                  default:
                    point$1(this, x2, y2);
                    break;
                }
                this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
                this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
              }
            };
            var cardinalOpen = function custom(tension) {
              function cardinal2(context) {
                return new CardinalOpen(context, tension);
              }
              cardinal2.tension = function(tension2) {
                return custom(+tension2);
              };
              return cardinal2;
            }(0);
            function point$2(that, x2, y2) {
              var x1 = that._x1, y1 = that._y1, x22 = that._x2, y22 = that._y2;
              if (that._l01_a > epsilon) {
                var a2 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n = 3 * that._l01_a * (that._l01_a + that._l12_a);
                x1 = (x1 * a2 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
                y1 = (y1 * a2 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
              }
              if (that._l23_a > epsilon) {
                var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m = 3 * that._l23_a * (that._l23_a + that._l12_a);
                x22 = (x22 * b + that._x1 * that._l23_2a - x2 * that._l12_2a) / m;
                y22 = (y22 * b + that._y1 * that._l23_2a - y2 * that._l12_2a) / m;
              }
              that._context.bezierCurveTo(x1, y1, x22, y22, that._x2, that._y2);
            }
            function CatmullRom(context, alpha) {
              this._context = context;
              this._alpha = alpha;
            }
            CatmullRom.prototype = {
              areaStart: function() {
                this._line = 0;
              },
              areaEnd: function() {
                this._line = NaN;
              },
              lineStart: function() {
                this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
                this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
              },
              lineEnd: function() {
                switch (this._point) {
                  case 2:
                    this._context.lineTo(this._x2, this._y2);
                    break;
                  case 3:
                    this.point(this._x2, this._y2);
                    break;
                }
                if (this._line || this._line !== 0 && this._point === 1)
                  this._context.closePath();
                this._line = 1 - this._line;
              },
              point: function(x2, y2) {
                x2 = +x2, y2 = +y2;
                if (this._point) {
                  var x23 = this._x2 - x2, y23 = this._y2 - y2;
                  this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
                }
                switch (this._point) {
                  case 0:
                    this._point = 1;
                    this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
                    break;
                  case 1:
                    this._point = 2;
                    break;
                  case 2:
                    this._point = 3;
                  default:
                    point$2(this, x2, y2);
                    break;
                }
                this._l01_a = this._l12_a, this._l12_a = this._l23_a;
                this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
                this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
                this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
              }
            };
            var catmullRom = function custom(alpha) {
              function catmullRom2(context) {
                return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
              }
              catmullRom2.alpha = function(alpha2) {
                return custom(+alpha2);
              };
              return catmullRom2;
            }(0.5);
            function CatmullRomClosed(context, alpha) {
              this._context = context;
              this._alpha = alpha;
            }
            CatmullRomClosed.prototype = {
              areaStart: noop,
              areaEnd: noop,
              lineStart: function() {
                this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
                this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
              },
              lineEnd: function() {
                switch (this._point) {
                  case 1: {
                    this._context.moveTo(this._x3, this._y3);
                    this._context.closePath();
                    break;
                  }
                  case 2: {
                    this._context.lineTo(this._x3, this._y3);
                    this._context.closePath();
                    break;
                  }
                  case 3: {
                    this.point(this._x3, this._y3);
                    this.point(this._x4, this._y4);
                    this.point(this._x5, this._y5);
                    break;
                  }
                }
              },
              point: function(x2, y2) {
                x2 = +x2, y2 = +y2;
                if (this._point) {
                  var x23 = this._x2 - x2, y23 = this._y2 - y2;
                  this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
                }
                switch (this._point) {
                  case 0:
                    this._point = 1;
                    this._x3 = x2, this._y3 = y2;
                    break;
                  case 1:
                    this._point = 2;
                    this._context.moveTo(this._x4 = x2, this._y4 = y2);
                    break;
                  case 2:
                    this._point = 3;
                    this._x5 = x2, this._y5 = y2;
                    break;
                  default:
                    point$2(this, x2, y2);
                    break;
                }
                this._l01_a = this._l12_a, this._l12_a = this._l23_a;
                this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
                this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
                this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
              }
            };
            var catmullRomClosed = function custom(alpha) {
              function catmullRom2(context) {
                return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
              }
              catmullRom2.alpha = function(alpha2) {
                return custom(+alpha2);
              };
              return catmullRom2;
            }(0.5);
            function CatmullRomOpen(context, alpha) {
              this._context = context;
              this._alpha = alpha;
            }
            CatmullRomOpen.prototype = {
              areaStart: function() {
                this._line = 0;
              },
              areaEnd: function() {
                this._line = NaN;
              },
              lineStart: function() {
                this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
                this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
              },
              lineEnd: function() {
                if (this._line || this._line !== 0 && this._point === 3)
                  this._context.closePath();
                this._line = 1 - this._line;
              },
              point: function(x2, y2) {
                x2 = +x2, y2 = +y2;
                if (this._point) {
                  var x23 = this._x2 - x2, y23 = this._y2 - y2;
                  this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
                }
                switch (this._point) {
                  case 0:
                    this._point = 1;
                    break;
                  case 1:
                    this._point = 2;
                    break;
                  case 2:
                    this._point = 3;
                    this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
                    break;
                  case 3:
                    this._point = 4;
                  default:
                    point$2(this, x2, y2);
                    break;
                }
                this._l01_a = this._l12_a, this._l12_a = this._l23_a;
                this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
                this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
                this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
              }
            };
            var catmullRomOpen = function custom(alpha) {
              function catmullRom2(context) {
                return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
              }
              catmullRom2.alpha = function(alpha2) {
                return custom(+alpha2);
              };
              return catmullRom2;
            }(0.5);
            function LinearClosed(context) {
              this._context = context;
            }
            LinearClosed.prototype = {
              areaStart: noop,
              areaEnd: noop,
              lineStart: function() {
                this._point = 0;
              },
              lineEnd: function() {
                if (this._point)
                  this._context.closePath();
              },
              point: function(x2, y2) {
                x2 = +x2, y2 = +y2;
                if (this._point)
                  this._context.lineTo(x2, y2);
                else
                  this._point = 1, this._context.moveTo(x2, y2);
              }
            };
            function linearClosed(context) {
              return new LinearClosed(context);
            }
            function sign(x2) {
              return x2 < 0 ? -1 : 1;
            }
            function slope3(that, x2, y2) {
              var h0 = that._x1 - that._x0, h1 = x2 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0), p = (s0 * h1 + s1 * h0) / (h0 + h1);
              return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
            }
            function slope2(that, t) {
              var h = that._x1 - that._x0;
              return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
            }
            function point$3(that, t0, t1) {
              var x0 = that._x0, y0 = that._y0, x1 = that._x1, y1 = that._y1, dx = (x1 - x0) / 3;
              that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
            }
            function MonotoneX(context) {
              this._context = context;
            }
            MonotoneX.prototype = {
              areaStart: function() {
                this._line = 0;
              },
              areaEnd: function() {
                this._line = NaN;
              },
              lineStart: function() {
                this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
                this._point = 0;
              },
              lineEnd: function() {
                switch (this._point) {
                  case 2:
                    this._context.lineTo(this._x1, this._y1);
                    break;
                  case 3:
                    point$3(this, this._t0, slope2(this, this._t0));
                    break;
                }
                if (this._line || this._line !== 0 && this._point === 1)
                  this._context.closePath();
                this._line = 1 - this._line;
              },
              point: function(x2, y2) {
                var t1 = NaN;
                x2 = +x2, y2 = +y2;
                if (x2 === this._x1 && y2 === this._y1)
                  return;
                switch (this._point) {
                  case 0:
                    this._point = 1;
                    this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
                    break;
                  case 1:
                    this._point = 2;
                    break;
                  case 2:
                    this._point = 3;
                    point$3(this, slope2(this, t1 = slope3(this, x2, y2)), t1);
                    break;
                  default:
                    point$3(this, this._t0, t1 = slope3(this, x2, y2));
                    break;
                }
                this._x0 = this._x1, this._x1 = x2;
                this._y0 = this._y1, this._y1 = y2;
                this._t0 = t1;
              }
            };
            function MonotoneY(context) {
              this._context = new ReflectContext(context);
            }
            (MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x2, y2) {
              MonotoneX.prototype.point.call(this, y2, x2);
            };
            function ReflectContext(context) {
              this._context = context;
            }
            ReflectContext.prototype = {
              moveTo: function(x2, y2) {
                this._context.moveTo(y2, x2);
              },
              closePath: function() {
                this._context.closePath();
              },
              lineTo: function(x2, y2) {
                this._context.lineTo(y2, x2);
              },
              bezierCurveTo: function(x1, y1, x2, y2, x3, y3) {
                this._context.bezierCurveTo(y1, x1, y2, x2, y3, x3);
              }
            };
            function monotoneX(context) {
              return new MonotoneX(context);
            }
            function monotoneY(context) {
              return new MonotoneY(context);
            }
            function Natural(context) {
              this._context = context;
            }
            Natural.prototype = {
              areaStart: function() {
                this._line = 0;
              },
              areaEnd: function() {
                this._line = NaN;
              },
              lineStart: function() {
                this._x = [];
                this._y = [];
              },
              lineEnd: function() {
                var x2 = this._x, y2 = this._y, n = x2.length;
                if (n) {
                  this._line ? this._context.lineTo(x2[0], y2[0]) : this._context.moveTo(x2[0], y2[0]);
                  if (n === 2) {
                    this._context.lineTo(x2[1], y2[1]);
                  } else {
                    var px = controlPoints(x2), py = controlPoints(y2);
                    for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
                      this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x2[i1], y2[i1]);
                    }
                  }
                }
                if (this._line || this._line !== 0 && n === 1)
                  this._context.closePath();
                this._line = 1 - this._line;
                this._x = this._y = null;
              },
              point: function(x2, y2) {
                this._x.push(+x2);
                this._y.push(+y2);
              }
            };
            function controlPoints(x2) {
              var i, n = x2.length - 1, m, a2 = new Array(n), b = new Array(n), r = new Array(n);
              a2[0] = 0, b[0] = 2, r[0] = x2[0] + 2 * x2[1];
              for (i = 1; i < n - 1; ++i)
                a2[i] = 1, b[i] = 4, r[i] = 4 * x2[i] + 2 * x2[i + 1];
              a2[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x2[n - 1] + x2[n];
              for (i = 1; i < n; ++i)
                m = a2[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
              a2[n - 1] = r[n - 1] / b[n - 1];
              for (i = n - 2; i >= 0; --i)
                a2[i] = (r[i] - a2[i + 1]) / b[i];
              b[n - 1] = (x2[n] + a2[n - 1]) / 2;
              for (i = 0; i < n - 1; ++i)
                b[i] = 2 * x2[i + 1] - a2[i + 1];
              return [a2, b];
            }
            function natural(context) {
              return new Natural(context);
            }
            function Step(context, t) {
              this._context = context;
              this._t = t;
            }
            Step.prototype = {
              areaStart: function() {
                this._line = 0;
              },
              areaEnd: function() {
                this._line = NaN;
              },
              lineStart: function() {
                this._x = this._y = NaN;
                this._point = 0;
              },
              lineEnd: function() {
                if (0 < this._t && this._t < 1 && this._point === 2)
                  this._context.lineTo(this._x, this._y);
                if (this._line || this._line !== 0 && this._point === 1)
                  this._context.closePath();
                if (this._line >= 0)
                  this._t = 1 - this._t, this._line = 1 - this._line;
              },
              point: function(x2, y2) {
                x2 = +x2, y2 = +y2;
                switch (this._point) {
                  case 0:
                    this._point = 1;
                    this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
                    break;
                  case 1:
                    this._point = 2;
                  default: {
                    if (this._t <= 0) {
                      this._context.lineTo(this._x, y2);
                      this._context.lineTo(x2, y2);
                    } else {
                      var x1 = this._x * (1 - this._t) + x2 * this._t;
                      this._context.lineTo(x1, this._y);
                      this._context.lineTo(x1, y2);
                    }
                    break;
                  }
                }
                this._x = x2, this._y = y2;
              }
            };
            function step(context) {
              return new Step(context, 0.5);
            }
            function stepBefore(context) {
              return new Step(context, 0);
            }
            function stepAfter(context) {
              return new Step(context, 1);
            }
            function none(series, order) {
              if (!((n = series.length) > 1))
                return;
              for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
                s0 = s1, s1 = series[order[i]];
                for (j = 0; j < m; ++j) {
                  s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
                }
              }
            }
            function none$1(series) {
              var n = series.length, o = new Array(n);
              while (--n >= 0)
                o[n] = n;
              return o;
            }
            function stackValue(d, key) {
              return d[key];
            }
            function stack() {
              var keys = constant([]), order = none$1, offset = none, value = stackValue;
              function stack2(data) {
                var kz = keys.apply(this, arguments), i, m = data.length, n = kz.length, sz = new Array(n), oz;
                for (i = 0; i < n; ++i) {
                  for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {
                    si[j] = sij = [0, +value(data[j], ki, j, data)];
                    sij.data = data[j];
                  }
                  si.key = ki;
                }
                for (i = 0, oz = order(sz); i < n; ++i) {
                  sz[oz[i]].index = i;
                }
                offset(sz, oz);
                return sz;
              }
              stack2.keys = function(_) {
                return arguments.length ? (keys = typeof _ === "function" ? _ : constant(slice.call(_)), stack2) : keys;
              };
              stack2.value = function(_) {
                return arguments.length ? (value = typeof _ === "function" ? _ : constant(+_), stack2) : value;
              };
              stack2.order = function(_) {
                return arguments.length ? (order = _ == null ? none$1 : typeof _ === "function" ? _ : constant(slice.call(_)), stack2) : order;
              };
              stack2.offset = function(_) {
                return arguments.length ? (offset = _ == null ? none : _, stack2) : offset;
              };
              return stack2;
            }
            function expand(series, order) {
              if (!((n = series.length) > 0))
                return;
              for (var i, n, j = 0, m = series[0].length, y2; j < m; ++j) {
                for (y2 = i = 0; i < n; ++i)
                  y2 += series[i][j][1] || 0;
                if (y2)
                  for (i = 0; i < n; ++i)
                    series[i][j][1] /= y2;
              }
              none(series, order);
            }
            function diverging(series, order) {
              if (!((n = series.length) > 0))
                return;
              for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {
                for (yp = yn = 0, i = 0; i < n; ++i) {
                  if ((dy = (d = series[order[i]][j])[1] - d[0]) > 0) {
                    d[0] = yp, d[1] = yp += dy;
                  } else if (dy < 0) {
                    d[1] = yn, d[0] = yn += dy;
                  } else {
                    d[0] = 0, d[1] = dy;
                  }
                }
              }
            }
            function silhouette(series, order) {
              if (!((n = series.length) > 0))
                return;
              for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
                for (var i = 0, y2 = 0; i < n; ++i)
                  y2 += series[i][j][1] || 0;
                s0[j][1] += s0[j][0] = -y2 / 2;
              }
              none(series, order);
            }
            function wiggle(series, order) {
              if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0))
                return;
              for (var y2 = 0, j = 1, s0, m, n; j < m; ++j) {
                for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
                  var si = series[order[i]], sij0 = si[j][1] || 0, sij1 = si[j - 1][1] || 0, s3 = (sij0 - sij1) / 2;
                  for (var k2 = 0; k2 < i; ++k2) {
                    var sk = series[order[k2]], skj0 = sk[j][1] || 0, skj1 = sk[j - 1][1] || 0;
                    s3 += skj0 - skj1;
                  }
                  s1 += sij0, s2 += s3 * sij0;
                }
                s0[j - 1][1] += s0[j - 1][0] = y2;
                if (s1)
                  y2 -= s2 / s1;
              }
              s0[j - 1][1] += s0[j - 1][0] = y2;
              none(series, order);
            }
            function appearance(series) {
              var peaks = series.map(peak);
              return none$1(series).sort(function(a2, b) {
                return peaks[a2] - peaks[b];
              });
            }
            function peak(series) {
              var i = -1, j = 0, n = series.length, vi, vj = -Infinity;
              while (++i < n)
                if ((vi = +series[i][1]) > vj)
                  vj = vi, j = i;
              return j;
            }
            function ascending(series) {
              var sums = series.map(sum);
              return none$1(series).sort(function(a2, b) {
                return sums[a2] - sums[b];
              });
            }
            function sum(series) {
              var s2 = 0, i = -1, n = series.length, v;
              while (++i < n)
                if (v = +series[i][1])
                  s2 += v;
              return s2;
            }
            function descending$1(series) {
              return ascending(series).reverse();
            }
            function insideOut(series) {
              var n = series.length, i, j, sums = series.map(sum), order = appearance(series), top = 0, bottom = 0, tops = [], bottoms = [];
              for (i = 0; i < n; ++i) {
                j = order[i];
                if (top < bottom) {
                  top += sums[j];
                  tops.push(j);
                } else {
                  bottom += sums[j];
                  bottoms.push(j);
                }
              }
              return bottoms.reverse().concat(tops);
            }
            function reverse(series) {
              return none$1(series).reverse();
            }
            exports3.arc = arc;
            exports3.area = area;
            exports3.areaRadial = areaRadial;
            exports3.curveBasis = basis;
            exports3.curveBasisClosed = basisClosed;
            exports3.curveBasisOpen = basisOpen;
            exports3.curveBundle = bundle;
            exports3.curveCardinal = cardinal;
            exports3.curveCardinalClosed = cardinalClosed;
            exports3.curveCardinalOpen = cardinalOpen;
            exports3.curveCatmullRom = catmullRom;
            exports3.curveCatmullRomClosed = catmullRomClosed;
            exports3.curveCatmullRomOpen = catmullRomOpen;
            exports3.curveLinear = curveLinear;
            exports3.curveLinearClosed = linearClosed;
            exports3.curveMonotoneX = monotoneX;
            exports3.curveMonotoneY = monotoneY;
            exports3.curveNatural = natural;
            exports3.curveStep = step;
            exports3.curveStepAfter = stepAfter;
            exports3.curveStepBefore = stepBefore;
            exports3.line = line;
            exports3.lineRadial = lineRadial$1;
            exports3.linkHorizontal = linkHorizontal;
            exports3.linkRadial = linkRadial;
            exports3.linkVertical = linkVertical;
            exports3.pie = pie;
            exports3.pointRadial = pointRadial;
            exports3.radialArea = areaRadial;
            exports3.radialLine = lineRadial$1;
            exports3.stack = stack;
            exports3.stackOffsetDiverging = diverging;
            exports3.stackOffsetExpand = expand;
            exports3.stackOffsetNone = none;
            exports3.stackOffsetSilhouette = silhouette;
            exports3.stackOffsetWiggle = wiggle;
            exports3.stackOrderAppearance = appearance;
            exports3.stackOrderAscending = ascending;
            exports3.stackOrderDescending = descending$1;
            exports3.stackOrderInsideOut = insideOut;
            exports3.stackOrderNone = none$1;
            exports3.stackOrderReverse = reverse;
            exports3.symbol = symbol;
            exports3.symbolCircle = circle;
            exports3.symbolCross = cross;
            exports3.symbolDiamond = diamond;
            exports3.symbolSquare = square;
            exports3.symbolStar = star;
            exports3.symbolTriangle = triangle;
            exports3.symbolWye = wye;
            exports3.symbols = symbols;
            Object.defineProperty(exports3, "__esModule", { value: true });
          });
        },
        "./node_modules/_d3-voronoi@1.1.4@d3-voronoi/dist/d3-voronoi.js": function(module2, exports2, __webpack_require__) {
          (function(global, factory) {
            true ? factory(exports2) : void 0;
          })(this, function(exports3) {
            "use strict";
            function constant(x2) {
              return function() {
                return x2;
              };
            }
            function x(d) {
              return d[0];
            }
            function y(d) {
              return d[1];
            }
            function RedBlackTree() {
              this._ = null;
            }
            function RedBlackNode(node) {
              node.U = node.C = node.L = node.R = node.P = node.N = null;
            }
            RedBlackTree.prototype = {
              constructor: RedBlackTree,
              insert: function(after, node) {
                var parent, grandpa, uncle;
                if (after) {
                  node.P = after;
                  node.N = after.N;
                  if (after.N)
                    after.N.P = node;
                  after.N = node;
                  if (after.R) {
                    after = after.R;
                    while (after.L)
                      after = after.L;
                    after.L = node;
                  } else {
                    after.R = node;
                  }
                  parent = after;
                } else if (this._) {
                  after = RedBlackFirst(this._);
                  node.P = null;
                  node.N = after;
                  after.P = after.L = node;
                  parent = after;
                } else {
                  node.P = node.N = null;
                  this._ = node;
                  parent = null;
                }
                node.L = node.R = null;
                node.U = parent;
                node.C = true;
                after = node;
                while (parent && parent.C) {
                  grandpa = parent.U;
                  if (parent === grandpa.L) {
                    uncle = grandpa.R;
                    if (uncle && uncle.C) {
                      parent.C = uncle.C = false;
                      grandpa.C = true;
                      after = grandpa;
                    } else {
                      if (after === parent.R) {
                        RedBlackRotateLeft(this, parent);
                        after = parent;
                        parent = after.U;
                      }
                      parent.C = false;
                      grandpa.C = true;
                      RedBlackRotateRight(this, grandpa);
                    }
                  } else {
                    uncle = grandpa.L;
                    if (uncle && uncle.C) {
                      parent.C = uncle.C = false;
                      grandpa.C = true;
                      after = grandpa;
                    } else {
                      if (after === parent.L) {
                        RedBlackRotateRight(this, parent);
                        after = parent;
                        parent = after.U;
                      }
                      parent.C = false;
                      grandpa.C = true;
                      RedBlackRotateLeft(this, grandpa);
                    }
                  }
                  parent = after.U;
                }
                this._.C = false;
              },
              remove: function(node) {
                if (node.N)
                  node.N.P = node.P;
                if (node.P)
                  node.P.N = node.N;
                node.N = node.P = null;
                var parent = node.U, sibling, left = node.L, right = node.R, next, red;
                if (!left)
                  next = right;
                else if (!right)
                  next = left;
                else
                  next = RedBlackFirst(right);
                if (parent) {
                  if (parent.L === node)
                    parent.L = next;
                  else
                    parent.R = next;
                } else {
                  this._ = next;
                }
                if (left && right) {
                  red = next.C;
                  next.C = node.C;
                  next.L = left;
                  left.U = next;
                  if (next !== right) {
                    parent = next.U;
                    next.U = node.U;
                    node = next.R;
                    parent.L = node;
                    next.R = right;
                    right.U = next;
                  } else {
                    next.U = parent;
                    parent = next;
                    node = next.R;
                  }
                } else {
                  red = node.C;
                  node = next;
                }
                if (node)
                  node.U = parent;
                if (red)
                  return;
                if (node && node.C) {
                  node.C = false;
                  return;
                }
                do {
                  if (node === this._)
                    break;
                  if (node === parent.L) {
                    sibling = parent.R;
                    if (sibling.C) {
                      sibling.C = false;
                      parent.C = true;
                      RedBlackRotateLeft(this, parent);
                      sibling = parent.R;
                    }
                    if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                      if (!sibling.R || !sibling.R.C) {
                        sibling.L.C = false;
                        sibling.C = true;
                        RedBlackRotateRight(this, sibling);
                        sibling = parent.R;
                      }
                      sibling.C = parent.C;
                      parent.C = sibling.R.C = false;
                      RedBlackRotateLeft(this, parent);
                      node = this._;
                      break;
                    }
                  } else {
                    sibling = parent.L;
                    if (sibling.C) {
                      sibling.C = false;
                      parent.C = true;
                      RedBlackRotateRight(this, parent);
                      sibling = parent.L;
                    }
                    if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                      if (!sibling.L || !sibling.L.C) {
                        sibling.R.C = false;
                        sibling.C = true;
                        RedBlackRotateLeft(this, sibling);
                        sibling = parent.L;
                      }
                      sibling.C = parent.C;
                      parent.C = sibling.L.C = false;
                      RedBlackRotateRight(this, parent);
                      node = this._;
                      break;
                    }
                  }
                  sibling.C = true;
                  node = parent;
                  parent = parent.U;
                } while (!node.C);
                if (node)
                  node.C = false;
              }
            };
            function RedBlackRotateLeft(tree, node) {
              var p = node, q = node.R, parent = p.U;
              if (parent) {
                if (parent.L === p)
                  parent.L = q;
                else
                  parent.R = q;
              } else {
                tree._ = q;
              }
              q.U = parent;
              p.U = q;
              p.R = q.L;
              if (p.R)
                p.R.U = p;
              q.L = p;
            }
            function RedBlackRotateRight(tree, node) {
              var p = node, q = node.L, parent = p.U;
              if (parent) {
                if (parent.L === p)
                  parent.L = q;
                else
                  parent.R = q;
              } else {
                tree._ = q;
              }
              q.U = parent;
              p.U = q;
              p.L = q.R;
              if (p.L)
                p.L.U = p;
              q.R = p;
            }
            function RedBlackFirst(node) {
              while (node.L)
                node = node.L;
              return node;
            }
            function createEdge(left, right, v0, v1) {
              var edge = [null, null], index = edges.push(edge) - 1;
              edge.left = left;
              edge.right = right;
              if (v0)
                setEdgeEnd(edge, left, right, v0);
              if (v1)
                setEdgeEnd(edge, right, left, v1);
              cells[left.index].halfedges.push(index);
              cells[right.index].halfedges.push(index);
              return edge;
            }
            function createBorderEdge(left, v0, v1) {
              var edge = [v0, v1];
              edge.left = left;
              return edge;
            }
            function setEdgeEnd(edge, left, right, vertex) {
              if (!edge[0] && !edge[1]) {
                edge[0] = vertex;
                edge.left = left;
                edge.right = right;
              } else if (edge.left === right) {
                edge[1] = vertex;
              } else {
                edge[0] = vertex;
              }
            }
            function clipEdge(edge, x0, y0, x1, y1) {
              var a = edge[0], b = edge[1], ax = a[0], ay = a[1], bx = b[0], by = b[1], t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
              r = x0 - ax;
              if (!dx && r > 0)
                return;
              r /= dx;
              if (dx < 0) {
                if (r < t0)
                  return;
                if (r < t1)
                  t1 = r;
              } else if (dx > 0) {
                if (r > t1)
                  return;
                if (r > t0)
                  t0 = r;
              }
              r = x1 - ax;
              if (!dx && r < 0)
                return;
              r /= dx;
              if (dx < 0) {
                if (r > t1)
                  return;
                if (r > t0)
                  t0 = r;
              } else if (dx > 0) {
                if (r < t0)
                  return;
                if (r < t1)
                  t1 = r;
              }
              r = y0 - ay;
              if (!dy && r > 0)
                return;
              r /= dy;
              if (dy < 0) {
                if (r < t0)
                  return;
                if (r < t1)
                  t1 = r;
              } else if (dy > 0) {
                if (r > t1)
                  return;
                if (r > t0)
                  t0 = r;
              }
              r = y1 - ay;
              if (!dy && r < 0)
                return;
              r /= dy;
              if (dy < 0) {
                if (r > t1)
                  return;
                if (r > t0)
                  t0 = r;
              } else if (dy > 0) {
                if (r < t0)
                  return;
                if (r < t1)
                  t1 = r;
              }
              if (!(t0 > 0) && !(t1 < 1))
                return true;
              if (t0 > 0)
                edge[0] = [ax + t0 * dx, ay + t0 * dy];
              if (t1 < 1)
                edge[1] = [ax + t1 * dx, ay + t1 * dy];
              return true;
            }
            function connectEdge(edge, x0, y0, x1, y1) {
              var v1 = edge[1];
              if (v1)
                return true;
              var v0 = edge[0], left = edge.left, right = edge.right, lx = left[0], ly = left[1], rx = right[0], ry = right[1], fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
              if (ry === ly) {
                if (fx < x0 || fx >= x1)
                  return;
                if (lx > rx) {
                  if (!v0)
                    v0 = [fx, y0];
                  else if (v0[1] >= y1)
                    return;
                  v1 = [fx, y1];
                } else {
                  if (!v0)
                    v0 = [fx, y1];
                  else if (v0[1] < y0)
                    return;
                  v1 = [fx, y0];
                }
              } else {
                fm = (lx - rx) / (ry - ly);
                fb = fy - fm * fx;
                if (fm < -1 || fm > 1) {
                  if (lx > rx) {
                    if (!v0)
                      v0 = [(y0 - fb) / fm, y0];
                    else if (v0[1] >= y1)
                      return;
                    v1 = [(y1 - fb) / fm, y1];
                  } else {
                    if (!v0)
                      v0 = [(y1 - fb) / fm, y1];
                    else if (v0[1] < y0)
                      return;
                    v1 = [(y0 - fb) / fm, y0];
                  }
                } else {
                  if (ly < ry) {
                    if (!v0)
                      v0 = [x0, fm * x0 + fb];
                    else if (v0[0] >= x1)
                      return;
                    v1 = [x1, fm * x1 + fb];
                  } else {
                    if (!v0)
                      v0 = [x1, fm * x1 + fb];
                    else if (v0[0] < x0)
                      return;
                    v1 = [x0, fm * x0 + fb];
                  }
                }
              }
              edge[0] = v0;
              edge[1] = v1;
              return true;
            }
            function clipEdges(x0, y0, x1, y1) {
              var i = edges.length, edge;
              while (i--) {
                if (!connectEdge(edge = edges[i], x0, y0, x1, y1) || !clipEdge(edge, x0, y0, x1, y1) || !(Math.abs(edge[0][0] - edge[1][0]) > epsilon || Math.abs(edge[0][1] - edge[1][1]) > epsilon)) {
                  delete edges[i];
                }
              }
            }
            function createCell(site) {
              return cells[site.index] = {
                site,
                halfedges: []
              };
            }
            function cellHalfedgeAngle(cell, edge) {
              var site = cell.site, va = edge.left, vb = edge.right;
              if (site === vb)
                vb = va, va = site;
              if (vb)
                return Math.atan2(vb[1] - va[1], vb[0] - va[0]);
              if (site === va)
                va = edge[1], vb = edge[0];
              else
                va = edge[0], vb = edge[1];
              return Math.atan2(va[0] - vb[0], vb[1] - va[1]);
            }
            function cellHalfedgeStart(cell, edge) {
              return edge[+(edge.left !== cell.site)];
            }
            function cellHalfedgeEnd(cell, edge) {
              return edge[+(edge.left === cell.site)];
            }
            function sortCellHalfedges() {
              for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {
                if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {
                  var index = new Array(m), array = new Array(m);
                  for (j = 0; j < m; ++j)
                    index[j] = j, array[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);
                  index.sort(function(i2, j2) {
                    return array[j2] - array[i2];
                  });
                  for (j = 0; j < m; ++j)
                    array[j] = halfedges[index[j]];
                  for (j = 0; j < m; ++j)
                    halfedges[j] = array[j];
                }
              }
            }
            function clipCells(x0, y0, x1, y1) {
              var nCells = cells.length, iCell, cell, site, iHalfedge, halfedges, nHalfedges, start, startX, startY, end, endX, endY, cover = true;
              for (iCell = 0; iCell < nCells; ++iCell) {
                if (cell = cells[iCell]) {
                  site = cell.site;
                  halfedges = cell.halfedges;
                  iHalfedge = halfedges.length;
                  while (iHalfedge--) {
                    if (!edges[halfedges[iHalfedge]]) {
                      halfedges.splice(iHalfedge, 1);
                    }
                  }
                  iHalfedge = 0, nHalfedges = halfedges.length;
                  while (iHalfedge < nHalfedges) {
                    end = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];
                    start = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];
                    if (Math.abs(endX - startX) > epsilon || Math.abs(endY - startY) > epsilon) {
                      halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(site, end, Math.abs(endX - x0) < epsilon && y1 - endY > epsilon ? [x0, Math.abs(startX - x0) < epsilon ? startY : y1] : Math.abs(endY - y1) < epsilon && x1 - endX > epsilon ? [Math.abs(startY - y1) < epsilon ? startX : x1, y1] : Math.abs(endX - x1) < epsilon && endY - y0 > epsilon ? [x1, Math.abs(startX - x1) < epsilon ? startY : y0] : Math.abs(endY - y0) < epsilon && endX - x0 > epsilon ? [Math.abs(startY - y0) < epsilon ? startX : x0, y0] : null)) - 1);
                      ++nHalfedges;
                    }
                  }
                  if (nHalfedges)
                    cover = false;
                }
              }
              if (cover) {
                var dx, dy, d2, dc = Infinity;
                for (iCell = 0, cover = null; iCell < nCells; ++iCell) {
                  if (cell = cells[iCell]) {
                    site = cell.site;
                    dx = site[0] - x0;
                    dy = site[1] - y0;
                    d2 = dx * dx + dy * dy;
                    if (d2 < dc)
                      dc = d2, cover = cell;
                  }
                }
                if (cover) {
                  var v00 = [x0, y0], v01 = [x0, y1], v11 = [x1, y1], v10 = [x1, y0];
                  cover.halfedges.push(edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1, edges.push(createBorderEdge(site, v01, v11)) - 1, edges.push(createBorderEdge(site, v11, v10)) - 1, edges.push(createBorderEdge(site, v10, v00)) - 1);
                }
              }
              for (iCell = 0; iCell < nCells; ++iCell) {
                if (cell = cells[iCell]) {
                  if (!cell.halfedges.length) {
                    delete cells[iCell];
                  }
                }
              }
            }
            var circlePool = [];
            var firstCircle;
            function Circle() {
              RedBlackNode(this);
              this.x = this.y = this.arc = this.site = this.cy = null;
            }
            function attachCircle(arc) {
              var lArc = arc.P, rArc = arc.N;
              if (!lArc || !rArc)
                return;
              var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
              if (lSite === rSite)
                return;
              var bx = cSite[0], by = cSite[1], ax = lSite[0] - bx, ay = lSite[1] - by, cx = rSite[0] - bx, cy = rSite[1] - by;
              var d = 2 * (ax * cy - ay * cx);
              if (d >= -epsilon2)
                return;
              var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x2 = (cy * ha - ay * hc) / d, y2 = (ax * hc - cx * ha) / d;
              var circle = circlePool.pop() || new Circle();
              circle.arc = arc;
              circle.site = cSite;
              circle.x = x2 + bx;
              circle.y = (circle.cy = y2 + by) + Math.sqrt(x2 * x2 + y2 * y2);
              arc.circle = circle;
              var before = null, node = circles._;
              while (node) {
                if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
                  if (node.L)
                    node = node.L;
                  else {
                    before = node.P;
                    break;
                  }
                } else {
                  if (node.R)
                    node = node.R;
                  else {
                    before = node;
                    break;
                  }
                }
              }
              circles.insert(before, circle);
              if (!before)
                firstCircle = circle;
            }
            function detachCircle(arc) {
              var circle = arc.circle;
              if (circle) {
                if (!circle.P)
                  firstCircle = circle.N;
                circles.remove(circle);
                circlePool.push(circle);
                RedBlackNode(circle);
                arc.circle = null;
              }
            }
            var beachPool = [];
            function Beach() {
              RedBlackNode(this);
              this.edge = this.site = this.circle = null;
            }
            function createBeach(site) {
              var beach = beachPool.pop() || new Beach();
              beach.site = site;
              return beach;
            }
            function detachBeach(beach) {
              detachCircle(beach);
              beaches.remove(beach);
              beachPool.push(beach);
              RedBlackNode(beach);
            }
            function removeBeach(beach) {
              var circle = beach.circle, x2 = circle.x, y2 = circle.cy, vertex = [x2, y2], previous = beach.P, next = beach.N, disappearing = [beach];
              detachBeach(beach);
              var lArc = previous;
              while (lArc.circle && Math.abs(x2 - lArc.circle.x) < epsilon && Math.abs(y2 - lArc.circle.cy) < epsilon) {
                previous = lArc.P;
                disappearing.unshift(lArc);
                detachBeach(lArc);
                lArc = previous;
              }
              disappearing.unshift(lArc);
              detachCircle(lArc);
              var rArc = next;
              while (rArc.circle && Math.abs(x2 - rArc.circle.x) < epsilon && Math.abs(y2 - rArc.circle.cy) < epsilon) {
                next = rArc.N;
                disappearing.push(rArc);
                detachBeach(rArc);
                rArc = next;
              }
              disappearing.push(rArc);
              detachCircle(rArc);
              var nArcs = disappearing.length, iArc;
              for (iArc = 1; iArc < nArcs; ++iArc) {
                rArc = disappearing[iArc];
                lArc = disappearing[iArc - 1];
                setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
              }
              lArc = disappearing[0];
              rArc = disappearing[nArcs - 1];
              rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);
              attachCircle(lArc);
              attachCircle(rArc);
            }
            function addBeach(site) {
              var x2 = site[0], directrix = site[1], lArc, rArc, dxl, dxr, node = beaches._;
              while (node) {
                dxl = leftBreakPoint(node, directrix) - x2;
                if (dxl > epsilon)
                  node = node.L;
                else {
                  dxr = x2 - rightBreakPoint(node, directrix);
                  if (dxr > epsilon) {
                    if (!node.R) {
                      lArc = node;
                      break;
                    }
                    node = node.R;
                  } else {
                    if (dxl > -epsilon) {
                      lArc = node.P;
                      rArc = node;
                    } else if (dxr > -epsilon) {
                      lArc = node;
                      rArc = node.N;
                    } else {
                      lArc = rArc = node;
                    }
                    break;
                  }
                }
              }
              createCell(site);
              var newArc = createBeach(site);
              beaches.insert(lArc, newArc);
              if (!lArc && !rArc)
                return;
              if (lArc === rArc) {
                detachCircle(lArc);
                rArc = createBeach(lArc.site);
                beaches.insert(newArc, rArc);
                newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);
                attachCircle(lArc);
                attachCircle(rArc);
                return;
              }
              if (!rArc) {
                newArc.edge = createEdge(lArc.site, newArc.site);
                return;
              }
              detachCircle(lArc);
              detachCircle(rArc);
              var lSite = lArc.site, ax = lSite[0], ay = lSite[1], bx = site[0] - ax, by = site[1] - ay, rSite = rArc.site, cx = rSite[0] - ax, cy = rSite[1] - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];
              setEdgeEnd(rArc.edge, lSite, rSite, vertex);
              newArc.edge = createEdge(lSite, site, null, vertex);
              rArc.edge = createEdge(site, rSite, null, vertex);
              attachCircle(lArc);
              attachCircle(rArc);
            }
            function leftBreakPoint(arc, directrix) {
              var site = arc.site, rfocx = site[0], rfocy = site[1], pby2 = rfocy - directrix;
              if (!pby2)
                return rfocx;
              var lArc = arc.P;
              if (!lArc)
                return -Infinity;
              site = lArc.site;
              var lfocx = site[0], lfocy = site[1], plby2 = lfocy - directrix;
              if (!plby2)
                return lfocx;
              var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
              if (aby2)
                return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
              return (rfocx + lfocx) / 2;
            }
            function rightBreakPoint(arc, directrix) {
              var rArc = arc.N;
              if (rArc)
                return leftBreakPoint(rArc, directrix);
              var site = arc.site;
              return site[1] === directrix ? site[0] : Infinity;
            }
            var epsilon = 1e-6;
            var epsilon2 = 1e-12;
            var beaches;
            var cells;
            var circles;
            var edges;
            function triangleArea(a, b, c) {
              return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);
            }
            function lexicographic(a, b) {
              return b[1] - a[1] || b[0] - a[0];
            }
            function Diagram(sites, extent) {
              var site = sites.sort(lexicographic).pop(), x2, y2, circle;
              edges = [];
              cells = new Array(sites.length);
              beaches = new RedBlackTree();
              circles = new RedBlackTree();
              while (true) {
                circle = firstCircle;
                if (site && (!circle || site[1] < circle.y || site[1] === circle.y && site[0] < circle.x)) {
                  if (site[0] !== x2 || site[1] !== y2) {
                    addBeach(site);
                    x2 = site[0], y2 = site[1];
                  }
                  site = sites.pop();
                } else if (circle) {
                  removeBeach(circle.arc);
                } else {
                  break;
                }
              }
              sortCellHalfedges();
              if (extent) {
                var x0 = +extent[0][0], y0 = +extent[0][1], x1 = +extent[1][0], y1 = +extent[1][1];
                clipEdges(x0, y0, x1, y1);
                clipCells(x0, y0, x1, y1);
              }
              this.edges = edges;
              this.cells = cells;
              beaches = circles = edges = cells = null;
            }
            Diagram.prototype = {
              constructor: Diagram,
              polygons: function() {
                var edges2 = this.edges;
                return this.cells.map(function(cell) {
                  var polygon = cell.halfedges.map(function(i) {
                    return cellHalfedgeStart(cell, edges2[i]);
                  });
                  polygon.data = cell.site.data;
                  return polygon;
                });
              },
              triangles: function() {
                var triangles = [], edges2 = this.edges;
                this.cells.forEach(function(cell, i) {
                  if (!(m = (halfedges = cell.halfedges).length))
                    return;
                  var site = cell.site, halfedges, j = -1, m, s0, e1 = edges2[halfedges[m - 1]], s1 = e1.left === site ? e1.right : e1.left;
                  while (++j < m) {
                    s0 = s1;
                    e1 = edges2[halfedges[j]];
                    s1 = e1.left === site ? e1.right : e1.left;
                    if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {
                      triangles.push([site.data, s0.data, s1.data]);
                    }
                  }
                });
                return triangles;
              },
              links: function() {
                return this.edges.filter(function(edge) {
                  return edge.right;
                }).map(function(edge) {
                  return {
                    source: edge.left.data,
                    target: edge.right.data
                  };
                });
              },
              find: function(x2, y2, radius) {
                var that = this, i0, i1 = that._found || 0, n = that.cells.length, cell;
                while (!(cell = that.cells[i1]))
                  if (++i1 >= n)
                    return null;
                var dx = x2 - cell.site[0], dy = y2 - cell.site[1], d2 = dx * dx + dy * dy;
                do {
                  cell = that.cells[i0 = i1], i1 = null;
                  cell.halfedges.forEach(function(e) {
                    var edge = that.edges[e], v = edge.left;
                    if ((v === cell.site || !v) && !(v = edge.right))
                      return;
                    var vx = x2 - v[0], vy = y2 - v[1], v2 = vx * vx + vy * vy;
                    if (v2 < d2)
                      d2 = v2, i1 = v.index;
                  });
                } while (i1 !== null);
                that._found = i0;
                return radius == null || d2 <= radius * radius ? cell.site : null;
              }
            };
            function voronoi() {
              var x$$1 = x, y$$1 = y, extent = null;
              function voronoi2(data) {
                return new Diagram(data.map(function(d, i) {
                  var s = [Math.round(x$$1(d, i, data) / epsilon) * epsilon, Math.round(y$$1(d, i, data) / epsilon) * epsilon];
                  s.index = i;
                  s.data = d;
                  return s;
                }), extent);
              }
              voronoi2.polygons = function(data) {
                return voronoi2(data).polygons();
              };
              voronoi2.links = function(data) {
                return voronoi2(data).links();
              };
              voronoi2.triangles = function(data) {
                return voronoi2(data).triangles();
              };
              voronoi2.x = function(_) {
                return arguments.length ? (x$$1 = typeof _ === "function" ? _ : constant(+_), voronoi2) : x$$1;
              };
              voronoi2.y = function(_) {
                return arguments.length ? (y$$1 = typeof _ === "function" ? _ : constant(+_), voronoi2) : y$$1;
              };
              voronoi2.extent = function(_) {
                return arguments.length ? (extent = _ == null ? null : [[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]], voronoi2) : extent && [[extent[0][0], extent[0][1]], [extent[1][0], extent[1][1]]];
              };
              voronoi2.size = function(_) {
                return arguments.length ? (extent = _ == null ? null : [[0, 0], [+_[0], +_[1]]], voronoi2) : extent && [extent[1][0] - extent[0][0], extent[1][1] - extent[0][1]];
              };
              return voronoi2;
            }
            exports3.voronoi = voronoi;
            Object.defineProperty(exports3, "__esModule", { value: true });
          });
        },
        "./node_modules/_dagre@0.8.5@dagre/index.js": function(module2, exports2, __webpack_require__) {
          module2.exports = {
            graphlib: __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/graphlib.js"),
            layout: __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/layout.js"),
            debug: __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/debug.js"),
            util: {
              time: __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/util.js").time,
              notime: __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/util.js").notime
            },
            version: __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/version.js")
          };
        },
        "./node_modules/_dagre@0.8.5@dagre/lib/acyclic.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          var _ = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/lodash.js");
          var greedyFAS = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/greedy-fas.js");
          module2.exports = {
            run,
            undo
          };
          function run(g) {
            var fas = g.graph().acyclicer === "greedy" ? greedyFAS(g, weightFn(g)) : dfsFAS(g);
            _.forEach(fas, function(e) {
              var label = g.edge(e);
              g.removeEdge(e);
              label.forwardName = e.name;
              label.reversed = true;
              g.setEdge(e.w, e.v, label, _.uniqueId("rev"));
            });
            function weightFn(g2) {
              return function(e) {
                return g2.edge(e).weight;
              };
            }
          }
          function dfsFAS(g) {
            var fas = [];
            var stack = {};
            var visited = {};
            function dfs(v) {
              if (_.has(visited, v)) {
                return;
              }
              visited[v] = true;
              stack[v] = true;
              _.forEach(g.outEdges(v), function(e) {
                if (_.has(stack, e.w)) {
                  fas.push(e);
                } else {
                  dfs(e.w);
                }
              });
              delete stack[v];
            }
            _.forEach(g.nodes(), dfs);
            return fas;
          }
          function undo(g) {
            _.forEach(g.edges(), function(e) {
              var label = g.edge(e);
              if (label.reversed) {
                g.removeEdge(e);
                var forwardName = label.forwardName;
                delete label.reversed;
                delete label.forwardName;
                g.setEdge(e.w, e.v, label, forwardName);
              }
            });
          }
        },
        "./node_modules/_dagre@0.8.5@dagre/lib/add-border-segments.js": function(module2, exports2, __webpack_require__) {
          var _ = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/lodash.js");
          var util = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/util.js");
          module2.exports = addBorderSegments;
          function addBorderSegments(g) {
            function dfs(v) {
              var children = g.children(v);
              var node = g.node(v);
              if (children.length) {
                _.forEach(children, dfs);
              }
              if (_.has(node, "minRank")) {
                node.borderLeft = [];
                node.borderRight = [];
                for (var rank = node.minRank, maxRank = node.maxRank + 1; rank < maxRank; ++rank) {
                  addBorderNode(g, "borderLeft", "_bl", v, node, rank);
                  addBorderNode(g, "borderRight", "_br", v, node, rank);
                }
              }
            }
            _.forEach(g.children(), dfs);
          }
          function addBorderNode(g, prop, prefix, sg, sgNode, rank) {
            var label = { width: 0, height: 0, rank, borderType: prop };
            var prev = sgNode[prop][rank - 1];
            var curr = util.addDummyNode(g, "border", label, prefix);
            sgNode[prop][rank] = curr;
            g.setParent(curr, sg);
            if (prev) {
              g.setEdge(prev, curr, { weight: 1 });
            }
          }
        },
        "./node_modules/_dagre@0.8.5@dagre/lib/coordinate-system.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          var _ = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/lodash.js");
          module2.exports = {
            adjust,
            undo
          };
          function adjust(g) {
            var rankDir = g.graph().rankdir.toLowerCase();
            if (rankDir === "lr" || rankDir === "rl") {
              swapWidthHeight(g);
            }
          }
          function undo(g) {
            var rankDir = g.graph().rankdir.toLowerCase();
            if (rankDir === "bt" || rankDir === "rl") {
              reverseY(g);
            }
            if (rankDir === "lr" || rankDir === "rl") {
              swapXY(g);
              swapWidthHeight(g);
            }
          }
          function swapWidthHeight(g) {
            _.forEach(g.nodes(), function(v) {
              swapWidthHeightOne(g.node(v));
            });
            _.forEach(g.edges(), function(e) {
              swapWidthHeightOne(g.edge(e));
            });
          }
          function swapWidthHeightOne(attrs) {
            var w = attrs.width;
            attrs.width = attrs.height;
            attrs.height = w;
          }
          function reverseY(g) {
            _.forEach(g.nodes(), function(v) {
              reverseYOne(g.node(v));
            });
            _.forEach(g.edges(), function(e) {
              var edge = g.edge(e);
              _.forEach(edge.points, reverseYOne);
              if (_.has(edge, "y")) {
                reverseYOne(edge);
              }
            });
          }
          function reverseYOne(attrs) {
            attrs.y = -attrs.y;
          }
          function swapXY(g) {
            _.forEach(g.nodes(), function(v) {
              swapXYOne(g.node(v));
            });
            _.forEach(g.edges(), function(e) {
              var edge = g.edge(e);
              _.forEach(edge.points, swapXYOne);
              if (_.has(edge, "x")) {
                swapXYOne(edge);
              }
            });
          }
          function swapXYOne(attrs) {
            var x = attrs.x;
            attrs.x = attrs.y;
            attrs.y = x;
          }
        },
        "./node_modules/_dagre@0.8.5@dagre/lib/data/list.js": function(module2, exports2) {
          module2.exports = List;
          function List() {
            var sentinel = {};
            sentinel._next = sentinel._prev = sentinel;
            this._sentinel = sentinel;
          }
          List.prototype.dequeue = function() {
            var sentinel = this._sentinel;
            var entry = sentinel._prev;
            if (entry !== sentinel) {
              unlink(entry);
              return entry;
            }
          };
          List.prototype.enqueue = function(entry) {
            var sentinel = this._sentinel;
            if (entry._prev && entry._next) {
              unlink(entry);
            }
            entry._next = sentinel._next;
            sentinel._next._prev = entry;
            sentinel._next = entry;
            entry._prev = sentinel;
          };
          List.prototype.toString = function() {
            var strs = [];
            var sentinel = this._sentinel;
            var curr = sentinel._prev;
            while (curr !== sentinel) {
              strs.push(JSON.stringify(curr, filterOutLinks));
              curr = curr._prev;
            }
            return "[" + strs.join(", ") + "]";
          };
          function unlink(entry) {
            entry._prev._next = entry._next;
            entry._next._prev = entry._prev;
            delete entry._next;
            delete entry._prev;
          }
          function filterOutLinks(k, v) {
            if (k !== "_next" && k !== "_prev") {
              return v;
            }
          }
        },
        "./node_modules/_dagre@0.8.5@dagre/lib/debug.js": function(module2, exports2, __webpack_require__) {
          var _ = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/lodash.js");
          var util = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/util.js");
          var Graph = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/graphlib.js").Graph;
          module2.exports = {
            debugOrdering
          };
          function debugOrdering(g) {
            var layerMatrix = util.buildLayerMatrix(g);
            var h = new Graph({ compound: true, multigraph: true }).setGraph({});
            _.forEach(g.nodes(), function(v) {
              h.setNode(v, { label: v });
              h.setParent(v, "layer" + g.node(v).rank);
            });
            _.forEach(g.edges(), function(e) {
              h.setEdge(e.v, e.w, {}, e.name);
            });
            _.forEach(layerMatrix, function(layer, i) {
              var layerV = "layer" + i;
              h.setNode(layerV, { rank: "same" });
              _.reduce(layer, function(u, v) {
                h.setEdge(u, v, { style: "invis" });
                return v;
              });
            });
            return h;
          }
        },
        "./node_modules/_dagre@0.8.5@dagre/lib/graphlib.js": function(module2, exports2, __webpack_require__) {
          var graphlib;
          if (true) {
            try {
              graphlib = __webpack_require__("./node_modules/_graphlib@2.1.8@graphlib/index.js");
            } catch (e) {
            }
          }
          if (!graphlib) {
            graphlib = window.graphlib;
          }
          module2.exports = graphlib;
        },
        "./node_modules/_dagre@0.8.5@dagre/lib/greedy-fas.js": function(module2, exports2, __webpack_require__) {
          var _ = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/lodash.js");
          var Graph = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/graphlib.js").Graph;
          var List = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/data/list.js");
          module2.exports = greedyFAS;
          var DEFAULT_WEIGHT_FN = _.constant(1);
          function greedyFAS(g, weightFn) {
            if (g.nodeCount() <= 1) {
              return [];
            }
            var state = buildState(g, weightFn || DEFAULT_WEIGHT_FN);
            var results = doGreedyFAS(state.graph, state.buckets, state.zeroIdx);
            return _.flatten(_.map(results, function(e) {
              return g.outEdges(e.v, e.w);
            }), true);
          }
          function doGreedyFAS(g, buckets, zeroIdx) {
            var results = [];
            var sources = buckets[buckets.length - 1];
            var sinks = buckets[0];
            var entry;
            while (g.nodeCount()) {
              while (entry = sinks.dequeue()) {
                removeNode(g, buckets, zeroIdx, entry);
              }
              while (entry = sources.dequeue()) {
                removeNode(g, buckets, zeroIdx, entry);
              }
              if (g.nodeCount()) {
                for (var i = buckets.length - 2; i > 0; --i) {
                  entry = buckets[i].dequeue();
                  if (entry) {
                    results = results.concat(removeNode(g, buckets, zeroIdx, entry, true));
                    break;
                  }
                }
              }
            }
            return results;
          }
          function removeNode(g, buckets, zeroIdx, entry, collectPredecessors) {
            var results = collectPredecessors ? [] : void 0;
            _.forEach(g.inEdges(entry.v), function(edge) {
              var weight = g.edge(edge);
              var uEntry = g.node(edge.v);
              if (collectPredecessors) {
                results.push({ v: edge.v, w: edge.w });
              }
              uEntry.out -= weight;
              assignBucket(buckets, zeroIdx, uEntry);
            });
            _.forEach(g.outEdges(entry.v), function(edge) {
              var weight = g.edge(edge);
              var w = edge.w;
              var wEntry = g.node(w);
              wEntry["in"] -= weight;
              assignBucket(buckets, zeroIdx, wEntry);
            });
            g.removeNode(entry.v);
            return results;
          }
          function buildState(g, weightFn) {
            var fasGraph = new Graph();
            var maxIn = 0;
            var maxOut = 0;
            _.forEach(g.nodes(), function(v) {
              fasGraph.setNode(v, { v, "in": 0, out: 0 });
            });
            _.forEach(g.edges(), function(e) {
              var prevWeight = fasGraph.edge(e.v, e.w) || 0;
              var weight = weightFn(e);
              var edgeWeight = prevWeight + weight;
              fasGraph.setEdge(e.v, e.w, edgeWeight);
              maxOut = Math.max(maxOut, fasGraph.node(e.v).out += weight);
              maxIn = Math.max(maxIn, fasGraph.node(e.w)["in"] += weight);
            });
            var buckets = _.range(maxOut + maxIn + 3).map(function() {
              return new List();
            });
            var zeroIdx = maxIn + 1;
            _.forEach(fasGraph.nodes(), function(v) {
              assignBucket(buckets, zeroIdx, fasGraph.node(v));
            });
            return { graph: fasGraph, buckets, zeroIdx };
          }
          function assignBucket(buckets, zeroIdx, entry) {
            if (!entry.out) {
              buckets[0].enqueue(entry);
            } else if (!entry["in"]) {
              buckets[buckets.length - 1].enqueue(entry);
            } else {
              buckets[entry.out - entry["in"] + zeroIdx].enqueue(entry);
            }
          }
        },
        "./node_modules/_dagre@0.8.5@dagre/lib/layout.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          var _ = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/lodash.js");
          var acyclic = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/acyclic.js");
          var normalize = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/normalize.js");
          var rank = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/rank/index.js");
          var normalizeRanks = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/util.js").normalizeRanks;
          var parentDummyChains = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/parent-dummy-chains.js");
          var removeEmptyRanks = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/util.js").removeEmptyRanks;
          var nestingGraph = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/nesting-graph.js");
          var addBorderSegments = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/add-border-segments.js");
          var coordinateSystem = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/coordinate-system.js");
          var order = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/order/index.js");
          var position = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/position/index.js");
          var util = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/util.js");
          var Graph = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/graphlib.js").Graph;
          module2.exports = layout;
          function layout(g, opts) {
            var time = opts && opts.debugTiming ? util.time : util.notime;
            time("layout", function() {
              var layoutGraph = time("  buildLayoutGraph", function() {
                return buildLayoutGraph(g);
              });
              time("  runLayout", function() {
                runLayout(layoutGraph, time);
              });
              time("  updateInputGraph", function() {
                updateInputGraph(g, layoutGraph);
              });
            });
          }
          function runLayout(g, time) {
            time("    makeSpaceForEdgeLabels", function() {
              makeSpaceForEdgeLabels(g);
            });
            time("    removeSelfEdges", function() {
              removeSelfEdges(g);
            });
            time("    acyclic", function() {
              acyclic.run(g);
            });
            time("    nestingGraph.run", function() {
              nestingGraph.run(g);
            });
            time("    rank", function() {
              rank(util.asNonCompoundGraph(g));
            });
            time("    injectEdgeLabelProxies", function() {
              injectEdgeLabelProxies(g);
            });
            time("    removeEmptyRanks", function() {
              removeEmptyRanks(g);
            });
            time("    nestingGraph.cleanup", function() {
              nestingGraph.cleanup(g);
            });
            time("    normalizeRanks", function() {
              normalizeRanks(g);
            });
            time("    assignRankMinMax", function() {
              assignRankMinMax(g);
            });
            time("    removeEdgeLabelProxies", function() {
              removeEdgeLabelProxies(g);
            });
            time("    normalize.run", function() {
              normalize.run(g);
            });
            time("    parentDummyChains", function() {
              parentDummyChains(g);
            });
            time("    addBorderSegments", function() {
              addBorderSegments(g);
            });
            time("    order", function() {
              order(g);
            });
            time("    insertSelfEdges", function() {
              insertSelfEdges(g);
            });
            time("    adjustCoordinateSystem", function() {
              coordinateSystem.adjust(g);
            });
            time("    position", function() {
              position(g);
            });
            time("    positionSelfEdges", function() {
              positionSelfEdges(g);
            });
            time("    removeBorderNodes", function() {
              removeBorderNodes(g);
            });
            time("    normalize.undo", function() {
              normalize.undo(g);
            });
            time("    fixupEdgeLabelCoords", function() {
              fixupEdgeLabelCoords(g);
            });
            time("    undoCoordinateSystem", function() {
              coordinateSystem.undo(g);
            });
            time("    translateGraph", function() {
              translateGraph(g);
            });
            time("    assignNodeIntersects", function() {
              assignNodeIntersects(g);
            });
            time("    reversePoints", function() {
              reversePointsForReversedEdges(g);
            });
            time("    acyclic.undo", function() {
              acyclic.undo(g);
            });
          }
          function updateInputGraph(inputGraph, layoutGraph) {
            _.forEach(inputGraph.nodes(), function(v) {
              var inputLabel = inputGraph.node(v);
              var layoutLabel = layoutGraph.node(v);
              if (inputLabel) {
                inputLabel.x = layoutLabel.x;
                inputLabel.y = layoutLabel.y;
                if (layoutGraph.children(v).length) {
                  inputLabel.width = layoutLabel.width;
                  inputLabel.height = layoutLabel.height;
                }
              }
            });
            _.forEach(inputGraph.edges(), function(e) {
              var inputLabel = inputGraph.edge(e);
              var layoutLabel = layoutGraph.edge(e);
              inputLabel.points = layoutLabel.points;
              if (_.has(layoutLabel, "x")) {
                inputLabel.x = layoutLabel.x;
                inputLabel.y = layoutLabel.y;
              }
            });
            inputGraph.graph().width = layoutGraph.graph().width;
            inputGraph.graph().height = layoutGraph.graph().height;
          }
          var graphNumAttrs = ["nodesep", "edgesep", "ranksep", "marginx", "marginy"];
          var graphDefaults = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: "tb" };
          var graphAttrs = ["acyclicer", "ranker", "rankdir", "align"];
          var nodeNumAttrs = ["width", "height"];
          var nodeDefaults = { width: 0, height: 0 };
          var edgeNumAttrs = ["minlen", "weight", "width", "height", "labeloffset"];
          var edgeDefaults = {
            minlen: 1,
            weight: 1,
            width: 0,
            height: 0,
            labeloffset: 10,
            labelpos: "r"
          };
          var edgeAttrs = ["labelpos"];
          function buildLayoutGraph(inputGraph) {
            var g = new Graph({ multigraph: true, compound: true });
            var graph = canonicalize(inputGraph.graph());
            g.setGraph(_.merge(
              {},
              graphDefaults,
              selectNumberAttrs(graph, graphNumAttrs),
              _.pick(graph, graphAttrs)
            ));
            _.forEach(inputGraph.nodes(), function(v) {
              var node = canonicalize(inputGraph.node(v));
              g.setNode(v, _.defaults(selectNumberAttrs(node, nodeNumAttrs), nodeDefaults));
              g.setParent(v, inputGraph.parent(v));
            });
            _.forEach(inputGraph.edges(), function(e) {
              var edge = canonicalize(inputGraph.edge(e));
              g.setEdge(e, _.merge(
                {},
                edgeDefaults,
                selectNumberAttrs(edge, edgeNumAttrs),
                _.pick(edge, edgeAttrs)
              ));
            });
            return g;
          }
          function makeSpaceForEdgeLabels(g) {
            var graph = g.graph();
            graph.ranksep /= 2;
            _.forEach(g.edges(), function(e) {
              var edge = g.edge(e);
              edge.minlen *= 2;
              if (edge.labelpos.toLowerCase() !== "c") {
                if (graph.rankdir === "TB" || graph.rankdir === "BT") {
                  edge.width += edge.labeloffset;
                } else {
                  edge.height += edge.labeloffset;
                }
              }
            });
          }
          function injectEdgeLabelProxies(g) {
            _.forEach(g.edges(), function(e) {
              var edge = g.edge(e);
              if (edge.width && edge.height) {
                var v = g.node(e.v);
                var w = g.node(e.w);
                var label = { rank: (w.rank - v.rank) / 2 + v.rank, e };
                util.addDummyNode(g, "edge-proxy", label, "_ep");
              }
            });
          }
          function assignRankMinMax(g) {
            var maxRank = 0;
            _.forEach(g.nodes(), function(v) {
              var node = g.node(v);
              if (node.borderTop) {
                node.minRank = g.node(node.borderTop).rank;
                node.maxRank = g.node(node.borderBottom).rank;
                maxRank = _.max(maxRank, node.maxRank);
              }
            });
            g.graph().maxRank = maxRank;
          }
          function removeEdgeLabelProxies(g) {
            _.forEach(g.nodes(), function(v) {
              var node = g.node(v);
              if (node.dummy === "edge-proxy") {
                g.edge(node.e).labelRank = node.rank;
                g.removeNode(v);
              }
            });
          }
          function translateGraph(g) {
            var minX = Number.POSITIVE_INFINITY;
            var maxX = 0;
            var minY = Number.POSITIVE_INFINITY;
            var maxY = 0;
            var graphLabel = g.graph();
            var marginX = graphLabel.marginx || 0;
            var marginY = graphLabel.marginy || 0;
            function getExtremes(attrs) {
              var x = attrs.x;
              var y = attrs.y;
              var w = attrs.width;
              var h = attrs.height;
              minX = Math.min(minX, x - w / 2);
              maxX = Math.max(maxX, x + w / 2);
              minY = Math.min(minY, y - h / 2);
              maxY = Math.max(maxY, y + h / 2);
            }
            _.forEach(g.nodes(), function(v) {
              getExtremes(g.node(v));
            });
            _.forEach(g.edges(), function(e) {
              var edge = g.edge(e);
              if (_.has(edge, "x")) {
                getExtremes(edge);
              }
            });
            minX -= marginX;
            minY -= marginY;
            _.forEach(g.nodes(), function(v) {
              var node = g.node(v);
              node.x -= minX;
              node.y -= minY;
            });
            _.forEach(g.edges(), function(e) {
              var edge = g.edge(e);
              _.forEach(edge.points, function(p) {
                p.x -= minX;
                p.y -= minY;
              });
              if (_.has(edge, "x")) {
                edge.x -= minX;
              }
              if (_.has(edge, "y")) {
                edge.y -= minY;
              }
            });
            graphLabel.width = maxX - minX + marginX;
            graphLabel.height = maxY - minY + marginY;
          }
          function assignNodeIntersects(g) {
            _.forEach(g.edges(), function(e) {
              var edge = g.edge(e);
              var nodeV = g.node(e.v);
              var nodeW = g.node(e.w);
              var p1, p2;
              if (!edge.points) {
                edge.points = [];
                p1 = nodeW;
                p2 = nodeV;
              } else {
                p1 = edge.points[0];
                p2 = edge.points[edge.points.length - 1];
              }
              edge.points.unshift(util.intersectRect(nodeV, p1));
              edge.points.push(util.intersectRect(nodeW, p2));
            });
          }
          function fixupEdgeLabelCoords(g) {
            _.forEach(g.edges(), function(e) {
              var edge = g.edge(e);
              if (_.has(edge, "x")) {
                if (edge.labelpos === "l" || edge.labelpos === "r") {
                  edge.width -= edge.labeloffset;
                }
                switch (edge.labelpos) {
                  case "l":
                    edge.x -= edge.width / 2 + edge.labeloffset;
                    break;
                  case "r":
                    edge.x += edge.width / 2 + edge.labeloffset;
                    break;
                }
              }
            });
          }
          function reversePointsForReversedEdges(g) {
            _.forEach(g.edges(), function(e) {
              var edge = g.edge(e);
              if (edge.reversed) {
                edge.points.reverse();
              }
            });
          }
          function removeBorderNodes(g) {
            _.forEach(g.nodes(), function(v) {
              if (g.children(v).length) {
                var node = g.node(v);
                var t = g.node(node.borderTop);
                var b = g.node(node.borderBottom);
                var l = g.node(_.last(node.borderLeft));
                var r = g.node(_.last(node.borderRight));
                node.width = Math.abs(r.x - l.x);
                node.height = Math.abs(b.y - t.y);
                node.x = l.x + node.width / 2;
                node.y = t.y + node.height / 2;
              }
            });
            _.forEach(g.nodes(), function(v) {
              if (g.node(v).dummy === "border") {
                g.removeNode(v);
              }
            });
          }
          function removeSelfEdges(g) {
            _.forEach(g.edges(), function(e) {
              if (e.v === e.w) {
                var node = g.node(e.v);
                if (!node.selfEdges) {
                  node.selfEdges = [];
                }
                node.selfEdges.push({ e, label: g.edge(e) });
                g.removeEdge(e);
              }
            });
          }
          function insertSelfEdges(g) {
            var layers = util.buildLayerMatrix(g);
            _.forEach(layers, function(layer) {
              var orderShift = 0;
              _.forEach(layer, function(v, i) {
                var node = g.node(v);
                node.order = i + orderShift;
                _.forEach(node.selfEdges, function(selfEdge) {
                  util.addDummyNode(g, "selfedge", {
                    width: selfEdge.label.width,
                    height: selfEdge.label.height,
                    rank: node.rank,
                    order: i + ++orderShift,
                    e: selfEdge.e,
                    label: selfEdge.label
                  }, "_se");
                });
                delete node.selfEdges;
              });
            });
          }
          function positionSelfEdges(g) {
            _.forEach(g.nodes(), function(v) {
              var node = g.node(v);
              if (node.dummy === "selfedge") {
                var selfNode = g.node(node.e.v);
                var x = selfNode.x + selfNode.width / 2;
                var y = selfNode.y;
                var dx = node.x - x;
                var dy = selfNode.height / 2;
                g.setEdge(node.e, node.label);
                g.removeNode(v);
                node.label.points = [
                  { x: x + 2 * dx / 3, y: y - dy },
                  { x: x + 5 * dx / 6, y: y - dy },
                  { x: x + dx, y },
                  { x: x + 5 * dx / 6, y: y + dy },
                  { x: x + 2 * dx / 3, y: y + dy }
                ];
                node.label.x = node.x;
                node.label.y = node.y;
              }
            });
          }
          function selectNumberAttrs(obj, attrs) {
            return _.mapValues(_.pick(obj, attrs), Number);
          }
          function canonicalize(attrs) {
            var newAttrs = {};
            _.forEach(attrs, function(v, k) {
              newAttrs[k.toLowerCase()] = v;
            });
            return newAttrs;
          }
        },
        "./node_modules/_dagre@0.8.5@dagre/lib/lodash.js": function(module2, exports2, __webpack_require__) {
          var lodash;
          if (true) {
            try {
              lodash = {
                cloneDeep: __webpack_require__("./node_modules/_lodash@4.17.20@lodash/cloneDeep.js"),
                constant: __webpack_require__("./node_modules/_lodash@4.17.20@lodash/constant.js"),
                defaults: __webpack_require__("./node_modules/_lodash@4.17.20@lodash/defaults.js"),
                each: __webpack_require__("./node_modules/_lodash@4.17.20@lodash/each.js"),
                filter: __webpack_require__("./node_modules/_lodash@4.17.20@lodash/filter.js"),
                find: __webpack_require__("./node_modules/_lodash@4.17.20@lodash/find.js"),
                flatten: __webpack_require__("./node_modules/_lodash@4.17.20@lodash/flatten.js"),
                forEach: __webpack_require__("./node_modules/_lodash@4.17.20@lodash/forEach.js"),
                forIn: __webpack_require__("./node_modules/_lodash@4.17.20@lodash/forIn.js"),
                has: __webpack_require__("./node_modules/_lodash@4.17.20@lodash/has.js"),
                isUndefined: __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isUndefined.js"),
                last: __webpack_require__("./node_modules/_lodash@4.17.20@lodash/last.js"),
                map: __webpack_require__("./node_modules/_lodash@4.17.20@lodash/map.js"),
                mapValues: __webpack_require__("./node_modules/_lodash@4.17.20@lodash/mapValues.js"),
                max: __webpack_require__("./node_modules/_lodash@4.17.20@lodash/max.js"),
                merge: __webpack_require__("./node_modules/_lodash@4.17.20@lodash/merge.js"),
                min: __webpack_require__("./node_modules/_lodash@4.17.20@lodash/min.js"),
                minBy: __webpack_require__("./node_modules/_lodash@4.17.20@lodash/minBy.js"),
                now: __webpack_require__("./node_modules/_lodash@4.17.20@lodash/now.js"),
                pick: __webpack_require__("./node_modules/_lodash@4.17.20@lodash/pick.js"),
                range: __webpack_require__("./node_modules/_lodash@4.17.20@lodash/range.js"),
                reduce: __webpack_require__("./node_modules/_lodash@4.17.20@lodash/reduce.js"),
                sortBy: __webpack_require__("./node_modules/_lodash@4.17.20@lodash/sortBy.js"),
                uniqueId: __webpack_require__("./node_modules/_lodash@4.17.20@lodash/uniqueId.js"),
                values: __webpack_require__("./node_modules/_lodash@4.17.20@lodash/values.js"),
                zipObject: __webpack_require__("./node_modules/_lodash@4.17.20@lodash/zipObject.js")
              };
            } catch (e) {
            }
          }
          if (!lodash) {
            lodash = window._;
          }
          module2.exports = lodash;
        },
        "./node_modules/_dagre@0.8.5@dagre/lib/nesting-graph.js": function(module2, exports2, __webpack_require__) {
          var _ = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/lodash.js");
          var util = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/util.js");
          module2.exports = {
            run,
            cleanup
          };
          function run(g) {
            var root = util.addDummyNode(g, "root", {}, "_root");
            var depths = treeDepths(g);
            var height = _.max(_.values(depths)) - 1;
            var nodeSep = 2 * height + 1;
            g.graph().nestingRoot = root;
            _.forEach(g.edges(), function(e) {
              g.edge(e).minlen *= nodeSep;
            });
            var weight = sumWeights(g) + 1;
            _.forEach(g.children(), function(child) {
              dfs(g, root, nodeSep, weight, height, depths, child);
            });
            g.graph().nodeRankFactor = nodeSep;
          }
          function dfs(g, root, nodeSep, weight, height, depths, v) {
            var children = g.children(v);
            if (!children.length) {
              if (v !== root) {
                g.setEdge(root, v, { weight: 0, minlen: nodeSep });
              }
              return;
            }
            var top = util.addBorderNode(g, "_bt");
            var bottom = util.addBorderNode(g, "_bb");
            var label = g.node(v);
            g.setParent(top, v);
            label.borderTop = top;
            g.setParent(bottom, v);
            label.borderBottom = bottom;
            _.forEach(children, function(child) {
              dfs(g, root, nodeSep, weight, height, depths, child);
              var childNode = g.node(child);
              var childTop = childNode.borderTop ? childNode.borderTop : child;
              var childBottom = childNode.borderBottom ? childNode.borderBottom : child;
              var thisWeight = childNode.borderTop ? weight : 2 * weight;
              var minlen = childTop !== childBottom ? 1 : height - depths[v] + 1;
              g.setEdge(top, childTop, {
                weight: thisWeight,
                minlen,
                nestingEdge: true
              });
              g.setEdge(childBottom, bottom, {
                weight: thisWeight,
                minlen,
                nestingEdge: true
              });
            });
            if (!g.parent(v)) {
              g.setEdge(root, top, { weight: 0, minlen: height + depths[v] });
            }
          }
          function treeDepths(g) {
            var depths = {};
            function dfs2(v, depth) {
              var children = g.children(v);
              if (children && children.length) {
                _.forEach(children, function(child) {
                  dfs2(child, depth + 1);
                });
              }
              depths[v] = depth;
            }
            _.forEach(g.children(), function(v) {
              dfs2(v, 1);
            });
            return depths;
          }
          function sumWeights(g) {
            return _.reduce(g.edges(), function(acc, e) {
              return acc + g.edge(e).weight;
            }, 0);
          }
          function cleanup(g) {
            var graphLabel = g.graph();
            g.removeNode(graphLabel.nestingRoot);
            delete graphLabel.nestingRoot;
            _.forEach(g.edges(), function(e) {
              var edge = g.edge(e);
              if (edge.nestingEdge) {
                g.removeEdge(e);
              }
            });
          }
        },
        "./node_modules/_dagre@0.8.5@dagre/lib/normalize.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          var _ = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/lodash.js");
          var util = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/util.js");
          module2.exports = {
            run,
            undo
          };
          function run(g) {
            g.graph().dummyChains = [];
            _.forEach(g.edges(), function(edge) {
              normalizeEdge(g, edge);
            });
          }
          function normalizeEdge(g, e) {
            var v = e.v;
            var vRank = g.node(v).rank;
            var w = e.w;
            var wRank = g.node(w).rank;
            var name = e.name;
            var edgeLabel = g.edge(e);
            var labelRank = edgeLabel.labelRank;
            if (wRank === vRank + 1)
              return;
            g.removeEdge(e);
            var dummy, attrs, i;
            for (i = 0, ++vRank; vRank < wRank; ++i, ++vRank) {
              edgeLabel.points = [];
              attrs = {
                width: 0,
                height: 0,
                edgeLabel,
                edgeObj: e,
                rank: vRank
              };
              dummy = util.addDummyNode(g, "edge", attrs, "_d");
              if (vRank === labelRank) {
                attrs.width = edgeLabel.width;
                attrs.height = edgeLabel.height;
                attrs.dummy = "edge-label";
                attrs.labelpos = edgeLabel.labelpos;
              }
              g.setEdge(v, dummy, { weight: edgeLabel.weight }, name);
              if (i === 0) {
                g.graph().dummyChains.push(dummy);
              }
              v = dummy;
            }
            g.setEdge(v, w, { weight: edgeLabel.weight }, name);
          }
          function undo(g) {
            _.forEach(g.graph().dummyChains, function(v) {
              var node = g.node(v);
              var origLabel = node.edgeLabel;
              var w;
              g.setEdge(node.edgeObj, origLabel);
              while (node.dummy) {
                w = g.successors(v)[0];
                g.removeNode(v);
                origLabel.points.push({ x: node.x, y: node.y });
                if (node.dummy === "edge-label") {
                  origLabel.x = node.x;
                  origLabel.y = node.y;
                  origLabel.width = node.width;
                  origLabel.height = node.height;
                }
                v = w;
                node = g.node(v);
              }
            });
          }
        },
        "./node_modules/_dagre@0.8.5@dagre/lib/order/add-subgraph-constraints.js": function(module2, exports2, __webpack_require__) {
          var _ = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/lodash.js");
          module2.exports = addSubgraphConstraints;
          function addSubgraphConstraints(g, cg, vs) {
            var prev = {}, rootPrev;
            _.forEach(vs, function(v) {
              var child = g.parent(v), parent, prevChild;
              while (child) {
                parent = g.parent(child);
                if (parent) {
                  prevChild = prev[parent];
                  prev[parent] = child;
                } else {
                  prevChild = rootPrev;
                  rootPrev = child;
                }
                if (prevChild && prevChild !== child) {
                  cg.setEdge(prevChild, child);
                  return;
                }
                child = parent;
              }
            });
          }
        },
        "./node_modules/_dagre@0.8.5@dagre/lib/order/barycenter.js": function(module2, exports2, __webpack_require__) {
          var _ = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/lodash.js");
          module2.exports = barycenter;
          function barycenter(g, movable) {
            return _.map(movable, function(v) {
              var inV = g.inEdges(v);
              if (!inV.length) {
                return { v };
              } else {
                var result = _.reduce(inV, function(acc, e) {
                  var edge = g.edge(e), nodeU = g.node(e.v);
                  return {
                    sum: acc.sum + edge.weight * nodeU.order,
                    weight: acc.weight + edge.weight
                  };
                }, { sum: 0, weight: 0 });
                return {
                  v,
                  barycenter: result.sum / result.weight,
                  weight: result.weight
                };
              }
            });
          }
        },
        "./node_modules/_dagre@0.8.5@dagre/lib/order/build-layer-graph.js": function(module2, exports2, __webpack_require__) {
          var _ = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/lodash.js");
          var Graph = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/graphlib.js").Graph;
          module2.exports = buildLayerGraph;
          function buildLayerGraph(g, rank, relationship) {
            var root = createRootNode(g), result = new Graph({ compound: true }).setGraph({ root }).setDefaultNodeLabel(function(v) {
              return g.node(v);
            });
            _.forEach(g.nodes(), function(v) {
              var node = g.node(v), parent = g.parent(v);
              if (node.rank === rank || node.minRank <= rank && rank <= node.maxRank) {
                result.setNode(v);
                result.setParent(v, parent || root);
                _.forEach(g[relationship](v), function(e) {
                  var u = e.v === v ? e.w : e.v, edge = result.edge(u, v), weight = !_.isUndefined(edge) ? edge.weight : 0;
                  result.setEdge(u, v, { weight: g.edge(e).weight + weight });
                });
                if (_.has(node, "minRank")) {
                  result.setNode(v, {
                    borderLeft: node.borderLeft[rank],
                    borderRight: node.borderRight[rank]
                  });
                }
              }
            });
            return result;
          }
          function createRootNode(g) {
            var v;
            while (g.hasNode(v = _.uniqueId("_root")))
              ;
            return v;
          }
        },
        "./node_modules/_dagre@0.8.5@dagre/lib/order/cross-count.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          var _ = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/lodash.js");
          module2.exports = crossCount;
          function crossCount(g, layering) {
            var cc = 0;
            for (var i = 1; i < layering.length; ++i) {
              cc += twoLayerCrossCount(g, layering[i - 1], layering[i]);
            }
            return cc;
          }
          function twoLayerCrossCount(g, northLayer, southLayer) {
            var southPos = _.zipObject(
              southLayer,
              _.map(southLayer, function(v, i) {
                return i;
              })
            );
            var southEntries = _.flatten(_.map(northLayer, function(v) {
              return _.sortBy(_.map(g.outEdges(v), function(e) {
                return { pos: southPos[e.w], weight: g.edge(e).weight };
              }), "pos");
            }), true);
            var firstIndex = 1;
            while (firstIndex < southLayer.length)
              firstIndex <<= 1;
            var treeSize = 2 * firstIndex - 1;
            firstIndex -= 1;
            var tree = _.map(new Array(treeSize), function() {
              return 0;
            });
            var cc = 0;
            _.forEach(southEntries.forEach(function(entry) {
              var index = entry.pos + firstIndex;
              tree[index] += entry.weight;
              var weightSum = 0;
              while (index > 0) {
                if (index % 2) {
                  weightSum += tree[index + 1];
                }
                index = index - 1 >> 1;
                tree[index] += entry.weight;
              }
              cc += entry.weight * weightSum;
            }));
            return cc;
          }
        },
        "./node_modules/_dagre@0.8.5@dagre/lib/order/index.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          var _ = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/lodash.js");
          var initOrder = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/order/init-order.js");
          var crossCount = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/order/cross-count.js");
          var sortSubgraph = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/order/sort-subgraph.js");
          var buildLayerGraph = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/order/build-layer-graph.js");
          var addSubgraphConstraints = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/order/add-subgraph-constraints.js");
          var Graph = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/graphlib.js").Graph;
          var util = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/util.js");
          module2.exports = order;
          function order(g) {
            var maxRank = util.maxRank(g), downLayerGraphs = buildLayerGraphs(g, _.range(1, maxRank + 1), "inEdges"), upLayerGraphs = buildLayerGraphs(g, _.range(maxRank - 1, -1, -1), "outEdges");
            var layering = initOrder(g);
            assignOrder(g, layering);
            var bestCC = Number.POSITIVE_INFINITY, best;
            for (var i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {
              sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2);
              layering = util.buildLayerMatrix(g);
              var cc = crossCount(g, layering);
              if (cc < bestCC) {
                lastBest = 0;
                best = _.cloneDeep(layering);
                bestCC = cc;
              }
            }
            assignOrder(g, best);
          }
          function buildLayerGraphs(g, ranks, relationship) {
            return _.map(ranks, function(rank) {
              return buildLayerGraph(g, rank, relationship);
            });
          }
          function sweepLayerGraphs(layerGraphs, biasRight) {
            var cg = new Graph();
            _.forEach(layerGraphs, function(lg) {
              var root = lg.graph().root;
              var sorted = sortSubgraph(lg, root, cg, biasRight);
              _.forEach(sorted.vs, function(v, i) {
                lg.node(v).order = i;
              });
              addSubgraphConstraints(lg, cg, sorted.vs);
            });
          }
          function assignOrder(g, layering) {
            _.forEach(layering, function(layer) {
              _.forEach(layer, function(v, i) {
                g.node(v).order = i;
              });
            });
          }
        },
        "./node_modules/_dagre@0.8.5@dagre/lib/order/init-order.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          var _ = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/lodash.js");
          module2.exports = initOrder;
          function initOrder(g) {
            var visited = {};
            var simpleNodes = _.filter(g.nodes(), function(v) {
              return !g.children(v).length;
            });
            var maxRank = _.max(_.map(simpleNodes, function(v) {
              return g.node(v).rank;
            }));
            var layers = _.map(_.range(maxRank + 1), function() {
              return [];
            });
            function dfs(v) {
              if (_.has(visited, v))
                return;
              visited[v] = true;
              var node = g.node(v);
              layers[node.rank].push(v);
              _.forEach(g.successors(v), dfs);
            }
            var orderedVs = _.sortBy(simpleNodes, function(v) {
              return g.node(v).rank;
            });
            _.forEach(orderedVs, dfs);
            return layers;
          }
        },
        "./node_modules/_dagre@0.8.5@dagre/lib/order/resolve-conflicts.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          var _ = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/lodash.js");
          module2.exports = resolveConflicts;
          function resolveConflicts(entries, cg) {
            var mappedEntries = {};
            _.forEach(entries, function(entry, i) {
              var tmp = mappedEntries[entry.v] = {
                indegree: 0,
                "in": [],
                out: [],
                vs: [entry.v],
                i
              };
              if (!_.isUndefined(entry.barycenter)) {
                tmp.barycenter = entry.barycenter;
                tmp.weight = entry.weight;
              }
            });
            _.forEach(cg.edges(), function(e) {
              var entryV = mappedEntries[e.v];
              var entryW = mappedEntries[e.w];
              if (!_.isUndefined(entryV) && !_.isUndefined(entryW)) {
                entryW.indegree++;
                entryV.out.push(mappedEntries[e.w]);
              }
            });
            var sourceSet = _.filter(mappedEntries, function(entry) {
              return !entry.indegree;
            });
            return doResolveConflicts(sourceSet);
          }
          function doResolveConflicts(sourceSet) {
            var entries = [];
            function handleIn(vEntry) {
              return function(uEntry) {
                if (uEntry.merged) {
                  return;
                }
                if (_.isUndefined(uEntry.barycenter) || _.isUndefined(vEntry.barycenter) || uEntry.barycenter >= vEntry.barycenter) {
                  mergeEntries(vEntry, uEntry);
                }
              };
            }
            function handleOut(vEntry) {
              return function(wEntry) {
                wEntry["in"].push(vEntry);
                if (--wEntry.indegree === 0) {
                  sourceSet.push(wEntry);
                }
              };
            }
            while (sourceSet.length) {
              var entry = sourceSet.pop();
              entries.push(entry);
              _.forEach(entry["in"].reverse(), handleIn(entry));
              _.forEach(entry.out, handleOut(entry));
            }
            return _.map(
              _.filter(entries, function(entry2) {
                return !entry2.merged;
              }),
              function(entry2) {
                return _.pick(entry2, ["vs", "i", "barycenter", "weight"]);
              }
            );
          }
          function mergeEntries(target, source) {
            var sum = 0;
            var weight = 0;
            if (target.weight) {
              sum += target.barycenter * target.weight;
              weight += target.weight;
            }
            if (source.weight) {
              sum += source.barycenter * source.weight;
              weight += source.weight;
            }
            target.vs = source.vs.concat(target.vs);
            target.barycenter = sum / weight;
            target.weight = weight;
            target.i = Math.min(source.i, target.i);
            source.merged = true;
          }
        },
        "./node_modules/_dagre@0.8.5@dagre/lib/order/sort-subgraph.js": function(module2, exports2, __webpack_require__) {
          var _ = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/lodash.js");
          var barycenter = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/order/barycenter.js");
          var resolveConflicts = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/order/resolve-conflicts.js");
          var sort = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/order/sort.js");
          module2.exports = sortSubgraph;
          function sortSubgraph(g, v, cg, biasRight) {
            var movable = g.children(v);
            var node = g.node(v);
            var bl = node ? node.borderLeft : void 0;
            var br = node ? node.borderRight : void 0;
            var subgraphs = {};
            if (bl) {
              movable = _.filter(movable, function(w) {
                return w !== bl && w !== br;
              });
            }
            var barycenters = barycenter(g, movable);
            _.forEach(barycenters, function(entry) {
              if (g.children(entry.v).length) {
                var subgraphResult = sortSubgraph(g, entry.v, cg, biasRight);
                subgraphs[entry.v] = subgraphResult;
                if (_.has(subgraphResult, "barycenter")) {
                  mergeBarycenters(entry, subgraphResult);
                }
              }
            });
            var entries = resolveConflicts(barycenters, cg);
            expandSubgraphs(entries, subgraphs);
            var result = sort(entries, biasRight);
            if (bl) {
              result.vs = _.flatten([bl, result.vs, br], true);
              if (g.predecessors(bl).length) {
                var blPred = g.node(g.predecessors(bl)[0]), brPred = g.node(g.predecessors(br)[0]);
                if (!_.has(result, "barycenter")) {
                  result.barycenter = 0;
                  result.weight = 0;
                }
                result.barycenter = (result.barycenter * result.weight + blPred.order + brPred.order) / (result.weight + 2);
                result.weight += 2;
              }
            }
            return result;
          }
          function expandSubgraphs(entries, subgraphs) {
            _.forEach(entries, function(entry) {
              entry.vs = _.flatten(entry.vs.map(function(v) {
                if (subgraphs[v]) {
                  return subgraphs[v].vs;
                }
                return v;
              }), true);
            });
          }
          function mergeBarycenters(target, other) {
            if (!_.isUndefined(target.barycenter)) {
              target.barycenter = (target.barycenter * target.weight + other.barycenter * other.weight) / (target.weight + other.weight);
              target.weight += other.weight;
            } else {
              target.barycenter = other.barycenter;
              target.weight = other.weight;
            }
          }
        },
        "./node_modules/_dagre@0.8.5@dagre/lib/order/sort.js": function(module2, exports2, __webpack_require__) {
          var _ = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/lodash.js");
          var util = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/util.js");
          module2.exports = sort;
          function sort(entries, biasRight) {
            var parts = util.partition(entries, function(entry) {
              return _.has(entry, "barycenter");
            });
            var sortable = parts.lhs, unsortable = _.sortBy(parts.rhs, function(entry) {
              return -entry.i;
            }), vs = [], sum = 0, weight = 0, vsIndex = 0;
            sortable.sort(compareWithBias(!!biasRight));
            vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
            _.forEach(sortable, function(entry) {
              vsIndex += entry.vs.length;
              vs.push(entry.vs);
              sum += entry.barycenter * entry.weight;
              weight += entry.weight;
              vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
            });
            var result = { vs: _.flatten(vs, true) };
            if (weight) {
              result.barycenter = sum / weight;
              result.weight = weight;
            }
            return result;
          }
          function consumeUnsortable(vs, unsortable, index) {
            var last;
            while (unsortable.length && (last = _.last(unsortable)).i <= index) {
              unsortable.pop();
              vs.push(last.vs);
              index++;
            }
            return index;
          }
          function compareWithBias(bias) {
            return function(entryV, entryW) {
              if (entryV.barycenter < entryW.barycenter) {
                return -1;
              } else if (entryV.barycenter > entryW.barycenter) {
                return 1;
              }
              return !bias ? entryV.i - entryW.i : entryW.i - entryV.i;
            };
          }
        },
        "./node_modules/_dagre@0.8.5@dagre/lib/parent-dummy-chains.js": function(module2, exports2, __webpack_require__) {
          var _ = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/lodash.js");
          module2.exports = parentDummyChains;
          function parentDummyChains(g) {
            var postorderNums = postorder(g);
            _.forEach(g.graph().dummyChains, function(v) {
              var node = g.node(v);
              var edgeObj = node.edgeObj;
              var pathData = findPath(g, postorderNums, edgeObj.v, edgeObj.w);
              var path = pathData.path;
              var lca = pathData.lca;
              var pathIdx = 0;
              var pathV = path[pathIdx];
              var ascending = true;
              while (v !== edgeObj.w) {
                node = g.node(v);
                if (ascending) {
                  while ((pathV = path[pathIdx]) !== lca && g.node(pathV).maxRank < node.rank) {
                    pathIdx++;
                  }
                  if (pathV === lca) {
                    ascending = false;
                  }
                }
                if (!ascending) {
                  while (pathIdx < path.length - 1 && g.node(pathV = path[pathIdx + 1]).minRank <= node.rank) {
                    pathIdx++;
                  }
                  pathV = path[pathIdx];
                }
                g.setParent(v, pathV);
                v = g.successors(v)[0];
              }
            });
          }
          function findPath(g, postorderNums, v, w) {
            var vPath = [];
            var wPath = [];
            var low = Math.min(postorderNums[v].low, postorderNums[w].low);
            var lim = Math.max(postorderNums[v].lim, postorderNums[w].lim);
            var parent;
            var lca;
            parent = v;
            do {
              parent = g.parent(parent);
              vPath.push(parent);
            } while (parent && (postorderNums[parent].low > low || lim > postorderNums[parent].lim));
            lca = parent;
            parent = w;
            while ((parent = g.parent(parent)) !== lca) {
              wPath.push(parent);
            }
            return { path: vPath.concat(wPath.reverse()), lca };
          }
          function postorder(g) {
            var result = {};
            var lim = 0;
            function dfs(v) {
              var low = lim;
              _.forEach(g.children(v), dfs);
              result[v] = { low, lim: lim++ };
            }
            _.forEach(g.children(), dfs);
            return result;
          }
        },
        "./node_modules/_dagre@0.8.5@dagre/lib/position/bk.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          var _ = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/lodash.js");
          var Graph = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/graphlib.js").Graph;
          var util = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/util.js");
          module2.exports = {
            positionX,
            findType1Conflicts,
            findType2Conflicts,
            addConflict,
            hasConflict,
            verticalAlignment,
            horizontalCompaction,
            alignCoordinates,
            findSmallestWidthAlignment,
            balance
          };
          function findType1Conflicts(g, layering) {
            var conflicts = {};
            function visitLayer(prevLayer, layer) {
              var k0 = 0, scanPos = 0, prevLayerLength = prevLayer.length, lastNode = _.last(layer);
              _.forEach(layer, function(v, i) {
                var w = findOtherInnerSegmentNode(g, v), k1 = w ? g.node(w).order : prevLayerLength;
                if (w || v === lastNode) {
                  _.forEach(layer.slice(scanPos, i + 1), function(scanNode) {
                    _.forEach(g.predecessors(scanNode), function(u) {
                      var uLabel = g.node(u), uPos = uLabel.order;
                      if ((uPos < k0 || k1 < uPos) && !(uLabel.dummy && g.node(scanNode).dummy)) {
                        addConflict(conflicts, u, scanNode);
                      }
                    });
                  });
                  scanPos = i + 1;
                  k0 = k1;
                }
              });
              return layer;
            }
            _.reduce(layering, visitLayer);
            return conflicts;
          }
          function findType2Conflicts(g, layering) {
            var conflicts = {};
            function scan(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {
              var v;
              _.forEach(_.range(southPos, southEnd), function(i) {
                v = south[i];
                if (g.node(v).dummy) {
                  _.forEach(g.predecessors(v), function(u) {
                    var uNode = g.node(u);
                    if (uNode.dummy && (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {
                      addConflict(conflicts, u, v);
                    }
                  });
                }
              });
            }
            function visitLayer(north, south) {
              var prevNorthPos = -1, nextNorthPos, southPos = 0;
              _.forEach(south, function(v, southLookahead) {
                if (g.node(v).dummy === "border") {
                  var predecessors = g.predecessors(v);
                  if (predecessors.length) {
                    nextNorthPos = g.node(predecessors[0]).order;
                    scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos);
                    southPos = southLookahead;
                    prevNorthPos = nextNorthPos;
                  }
                }
                scan(south, southPos, south.length, nextNorthPos, north.length);
              });
              return south;
            }
            _.reduce(layering, visitLayer);
            return conflicts;
          }
          function findOtherInnerSegmentNode(g, v) {
            if (g.node(v).dummy) {
              return _.find(g.predecessors(v), function(u) {
                return g.node(u).dummy;
              });
            }
          }
          function addConflict(conflicts, v, w) {
            if (v > w) {
              var tmp = v;
              v = w;
              w = tmp;
            }
            var conflictsV = conflicts[v];
            if (!conflictsV) {
              conflicts[v] = conflictsV = {};
            }
            conflictsV[w] = true;
          }
          function hasConflict(conflicts, v, w) {
            if (v > w) {
              var tmp = v;
              v = w;
              w = tmp;
            }
            return _.has(conflicts[v], w);
          }
          function verticalAlignment(g, layering, conflicts, neighborFn) {
            var root = {}, align = {}, pos = {};
            _.forEach(layering, function(layer) {
              _.forEach(layer, function(v, order) {
                root[v] = v;
                align[v] = v;
                pos[v] = order;
              });
            });
            _.forEach(layering, function(layer) {
              var prevIdx = -1;
              _.forEach(layer, function(v) {
                var ws = neighborFn(v);
                if (ws.length) {
                  ws = _.sortBy(ws, function(w2) {
                    return pos[w2];
                  });
                  var mp = (ws.length - 1) / 2;
                  for (var i = Math.floor(mp), il = Math.ceil(mp); i <= il; ++i) {
                    var w = ws[i];
                    if (align[v] === v && prevIdx < pos[w] && !hasConflict(conflicts, v, w)) {
                      align[w] = v;
                      align[v] = root[v] = root[w];
                      prevIdx = pos[w];
                    }
                  }
                }
              });
            });
            return { root, align };
          }
          function horizontalCompaction(g, layering, root, align, reverseSep) {
            var xs = {}, blockG = buildBlockGraph(g, layering, root, reverseSep), borderType = reverseSep ? "borderLeft" : "borderRight";
            function iterate(setXsFunc, nextNodesFunc) {
              var stack = blockG.nodes();
              var elem = stack.pop();
              var visited = {};
              while (elem) {
                if (visited[elem]) {
                  setXsFunc(elem);
                } else {
                  visited[elem] = true;
                  stack.push(elem);
                  stack = stack.concat(nextNodesFunc(elem));
                }
                elem = stack.pop();
              }
            }
            function pass1(elem) {
              xs[elem] = blockG.inEdges(elem).reduce(function(acc, e) {
                return Math.max(acc, xs[e.v] + blockG.edge(e));
              }, 0);
            }
            function pass2(elem) {
              var min = blockG.outEdges(elem).reduce(function(acc, e) {
                return Math.min(acc, xs[e.w] - blockG.edge(e));
              }, Number.POSITIVE_INFINITY);
              var node = g.node(elem);
              if (min !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {
                xs[elem] = Math.max(xs[elem], min);
              }
            }
            iterate(pass1, blockG.predecessors.bind(blockG));
            iterate(pass2, blockG.successors.bind(blockG));
            _.forEach(align, function(v) {
              xs[v] = xs[root[v]];
            });
            return xs;
          }
          function buildBlockGraph(g, layering, root, reverseSep) {
            var blockGraph = new Graph(), graphLabel = g.graph(), sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep);
            _.forEach(layering, function(layer) {
              var u;
              _.forEach(layer, function(v) {
                var vRoot = root[v];
                blockGraph.setNode(vRoot);
                if (u) {
                  var uRoot = root[u], prevMax = blockGraph.edge(uRoot, vRoot);
                  blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g, v, u), prevMax || 0));
                }
                u = v;
              });
            });
            return blockGraph;
          }
          function findSmallestWidthAlignment(g, xss) {
            return _.minBy(_.values(xss), function(xs) {
              var max = Number.NEGATIVE_INFINITY;
              var min = Number.POSITIVE_INFINITY;
              _.forIn(xs, function(x, v) {
                var halfWidth = width(g, v) / 2;
                max = Math.max(x + halfWidth, max);
                min = Math.min(x - halfWidth, min);
              });
              return max - min;
            });
          }
          function alignCoordinates(xss, alignTo) {
            var alignToVals = _.values(alignTo), alignToMin = _.min(alignToVals), alignToMax = _.max(alignToVals);
            _.forEach(["u", "d"], function(vert) {
              _.forEach(["l", "r"], function(horiz) {
                var alignment = vert + horiz, xs = xss[alignment], delta;
                if (xs === alignTo)
                  return;
                var xsVals = _.values(xs);
                delta = horiz === "l" ? alignToMin - _.min(xsVals) : alignToMax - _.max(xsVals);
                if (delta) {
                  xss[alignment] = _.mapValues(xs, function(x) {
                    return x + delta;
                  });
                }
              });
            });
          }
          function balance(xss, align) {
            return _.mapValues(xss.ul, function(ignore, v) {
              if (align) {
                return xss[align.toLowerCase()][v];
              } else {
                var xs = _.sortBy(_.map(xss, v));
                return (xs[1] + xs[2]) / 2;
              }
            });
          }
          function positionX(g) {
            var layering = util.buildLayerMatrix(g);
            var conflicts = _.merge(
              findType1Conflicts(g, layering),
              findType2Conflicts(g, layering)
            );
            var xss = {};
            var adjustedLayering;
            _.forEach(["u", "d"], function(vert) {
              adjustedLayering = vert === "u" ? layering : _.values(layering).reverse();
              _.forEach(["l", "r"], function(horiz) {
                if (horiz === "r") {
                  adjustedLayering = _.map(adjustedLayering, function(inner) {
                    return _.values(inner).reverse();
                  });
                }
                var neighborFn = (vert === "u" ? g.predecessors : g.successors).bind(g);
                var align = verticalAlignment(g, adjustedLayering, conflicts, neighborFn);
                var xs = horizontalCompaction(
                  g,
                  adjustedLayering,
                  align.root,
                  align.align,
                  horiz === "r"
                );
                if (horiz === "r") {
                  xs = _.mapValues(xs, function(x) {
                    return -x;
                  });
                }
                xss[vert + horiz] = xs;
              });
            });
            var smallestWidth = findSmallestWidthAlignment(g, xss);
            alignCoordinates(xss, smallestWidth);
            return balance(xss, g.graph().align);
          }
          function sep(nodeSep, edgeSep, reverseSep) {
            return function(g, v, w) {
              var vLabel = g.node(v);
              var wLabel = g.node(w);
              var sum = 0;
              var delta;
              sum += vLabel.width / 2;
              if (_.has(vLabel, "labelpos")) {
                switch (vLabel.labelpos.toLowerCase()) {
                  case "l":
                    delta = -vLabel.width / 2;
                    break;
                  case "r":
                    delta = vLabel.width / 2;
                    break;
                }
              }
              if (delta) {
                sum += reverseSep ? delta : -delta;
              }
              delta = 0;
              sum += (vLabel.dummy ? edgeSep : nodeSep) / 2;
              sum += (wLabel.dummy ? edgeSep : nodeSep) / 2;
              sum += wLabel.width / 2;
              if (_.has(wLabel, "labelpos")) {
                switch (wLabel.labelpos.toLowerCase()) {
                  case "l":
                    delta = wLabel.width / 2;
                    break;
                  case "r":
                    delta = -wLabel.width / 2;
                    break;
                }
              }
              if (delta) {
                sum += reverseSep ? delta : -delta;
              }
              delta = 0;
              return sum;
            };
          }
          function width(g, v) {
            return g.node(v).width;
          }
        },
        "./node_modules/_dagre@0.8.5@dagre/lib/position/index.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          var _ = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/lodash.js");
          var util = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/util.js");
          var positionX = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/position/bk.js").positionX;
          module2.exports = position;
          function position(g) {
            g = util.asNonCompoundGraph(g);
            positionY(g);
            _.forEach(positionX(g), function(x, v) {
              g.node(v).x = x;
            });
          }
          function positionY(g) {
            var layering = util.buildLayerMatrix(g);
            var rankSep = g.graph().ranksep;
            var prevY = 0;
            _.forEach(layering, function(layer) {
              var maxHeight = _.max(_.map(layer, function(v) {
                return g.node(v).height;
              }));
              _.forEach(layer, function(v) {
                g.node(v).y = prevY + maxHeight / 2;
              });
              prevY += maxHeight + rankSep;
            });
          }
        },
        "./node_modules/_dagre@0.8.5@dagre/lib/rank/feasible-tree.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          var _ = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/lodash.js");
          var Graph = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/graphlib.js").Graph;
          var slack = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/rank/util.js").slack;
          module2.exports = feasibleTree;
          function feasibleTree(g) {
            var t = new Graph({ directed: false });
            var start = g.nodes()[0];
            var size = g.nodeCount();
            t.setNode(start, {});
            var edge, delta;
            while (tightTree(t, g) < size) {
              edge = findMinSlackEdge(t, g);
              delta = t.hasNode(edge.v) ? slack(g, edge) : -slack(g, edge);
              shiftRanks(t, g, delta);
            }
            return t;
          }
          function tightTree(t, g) {
            function dfs(v) {
              _.forEach(g.nodeEdges(v), function(e) {
                var edgeV = e.v, w = v === edgeV ? e.w : edgeV;
                if (!t.hasNode(w) && !slack(g, e)) {
                  t.setNode(w, {});
                  t.setEdge(v, w, {});
                  dfs(w);
                }
              });
            }
            _.forEach(t.nodes(), dfs);
            return t.nodeCount();
          }
          function findMinSlackEdge(t, g) {
            return _.minBy(g.edges(), function(e) {
              if (t.hasNode(e.v) !== t.hasNode(e.w)) {
                return slack(g, e);
              }
            });
          }
          function shiftRanks(t, g, delta) {
            _.forEach(t.nodes(), function(v) {
              g.node(v).rank += delta;
            });
          }
        },
        "./node_modules/_dagre@0.8.5@dagre/lib/rank/index.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          var rankUtil = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/rank/util.js");
          var longestPath = rankUtil.longestPath;
          var feasibleTree = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/rank/feasible-tree.js");
          var networkSimplex = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/rank/network-simplex.js");
          module2.exports = rank;
          function rank(g) {
            switch (g.graph().ranker) {
              case "network-simplex":
                networkSimplexRanker(g);
                break;
              case "tight-tree":
                tightTreeRanker(g);
                break;
              case "longest-path":
                longestPathRanker(g);
                break;
              default:
                networkSimplexRanker(g);
            }
          }
          var longestPathRanker = longestPath;
          function tightTreeRanker(g) {
            longestPath(g);
            feasibleTree(g);
          }
          function networkSimplexRanker(g) {
            networkSimplex(g);
          }
        },
        "./node_modules/_dagre@0.8.5@dagre/lib/rank/network-simplex.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          var _ = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/lodash.js");
          var feasibleTree = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/rank/feasible-tree.js");
          var slack = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/rank/util.js").slack;
          var initRank = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/rank/util.js").longestPath;
          var preorder = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/graphlib.js").alg.preorder;
          var postorder = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/graphlib.js").alg.postorder;
          var simplify = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/util.js").simplify;
          module2.exports = networkSimplex;
          networkSimplex.initLowLimValues = initLowLimValues;
          networkSimplex.initCutValues = initCutValues;
          networkSimplex.calcCutValue = calcCutValue;
          networkSimplex.leaveEdge = leaveEdge;
          networkSimplex.enterEdge = enterEdge;
          networkSimplex.exchangeEdges = exchangeEdges;
          function networkSimplex(g) {
            g = simplify(g);
            initRank(g);
            var t = feasibleTree(g);
            initLowLimValues(t);
            initCutValues(t, g);
            var e, f;
            while (e = leaveEdge(t)) {
              f = enterEdge(t, g, e);
              exchangeEdges(t, g, e, f);
            }
          }
          function initCutValues(t, g) {
            var vs = postorder(t, t.nodes());
            vs = vs.slice(0, vs.length - 1);
            _.forEach(vs, function(v) {
              assignCutValue(t, g, v);
            });
          }
          function assignCutValue(t, g, child) {
            var childLab = t.node(child);
            var parent = childLab.parent;
            t.edge(child, parent).cutvalue = calcCutValue(t, g, child);
          }
          function calcCutValue(t, g, child) {
            var childLab = t.node(child);
            var parent = childLab.parent;
            var childIsTail = true;
            var graphEdge = g.edge(child, parent);
            var cutValue = 0;
            if (!graphEdge) {
              childIsTail = false;
              graphEdge = g.edge(parent, child);
            }
            cutValue = graphEdge.weight;
            _.forEach(g.nodeEdges(child), function(e) {
              var isOutEdge = e.v === child, other = isOutEdge ? e.w : e.v;
              if (other !== parent) {
                var pointsToHead = isOutEdge === childIsTail, otherWeight = g.edge(e).weight;
                cutValue += pointsToHead ? otherWeight : -otherWeight;
                if (isTreeEdge(t, child, other)) {
                  var otherCutValue = t.edge(child, other).cutvalue;
                  cutValue += pointsToHead ? -otherCutValue : otherCutValue;
                }
              }
            });
            return cutValue;
          }
          function initLowLimValues(tree, root) {
            if (arguments.length < 2) {
              root = tree.nodes()[0];
            }
            dfsAssignLowLim(tree, {}, 1, root);
          }
          function dfsAssignLowLim(tree, visited, nextLim, v, parent) {
            var low = nextLim;
            var label = tree.node(v);
            visited[v] = true;
            _.forEach(tree.neighbors(v), function(w) {
              if (!_.has(visited, w)) {
                nextLim = dfsAssignLowLim(tree, visited, nextLim, w, v);
              }
            });
            label.low = low;
            label.lim = nextLim++;
            if (parent) {
              label.parent = parent;
            } else {
              delete label.parent;
            }
            return nextLim;
          }
          function leaveEdge(tree) {
            return _.find(tree.edges(), function(e) {
              return tree.edge(e).cutvalue < 0;
            });
          }
          function enterEdge(t, g, edge) {
            var v = edge.v;
            var w = edge.w;
            if (!g.hasEdge(v, w)) {
              v = edge.w;
              w = edge.v;
            }
            var vLabel = t.node(v);
            var wLabel = t.node(w);
            var tailLabel = vLabel;
            var flip = false;
            if (vLabel.lim > wLabel.lim) {
              tailLabel = wLabel;
              flip = true;
            }
            var candidates = _.filter(g.edges(), function(edge2) {
              return flip === isDescendant(t, t.node(edge2.v), tailLabel) && flip !== isDescendant(t, t.node(edge2.w), tailLabel);
            });
            return _.minBy(candidates, function(edge2) {
              return slack(g, edge2);
            });
          }
          function exchangeEdges(t, g, e, f) {
            var v = e.v;
            var w = e.w;
            t.removeEdge(v, w);
            t.setEdge(f.v, f.w, {});
            initLowLimValues(t);
            initCutValues(t, g);
            updateRanks(t, g);
          }
          function updateRanks(t, g) {
            var root = _.find(t.nodes(), function(v) {
              return !g.node(v).parent;
            });
            var vs = preorder(t, root);
            vs = vs.slice(1);
            _.forEach(vs, function(v) {
              var parent = t.node(v).parent, edge = g.edge(v, parent), flipped = false;
              if (!edge) {
                edge = g.edge(parent, v);
                flipped = true;
              }
              g.node(v).rank = g.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);
            });
          }
          function isTreeEdge(tree, u, v) {
            return tree.hasEdge(u, v);
          }
          function isDescendant(tree, vLabel, rootLabel) {
            return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;
          }
        },
        "./node_modules/_dagre@0.8.5@dagre/lib/rank/util.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          var _ = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/lodash.js");
          module2.exports = {
            longestPath,
            slack
          };
          function longestPath(g) {
            var visited = {};
            function dfs(v) {
              var label = g.node(v);
              if (_.has(visited, v)) {
                return label.rank;
              }
              visited[v] = true;
              var rank = _.min(_.map(g.outEdges(v), function(e) {
                return dfs(e.w) - g.edge(e).minlen;
              }));
              if (rank === Number.POSITIVE_INFINITY || rank === void 0 || rank === null) {
                rank = 0;
              }
              return label.rank = rank;
            }
            _.forEach(g.sources(), dfs);
          }
          function slack(g, e) {
            return g.node(e.w).rank - g.node(e.v).rank - g.edge(e).minlen;
          }
        },
        "./node_modules/_dagre@0.8.5@dagre/lib/util.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          var _ = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/lodash.js");
          var Graph = __webpack_require__("./node_modules/_dagre@0.8.5@dagre/lib/graphlib.js").Graph;
          module2.exports = {
            addDummyNode,
            simplify,
            asNonCompoundGraph,
            successorWeights,
            predecessorWeights,
            intersectRect,
            buildLayerMatrix,
            normalizeRanks,
            removeEmptyRanks,
            addBorderNode,
            maxRank,
            partition,
            time,
            notime
          };
          function addDummyNode(g, type, attrs, name) {
            var v;
            do {
              v = _.uniqueId(name);
            } while (g.hasNode(v));
            attrs.dummy = type;
            g.setNode(v, attrs);
            return v;
          }
          function simplify(g) {
            var simplified = new Graph().setGraph(g.graph());
            _.forEach(g.nodes(), function(v) {
              simplified.setNode(v, g.node(v));
            });
            _.forEach(g.edges(), function(e) {
              var simpleLabel = simplified.edge(e.v, e.w) || { weight: 0, minlen: 1 };
              var label = g.edge(e);
              simplified.setEdge(e.v, e.w, {
                weight: simpleLabel.weight + label.weight,
                minlen: Math.max(simpleLabel.minlen, label.minlen)
              });
            });
            return simplified;
          }
          function asNonCompoundGraph(g) {
            var simplified = new Graph({ multigraph: g.isMultigraph() }).setGraph(g.graph());
            _.forEach(g.nodes(), function(v) {
              if (!g.children(v).length) {
                simplified.setNode(v, g.node(v));
              }
            });
            _.forEach(g.edges(), function(e) {
              simplified.setEdge(e, g.edge(e));
            });
            return simplified;
          }
          function successorWeights(g) {
            var weightMap = _.map(g.nodes(), function(v) {
              var sucs = {};
              _.forEach(g.outEdges(v), function(e) {
                sucs[e.w] = (sucs[e.w] || 0) + g.edge(e).weight;
              });
              return sucs;
            });
            return _.zipObject(g.nodes(), weightMap);
          }
          function predecessorWeights(g) {
            var weightMap = _.map(g.nodes(), function(v) {
              var preds = {};
              _.forEach(g.inEdges(v), function(e) {
                preds[e.v] = (preds[e.v] || 0) + g.edge(e).weight;
              });
              return preds;
            });
            return _.zipObject(g.nodes(), weightMap);
          }
          function intersectRect(rect, point) {
            var x = rect.x;
            var y = rect.y;
            var dx = point.x - x;
            var dy = point.y - y;
            var w = rect.width / 2;
            var h = rect.height / 2;
            if (!dx && !dy) {
              throw new Error("Not possible to find intersection inside of the rectangle");
            }
            var sx, sy;
            if (Math.abs(dy) * w > Math.abs(dx) * h) {
              if (dy < 0) {
                h = -h;
              }
              sx = h * dx / dy;
              sy = h;
            } else {
              if (dx < 0) {
                w = -w;
              }
              sx = w;
              sy = w * dy / dx;
            }
            return { x: x + sx, y: y + sy };
          }
          function buildLayerMatrix(g) {
            var layering = _.map(_.range(maxRank(g) + 1), function() {
              return [];
            });
            _.forEach(g.nodes(), function(v) {
              var node = g.node(v);
              var rank = node.rank;
              if (!_.isUndefined(rank)) {
                layering[rank][node.order] = v;
              }
            });
            return layering;
          }
          function normalizeRanks(g) {
            var min = _.min(_.map(g.nodes(), function(v) {
              return g.node(v).rank;
            }));
            _.forEach(g.nodes(), function(v) {
              var node = g.node(v);
              if (_.has(node, "rank")) {
                node.rank -= min;
              }
            });
          }
          function removeEmptyRanks(g) {
            var offset = _.min(_.map(g.nodes(), function(v) {
              return g.node(v).rank;
            }));
            var layers = [];
            _.forEach(g.nodes(), function(v) {
              var rank = g.node(v).rank - offset;
              if (!layers[rank]) {
                layers[rank] = [];
              }
              layers[rank].push(v);
            });
            var delta = 0;
            var nodeRankFactor = g.graph().nodeRankFactor;
            _.forEach(layers, function(vs, i) {
              if (_.isUndefined(vs) && i % nodeRankFactor !== 0) {
                --delta;
              } else if (delta) {
                _.forEach(vs, function(v) {
                  g.node(v).rank += delta;
                });
              }
            });
          }
          function addBorderNode(g, prefix, rank, order) {
            var node = {
              width: 0,
              height: 0
            };
            if (arguments.length >= 4) {
              node.rank = rank;
              node.order = order;
            }
            return addDummyNode(g, "border", node, prefix);
          }
          function maxRank(g) {
            return _.max(_.map(g.nodes(), function(v) {
              var rank = g.node(v).rank;
              if (!_.isUndefined(rank)) {
                return rank;
              }
            }));
          }
          function partition(collection, fn) {
            var result = { lhs: [], rhs: [] };
            _.forEach(collection, function(value) {
              if (fn(value)) {
                result.lhs.push(value);
              } else {
                result.rhs.push(value);
              }
            });
            return result;
          }
          function time(name, fn) {
            var start = _.now();
            try {
              return fn();
            } finally {
              console.log(name + " time: " + (_.now() - start) + "ms");
            }
          }
          function notime(name, fn) {
            return fn();
          }
        },
        "./node_modules/_dagre@0.8.5@dagre/lib/version.js": function(module2, exports2) {
          module2.exports = "0.8.5";
        },
        "./node_modules/_graphlib@2.1.8@graphlib/index.js": function(module2, exports2, __webpack_require__) {
          var lib = __webpack_require__("./node_modules/_graphlib@2.1.8@graphlib/lib/index.js");
          module2.exports = {
            Graph: lib.Graph,
            json: __webpack_require__("./node_modules/_graphlib@2.1.8@graphlib/lib/json.js"),
            alg: __webpack_require__("./node_modules/_graphlib@2.1.8@graphlib/lib/alg/index.js"),
            version: lib.version
          };
        },
        "./node_modules/_graphlib@2.1.8@graphlib/lib/alg/components.js": function(module2, exports2, __webpack_require__) {
          var _ = __webpack_require__("./node_modules/_graphlib@2.1.8@graphlib/lib/lodash.js");
          module2.exports = components;
          function components(g) {
            var visited = {};
            var cmpts = [];
            var cmpt;
            function dfs(v) {
              if (_.has(visited, v))
                return;
              visited[v] = true;
              cmpt.push(v);
              _.each(g.successors(v), dfs);
              _.each(g.predecessors(v), dfs);
            }
            _.each(g.nodes(), function(v) {
              cmpt = [];
              dfs(v);
              if (cmpt.length) {
                cmpts.push(cmpt);
              }
            });
            return cmpts;
          }
        },
        "./node_modules/_graphlib@2.1.8@graphlib/lib/alg/dfs.js": function(module2, exports2, __webpack_require__) {
          var _ = __webpack_require__("./node_modules/_graphlib@2.1.8@graphlib/lib/lodash.js");
          module2.exports = dfs;
          function dfs(g, vs, order) {
            if (!_.isArray(vs)) {
              vs = [vs];
            }
            var navigation = (g.isDirected() ? g.successors : g.neighbors).bind(g);
            var acc = [];
            var visited = {};
            _.each(vs, function(v) {
              if (!g.hasNode(v)) {
                throw new Error("Graph does not have node: " + v);
              }
              doDfs(g, v, order === "post", visited, navigation, acc);
            });
            return acc;
          }
          function doDfs(g, v, postorder, visited, navigation, acc) {
            if (!_.has(visited, v)) {
              visited[v] = true;
              if (!postorder) {
                acc.push(v);
              }
              _.each(navigation(v), function(w) {
                doDfs(g, w, postorder, visited, navigation, acc);
              });
              if (postorder) {
                acc.push(v);
              }
            }
          }
        },
        "./node_modules/_graphlib@2.1.8@graphlib/lib/alg/dijkstra-all.js": function(module2, exports2, __webpack_require__) {
          var dijkstra = __webpack_require__("./node_modules/_graphlib@2.1.8@graphlib/lib/alg/dijkstra.js");
          var _ = __webpack_require__("./node_modules/_graphlib@2.1.8@graphlib/lib/lodash.js");
          module2.exports = dijkstraAll;
          function dijkstraAll(g, weightFunc, edgeFunc) {
            return _.transform(g.nodes(), function(acc, v) {
              acc[v] = dijkstra(g, v, weightFunc, edgeFunc);
            }, {});
          }
        },
        "./node_modules/_graphlib@2.1.8@graphlib/lib/alg/dijkstra.js": function(module2, exports2, __webpack_require__) {
          var _ = __webpack_require__("./node_modules/_graphlib@2.1.8@graphlib/lib/lodash.js");
          var PriorityQueue = __webpack_require__("./node_modules/_graphlib@2.1.8@graphlib/lib/data/priority-queue.js");
          module2.exports = dijkstra;
          var DEFAULT_WEIGHT_FUNC = _.constant(1);
          function dijkstra(g, source, weightFn, edgeFn) {
            return runDijkstra(
              g,
              String(source),
              weightFn || DEFAULT_WEIGHT_FUNC,
              edgeFn || function(v) {
                return g.outEdges(v);
              }
            );
          }
          function runDijkstra(g, source, weightFn, edgeFn) {
            var results = {};
            var pq = new PriorityQueue();
            var v, vEntry;
            var updateNeighbors = function(edge) {
              var w = edge.v !== v ? edge.v : edge.w;
              var wEntry = results[w];
              var weight = weightFn(edge);
              var distance = vEntry.distance + weight;
              if (weight < 0) {
                throw new Error("dijkstra does not allow negative edge weights. Bad edge: " + edge + " Weight: " + weight);
              }
              if (distance < wEntry.distance) {
                wEntry.distance = distance;
                wEntry.predecessor = v;
                pq.decrease(w, distance);
              }
            };
            g.nodes().forEach(function(v2) {
              var distance = v2 === source ? 0 : Number.POSITIVE_INFINITY;
              results[v2] = { distance };
              pq.add(v2, distance);
            });
            while (pq.size() > 0) {
              v = pq.removeMin();
              vEntry = results[v];
              if (vEntry.distance === Number.POSITIVE_INFINITY) {
                break;
              }
              edgeFn(v).forEach(updateNeighbors);
            }
            return results;
          }
        },
        "./node_modules/_graphlib@2.1.8@graphlib/lib/alg/find-cycles.js": function(module2, exports2, __webpack_require__) {
          var _ = __webpack_require__("./node_modules/_graphlib@2.1.8@graphlib/lib/lodash.js");
          var tarjan = __webpack_require__("./node_modules/_graphlib@2.1.8@graphlib/lib/alg/tarjan.js");
          module2.exports = findCycles;
          function findCycles(g) {
            return _.filter(tarjan(g), function(cmpt) {
              return cmpt.length > 1 || cmpt.length === 1 && g.hasEdge(cmpt[0], cmpt[0]);
            });
          }
        },
        "./node_modules/_graphlib@2.1.8@graphlib/lib/alg/floyd-warshall.js": function(module2, exports2, __webpack_require__) {
          var _ = __webpack_require__("./node_modules/_graphlib@2.1.8@graphlib/lib/lodash.js");
          module2.exports = floydWarshall;
          var DEFAULT_WEIGHT_FUNC = _.constant(1);
          function floydWarshall(g, weightFn, edgeFn) {
            return runFloydWarshall(
              g,
              weightFn || DEFAULT_WEIGHT_FUNC,
              edgeFn || function(v) {
                return g.outEdges(v);
              }
            );
          }
          function runFloydWarshall(g, weightFn, edgeFn) {
            var results = {};
            var nodes = g.nodes();
            nodes.forEach(function(v) {
              results[v] = {};
              results[v][v] = { distance: 0 };
              nodes.forEach(function(w) {
                if (v !== w) {
                  results[v][w] = { distance: Number.POSITIVE_INFINITY };
                }
              });
              edgeFn(v).forEach(function(edge) {
                var w = edge.v === v ? edge.w : edge.v;
                var d = weightFn(edge);
                results[v][w] = { distance: d, predecessor: v };
              });
            });
            nodes.forEach(function(k) {
              var rowK = results[k];
              nodes.forEach(function(i) {
                var rowI = results[i];
                nodes.forEach(function(j) {
                  var ik = rowI[k];
                  var kj = rowK[j];
                  var ij = rowI[j];
                  var altDistance = ik.distance + kj.distance;
                  if (altDistance < ij.distance) {
                    ij.distance = altDistance;
                    ij.predecessor = kj.predecessor;
                  }
                });
              });
            });
            return results;
          }
        },
        "./node_modules/_graphlib@2.1.8@graphlib/lib/alg/index.js": function(module2, exports2, __webpack_require__) {
          module2.exports = {
            components: __webpack_require__("./node_modules/_graphlib@2.1.8@graphlib/lib/alg/components.js"),
            dijkstra: __webpack_require__("./node_modules/_graphlib@2.1.8@graphlib/lib/alg/dijkstra.js"),
            dijkstraAll: __webpack_require__("./node_modules/_graphlib@2.1.8@graphlib/lib/alg/dijkstra-all.js"),
            findCycles: __webpack_require__("./node_modules/_graphlib@2.1.8@graphlib/lib/alg/find-cycles.js"),
            floydWarshall: __webpack_require__("./node_modules/_graphlib@2.1.8@graphlib/lib/alg/floyd-warshall.js"),
            isAcyclic: __webpack_require__("./node_modules/_graphlib@2.1.8@graphlib/lib/alg/is-acyclic.js"),
            postorder: __webpack_require__("./node_modules/_graphlib@2.1.8@graphlib/lib/alg/postorder.js"),
            preorder: __webpack_require__("./node_modules/_graphlib@2.1.8@graphlib/lib/alg/preorder.js"),
            prim: __webpack_require__("./node_modules/_graphlib@2.1.8@graphlib/lib/alg/prim.js"),
            tarjan: __webpack_require__("./node_modules/_graphlib@2.1.8@graphlib/lib/alg/tarjan.js"),
            topsort: __webpack_require__("./node_modules/_graphlib@2.1.8@graphlib/lib/alg/topsort.js")
          };
        },
        "./node_modules/_graphlib@2.1.8@graphlib/lib/alg/is-acyclic.js": function(module2, exports2, __webpack_require__) {
          var topsort = __webpack_require__("./node_modules/_graphlib@2.1.8@graphlib/lib/alg/topsort.js");
          module2.exports = isAcyclic;
          function isAcyclic(g) {
            try {
              topsort(g);
            } catch (e) {
              if (e instanceof topsort.CycleException) {
                return false;
              }
              throw e;
            }
            return true;
          }
        },
        "./node_modules/_graphlib@2.1.8@graphlib/lib/alg/postorder.js": function(module2, exports2, __webpack_require__) {
          var dfs = __webpack_require__("./node_modules/_graphlib@2.1.8@graphlib/lib/alg/dfs.js");
          module2.exports = postorder;
          function postorder(g, vs) {
            return dfs(g, vs, "post");
          }
        },
        "./node_modules/_graphlib@2.1.8@graphlib/lib/alg/preorder.js": function(module2, exports2, __webpack_require__) {
          var dfs = __webpack_require__("./node_modules/_graphlib@2.1.8@graphlib/lib/alg/dfs.js");
          module2.exports = preorder;
          function preorder(g, vs) {
            return dfs(g, vs, "pre");
          }
        },
        "./node_modules/_graphlib@2.1.8@graphlib/lib/alg/prim.js": function(module2, exports2, __webpack_require__) {
          var _ = __webpack_require__("./node_modules/_graphlib@2.1.8@graphlib/lib/lodash.js");
          var Graph = __webpack_require__("./node_modules/_graphlib@2.1.8@graphlib/lib/graph.js");
          var PriorityQueue = __webpack_require__("./node_modules/_graphlib@2.1.8@graphlib/lib/data/priority-queue.js");
          module2.exports = prim;
          function prim(g, weightFunc) {
            var result = new Graph();
            var parents = {};
            var pq = new PriorityQueue();
            var v;
            function updateNeighbors(edge) {
              var w = edge.v === v ? edge.w : edge.v;
              var pri = pq.priority(w);
              if (pri !== void 0) {
                var edgeWeight = weightFunc(edge);
                if (edgeWeight < pri) {
                  parents[w] = v;
                  pq.decrease(w, edgeWeight);
                }
              }
            }
            if (g.nodeCount() === 0) {
              return result;
            }
            _.each(g.nodes(), function(v2) {
              pq.add(v2, Number.POSITIVE_INFINITY);
              result.setNode(v2);
            });
            pq.decrease(g.nodes()[0], 0);
            var init = false;
            while (pq.size() > 0) {
              v = pq.removeMin();
              if (_.has(parents, v)) {
                result.setEdge(v, parents[v]);
              } else if (init) {
                throw new Error("Input graph is not connected: " + g);
              } else {
                init = true;
              }
              g.nodeEdges(v).forEach(updateNeighbors);
            }
            return result;
          }
        },
        "./node_modules/_graphlib@2.1.8@graphlib/lib/alg/tarjan.js": function(module2, exports2, __webpack_require__) {
          var _ = __webpack_require__("./node_modules/_graphlib@2.1.8@graphlib/lib/lodash.js");
          module2.exports = tarjan;
          function tarjan(g) {
            var index = 0;
            var stack = [];
            var visited = {};
            var results = [];
            function dfs(v) {
              var entry = visited[v] = {
                onStack: true,
                lowlink: index,
                index: index++
              };
              stack.push(v);
              g.successors(v).forEach(function(w2) {
                if (!_.has(visited, w2)) {
                  dfs(w2);
                  entry.lowlink = Math.min(entry.lowlink, visited[w2].lowlink);
                } else if (visited[w2].onStack) {
                  entry.lowlink = Math.min(entry.lowlink, visited[w2].index);
                }
              });
              if (entry.lowlink === entry.index) {
                var cmpt = [];
                var w;
                do {
                  w = stack.pop();
                  visited[w].onStack = false;
                  cmpt.push(w);
                } while (v !== w);
                results.push(cmpt);
              }
            }
            g.nodes().forEach(function(v) {
              if (!_.has(visited, v)) {
                dfs(v);
              }
            });
            return results;
          }
        },
        "./node_modules/_graphlib@2.1.8@graphlib/lib/alg/topsort.js": function(module2, exports2, __webpack_require__) {
          var _ = __webpack_require__("./node_modules/_graphlib@2.1.8@graphlib/lib/lodash.js");
          module2.exports = topsort;
          topsort.CycleException = CycleException;
          function topsort(g) {
            var visited = {};
            var stack = {};
            var results = [];
            function visit(node) {
              if (_.has(stack, node)) {
                throw new CycleException();
              }
              if (!_.has(visited, node)) {
                stack[node] = true;
                visited[node] = true;
                _.each(g.predecessors(node), visit);
                delete stack[node];
                results.push(node);
              }
            }
            _.each(g.sinks(), visit);
            if (_.size(visited) !== g.nodeCount()) {
              throw new CycleException();
            }
            return results;
          }
          function CycleException() {
          }
          CycleException.prototype = new Error();
        },
        "./node_modules/_graphlib@2.1.8@graphlib/lib/data/priority-queue.js": function(module2, exports2, __webpack_require__) {
          var _ = __webpack_require__("./node_modules/_graphlib@2.1.8@graphlib/lib/lodash.js");
          module2.exports = PriorityQueue;
          function PriorityQueue() {
            this._arr = [];
            this._keyIndices = {};
          }
          PriorityQueue.prototype.size = function() {
            return this._arr.length;
          };
          PriorityQueue.prototype.keys = function() {
            return this._arr.map(function(x) {
              return x.key;
            });
          };
          PriorityQueue.prototype.has = function(key) {
            return _.has(this._keyIndices, key);
          };
          PriorityQueue.prototype.priority = function(key) {
            var index = this._keyIndices[key];
            if (index !== void 0) {
              return this._arr[index].priority;
            }
          };
          PriorityQueue.prototype.min = function() {
            if (this.size() === 0) {
              throw new Error("Queue underflow");
            }
            return this._arr[0].key;
          };
          PriorityQueue.prototype.add = function(key, priority) {
            var keyIndices = this._keyIndices;
            key = String(key);
            if (!_.has(keyIndices, key)) {
              var arr = this._arr;
              var index = arr.length;
              keyIndices[key] = index;
              arr.push({ key, priority });
              this._decrease(index);
              return true;
            }
            return false;
          };
          PriorityQueue.prototype.removeMin = function() {
            this._swap(0, this._arr.length - 1);
            var min = this._arr.pop();
            delete this._keyIndices[min.key];
            this._heapify(0);
            return min.key;
          };
          PriorityQueue.prototype.decrease = function(key, priority) {
            var index = this._keyIndices[key];
            if (priority > this._arr[index].priority) {
              throw new Error("New priority is greater than current priority. Key: " + key + " Old: " + this._arr[index].priority + " New: " + priority);
            }
            this._arr[index].priority = priority;
            this._decrease(index);
          };
          PriorityQueue.prototype._heapify = function(i) {
            var arr = this._arr;
            var l = 2 * i;
            var r = l + 1;
            var largest = i;
            if (l < arr.length) {
              largest = arr[l].priority < arr[largest].priority ? l : largest;
              if (r < arr.length) {
                largest = arr[r].priority < arr[largest].priority ? r : largest;
              }
              if (largest !== i) {
                this._swap(i, largest);
                this._heapify(largest);
              }
            }
          };
          PriorityQueue.prototype._decrease = function(index) {
            var arr = this._arr;
            var priority = arr[index].priority;
            var parent;
            while (index !== 0) {
              parent = index >> 1;
              if (arr[parent].priority < priority) {
                break;
              }
              this._swap(index, parent);
              index = parent;
            }
          };
          PriorityQueue.prototype._swap = function(i, j) {
            var arr = this._arr;
            var keyIndices = this._keyIndices;
            var origArrI = arr[i];
            var origArrJ = arr[j];
            arr[i] = origArrJ;
            arr[j] = origArrI;
            keyIndices[origArrJ.key] = i;
            keyIndices[origArrI.key] = j;
          };
        },
        "./node_modules/_graphlib@2.1.8@graphlib/lib/graph.js": function(module2, exports2, __webpack_require__) {
          "use strict";
          var _ = __webpack_require__("./node_modules/_graphlib@2.1.8@graphlib/lib/lodash.js");
          module2.exports = Graph;
          var DEFAULT_EDGE_NAME = "\0";
          var GRAPH_NODE = "\0";
          var EDGE_KEY_DELIM = "";
          function Graph(opts) {
            this._isDirected = _.has(opts, "directed") ? opts.directed : true;
            this._isMultigraph = _.has(opts, "multigraph") ? opts.multigraph : false;
            this._isCompound = _.has(opts, "compound") ? opts.compound : false;
            this._label = void 0;
            this._defaultNodeLabelFn = _.constant(void 0);
            this._defaultEdgeLabelFn = _.constant(void 0);
            this._nodes = {};
            if (this._isCompound) {
              this._parent = {};
              this._children = {};
              this._children[GRAPH_NODE] = {};
            }
            this._in = {};
            this._preds = {};
            this._out = {};
            this._sucs = {};
            this._edgeObjs = {};
            this._edgeLabels = {};
          }
          Graph.prototype._nodeCount = 0;
          Graph.prototype._edgeCount = 0;
          Graph.prototype.isDirected = function() {
            return this._isDirected;
          };
          Graph.prototype.isMultigraph = function() {
            return this._isMultigraph;
          };
          Graph.prototype.isCompound = function() {
            return this._isCompound;
          };
          Graph.prototype.setGraph = function(label) {
            this._label = label;
            return this;
          };
          Graph.prototype.graph = function() {
            return this._label;
          };
          Graph.prototype.setDefaultNodeLabel = function(newDefault) {
            if (!_.isFunction(newDefault)) {
              newDefault = _.constant(newDefault);
            }
            this._defaultNodeLabelFn = newDefault;
            return this;
          };
          Graph.prototype.nodeCount = function() {
            return this._nodeCount;
          };
          Graph.prototype.nodes = function() {
            return _.keys(this._nodes);
          };
          Graph.prototype.sources = function() {
            var self2 = this;
            return _.filter(this.nodes(), function(v) {
              return _.isEmpty(self2._in[v]);
            });
          };
          Graph.prototype.sinks = function() {
            var self2 = this;
            return _.filter(this.nodes(), function(v) {
              return _.isEmpty(self2._out[v]);
            });
          };
          Graph.prototype.setNodes = function(vs, value) {
            var args = arguments;
            var self2 = this;
            _.each(vs, function(v) {
              if (args.length > 1) {
                self2.setNode(v, value);
              } else {
                self2.setNode(v);
              }
            });
            return this;
          };
          Graph.prototype.setNode = function(v, value) {
            if (_.has(this._nodes, v)) {
              if (arguments.length > 1) {
                this._nodes[v] = value;
              }
              return this;
            }
            this._nodes[v] = arguments.length > 1 ? value : this._defaultNodeLabelFn(v);
            if (this._isCompound) {
              this._parent[v] = GRAPH_NODE;
              this._children[v] = {};
              this._children[GRAPH_NODE][v] = true;
            }
            this._in[v] = {};
            this._preds[v] = {};
            this._out[v] = {};
            this._sucs[v] = {};
            ++this._nodeCount;
            return this;
          };
          Graph.prototype.node = function(v) {
            return this._nodes[v];
          };
          Graph.prototype.hasNode = function(v) {
            return _.has(this._nodes, v);
          };
          Graph.prototype.removeNode = function(v) {
            var self2 = this;
            if (_.has(this._nodes, v)) {
              var removeEdge = function(e) {
                self2.removeEdge(self2._edgeObjs[e]);
              };
              delete this._nodes[v];
              if (this._isCompound) {
                this._removeFromParentsChildList(v);
                delete this._parent[v];
                _.each(this.children(v), function(child) {
                  self2.setParent(child);
                });
                delete this._children[v];
              }
              _.each(_.keys(this._in[v]), removeEdge);
              delete this._in[v];
              delete this._preds[v];
              _.each(_.keys(this._out[v]), removeEdge);
              delete this._out[v];
              delete this._sucs[v];
              --this._nodeCount;
            }
            return this;
          };
          Graph.prototype.setParent = function(v, parent) {
            if (!this._isCompound) {
              throw new Error("Cannot set parent in a non-compound graph");
            }
            if (_.isUndefined(parent)) {
              parent = GRAPH_NODE;
            } else {
              parent += "";
              for (var ancestor = parent; !_.isUndefined(ancestor); ancestor = this.parent(ancestor)) {
                if (ancestor === v) {
                  throw new Error("Setting " + parent + " as parent of " + v + " would create a cycle");
                }
              }
              this.setNode(parent);
            }
            this.setNode(v);
            this._removeFromParentsChildList(v);
            this._parent[v] = parent;
            this._children[parent][v] = true;
            return this;
          };
          Graph.prototype._removeFromParentsChildList = function(v) {
            delete this._children[this._parent[v]][v];
          };
          Graph.prototype.parent = function(v) {
            if (this._isCompound) {
              var parent = this._parent[v];
              if (parent !== GRAPH_NODE) {
                return parent;
              }
            }
          };
          Graph.prototype.children = function(v) {
            if (_.isUndefined(v)) {
              v = GRAPH_NODE;
            }
            if (this._isCompound) {
              var children = this._children[v];
              if (children) {
                return _.keys(children);
              }
            } else if (v === GRAPH_NODE) {
              return this.nodes();
            } else if (this.hasNode(v)) {
              return [];
            }
          };
          Graph.prototype.predecessors = function(v) {
            var predsV = this._preds[v];
            if (predsV) {
              return _.keys(predsV);
            }
          };
          Graph.prototype.successors = function(v) {
            var sucsV = this._sucs[v];
            if (sucsV) {
              return _.keys(sucsV);
            }
          };
          Graph.prototype.neighbors = function(v) {
            var preds = this.predecessors(v);
            if (preds) {
              return _.union(preds, this.successors(v));
            }
          };
          Graph.prototype.isLeaf = function(v) {
            var neighbors;
            if (this.isDirected()) {
              neighbors = this.successors(v);
            } else {
              neighbors = this.neighbors(v);
            }
            return neighbors.length === 0;
          };
          Graph.prototype.filterNodes = function(filter) {
            var copy = new this.constructor({
              directed: this._isDirected,
              multigraph: this._isMultigraph,
              compound: this._isCompound
            });
            copy.setGraph(this.graph());
            var self2 = this;
            _.each(this._nodes, function(value, v) {
              if (filter(v)) {
                copy.setNode(v, value);
              }
            });
            _.each(this._edgeObjs, function(e) {
              if (copy.hasNode(e.v) && copy.hasNode(e.w)) {
                copy.setEdge(e, self2.edge(e));
              }
            });
            var parents = {};
            function findParent(v) {
              var parent = self2.parent(v);
              if (parent === void 0 || copy.hasNode(parent)) {
                parents[v] = parent;
                return parent;
              } else if (parent in parents) {
                return parents[parent];
              } else {
                return findParent(parent);
              }
            }
            if (this._isCompound) {
              _.each(copy.nodes(), function(v) {
                copy.setParent(v, findParent(v));
              });
            }
            return copy;
          };
          Graph.prototype.setDefaultEdgeLabel = function(newDefault) {
            if (!_.isFunction(newDefault)) {
              newDefault = _.constant(newDefault);
            }
            this._defaultEdgeLabelFn = newDefault;
            return this;
          };
          Graph.prototype.edgeCount = function() {
            return this._edgeCount;
          };
          Graph.prototype.edges = function() {
            return _.values(this._edgeObjs);
          };
          Graph.prototype.setPath = function(vs, value) {
            var self2 = this;
            var args = arguments;
            _.reduce(vs, function(v, w) {
              if (args.length > 1) {
                self2.setEdge(v, w, value);
              } else {
                self2.setEdge(v, w);
              }
              return w;
            });
            return this;
          };
          Graph.prototype.setEdge = function() {
            var v, w, name, value;
            var valueSpecified = false;
            var arg0 = arguments[0];
            if (typeof arg0 === "object" && arg0 !== null && "v" in arg0) {
              v = arg0.v;
              w = arg0.w;
              name = arg0.name;
              if (arguments.length === 2) {
                value = arguments[1];
                valueSpecified = true;
              }
            } else {
              v = arg0;
              w = arguments[1];
              name = arguments[3];
              if (arguments.length > 2) {
                value = arguments[2];
                valueSpecified = true;
              }
            }
            v = "" + v;
            w = "" + w;
            if (!_.isUndefined(name)) {
              name = "" + name;
            }
            var e = edgeArgsToId(this._isDirected, v, w, name);
            if (_.has(this._edgeLabels, e)) {
              if (valueSpecified) {
                this._edgeLabels[e] = value;
              }
              return this;
            }
            if (!_.isUndefined(name) && !this._isMultigraph) {
              throw new Error("Cannot set a named edge when isMultigraph = false");
            }
            this.setNode(v);
            this.setNode(w);
            this._edgeLabels[e] = valueSpecified ? value : this._defaultEdgeLabelFn(v, w, name);
            var edgeObj = edgeArgsToObj(this._isDirected, v, w, name);
            v = edgeObj.v;
            w = edgeObj.w;
            Object.freeze(edgeObj);
            this._edgeObjs[e] = edgeObj;
            incrementOrInitEntry(this._preds[w], v);
            incrementOrInitEntry(this._sucs[v], w);
            this._in[w][e] = edgeObj;
            this._out[v][e] = edgeObj;
            this._edgeCount++;
            return this;
          };
          Graph.prototype.edge = function(v, w, name) {
            var e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w, name);
            return this._edgeLabels[e];
          };
          Graph.prototype.hasEdge = function(v, w, name) {
            var e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w, name);
            return _.has(this._edgeLabels, e);
          };
          Graph.prototype.removeEdge = function(v, w, name) {
            var e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w, name);
            var edge = this._edgeObjs[e];
            if (edge) {
              v = edge.v;
              w = edge.w;
              delete this._edgeLabels[e];
              delete this._edgeObjs[e];
              decrementOrRemoveEntry(this._preds[w], v);
              decrementOrRemoveEntry(this._sucs[v], w);
              delete this._in[w][e];
              delete this._out[v][e];
              this._edgeCount--;
            }
            return this;
          };
          Graph.prototype.inEdges = function(v, u) {
            var inV = this._in[v];
            if (inV) {
              var edges = _.values(inV);
              if (!u) {
                return edges;
              }
              return _.filter(edges, function(edge) {
                return edge.v === u;
              });
            }
          };
          Graph.prototype.outEdges = function(v, w) {
            var outV = this._out[v];
            if (outV) {
              var edges = _.values(outV);
              if (!w) {
                return edges;
              }
              return _.filter(edges, function(edge) {
                return edge.w === w;
              });
            }
          };
          Graph.prototype.nodeEdges = function(v, w) {
            var inEdges = this.inEdges(v, w);
            if (inEdges) {
              return inEdges.concat(this.outEdges(v, w));
            }
          };
          function incrementOrInitEntry(map, k) {
            if (map[k]) {
              map[k]++;
            } else {
              map[k] = 1;
            }
          }
          function decrementOrRemoveEntry(map, k) {
            if (!--map[k]) {
              delete map[k];
            }
          }
          function edgeArgsToId(isDirected, v_, w_, name) {
            var v = "" + v_;
            var w = "" + w_;
            if (!isDirected && v > w) {
              var tmp = v;
              v = w;
              w = tmp;
            }
            return v + EDGE_KEY_DELIM + w + EDGE_KEY_DELIM + (_.isUndefined(name) ? DEFAULT_EDGE_NAME : name);
          }
          function edgeArgsToObj(isDirected, v_, w_, name) {
            var v = "" + v_;
            var w = "" + w_;
            if (!isDirected && v > w) {
              var tmp = v;
              v = w;
              w = tmp;
            }
            var edgeObj = { v, w };
            if (name) {
              edgeObj.name = name;
            }
            return edgeObj;
          }
          function edgeObjToId(isDirected, edgeObj) {
            return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);
          }
        },
        "./node_modules/_graphlib@2.1.8@graphlib/lib/index.js": function(module2, exports2, __webpack_require__) {
          module2.exports = {
            Graph: __webpack_require__("./node_modules/_graphlib@2.1.8@graphlib/lib/graph.js"),
            version: __webpack_require__("./node_modules/_graphlib@2.1.8@graphlib/lib/version.js")
          };
        },
        "./node_modules/_graphlib@2.1.8@graphlib/lib/json.js": function(module2, exports2, __webpack_require__) {
          var _ = __webpack_require__("./node_modules/_graphlib@2.1.8@graphlib/lib/lodash.js");
          var Graph = __webpack_require__("./node_modules/_graphlib@2.1.8@graphlib/lib/graph.js");
          module2.exports = {
            write,
            read
          };
          function write(g) {
            var json = {
              options: {
                directed: g.isDirected(),
                multigraph: g.isMultigraph(),
                compound: g.isCompound()
              },
              nodes: writeNodes(g),
              edges: writeEdges(g)
            };
            if (!_.isUndefined(g.graph())) {
              json.value = _.clone(g.graph());
            }
            return json;
          }
          function writeNodes(g) {
            return _.map(g.nodes(), function(v) {
              var nodeValue = g.node(v);
              var parent = g.parent(v);
              var node = { v };
              if (!_.isUndefined(nodeValue)) {
                node.value = nodeValue;
              }
              if (!_.isUndefined(parent)) {
                node.parent = parent;
              }
              return node;
            });
          }
          function writeEdges(g) {
            return _.map(g.edges(), function(e) {
              var edgeValue = g.edge(e);
              var edge = { v: e.v, w: e.w };
              if (!_.isUndefined(e.name)) {
                edge.name = e.name;
              }
              if (!_.isUndefined(edgeValue)) {
                edge.value = edgeValue;
              }
              return edge;
            });
          }
          function read(json) {
            var g = new Graph(json.options).setGraph(json.value);
            _.each(json.nodes, function(entry) {
              g.setNode(entry.v, entry.value);
              if (entry.parent) {
                g.setParent(entry.v, entry.parent);
              }
            });
            _.each(json.edges, function(entry) {
              g.setEdge({ v: entry.v, w: entry.w, name: entry.name }, entry.value);
            });
            return g;
          }
        },
        "./node_modules/_graphlib@2.1.8@graphlib/lib/lodash.js": function(module2, exports2, __webpack_require__) {
          var lodash;
          if (true) {
            try {
              lodash = {
                clone: __webpack_require__("./node_modules/_lodash@4.17.20@lodash/clone.js"),
                constant: __webpack_require__("./node_modules/_lodash@4.17.20@lodash/constant.js"),
                each: __webpack_require__("./node_modules/_lodash@4.17.20@lodash/each.js"),
                filter: __webpack_require__("./node_modules/_lodash@4.17.20@lodash/filter.js"),
                has: __webpack_require__("./node_modules/_lodash@4.17.20@lodash/has.js"),
                isArray: __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isArray.js"),
                isEmpty: __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isEmpty.js"),
                isFunction: __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isFunction.js"),
                isUndefined: __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isUndefined.js"),
                keys: __webpack_require__("./node_modules/_lodash@4.17.20@lodash/keys.js"),
                map: __webpack_require__("./node_modules/_lodash@4.17.20@lodash/map.js"),
                reduce: __webpack_require__("./node_modules/_lodash@4.17.20@lodash/reduce.js"),
                size: __webpack_require__("./node_modules/_lodash@4.17.20@lodash/size.js"),
                transform: __webpack_require__("./node_modules/_lodash@4.17.20@lodash/transform.js"),
                union: __webpack_require__("./node_modules/_lodash@4.17.20@lodash/union.js"),
                values: __webpack_require__("./node_modules/_lodash@4.17.20@lodash/values.js")
              };
            } catch (e) {
            }
          }
          if (!lodash) {
            lodash = window._;
          }
          module2.exports = lodash;
        },
        "./node_modules/_graphlib@2.1.8@graphlib/lib/version.js": function(module2, exports2) {
          module2.exports = "2.1.8";
        },
        "./node_modules/_isarray@0.0.1@isarray/index.js": function(module2, exports2) {
          module2.exports = Array.isArray || function(arr) {
            return Object.prototype.toString.call(arr) == "[object Array]";
          };
        },
        "./node_modules/_lodash@4.17.20@lodash/_DataView.js": function(module2, exports2, __webpack_require__) {
          var getNative = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_getNative.js"), root = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_root.js");
          var DataView = getNative(root, "DataView");
          module2.exports = DataView;
        },
        "./node_modules/_lodash@4.17.20@lodash/_Hash.js": function(module2, exports2, __webpack_require__) {
          var hashClear = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_hashClear.js"), hashDelete = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_hashDelete.js"), hashGet = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_hashGet.js"), hashHas = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_hashHas.js"), hashSet = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_hashSet.js");
          function Hash(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          Hash.prototype.clear = hashClear;
          Hash.prototype["delete"] = hashDelete;
          Hash.prototype.get = hashGet;
          Hash.prototype.has = hashHas;
          Hash.prototype.set = hashSet;
          module2.exports = Hash;
        },
        "./node_modules/_lodash@4.17.20@lodash/_ListCache.js": function(module2, exports2, __webpack_require__) {
          var listCacheClear = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_listCacheClear.js"), listCacheDelete = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_listCacheDelete.js"), listCacheGet = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_listCacheGet.js"), listCacheHas = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_listCacheHas.js"), listCacheSet = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_listCacheSet.js");
          function ListCache(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          ListCache.prototype.clear = listCacheClear;
          ListCache.prototype["delete"] = listCacheDelete;
          ListCache.prototype.get = listCacheGet;
          ListCache.prototype.has = listCacheHas;
          ListCache.prototype.set = listCacheSet;
          module2.exports = ListCache;
        },
        "./node_modules/_lodash@4.17.20@lodash/_Map.js": function(module2, exports2, __webpack_require__) {
          var getNative = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_getNative.js"), root = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_root.js");
          var Map2 = getNative(root, "Map");
          module2.exports = Map2;
        },
        "./node_modules/_lodash@4.17.20@lodash/_MapCache.js": function(module2, exports2, __webpack_require__) {
          var mapCacheClear = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_mapCacheClear.js"), mapCacheDelete = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_mapCacheDelete.js"), mapCacheGet = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_mapCacheGet.js"), mapCacheHas = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_mapCacheHas.js"), mapCacheSet = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_mapCacheSet.js");
          function MapCache(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          MapCache.prototype.clear = mapCacheClear;
          MapCache.prototype["delete"] = mapCacheDelete;
          MapCache.prototype.get = mapCacheGet;
          MapCache.prototype.has = mapCacheHas;
          MapCache.prototype.set = mapCacheSet;
          module2.exports = MapCache;
        },
        "./node_modules/_lodash@4.17.20@lodash/_Promise.js": function(module2, exports2, __webpack_require__) {
          var getNative = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_getNative.js"), root = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_root.js");
          var Promise2 = getNative(root, "Promise");
          module2.exports = Promise2;
        },
        "./node_modules/_lodash@4.17.20@lodash/_Set.js": function(module2, exports2, __webpack_require__) {
          var getNative = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_getNative.js"), root = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_root.js");
          var Set2 = getNative(root, "Set");
          module2.exports = Set2;
        },
        "./node_modules/_lodash@4.17.20@lodash/_SetCache.js": function(module2, exports2, __webpack_require__) {
          var MapCache = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_MapCache.js"), setCacheAdd = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_setCacheAdd.js"), setCacheHas = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_setCacheHas.js");
          function SetCache(values) {
            var index = -1, length = values == null ? 0 : values.length;
            this.__data__ = new MapCache();
            while (++index < length) {
              this.add(values[index]);
            }
          }
          SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
          SetCache.prototype.has = setCacheHas;
          module2.exports = SetCache;
        },
        "./node_modules/_lodash@4.17.20@lodash/_Stack.js": function(module2, exports2, __webpack_require__) {
          var ListCache = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_ListCache.js"), stackClear = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_stackClear.js"), stackDelete = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_stackDelete.js"), stackGet = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_stackGet.js"), stackHas = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_stackHas.js"), stackSet = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_stackSet.js");
          function Stack(entries) {
            var data = this.__data__ = new ListCache(entries);
            this.size = data.size;
          }
          Stack.prototype.clear = stackClear;
          Stack.prototype["delete"] = stackDelete;
          Stack.prototype.get = stackGet;
          Stack.prototype.has = stackHas;
          Stack.prototype.set = stackSet;
          module2.exports = Stack;
        },
        "./node_modules/_lodash@4.17.20@lodash/_Symbol.js": function(module2, exports2, __webpack_require__) {
          var root = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_root.js");
          var Symbol2 = root.Symbol;
          module2.exports = Symbol2;
        },
        "./node_modules/_lodash@4.17.20@lodash/_Uint8Array.js": function(module2, exports2, __webpack_require__) {
          var root = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_root.js");
          var Uint8Array = root.Uint8Array;
          module2.exports = Uint8Array;
        },
        "./node_modules/_lodash@4.17.20@lodash/_WeakMap.js": function(module2, exports2, __webpack_require__) {
          var getNative = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_getNative.js"), root = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_root.js");
          var WeakMap = getNative(root, "WeakMap");
          module2.exports = WeakMap;
        },
        "./node_modules/_lodash@4.17.20@lodash/_apply.js": function(module2, exports2) {
          function apply(func, thisArg, args) {
            switch (args.length) {
              case 0:
                return func.call(thisArg);
              case 1:
                return func.call(thisArg, args[0]);
              case 2:
                return func.call(thisArg, args[0], args[1]);
              case 3:
                return func.call(thisArg, args[0], args[1], args[2]);
            }
            return func.apply(thisArg, args);
          }
          module2.exports = apply;
        },
        "./node_modules/_lodash@4.17.20@lodash/_arrayEach.js": function(module2, exports2) {
          function arrayEach(array, iteratee) {
            var index = -1, length = array == null ? 0 : array.length;
            while (++index < length) {
              if (iteratee(array[index], index, array) === false) {
                break;
              }
            }
            return array;
          }
          module2.exports = arrayEach;
        },
        "./node_modules/_lodash@4.17.20@lodash/_arrayFilter.js": function(module2, exports2) {
          function arrayFilter(array, predicate) {
            var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
            while (++index < length) {
              var value = array[index];
              if (predicate(value, index, array)) {
                result[resIndex++] = value;
              }
            }
            return result;
          }
          module2.exports = arrayFilter;
        },
        "./node_modules/_lodash@4.17.20@lodash/_arrayIncludes.js": function(module2, exports2, __webpack_require__) {
          var baseIndexOf = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseIndexOf.js");
          function arrayIncludes(array, value) {
            var length = array == null ? 0 : array.length;
            return !!length && baseIndexOf(array, value, 0) > -1;
          }
          module2.exports = arrayIncludes;
        },
        "./node_modules/_lodash@4.17.20@lodash/_arrayIncludesWith.js": function(module2, exports2) {
          function arrayIncludesWith(array, value, comparator) {
            var index = -1, length = array == null ? 0 : array.length;
            while (++index < length) {
              if (comparator(value, array[index])) {
                return true;
              }
            }
            return false;
          }
          module2.exports = arrayIncludesWith;
        },
        "./node_modules/_lodash@4.17.20@lodash/_arrayLikeKeys.js": function(module2, exports2, __webpack_require__) {
          var baseTimes = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseTimes.js"), isArguments = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isArguments.js"), isArray = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isArray.js"), isBuffer = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isBuffer.js"), isIndex = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_isIndex.js"), isTypedArray = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isTypedArray.js");
          var objectProto = Object.prototype;
          var hasOwnProperty = objectProto.hasOwnProperty;
          function arrayLikeKeys(value, inherited) {
            var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
            for (var key in value) {
              if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
                result.push(key);
              }
            }
            return result;
          }
          module2.exports = arrayLikeKeys;
        },
        "./node_modules/_lodash@4.17.20@lodash/_arrayMap.js": function(module2, exports2) {
          function arrayMap(array, iteratee) {
            var index = -1, length = array == null ? 0 : array.length, result = Array(length);
            while (++index < length) {
              result[index] = iteratee(array[index], index, array);
            }
            return result;
          }
          module2.exports = arrayMap;
        },
        "./node_modules/_lodash@4.17.20@lodash/_arrayPush.js": function(module2, exports2) {
          function arrayPush(array, values) {
            var index = -1, length = values.length, offset = array.length;
            while (++index < length) {
              array[offset + index] = values[index];
            }
            return array;
          }
          module2.exports = arrayPush;
        },
        "./node_modules/_lodash@4.17.20@lodash/_arrayReduce.js": function(module2, exports2) {
          function arrayReduce(array, iteratee, accumulator, initAccum) {
            var index = -1, length = array == null ? 0 : array.length;
            if (initAccum && length) {
              accumulator = array[++index];
            }
            while (++index < length) {
              accumulator = iteratee(accumulator, array[index], index, array);
            }
            return accumulator;
          }
          module2.exports = arrayReduce;
        },
        "./node_modules/_lodash@4.17.20@lodash/_arraySome.js": function(module2, exports2) {
          function arraySome(array, predicate) {
            var index = -1, length = array == null ? 0 : array.length;
            while (++index < length) {
              if (predicate(array[index], index, array)) {
                return true;
              }
            }
            return false;
          }
          module2.exports = arraySome;
        },
        "./node_modules/_lodash@4.17.20@lodash/_asciiSize.js": function(module2, exports2, __webpack_require__) {
          var baseProperty = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseProperty.js");
          var asciiSize = baseProperty("length");
          module2.exports = asciiSize;
        },
        "./node_modules/_lodash@4.17.20@lodash/_assignMergeValue.js": function(module2, exports2, __webpack_require__) {
          var baseAssignValue = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseAssignValue.js"), eq = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/eq.js");
          function assignMergeValue(object, key, value) {
            if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }
          module2.exports = assignMergeValue;
        },
        "./node_modules/_lodash@4.17.20@lodash/_assignValue.js": function(module2, exports2, __webpack_require__) {
          var baseAssignValue = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseAssignValue.js"), eq = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/eq.js");
          var objectProto = Object.prototype;
          var hasOwnProperty = objectProto.hasOwnProperty;
          function assignValue(object, key, value) {
            var objValue = object[key];
            if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }
          module2.exports = assignValue;
        },
        "./node_modules/_lodash@4.17.20@lodash/_assocIndexOf.js": function(module2, exports2, __webpack_require__) {
          var eq = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/eq.js");
          function assocIndexOf(array, key) {
            var length = array.length;
            while (length--) {
              if (eq(array[length][0], key)) {
                return length;
              }
            }
            return -1;
          }
          module2.exports = assocIndexOf;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseAssign.js": function(module2, exports2, __webpack_require__) {
          var copyObject = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_copyObject.js"), keys = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/keys.js");
          function baseAssign(object, source) {
            return object && copyObject(source, keys(source), object);
          }
          module2.exports = baseAssign;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseAssignIn.js": function(module2, exports2, __webpack_require__) {
          var copyObject = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_copyObject.js"), keysIn = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/keysIn.js");
          function baseAssignIn(object, source) {
            return object && copyObject(source, keysIn(source), object);
          }
          module2.exports = baseAssignIn;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseAssignValue.js": function(module2, exports2, __webpack_require__) {
          var defineProperty = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_defineProperty.js");
          function baseAssignValue(object, key, value) {
            if (key == "__proto__" && defineProperty) {
              defineProperty(object, key, {
                "configurable": true,
                "enumerable": true,
                "value": value,
                "writable": true
              });
            } else {
              object[key] = value;
            }
          }
          module2.exports = baseAssignValue;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseClone.js": function(module2, exports2, __webpack_require__) {
          var Stack = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_Stack.js"), arrayEach = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_arrayEach.js"), assignValue = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_assignValue.js"), baseAssign = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseAssign.js"), baseAssignIn = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseAssignIn.js"), cloneBuffer = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_cloneBuffer.js"), copyArray = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_copyArray.js"), copySymbols = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_copySymbols.js"), copySymbolsIn = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_copySymbolsIn.js"), getAllKeys = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_getAllKeys.js"), getAllKeysIn = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_getAllKeysIn.js"), getTag = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_getTag.js"), initCloneArray = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_initCloneArray.js"), initCloneByTag = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_initCloneByTag.js"), initCloneObject = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_initCloneObject.js"), isArray = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isArray.js"), isBuffer = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isBuffer.js"), isMap = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isMap.js"), isObject = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isObject.js"), isSet = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isSet.js"), keys = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/keys.js"), keysIn = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/keysIn.js");
          var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
          var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
          var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
          var cloneableTags = {};
          cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
          cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
          function baseClone(value, bitmask, customizer, key, object, stack) {
            var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
            if (customizer) {
              result = object ? customizer(value, key, object, stack) : customizer(value);
            }
            if (result !== void 0) {
              return result;
            }
            if (!isObject(value)) {
              return value;
            }
            var isArr = isArray(value);
            if (isArr) {
              result = initCloneArray(value);
              if (!isDeep) {
                return copyArray(value, result);
              }
            } else {
              var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
              if (isBuffer(value)) {
                return cloneBuffer(value, isDeep);
              }
              if (tag == objectTag || tag == argsTag || isFunc && !object) {
                result = isFlat || isFunc ? {} : initCloneObject(value);
                if (!isDeep) {
                  return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
                }
              } else {
                if (!cloneableTags[tag]) {
                  return object ? value : {};
                }
                result = initCloneByTag(value, tag, isDeep);
              }
            }
            stack || (stack = new Stack());
            var stacked = stack.get(value);
            if (stacked) {
              return stacked;
            }
            stack.set(value, result);
            if (isSet(value)) {
              value.forEach(function(subValue) {
                result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
              });
            } else if (isMap(value)) {
              value.forEach(function(subValue, key2) {
                result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
              });
            }
            var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
            var props = isArr ? void 0 : keysFunc(value);
            arrayEach(props || value, function(subValue, key2) {
              if (props) {
                key2 = subValue;
                subValue = value[key2];
              }
              assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
            return result;
          }
          module2.exports = baseClone;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseCreate.js": function(module2, exports2, __webpack_require__) {
          var isObject = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isObject.js");
          var objectCreate = Object.create;
          var baseCreate = function() {
            function object() {
            }
            return function(proto) {
              if (!isObject(proto)) {
                return {};
              }
              if (objectCreate) {
                return objectCreate(proto);
              }
              object.prototype = proto;
              var result = new object();
              object.prototype = void 0;
              return result;
            };
          }();
          module2.exports = baseCreate;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseEach.js": function(module2, exports2, __webpack_require__) {
          var baseForOwn = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseForOwn.js"), createBaseEach = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_createBaseEach.js");
          var baseEach = createBaseEach(baseForOwn);
          module2.exports = baseEach;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseExtremum.js": function(module2, exports2, __webpack_require__) {
          var isSymbol = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isSymbol.js");
          function baseExtremum(array, iteratee, comparator) {
            var index = -1, length = array.length;
            while (++index < length) {
              var value = array[index], current = iteratee(value);
              if (current != null && (computed === void 0 ? current === current && !isSymbol(current) : comparator(current, computed))) {
                var computed = current, result = value;
              }
            }
            return result;
          }
          module2.exports = baseExtremum;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseFilter.js": function(module2, exports2, __webpack_require__) {
          var baseEach = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseEach.js");
          function baseFilter(collection, predicate) {
            var result = [];
            baseEach(collection, function(value, index, collection2) {
              if (predicate(value, index, collection2)) {
                result.push(value);
              }
            });
            return result;
          }
          module2.exports = baseFilter;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseFindIndex.js": function(module2, exports2) {
          function baseFindIndex(array, predicate, fromIndex, fromRight) {
            var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
            while (fromRight ? index-- : ++index < length) {
              if (predicate(array[index], index, array)) {
                return index;
              }
            }
            return -1;
          }
          module2.exports = baseFindIndex;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseFlatten.js": function(module2, exports2, __webpack_require__) {
          var arrayPush = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_arrayPush.js"), isFlattenable = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_isFlattenable.js");
          function baseFlatten(array, depth, predicate, isStrict, result) {
            var index = -1, length = array.length;
            predicate || (predicate = isFlattenable);
            result || (result = []);
            while (++index < length) {
              var value = array[index];
              if (depth > 0 && predicate(value)) {
                if (depth > 1) {
                  baseFlatten(value, depth - 1, predicate, isStrict, result);
                } else {
                  arrayPush(result, value);
                }
              } else if (!isStrict) {
                result[result.length] = value;
              }
            }
            return result;
          }
          module2.exports = baseFlatten;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseFor.js": function(module2, exports2, __webpack_require__) {
          var createBaseFor = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_createBaseFor.js");
          var baseFor = createBaseFor();
          module2.exports = baseFor;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseForOwn.js": function(module2, exports2, __webpack_require__) {
          var baseFor = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseFor.js"), keys = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/keys.js");
          function baseForOwn(object, iteratee) {
            return object && baseFor(object, iteratee, keys);
          }
          module2.exports = baseForOwn;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseGet.js": function(module2, exports2, __webpack_require__) {
          var castPath = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_castPath.js"), toKey = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_toKey.js");
          function baseGet(object, path) {
            path = castPath(path, object);
            var index = 0, length = path.length;
            while (object != null && index < length) {
              object = object[toKey(path[index++])];
            }
            return index && index == length ? object : void 0;
          }
          module2.exports = baseGet;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseGetAllKeys.js": function(module2, exports2, __webpack_require__) {
          var arrayPush = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_arrayPush.js"), isArray = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isArray.js");
          function baseGetAllKeys(object, keysFunc, symbolsFunc) {
            var result = keysFunc(object);
            return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
          }
          module2.exports = baseGetAllKeys;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseGetTag.js": function(module2, exports2, __webpack_require__) {
          var Symbol2 = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_Symbol.js"), getRawTag = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_getRawTag.js"), objectToString = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_objectToString.js");
          var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
          var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
          function baseGetTag(value) {
            if (value == null) {
              return value === void 0 ? undefinedTag : nullTag;
            }
            return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
          }
          module2.exports = baseGetTag;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseGt.js": function(module2, exports2) {
          function baseGt(value, other) {
            return value > other;
          }
          module2.exports = baseGt;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseHas.js": function(module2, exports2) {
          var objectProto = Object.prototype;
          var hasOwnProperty = objectProto.hasOwnProperty;
          function baseHas(object, key) {
            return object != null && hasOwnProperty.call(object, key);
          }
          module2.exports = baseHas;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseHasIn.js": function(module2, exports2) {
          function baseHasIn(object, key) {
            return object != null && key in Object(object);
          }
          module2.exports = baseHasIn;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseIndexOf.js": function(module2, exports2, __webpack_require__) {
          var baseFindIndex = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseFindIndex.js"), baseIsNaN = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseIsNaN.js"), strictIndexOf = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_strictIndexOf.js");
          function baseIndexOf(array, value, fromIndex) {
            return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
          }
          module2.exports = baseIndexOf;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseIsArguments.js": function(module2, exports2, __webpack_require__) {
          var baseGetTag = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseGetTag.js"), isObjectLike = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isObjectLike.js");
          var argsTag = "[object Arguments]";
          function baseIsArguments(value) {
            return isObjectLike(value) && baseGetTag(value) == argsTag;
          }
          module2.exports = baseIsArguments;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseIsEqual.js": function(module2, exports2, __webpack_require__) {
          var baseIsEqualDeep = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseIsEqualDeep.js"), isObjectLike = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isObjectLike.js");
          function baseIsEqual(value, other, bitmask, customizer, stack) {
            if (value === other) {
              return true;
            }
            if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
              return value !== value && other !== other;
            }
            return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
          }
          module2.exports = baseIsEqual;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseIsEqualDeep.js": function(module2, exports2, __webpack_require__) {
          var Stack = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_Stack.js"), equalArrays = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_equalArrays.js"), equalByTag = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_equalByTag.js"), equalObjects = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_equalObjects.js"), getTag = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_getTag.js"), isArray = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isArray.js"), isBuffer = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isBuffer.js"), isTypedArray = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isTypedArray.js");
          var COMPARE_PARTIAL_FLAG = 1;
          var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
          var objectProto = Object.prototype;
          var hasOwnProperty = objectProto.hasOwnProperty;
          function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
            var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
            objTag = objTag == argsTag ? objectTag : objTag;
            othTag = othTag == argsTag ? objectTag : othTag;
            var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
            if (isSameTag && isBuffer(object)) {
              if (!isBuffer(other)) {
                return false;
              }
              objIsArr = true;
              objIsObj = false;
            }
            if (isSameTag && !objIsObj) {
              stack || (stack = new Stack());
              return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
            }
            if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
              var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
              if (objIsWrapped || othIsWrapped) {
                var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                stack || (stack = new Stack());
                return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
              }
            }
            if (!isSameTag) {
              return false;
            }
            stack || (stack = new Stack());
            return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
          }
          module2.exports = baseIsEqualDeep;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseIsMap.js": function(module2, exports2, __webpack_require__) {
          var getTag = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_getTag.js"), isObjectLike = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isObjectLike.js");
          var mapTag = "[object Map]";
          function baseIsMap(value) {
            return isObjectLike(value) && getTag(value) == mapTag;
          }
          module2.exports = baseIsMap;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseIsMatch.js": function(module2, exports2, __webpack_require__) {
          var Stack = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_Stack.js"), baseIsEqual = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseIsEqual.js");
          var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
          function baseIsMatch(object, source, matchData, customizer) {
            var index = matchData.length, length = index, noCustomizer = !customizer;
            if (object == null) {
              return !length;
            }
            object = Object(object);
            while (index--) {
              var data = matchData[index];
              if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
                return false;
              }
            }
            while (++index < length) {
              data = matchData[index];
              var key = data[0], objValue = object[key], srcValue = data[1];
              if (noCustomizer && data[2]) {
                if (objValue === void 0 && !(key in object)) {
                  return false;
                }
              } else {
                var stack = new Stack();
                if (customizer) {
                  var result = customizer(objValue, srcValue, key, object, source, stack);
                }
                if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
                  return false;
                }
              }
            }
            return true;
          }
          module2.exports = baseIsMatch;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseIsNaN.js": function(module2, exports2) {
          function baseIsNaN(value) {
            return value !== value;
          }
          module2.exports = baseIsNaN;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseIsNative.js": function(module2, exports2, __webpack_require__) {
          var isFunction = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isFunction.js"), isMasked = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_isMasked.js"), isObject = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isObject.js"), toSource = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_toSource.js");
          var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
          var reIsHostCtor = /^\[object .+?Constructor\]$/;
          var funcProto = Function.prototype, objectProto = Object.prototype;
          var funcToString = funcProto.toString;
          var hasOwnProperty = objectProto.hasOwnProperty;
          var reIsNative = RegExp(
            "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
          );
          function baseIsNative(value) {
            if (!isObject(value) || isMasked(value)) {
              return false;
            }
            var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
            return pattern.test(toSource(value));
          }
          module2.exports = baseIsNative;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseIsSet.js": function(module2, exports2, __webpack_require__) {
          var getTag = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_getTag.js"), isObjectLike = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isObjectLike.js");
          var setTag = "[object Set]";
          function baseIsSet(value) {
            return isObjectLike(value) && getTag(value) == setTag;
          }
          module2.exports = baseIsSet;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseIsTypedArray.js": function(module2, exports2, __webpack_require__) {
          var baseGetTag = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseGetTag.js"), isLength = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isLength.js"), isObjectLike = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isObjectLike.js");
          var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]";
          var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
          var typedArrayTags = {};
          typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
          typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
          function baseIsTypedArray(value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
          }
          module2.exports = baseIsTypedArray;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseIteratee.js": function(module2, exports2, __webpack_require__) {
          var baseMatches = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseMatches.js"), baseMatchesProperty = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseMatchesProperty.js"), identity = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/identity.js"), isArray = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isArray.js"), property = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/property.js");
          function baseIteratee(value) {
            if (typeof value == "function") {
              return value;
            }
            if (value == null) {
              return identity;
            }
            if (typeof value == "object") {
              return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
            }
            return property(value);
          }
          module2.exports = baseIteratee;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseKeys.js": function(module2, exports2, __webpack_require__) {
          var isPrototype = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_isPrototype.js"), nativeKeys = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_nativeKeys.js");
          var objectProto = Object.prototype;
          var hasOwnProperty = objectProto.hasOwnProperty;
          function baseKeys(object) {
            if (!isPrototype(object)) {
              return nativeKeys(object);
            }
            var result = [];
            for (var key in Object(object)) {
              if (hasOwnProperty.call(object, key) && key != "constructor") {
                result.push(key);
              }
            }
            return result;
          }
          module2.exports = baseKeys;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseKeysIn.js": function(module2, exports2, __webpack_require__) {
          var isObject = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isObject.js"), isPrototype = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_isPrototype.js"), nativeKeysIn = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_nativeKeysIn.js");
          var objectProto = Object.prototype;
          var hasOwnProperty = objectProto.hasOwnProperty;
          function baseKeysIn(object) {
            if (!isObject(object)) {
              return nativeKeysIn(object);
            }
            var isProto = isPrototype(object), result = [];
            for (var key in object) {
              if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
                result.push(key);
              }
            }
            return result;
          }
          module2.exports = baseKeysIn;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseLt.js": function(module2, exports2) {
          function baseLt(value, other) {
            return value < other;
          }
          module2.exports = baseLt;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseMap.js": function(module2, exports2, __webpack_require__) {
          var baseEach = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseEach.js"), isArrayLike = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isArrayLike.js");
          function baseMap(collection, iteratee) {
            var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
            baseEach(collection, function(value, key, collection2) {
              result[++index] = iteratee(value, key, collection2);
            });
            return result;
          }
          module2.exports = baseMap;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseMatches.js": function(module2, exports2, __webpack_require__) {
          var baseIsMatch = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseIsMatch.js"), getMatchData = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_getMatchData.js"), matchesStrictComparable = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_matchesStrictComparable.js");
          function baseMatches(source) {
            var matchData = getMatchData(source);
            if (matchData.length == 1 && matchData[0][2]) {
              return matchesStrictComparable(matchData[0][0], matchData[0][1]);
            }
            return function(object) {
              return object === source || baseIsMatch(object, source, matchData);
            };
          }
          module2.exports = baseMatches;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseMatchesProperty.js": function(module2, exports2, __webpack_require__) {
          var baseIsEqual = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseIsEqual.js"), get = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/get.js"), hasIn = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/hasIn.js"), isKey = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_isKey.js"), isStrictComparable = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_isStrictComparable.js"), matchesStrictComparable = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_matchesStrictComparable.js"), toKey = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_toKey.js");
          var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
          function baseMatchesProperty(path, srcValue) {
            if (isKey(path) && isStrictComparable(srcValue)) {
              return matchesStrictComparable(toKey(path), srcValue);
            }
            return function(object) {
              var objValue = get(object, path);
              return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
            };
          }
          module2.exports = baseMatchesProperty;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseMerge.js": function(module2, exports2, __webpack_require__) {
          var Stack = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_Stack.js"), assignMergeValue = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_assignMergeValue.js"), baseFor = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseFor.js"), baseMergeDeep = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseMergeDeep.js"), isObject = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isObject.js"), keysIn = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/keysIn.js"), safeGet = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_safeGet.js");
          function baseMerge(object, source, srcIndex, customizer, stack) {
            if (object === source) {
              return;
            }
            baseFor(source, function(srcValue, key) {
              stack || (stack = new Stack());
              if (isObject(srcValue)) {
                baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
              } else {
                var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
                if (newValue === void 0) {
                  newValue = srcValue;
                }
                assignMergeValue(object, key, newValue);
              }
            }, keysIn);
          }
          module2.exports = baseMerge;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseMergeDeep.js": function(module2, exports2, __webpack_require__) {
          var assignMergeValue = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_assignMergeValue.js"), cloneBuffer = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_cloneBuffer.js"), cloneTypedArray = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_cloneTypedArray.js"), copyArray = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_copyArray.js"), initCloneObject = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_initCloneObject.js"), isArguments = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isArguments.js"), isArray = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isArray.js"), isArrayLikeObject = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isArrayLikeObject.js"), isBuffer = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isBuffer.js"), isFunction = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isFunction.js"), isObject = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isObject.js"), isPlainObject = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isPlainObject.js"), isTypedArray = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isTypedArray.js"), safeGet = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_safeGet.js"), toPlainObject = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/toPlainObject.js");
          function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
            var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
            if (stacked) {
              assignMergeValue(object, key, stacked);
              return;
            }
            var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
            var isCommon = newValue === void 0;
            if (isCommon) {
              var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
              newValue = srcValue;
              if (isArr || isBuff || isTyped) {
                if (isArray(objValue)) {
                  newValue = objValue;
                } else if (isArrayLikeObject(objValue)) {
                  newValue = copyArray(objValue);
                } else if (isBuff) {
                  isCommon = false;
                  newValue = cloneBuffer(srcValue, true);
                } else if (isTyped) {
                  isCommon = false;
                  newValue = cloneTypedArray(srcValue, true);
                } else {
                  newValue = [];
                }
              } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                newValue = objValue;
                if (isArguments(objValue)) {
                  newValue = toPlainObject(objValue);
                } else if (!isObject(objValue) || isFunction(objValue)) {
                  newValue = initCloneObject(srcValue);
                }
              } else {
                isCommon = false;
              }
            }
            if (isCommon) {
              stack.set(srcValue, newValue);
              mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
              stack["delete"](srcValue);
            }
            assignMergeValue(object, key, newValue);
          }
          module2.exports = baseMergeDeep;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseOrderBy.js": function(module2, exports2, __webpack_require__) {
          var arrayMap = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_arrayMap.js"), baseGet = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseGet.js"), baseIteratee = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseIteratee.js"), baseMap = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseMap.js"), baseSortBy = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseSortBy.js"), baseUnary = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseUnary.js"), compareMultiple = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_compareMultiple.js"), identity = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/identity.js"), isArray = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isArray.js");
          function baseOrderBy(collection, iteratees, orders) {
            if (iteratees.length) {
              iteratees = arrayMap(iteratees, function(iteratee) {
                if (isArray(iteratee)) {
                  return function(value) {
                    return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
                  };
                }
                return iteratee;
              });
            } else {
              iteratees = [identity];
            }
            var index = -1;
            iteratees = arrayMap(iteratees, baseUnary(baseIteratee));
            var result = baseMap(collection, function(value, key, collection2) {
              var criteria = arrayMap(iteratees, function(iteratee) {
                return iteratee(value);
              });
              return { "criteria": criteria, "index": ++index, "value": value };
            });
            return baseSortBy(result, function(object, other) {
              return compareMultiple(object, other, orders);
            });
          }
          module2.exports = baseOrderBy;
        },
        "./node_modules/_lodash@4.17.20@lodash/_basePick.js": function(module2, exports2, __webpack_require__) {
          var basePickBy = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_basePickBy.js"), hasIn = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/hasIn.js");
          function basePick(object, paths) {
            return basePickBy(object, paths, function(value, path) {
              return hasIn(object, path);
            });
          }
          module2.exports = basePick;
        },
        "./node_modules/_lodash@4.17.20@lodash/_basePickBy.js": function(module2, exports2, __webpack_require__) {
          var baseGet = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseGet.js"), baseSet = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseSet.js"), castPath = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_castPath.js");
          function basePickBy(object, paths, predicate) {
            var index = -1, length = paths.length, result = {};
            while (++index < length) {
              var path = paths[index], value = baseGet(object, path);
              if (predicate(value, path)) {
                baseSet(result, castPath(path, object), value);
              }
            }
            return result;
          }
          module2.exports = basePickBy;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseProperty.js": function(module2, exports2) {
          function baseProperty(key) {
            return function(object) {
              return object == null ? void 0 : object[key];
            };
          }
          module2.exports = baseProperty;
        },
        "./node_modules/_lodash@4.17.20@lodash/_basePropertyDeep.js": function(module2, exports2, __webpack_require__) {
          var baseGet = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseGet.js");
          function basePropertyDeep(path) {
            return function(object) {
              return baseGet(object, path);
            };
          }
          module2.exports = basePropertyDeep;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseRange.js": function(module2, exports2) {
          var nativeCeil = Math.ceil, nativeMax = Math.max;
          function baseRange(start, end, step, fromRight) {
            var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result = Array(length);
            while (length--) {
              result[fromRight ? length : ++index] = start;
              start += step;
            }
            return result;
          }
          module2.exports = baseRange;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseReduce.js": function(module2, exports2) {
          function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
            eachFunc(collection, function(value, index, collection2) {
              accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
            });
            return accumulator;
          }
          module2.exports = baseReduce;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseRest.js": function(module2, exports2, __webpack_require__) {
          var identity = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/identity.js"), overRest = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_overRest.js"), setToString = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_setToString.js");
          function baseRest(func, start) {
            return setToString(overRest(func, start, identity), func + "");
          }
          module2.exports = baseRest;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseSet.js": function(module2, exports2, __webpack_require__) {
          var assignValue = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_assignValue.js"), castPath = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_castPath.js"), isIndex = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_isIndex.js"), isObject = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isObject.js"), toKey = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_toKey.js");
          function baseSet(object, path, value, customizer) {
            if (!isObject(object)) {
              return object;
            }
            path = castPath(path, object);
            var index = -1, length = path.length, lastIndex = length - 1, nested = object;
            while (nested != null && ++index < length) {
              var key = toKey(path[index]), newValue = value;
              if (key === "__proto__" || key === "constructor" || key === "prototype") {
                return object;
              }
              if (index != lastIndex) {
                var objValue = nested[key];
                newValue = customizer ? customizer(objValue, key, nested) : void 0;
                if (newValue === void 0) {
                  newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
                }
              }
              assignValue(nested, key, newValue);
              nested = nested[key];
            }
            return object;
          }
          module2.exports = baseSet;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseSetToString.js": function(module2, exports2, __webpack_require__) {
          var constant = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/constant.js"), defineProperty = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_defineProperty.js"), identity = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/identity.js");
          var baseSetToString = !defineProperty ? identity : function(func, string) {
            return defineProperty(func, "toString", {
              "configurable": true,
              "enumerable": false,
              "value": constant(string),
              "writable": true
            });
          };
          module2.exports = baseSetToString;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseSortBy.js": function(module2, exports2) {
          function baseSortBy(array, comparer) {
            var length = array.length;
            array.sort(comparer);
            while (length--) {
              array[length] = array[length].value;
            }
            return array;
          }
          module2.exports = baseSortBy;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseTimes.js": function(module2, exports2) {
          function baseTimes(n, iteratee) {
            var index = -1, result = Array(n);
            while (++index < n) {
              result[index] = iteratee(index);
            }
            return result;
          }
          module2.exports = baseTimes;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseToString.js": function(module2, exports2, __webpack_require__) {
          var Symbol2 = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_Symbol.js"), arrayMap = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_arrayMap.js"), isArray = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isArray.js"), isSymbol = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isSymbol.js");
          var INFINITY = 1 / 0;
          var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
          function baseToString(value) {
            if (typeof value == "string") {
              return value;
            }
            if (isArray(value)) {
              return arrayMap(value, baseToString) + "";
            }
            if (isSymbol(value)) {
              return symbolToString ? symbolToString.call(value) : "";
            }
            var result = value + "";
            return result == "0" && 1 / value == -INFINITY ? "-0" : result;
          }
          module2.exports = baseToString;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseUnary.js": function(module2, exports2) {
          function baseUnary(func) {
            return function(value) {
              return func(value);
            };
          }
          module2.exports = baseUnary;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseUniq.js": function(module2, exports2, __webpack_require__) {
          var SetCache = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_SetCache.js"), arrayIncludes = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_arrayIncludes.js"), arrayIncludesWith = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_arrayIncludesWith.js"), cacheHas = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_cacheHas.js"), createSet = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_createSet.js"), setToArray = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_setToArray.js");
          var LARGE_ARRAY_SIZE = 200;
          function baseUniq(array, iteratee, comparator) {
            var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
            if (comparator) {
              isCommon = false;
              includes = arrayIncludesWith;
            } else if (length >= LARGE_ARRAY_SIZE) {
              var set = iteratee ? null : createSet(array);
              if (set) {
                return setToArray(set);
              }
              isCommon = false;
              includes = cacheHas;
              seen = new SetCache();
            } else {
              seen = iteratee ? [] : result;
            }
            outer:
              while (++index < length) {
                var value = array[index], computed = iteratee ? iteratee(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed === computed) {
                  var seenIndex = seen.length;
                  while (seenIndex--) {
                    if (seen[seenIndex] === computed) {
                      continue outer;
                    }
                  }
                  if (iteratee) {
                    seen.push(computed);
                  }
                  result.push(value);
                } else if (!includes(seen, computed, comparator)) {
                  if (seen !== result) {
                    seen.push(computed);
                  }
                  result.push(value);
                }
              }
            return result;
          }
          module2.exports = baseUniq;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseValues.js": function(module2, exports2, __webpack_require__) {
          var arrayMap = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_arrayMap.js");
          function baseValues(object, props) {
            return arrayMap(props, function(key) {
              return object[key];
            });
          }
          module2.exports = baseValues;
        },
        "./node_modules/_lodash@4.17.20@lodash/_baseZipObject.js": function(module2, exports2) {
          function baseZipObject(props, values, assignFunc) {
            var index = -1, length = props.length, valsLength = values.length, result = {};
            while (++index < length) {
              var value = index < valsLength ? values[index] : void 0;
              assignFunc(result, props[index], value);
            }
            return result;
          }
          module2.exports = baseZipObject;
        },
        "./node_modules/_lodash@4.17.20@lodash/_cacheHas.js": function(module2, exports2) {
          function cacheHas(cache, key) {
            return cache.has(key);
          }
          module2.exports = cacheHas;
        },
        "./node_modules/_lodash@4.17.20@lodash/_castFunction.js": function(module2, exports2, __webpack_require__) {
          var identity = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/identity.js");
          function castFunction(value) {
            return typeof value == "function" ? value : identity;
          }
          module2.exports = castFunction;
        },
        "./node_modules/_lodash@4.17.20@lodash/_castPath.js": function(module2, exports2, __webpack_require__) {
          var isArray = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isArray.js"), isKey = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_isKey.js"), stringToPath = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_stringToPath.js"), toString = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/toString.js");
          function castPath(value, object) {
            if (isArray(value)) {
              return value;
            }
            return isKey(value, object) ? [value] : stringToPath(toString(value));
          }
          module2.exports = castPath;
        },
        "./node_modules/_lodash@4.17.20@lodash/_cloneArrayBuffer.js": function(module2, exports2, __webpack_require__) {
          var Uint8Array = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_Uint8Array.js");
          function cloneArrayBuffer(arrayBuffer) {
            var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
            new Uint8Array(result).set(new Uint8Array(arrayBuffer));
            return result;
          }
          module2.exports = cloneArrayBuffer;
        },
        "./node_modules/_lodash@4.17.20@lodash/_cloneBuffer.js": function(module2, exports2, __webpack_require__) {
          (function(module3) {
            var root = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_root.js");
            var freeExports = exports2 && !exports2.nodeType && exports2;
            var freeModule = freeExports && typeof module3 == "object" && module3 && !module3.nodeType && module3;
            var moduleExports = freeModule && freeModule.exports === freeExports;
            var Buffer = moduleExports ? root.Buffer : void 0, allocUnsafe = Buffer ? Buffer.allocUnsafe : void 0;
            function cloneBuffer(buffer, isDeep) {
              if (isDeep) {
                return buffer.slice();
              }
              var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
              buffer.copy(result);
              return result;
            }
            module3.exports = cloneBuffer;
          }).call(this, __webpack_require__("./node_modules/_webpack@4.46.0@webpack/buildin/module.js")(module2));
        },
        "./node_modules/_lodash@4.17.20@lodash/_cloneDataView.js": function(module2, exports2, __webpack_require__) {
          var cloneArrayBuffer = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_cloneArrayBuffer.js");
          function cloneDataView(dataView, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
            return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
          }
          module2.exports = cloneDataView;
        },
        "./node_modules/_lodash@4.17.20@lodash/_cloneRegExp.js": function(module2, exports2) {
          var reFlags = /\w*$/;
          function cloneRegExp(regexp) {
            var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
            result.lastIndex = regexp.lastIndex;
            return result;
          }
          module2.exports = cloneRegExp;
        },
        "./node_modules/_lodash@4.17.20@lodash/_cloneSymbol.js": function(module2, exports2, __webpack_require__) {
          var Symbol2 = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_Symbol.js");
          var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
          function cloneSymbol(symbol) {
            return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
          }
          module2.exports = cloneSymbol;
        },
        "./node_modules/_lodash@4.17.20@lodash/_cloneTypedArray.js": function(module2, exports2, __webpack_require__) {
          var cloneArrayBuffer = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_cloneArrayBuffer.js");
          function cloneTypedArray(typedArray, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
          }
          module2.exports = cloneTypedArray;
        },
        "./node_modules/_lodash@4.17.20@lodash/_compareAscending.js": function(module2, exports2, __webpack_require__) {
          var isSymbol = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isSymbol.js");
          function compareAscending(value, other) {
            if (value !== other) {
              var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
              var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
              if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
                return 1;
              }
              if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
                return -1;
              }
            }
            return 0;
          }
          module2.exports = compareAscending;
        },
        "./node_modules/_lodash@4.17.20@lodash/_compareMultiple.js": function(module2, exports2, __webpack_require__) {
          var compareAscending = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_compareAscending.js");
          function compareMultiple(object, other, orders) {
            var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
            while (++index < length) {
              var result = compareAscending(objCriteria[index], othCriteria[index]);
              if (result) {
                if (index >= ordersLength) {
                  return result;
                }
                var order = orders[index];
                return result * (order == "desc" ? -1 : 1);
              }
            }
            return object.index - other.index;
          }
          module2.exports = compareMultiple;
        },
        "./node_modules/_lodash@4.17.20@lodash/_copyArray.js": function(module2, exports2) {
          function copyArray(source, array) {
            var index = -1, length = source.length;
            array || (array = Array(length));
            while (++index < length) {
              array[index] = source[index];
            }
            return array;
          }
          module2.exports = copyArray;
        },
        "./node_modules/_lodash@4.17.20@lodash/_copyObject.js": function(module2, exports2, __webpack_require__) {
          var assignValue = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_assignValue.js"), baseAssignValue = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseAssignValue.js");
          function copyObject(source, props, object, customizer) {
            var isNew = !object;
            object || (object = {});
            var index = -1, length = props.length;
            while (++index < length) {
              var key = props[index];
              var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
              if (newValue === void 0) {
                newValue = source[key];
              }
              if (isNew) {
                baseAssignValue(object, key, newValue);
              } else {
                assignValue(object, key, newValue);
              }
            }
            return object;
          }
          module2.exports = copyObject;
        },
        "./node_modules/_lodash@4.17.20@lodash/_copySymbols.js": function(module2, exports2, __webpack_require__) {
          var copyObject = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_copyObject.js"), getSymbols = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_getSymbols.js");
          function copySymbols(source, object) {
            return copyObject(source, getSymbols(source), object);
          }
          module2.exports = copySymbols;
        },
        "./node_modules/_lodash@4.17.20@lodash/_copySymbolsIn.js": function(module2, exports2, __webpack_require__) {
          var copyObject = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_copyObject.js"), getSymbolsIn = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_getSymbolsIn.js");
          function copySymbolsIn(source, object) {
            return copyObject(source, getSymbolsIn(source), object);
          }
          module2.exports = copySymbolsIn;
        },
        "./node_modules/_lodash@4.17.20@lodash/_coreJsData.js": function(module2, exports2, __webpack_require__) {
          var root = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_root.js");
          var coreJsData = root["__core-js_shared__"];
          module2.exports = coreJsData;
        },
        "./node_modules/_lodash@4.17.20@lodash/_createAssigner.js": function(module2, exports2, __webpack_require__) {
          var baseRest = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseRest.js"), isIterateeCall = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_isIterateeCall.js");
          function createAssigner(assigner) {
            return baseRest(function(object, sources) {
              var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
              customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
              if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                customizer = length < 3 ? void 0 : customizer;
                length = 1;
              }
              object = Object(object);
              while (++index < length) {
                var source = sources[index];
                if (source) {
                  assigner(object, source, index, customizer);
                }
              }
              return object;
            });
          }
          module2.exports = createAssigner;
        },
        "./node_modules/_lodash@4.17.20@lodash/_createBaseEach.js": function(module2, exports2, __webpack_require__) {
          var isArrayLike = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isArrayLike.js");
          function createBaseEach(eachFunc, fromRight) {
            return function(collection, iteratee) {
              if (collection == null) {
                return collection;
              }
              if (!isArrayLike(collection)) {
                return eachFunc(collection, iteratee);
              }
              var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
              while (fromRight ? index-- : ++index < length) {
                if (iteratee(iterable[index], index, iterable) === false) {
                  break;
                }
              }
              return collection;
            };
          }
          module2.exports = createBaseEach;
        },
        "./node_modules/_lodash@4.17.20@lodash/_createBaseFor.js": function(module2, exports2) {
          function createBaseFor(fromRight) {
            return function(object, iteratee, keysFunc) {
              var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
              while (length--) {
                var key = props[fromRight ? length : ++index];
                if (iteratee(iterable[key], key, iterable) === false) {
                  break;
                }
              }
              return object;
            };
          }
          module2.exports = createBaseFor;
        },
        "./node_modules/_lodash@4.17.20@lodash/_createFind.js": function(module2, exports2, __webpack_require__) {
          var baseIteratee = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseIteratee.js"), isArrayLike = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isArrayLike.js"), keys = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/keys.js");
          function createFind(findIndexFunc) {
            return function(collection, predicate, fromIndex) {
              var iterable = Object(collection);
              if (!isArrayLike(collection)) {
                var iteratee = baseIteratee(predicate, 3);
                collection = keys(collection);
                predicate = function(key) {
                  return iteratee(iterable[key], key, iterable);
                };
              }
              var index = findIndexFunc(collection, predicate, fromIndex);
              return index > -1 ? iterable[iteratee ? collection[index] : index] : void 0;
            };
          }
          module2.exports = createFind;
        },
        "./node_modules/_lodash@4.17.20@lodash/_createRange.js": function(module2, exports2, __webpack_require__) {
          var baseRange = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseRange.js"), isIterateeCall = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_isIterateeCall.js"), toFinite = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/toFinite.js");
          function createRange(fromRight) {
            return function(start, end, step) {
              if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
                end = step = void 0;
              }
              start = toFinite(start);
              if (end === void 0) {
                end = start;
                start = 0;
              } else {
                end = toFinite(end);
              }
              step = step === void 0 ? start < end ? 1 : -1 : toFinite(step);
              return baseRange(start, end, step, fromRight);
            };
          }
          module2.exports = createRange;
        },
        "./node_modules/_lodash@4.17.20@lodash/_createSet.js": function(module2, exports2, __webpack_require__) {
          var Set2 = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_Set.js"), noop = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/noop.js"), setToArray = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_setToArray.js");
          var INFINITY = 1 / 0;
          var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values) {
            return new Set2(values);
          };
          module2.exports = createSet;
        },
        "./node_modules/_lodash@4.17.20@lodash/_defineProperty.js": function(module2, exports2, __webpack_require__) {
          var getNative = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_getNative.js");
          var defineProperty = function() {
            try {
              var func = getNative(Object, "defineProperty");
              func({}, "", {});
              return func;
            } catch (e) {
            }
          }();
          module2.exports = defineProperty;
        },
        "./node_modules/_lodash@4.17.20@lodash/_equalArrays.js": function(module2, exports2, __webpack_require__) {
          var SetCache = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_SetCache.js"), arraySome = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_arraySome.js"), cacheHas = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_cacheHas.js");
          var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
          function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
            if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
              return false;
            }
            var arrStacked = stack.get(array);
            var othStacked = stack.get(other);
            if (arrStacked && othStacked) {
              return arrStacked == other && othStacked == array;
            }
            var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
            stack.set(array, other);
            stack.set(other, array);
            while (++index < arrLength) {
              var arrValue = array[index], othValue = other[index];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
              }
              if (compared !== void 0) {
                if (compared) {
                  continue;
                }
                result = false;
                break;
              }
              if (seen) {
                if (!arraySome(other, function(othValue2, othIndex) {
                  if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                    return seen.push(othIndex);
                  }
                })) {
                  result = false;
                  break;
                }
              } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                result = false;
                break;
              }
            }
            stack["delete"](array);
            stack["delete"](other);
            return result;
          }
          module2.exports = equalArrays;
        },
        "./node_modules/_lodash@4.17.20@lodash/_equalByTag.js": function(module2, exports2, __webpack_require__) {
          var Symbol2 = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_Symbol.js"), Uint8Array = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_Uint8Array.js"), eq = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/eq.js"), equalArrays = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_equalArrays.js"), mapToArray = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_mapToArray.js"), setToArray = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_setToArray.js");
          var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
          var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
          var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
          var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
          function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
            switch (tag) {
              case dataViewTag:
                if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                  return false;
                }
                object = object.buffer;
                other = other.buffer;
              case arrayBufferTag:
                if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
                  return false;
                }
                return true;
              case boolTag:
              case dateTag:
              case numberTag:
                return eq(+object, +other);
              case errorTag:
                return object.name == other.name && object.message == other.message;
              case regexpTag:
              case stringTag:
                return object == other + "";
              case mapTag:
                var convert = mapToArray;
              case setTag:
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                convert || (convert = setToArray);
                if (object.size != other.size && !isPartial) {
                  return false;
                }
                var stacked = stack.get(object);
                if (stacked) {
                  return stacked == other;
                }
                bitmask |= COMPARE_UNORDERED_FLAG;
                stack.set(object, other);
                var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                stack["delete"](object);
                return result;
              case symbolTag:
                if (symbolValueOf) {
                  return symbolValueOf.call(object) == symbolValueOf.call(other);
                }
            }
            return false;
          }
          module2.exports = equalByTag;
        },
        "./node_modules/_lodash@4.17.20@lodash/_equalObjects.js": function(module2, exports2, __webpack_require__) {
          var getAllKeys = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_getAllKeys.js");
          var COMPARE_PARTIAL_FLAG = 1;
          var objectProto = Object.prototype;
          var hasOwnProperty = objectProto.hasOwnProperty;
          function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
            if (objLength != othLength && !isPartial) {
              return false;
            }
            var index = objLength;
            while (index--) {
              var key = objProps[index];
              if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
                return false;
              }
            }
            var objStacked = stack.get(object);
            var othStacked = stack.get(other);
            if (objStacked && othStacked) {
              return objStacked == other && othStacked == object;
            }
            var result = true;
            stack.set(object, other);
            stack.set(other, object);
            var skipCtor = isPartial;
            while (++index < objLength) {
              key = objProps[index];
              var objValue = object[key], othValue = other[key];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
              }
              if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                result = false;
                break;
              }
              skipCtor || (skipCtor = key == "constructor");
            }
            if (result && !skipCtor) {
              var objCtor = object.constructor, othCtor = other.constructor;
              if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
                result = false;
              }
            }
            stack["delete"](object);
            stack["delete"](other);
            return result;
          }
          module2.exports = equalObjects;
        },
        "./node_modules/_lodash@4.17.20@lodash/_flatRest.js": function(module2, exports2, __webpack_require__) {
          var flatten = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/flatten.js"), overRest = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_overRest.js"), setToString = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_setToString.js");
          function flatRest(func) {
            return setToString(overRest(func, void 0, flatten), func + "");
          }
          module2.exports = flatRest;
        },
        "./node_modules/_lodash@4.17.20@lodash/_freeGlobal.js": function(module2, exports2, __webpack_require__) {
          (function(global) {
            var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
            module2.exports = freeGlobal;
          }).call(this, __webpack_require__("./node_modules/_webpack@4.46.0@webpack/buildin/global.js"));
        },
        "./node_modules/_lodash@4.17.20@lodash/_getAllKeys.js": function(module2, exports2, __webpack_require__) {
          var baseGetAllKeys = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseGetAllKeys.js"), getSymbols = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_getSymbols.js"), keys = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/keys.js");
          function getAllKeys(object) {
            return baseGetAllKeys(object, keys, getSymbols);
          }
          module2.exports = getAllKeys;
        },
        "./node_modules/_lodash@4.17.20@lodash/_getAllKeysIn.js": function(module2, exports2, __webpack_require__) {
          var baseGetAllKeys = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseGetAllKeys.js"), getSymbolsIn = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_getSymbolsIn.js"), keysIn = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/keysIn.js");
          function getAllKeysIn(object) {
            return baseGetAllKeys(object, keysIn, getSymbolsIn);
          }
          module2.exports = getAllKeysIn;
        },
        "./node_modules/_lodash@4.17.20@lodash/_getMapData.js": function(module2, exports2, __webpack_require__) {
          var isKeyable = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_isKeyable.js");
          function getMapData(map, key) {
            var data = map.__data__;
            return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
          }
          module2.exports = getMapData;
        },
        "./node_modules/_lodash@4.17.20@lodash/_getMatchData.js": function(module2, exports2, __webpack_require__) {
          var isStrictComparable = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_isStrictComparable.js"), keys = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/keys.js");
          function getMatchData(object) {
            var result = keys(object), length = result.length;
            while (length--) {
              var key = result[length], value = object[key];
              result[length] = [key, value, isStrictComparable(value)];
            }
            return result;
          }
          module2.exports = getMatchData;
        },
        "./node_modules/_lodash@4.17.20@lodash/_getNative.js": function(module2, exports2, __webpack_require__) {
          var baseIsNative = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseIsNative.js"), getValue = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_getValue.js");
          function getNative(object, key) {
            var value = getValue(object, key);
            return baseIsNative(value) ? value : void 0;
          }
          module2.exports = getNative;
        },
        "./node_modules/_lodash@4.17.20@lodash/_getPrototype.js": function(module2, exports2, __webpack_require__) {
          var overArg = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_overArg.js");
          var getPrototype = overArg(Object.getPrototypeOf, Object);
          module2.exports = getPrototype;
        },
        "./node_modules/_lodash@4.17.20@lodash/_getRawTag.js": function(module2, exports2, __webpack_require__) {
          var Symbol2 = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_Symbol.js");
          var objectProto = Object.prototype;
          var hasOwnProperty = objectProto.hasOwnProperty;
          var nativeObjectToString = objectProto.toString;
          var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
          function getRawTag(value) {
            var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
            try {
              value[symToStringTag] = void 0;
              var unmasked = true;
            } catch (e) {
            }
            var result = nativeObjectToString.call(value);
            if (unmasked) {
              if (isOwn) {
                value[symToStringTag] = tag;
              } else {
                delete value[symToStringTag];
              }
            }
            return result;
          }
          module2.exports = getRawTag;
        },
        "./node_modules/_lodash@4.17.20@lodash/_getSymbols.js": function(module2, exports2, __webpack_require__) {
          var arrayFilter = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_arrayFilter.js"), stubArray = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/stubArray.js");
          var objectProto = Object.prototype;
          var propertyIsEnumerable = objectProto.propertyIsEnumerable;
          var nativeGetSymbols = Object.getOwnPropertySymbols;
          var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
            if (object == null) {
              return [];
            }
            object = Object(object);
            return arrayFilter(nativeGetSymbols(object), function(symbol) {
              return propertyIsEnumerable.call(object, symbol);
            });
          };
          module2.exports = getSymbols;
        },
        "./node_modules/_lodash@4.17.20@lodash/_getSymbolsIn.js": function(module2, exports2, __webpack_require__) {
          var arrayPush = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_arrayPush.js"), getPrototype = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_getPrototype.js"), getSymbols = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_getSymbols.js"), stubArray = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/stubArray.js");
          var nativeGetSymbols = Object.getOwnPropertySymbols;
          var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
            var result = [];
            while (object) {
              arrayPush(result, getSymbols(object));
              object = getPrototype(object);
            }
            return result;
          };
          module2.exports = getSymbolsIn;
        },
        "./node_modules/_lodash@4.17.20@lodash/_getTag.js": function(module2, exports2, __webpack_require__) {
          var DataView = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_DataView.js"), Map2 = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_Map.js"), Promise2 = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_Promise.js"), Set2 = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_Set.js"), WeakMap = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_WeakMap.js"), baseGetTag = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseGetTag.js"), toSource = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_toSource.js");
          var mapTag = "[object Map]", objectTag = "[object Object]", promiseTag = "[object Promise]", setTag = "[object Set]", weakMapTag = "[object WeakMap]";
          var dataViewTag = "[object DataView]";
          var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap);
          var getTag = baseGetTag;
          if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
            getTag = function(value) {
              var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
              if (ctorString) {
                switch (ctorString) {
                  case dataViewCtorString:
                    return dataViewTag;
                  case mapCtorString:
                    return mapTag;
                  case promiseCtorString:
                    return promiseTag;
                  case setCtorString:
                    return setTag;
                  case weakMapCtorString:
                    return weakMapTag;
                }
              }
              return result;
            };
          }
          module2.exports = getTag;
        },
        "./node_modules/_lodash@4.17.20@lodash/_getValue.js": function(module2, exports2) {
          function getValue(object, key) {
            return object == null ? void 0 : object[key];
          }
          module2.exports = getValue;
        },
        "./node_modules/_lodash@4.17.20@lodash/_hasPath.js": function(module2, exports2, __webpack_require__) {
          var castPath = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_castPath.js"), isArguments = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isArguments.js"), isArray = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isArray.js"), isIndex = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_isIndex.js"), isLength = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isLength.js"), toKey = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_toKey.js");
          function hasPath(object, path, hasFunc) {
            path = castPath(path, object);
            var index = -1, length = path.length, result = false;
            while (++index < length) {
              var key = toKey(path[index]);
              if (!(result = object != null && hasFunc(object, key))) {
                break;
              }
              object = object[key];
            }
            if (result || ++index != length) {
              return result;
            }
            length = object == null ? 0 : object.length;
            return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
          }
          module2.exports = hasPath;
        },
        "./node_modules/_lodash@4.17.20@lodash/_hasUnicode.js": function(module2, exports2) {
          var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsVarRange = "\\ufe0e\\ufe0f";
          var rsZWJ = "\\u200d";
          var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
          function hasUnicode(string) {
            return reHasUnicode.test(string);
          }
          module2.exports = hasUnicode;
        },
        "./node_modules/_lodash@4.17.20@lodash/_hashClear.js": function(module2, exports2, __webpack_require__) {
          var nativeCreate = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_nativeCreate.js");
          function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {};
            this.size = 0;
          }
          module2.exports = hashClear;
        },
        "./node_modules/_lodash@4.17.20@lodash/_hashDelete.js": function(module2, exports2) {
          function hashDelete(key) {
            var result = this.has(key) && delete this.__data__[key];
            this.size -= result ? 1 : 0;
            return result;
          }
          module2.exports = hashDelete;
        },
        "./node_modules/_lodash@4.17.20@lodash/_hashGet.js": function(module2, exports2, __webpack_require__) {
          var nativeCreate = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_nativeCreate.js");
          var HASH_UNDEFINED = "__lodash_hash_undefined__";
          var objectProto = Object.prototype;
          var hasOwnProperty = objectProto.hasOwnProperty;
          function hashGet(key) {
            var data = this.__data__;
            if (nativeCreate) {
              var result = data[key];
              return result === HASH_UNDEFINED ? void 0 : result;
            }
            return hasOwnProperty.call(data, key) ? data[key] : void 0;
          }
          module2.exports = hashGet;
        },
        "./node_modules/_lodash@4.17.20@lodash/_hashHas.js": function(module2, exports2, __webpack_require__) {
          var nativeCreate = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_nativeCreate.js");
          var objectProto = Object.prototype;
          var hasOwnProperty = objectProto.hasOwnProperty;
          function hashHas(key) {
            var data = this.__data__;
            return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
          }
          module2.exports = hashHas;
        },
        "./node_modules/_lodash@4.17.20@lodash/_hashSet.js": function(module2, exports2, __webpack_require__) {
          var nativeCreate = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_nativeCreate.js");
          var HASH_UNDEFINED = "__lodash_hash_undefined__";
          function hashSet(key, value) {
            var data = this.__data__;
            this.size += this.has(key) ? 0 : 1;
            data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
            return this;
          }
          module2.exports = hashSet;
        },
        "./node_modules/_lodash@4.17.20@lodash/_initCloneArray.js": function(module2, exports2) {
          var objectProto = Object.prototype;
          var hasOwnProperty = objectProto.hasOwnProperty;
          function initCloneArray(array) {
            var length = array.length, result = new array.constructor(length);
            if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
              result.index = array.index;
              result.input = array.input;
            }
            return result;
          }
          module2.exports = initCloneArray;
        },
        "./node_modules/_lodash@4.17.20@lodash/_initCloneByTag.js": function(module2, exports2, __webpack_require__) {
          var cloneArrayBuffer = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_cloneArrayBuffer.js"), cloneDataView = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_cloneDataView.js"), cloneRegExp = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_cloneRegExp.js"), cloneSymbol = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_cloneSymbol.js"), cloneTypedArray = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_cloneTypedArray.js");
          var boolTag = "[object Boolean]", dateTag = "[object Date]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
          var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
          function initCloneByTag(object, tag, isDeep) {
            var Ctor = object.constructor;
            switch (tag) {
              case arrayBufferTag:
                return cloneArrayBuffer(object);
              case boolTag:
              case dateTag:
                return new Ctor(+object);
              case dataViewTag:
                return cloneDataView(object, isDeep);
              case float32Tag:
              case float64Tag:
              case int8Tag:
              case int16Tag:
              case int32Tag:
              case uint8Tag:
              case uint8ClampedTag:
              case uint16Tag:
              case uint32Tag:
                return cloneTypedArray(object, isDeep);
              case mapTag:
                return new Ctor();
              case numberTag:
              case stringTag:
                return new Ctor(object);
              case regexpTag:
                return cloneRegExp(object);
              case setTag:
                return new Ctor();
              case symbolTag:
                return cloneSymbol(object);
            }
          }
          module2.exports = initCloneByTag;
        },
        "./node_modules/_lodash@4.17.20@lodash/_initCloneObject.js": function(module2, exports2, __webpack_require__) {
          var baseCreate = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseCreate.js"), getPrototype = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_getPrototype.js"), isPrototype = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_isPrototype.js");
          function initCloneObject(object) {
            return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
          }
          module2.exports = initCloneObject;
        },
        "./node_modules/_lodash@4.17.20@lodash/_isFlattenable.js": function(module2, exports2, __webpack_require__) {
          var Symbol2 = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_Symbol.js"), isArguments = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isArguments.js"), isArray = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isArray.js");
          var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
          function isFlattenable(value) {
            return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
          }
          module2.exports = isFlattenable;
        },
        "./node_modules/_lodash@4.17.20@lodash/_isIndex.js": function(module2, exports2) {
          var MAX_SAFE_INTEGER = 9007199254740991;
          var reIsUint = /^(?:0|[1-9]\d*)$/;
          function isIndex(value, length) {
            var type = typeof value;
            length = length == null ? MAX_SAFE_INTEGER : length;
            return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
          }
          module2.exports = isIndex;
        },
        "./node_modules/_lodash@4.17.20@lodash/_isIterateeCall.js": function(module2, exports2, __webpack_require__) {
          var eq = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/eq.js"), isArrayLike = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isArrayLike.js"), isIndex = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_isIndex.js"), isObject = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isObject.js");
          function isIterateeCall(value, index, object) {
            if (!isObject(object)) {
              return false;
            }
            var type = typeof index;
            if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
              return eq(object[index], value);
            }
            return false;
          }
          module2.exports = isIterateeCall;
        },
        "./node_modules/_lodash@4.17.20@lodash/_isKey.js": function(module2, exports2, __webpack_require__) {
          var isArray = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isArray.js"), isSymbol = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isSymbol.js");
          var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
          function isKey(value, object) {
            if (isArray(value)) {
              return false;
            }
            var type = typeof value;
            if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
              return true;
            }
            return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
          }
          module2.exports = isKey;
        },
        "./node_modules/_lodash@4.17.20@lodash/_isKeyable.js": function(module2, exports2) {
          function isKeyable(value) {
            var type = typeof value;
            return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
          }
          module2.exports = isKeyable;
        },
        "./node_modules/_lodash@4.17.20@lodash/_isMasked.js": function(module2, exports2, __webpack_require__) {
          var coreJsData = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_coreJsData.js");
          var maskSrcKey = function() {
            var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
            return uid ? "Symbol(src)_1." + uid : "";
          }();
          function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
          }
          module2.exports = isMasked;
        },
        "./node_modules/_lodash@4.17.20@lodash/_isPrototype.js": function(module2, exports2) {
          var objectProto = Object.prototype;
          function isPrototype(value) {
            var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
            return value === proto;
          }
          module2.exports = isPrototype;
        },
        "./node_modules/_lodash@4.17.20@lodash/_isStrictComparable.js": function(module2, exports2, __webpack_require__) {
          var isObject = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isObject.js");
          function isStrictComparable(value) {
            return value === value && !isObject(value);
          }
          module2.exports = isStrictComparable;
        },
        "./node_modules/_lodash@4.17.20@lodash/_listCacheClear.js": function(module2, exports2) {
          function listCacheClear() {
            this.__data__ = [];
            this.size = 0;
          }
          module2.exports = listCacheClear;
        },
        "./node_modules/_lodash@4.17.20@lodash/_listCacheDelete.js": function(module2, exports2, __webpack_require__) {
          var assocIndexOf = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_assocIndexOf.js");
          var arrayProto = Array.prototype;
          var splice = arrayProto.splice;
          function listCacheDelete(key) {
            var data = this.__data__, index = assocIndexOf(data, key);
            if (index < 0) {
              return false;
            }
            var lastIndex = data.length - 1;
            if (index == lastIndex) {
              data.pop();
            } else {
              splice.call(data, index, 1);
            }
            --this.size;
            return true;
          }
          module2.exports = listCacheDelete;
        },
        "./node_modules/_lodash@4.17.20@lodash/_listCacheGet.js": function(module2, exports2, __webpack_require__) {
          var assocIndexOf = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_assocIndexOf.js");
          function listCacheGet(key) {
            var data = this.__data__, index = assocIndexOf(data, key);
            return index < 0 ? void 0 : data[index][1];
          }
          module2.exports = listCacheGet;
        },
        "./node_modules/_lodash@4.17.20@lodash/_listCacheHas.js": function(module2, exports2, __webpack_require__) {
          var assocIndexOf = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_assocIndexOf.js");
          function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1;
          }
          module2.exports = listCacheHas;
        },
        "./node_modules/_lodash@4.17.20@lodash/_listCacheSet.js": function(module2, exports2, __webpack_require__) {
          var assocIndexOf = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_assocIndexOf.js");
          function listCacheSet(key, value) {
            var data = this.__data__, index = assocIndexOf(data, key);
            if (index < 0) {
              ++this.size;
              data.push([key, value]);
            } else {
              data[index][1] = value;
            }
            return this;
          }
          module2.exports = listCacheSet;
        },
        "./node_modules/_lodash@4.17.20@lodash/_mapCacheClear.js": function(module2, exports2, __webpack_require__) {
          var Hash = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_Hash.js"), ListCache = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_ListCache.js"), Map2 = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_Map.js");
          function mapCacheClear() {
            this.size = 0;
            this.__data__ = {
              "hash": new Hash(),
              "map": new (Map2 || ListCache)(),
              "string": new Hash()
            };
          }
          module2.exports = mapCacheClear;
        },
        "./node_modules/_lodash@4.17.20@lodash/_mapCacheDelete.js": function(module2, exports2, __webpack_require__) {
          var getMapData = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_getMapData.js");
          function mapCacheDelete(key) {
            var result = getMapData(this, key)["delete"](key);
            this.size -= result ? 1 : 0;
            return result;
          }
          module2.exports = mapCacheDelete;
        },
        "./node_modules/_lodash@4.17.20@lodash/_mapCacheGet.js": function(module2, exports2, __webpack_require__) {
          var getMapData = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_getMapData.js");
          function mapCacheGet(key) {
            return getMapData(this, key).get(key);
          }
          module2.exports = mapCacheGet;
        },
        "./node_modules/_lodash@4.17.20@lodash/_mapCacheHas.js": function(module2, exports2, __webpack_require__) {
          var getMapData = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_getMapData.js");
          function mapCacheHas(key) {
            return getMapData(this, key).has(key);
          }
          module2.exports = mapCacheHas;
        },
        "./node_modules/_lodash@4.17.20@lodash/_mapCacheSet.js": function(module2, exports2, __webpack_require__) {
          var getMapData = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_getMapData.js");
          function mapCacheSet(key, value) {
            var data = getMapData(this, key), size = data.size;
            data.set(key, value);
            this.size += data.size == size ? 0 : 1;
            return this;
          }
          module2.exports = mapCacheSet;
        },
        "./node_modules/_lodash@4.17.20@lodash/_mapToArray.js": function(module2, exports2) {
          function mapToArray(map) {
            var index = -1, result = Array(map.size);
            map.forEach(function(value, key) {
              result[++index] = [key, value];
            });
            return result;
          }
          module2.exports = mapToArray;
        },
        "./node_modules/_lodash@4.17.20@lodash/_matchesStrictComparable.js": function(module2, exports2) {
          function matchesStrictComparable(key, srcValue) {
            return function(object) {
              if (object == null) {
                return false;
              }
              return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
            };
          }
          module2.exports = matchesStrictComparable;
        },
        "./node_modules/_lodash@4.17.20@lodash/_memoizeCapped.js": function(module2, exports2, __webpack_require__) {
          var memoize = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/memoize.js");
          var MAX_MEMOIZE_SIZE = 500;
          function memoizeCapped(func) {
            var result = memoize(func, function(key) {
              if (cache.size === MAX_MEMOIZE_SIZE) {
                cache.clear();
              }
              return key;
            });
            var cache = result.cache;
            return result;
          }
          module2.exports = memoizeCapped;
        },
        "./node_modules/_lodash@4.17.20@lodash/_nativeCreate.js": function(module2, exports2, __webpack_require__) {
          var getNative = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_getNative.js");
          var nativeCreate = getNative(Object, "create");
          module2.exports = nativeCreate;
        },
        "./node_modules/_lodash@4.17.20@lodash/_nativeKeys.js": function(module2, exports2, __webpack_require__) {
          var overArg = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_overArg.js");
          var nativeKeys = overArg(Object.keys, Object);
          module2.exports = nativeKeys;
        },
        "./node_modules/_lodash@4.17.20@lodash/_nativeKeysIn.js": function(module2, exports2) {
          function nativeKeysIn(object) {
            var result = [];
            if (object != null) {
              for (var key in Object(object)) {
                result.push(key);
              }
            }
            return result;
          }
          module2.exports = nativeKeysIn;
        },
        "./node_modules/_lodash@4.17.20@lodash/_nodeUtil.js": function(module2, exports2, __webpack_require__) {
          (function(module3) {
            var freeGlobal = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_freeGlobal.js");
            var freeExports = exports2 && !exports2.nodeType && exports2;
            var freeModule = freeExports && typeof module3 == "object" && module3 && !module3.nodeType && module3;
            var moduleExports = freeModule && freeModule.exports === freeExports;
            var freeProcess = moduleExports && freeGlobal.process;
            var nodeUtil = function() {
              try {
                var types = freeModule && freeModule.require && freeModule.require("util").types;
                if (types) {
                  return types;
                }
                return freeProcess && freeProcess.binding && freeProcess.binding("util");
              } catch (e) {
              }
            }();
            module3.exports = nodeUtil;
          }).call(this, __webpack_require__("./node_modules/_webpack@4.46.0@webpack/buildin/module.js")(module2));
        },
        "./node_modules/_lodash@4.17.20@lodash/_objectToString.js": function(module2, exports2) {
          var objectProto = Object.prototype;
          var nativeObjectToString = objectProto.toString;
          function objectToString(value) {
            return nativeObjectToString.call(value);
          }
          module2.exports = objectToString;
        },
        "./node_modules/_lodash@4.17.20@lodash/_overArg.js": function(module2, exports2) {
          function overArg(func, transform) {
            return function(arg) {
              return func(transform(arg));
            };
          }
          module2.exports = overArg;
        },
        "./node_modules/_lodash@4.17.20@lodash/_overRest.js": function(module2, exports2, __webpack_require__) {
          var apply = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_apply.js");
          var nativeMax = Math.max;
          function overRest(func, start, transform) {
            start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
            return function() {
              var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
              while (++index < length) {
                array[index] = args[start + index];
              }
              index = -1;
              var otherArgs = Array(start + 1);
              while (++index < start) {
                otherArgs[index] = args[index];
              }
              otherArgs[start] = transform(array);
              return apply(func, this, otherArgs);
            };
          }
          module2.exports = overRest;
        },
        "./node_modules/_lodash@4.17.20@lodash/_root.js": function(module2, exports2, __webpack_require__) {
          var freeGlobal = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_freeGlobal.js");
          var freeSelf = typeof self == "object" && self && self.Object === Object && self;
          var root = freeGlobal || freeSelf || Function("return this")();
          module2.exports = root;
        },
        "./node_modules/_lodash@4.17.20@lodash/_safeGet.js": function(module2, exports2) {
          function safeGet(object, key) {
            if (key === "constructor" && typeof object[key] === "function") {
              return;
            }
            if (key == "__proto__") {
              return;
            }
            return object[key];
          }
          module2.exports = safeGet;
        },
        "./node_modules/_lodash@4.17.20@lodash/_setCacheAdd.js": function(module2, exports2) {
          var HASH_UNDEFINED = "__lodash_hash_undefined__";
          function setCacheAdd(value) {
            this.__data__.set(value, HASH_UNDEFINED);
            return this;
          }
          module2.exports = setCacheAdd;
        },
        "./node_modules/_lodash@4.17.20@lodash/_setCacheHas.js": function(module2, exports2) {
          function setCacheHas(value) {
            return this.__data__.has(value);
          }
          module2.exports = setCacheHas;
        },
        "./node_modules/_lodash@4.17.20@lodash/_setToArray.js": function(module2, exports2) {
          function setToArray(set) {
            var index = -1, result = Array(set.size);
            set.forEach(function(value) {
              result[++index] = value;
            });
            return result;
          }
          module2.exports = setToArray;
        },
        "./node_modules/_lodash@4.17.20@lodash/_setToString.js": function(module2, exports2, __webpack_require__) {
          var baseSetToString = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseSetToString.js"), shortOut = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_shortOut.js");
          var setToString = shortOut(baseSetToString);
          module2.exports = setToString;
        },
        "./node_modules/_lodash@4.17.20@lodash/_shortOut.js": function(module2, exports2) {
          var HOT_COUNT = 800, HOT_SPAN = 16;
          var nativeNow = Date.now;
          function shortOut(func) {
            var count = 0, lastCalled = 0;
            return function() {
              var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
              lastCalled = stamp;
              if (remaining > 0) {
                if (++count >= HOT_COUNT) {
                  return arguments[0];
                }
              } else {
                count = 0;
              }
              return func.apply(void 0, arguments);
            };
          }
          module2.exports = shortOut;
        },
        "./node_modules/_lodash@4.17.20@lodash/_stackClear.js": function(module2, exports2, __webpack_require__) {
          var ListCache = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_ListCache.js");
          function stackClear() {
            this.__data__ = new ListCache();
            this.size = 0;
          }
          module2.exports = stackClear;
        },
        "./node_modules/_lodash@4.17.20@lodash/_stackDelete.js": function(module2, exports2) {
          function stackDelete(key) {
            var data = this.__data__, result = data["delete"](key);
            this.size = data.size;
            return result;
          }
          module2.exports = stackDelete;
        },
        "./node_modules/_lodash@4.17.20@lodash/_stackGet.js": function(module2, exports2) {
          function stackGet(key) {
            return this.__data__.get(key);
          }
          module2.exports = stackGet;
        },
        "./node_modules/_lodash@4.17.20@lodash/_stackHas.js": function(module2, exports2) {
          function stackHas(key) {
            return this.__data__.has(key);
          }
          module2.exports = stackHas;
        },
        "./node_modules/_lodash@4.17.20@lodash/_stackSet.js": function(module2, exports2, __webpack_require__) {
          var ListCache = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_ListCache.js"), Map2 = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_Map.js"), MapCache = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_MapCache.js");
          var LARGE_ARRAY_SIZE = 200;
          function stackSet(key, value) {
            var data = this.__data__;
            if (data instanceof ListCache) {
              var pairs = data.__data__;
              if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
                pairs.push([key, value]);
                this.size = ++data.size;
                return this;
              }
              data = this.__data__ = new MapCache(pairs);
            }
            data.set(key, value);
            this.size = data.size;
            return this;
          }
          module2.exports = stackSet;
        },
        "./node_modules/_lodash@4.17.20@lodash/_strictIndexOf.js": function(module2, exports2) {
          function strictIndexOf(array, value, fromIndex) {
            var index = fromIndex - 1, length = array.length;
            while (++index < length) {
              if (array[index] === value) {
                return index;
              }
            }
            return -1;
          }
          module2.exports = strictIndexOf;
        },
        "./node_modules/_lodash@4.17.20@lodash/_stringSize.js": function(module2, exports2, __webpack_require__) {
          var asciiSize = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_asciiSize.js"), hasUnicode = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_hasUnicode.js"), unicodeSize = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_unicodeSize.js");
          function stringSize(string) {
            return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
          }
          module2.exports = stringSize;
        },
        "./node_modules/_lodash@4.17.20@lodash/_stringToPath.js": function(module2, exports2, __webpack_require__) {
          var memoizeCapped = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_memoizeCapped.js");
          var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
          var reEscapeChar = /\\(\\)?/g;
          var stringToPath = memoizeCapped(function(string) {
            var result = [];
            if (string.charCodeAt(0) === 46) {
              result.push("");
            }
            string.replace(rePropName, function(match, number, quote, subString) {
              result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
            });
            return result;
          });
          module2.exports = stringToPath;
        },
        "./node_modules/_lodash@4.17.20@lodash/_toKey.js": function(module2, exports2, __webpack_require__) {
          var isSymbol = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isSymbol.js");
          var INFINITY = 1 / 0;
          function toKey(value) {
            if (typeof value == "string" || isSymbol(value)) {
              return value;
            }
            var result = value + "";
            return result == "0" && 1 / value == -INFINITY ? "-0" : result;
          }
          module2.exports = toKey;
        },
        "./node_modules/_lodash@4.17.20@lodash/_toSource.js": function(module2, exports2) {
          var funcProto = Function.prototype;
          var funcToString = funcProto.toString;
          function toSource(func) {
            if (func != null) {
              try {
                return funcToString.call(func);
              } catch (e) {
              }
              try {
                return func + "";
              } catch (e) {
              }
            }
            return "";
          }
          module2.exports = toSource;
        },
        "./node_modules/_lodash@4.17.20@lodash/_unicodeSize.js": function(module2, exports2) {
          var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsVarRange = "\\ufe0e\\ufe0f";
          var rsAstral = "[" + rsAstralRange + "]", rsCombo = "[" + rsComboRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ = "\\u200d";
          var reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
          var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
          function unicodeSize(string) {
            var result = reUnicode.lastIndex = 0;
            while (reUnicode.test(string)) {
              ++result;
            }
            return result;
          }
          module2.exports = unicodeSize;
        },
        "./node_modules/_lodash@4.17.20@lodash/clone.js": function(module2, exports2, __webpack_require__) {
          var baseClone = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseClone.js");
          var CLONE_SYMBOLS_FLAG = 4;
          function clone(value) {
            return baseClone(value, CLONE_SYMBOLS_FLAG);
          }
          module2.exports = clone;
        },
        "./node_modules/_lodash@4.17.20@lodash/cloneDeep.js": function(module2, exports2, __webpack_require__) {
          var baseClone = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseClone.js");
          var CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
          function cloneDeep(value) {
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
          }
          module2.exports = cloneDeep;
        },
        "./node_modules/_lodash@4.17.20@lodash/constant.js": function(module2, exports2) {
          function constant(value) {
            return function() {
              return value;
            };
          }
          module2.exports = constant;
        },
        "./node_modules/_lodash@4.17.20@lodash/defaults.js": function(module2, exports2, __webpack_require__) {
          var baseRest = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseRest.js"), eq = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/eq.js"), isIterateeCall = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_isIterateeCall.js"), keysIn = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/keysIn.js");
          var objectProto = Object.prototype;
          var hasOwnProperty = objectProto.hasOwnProperty;
          var defaults = baseRest(function(object, sources) {
            object = Object(object);
            var index = -1;
            var length = sources.length;
            var guard = length > 2 ? sources[2] : void 0;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              length = 1;
            }
            while (++index < length) {
              var source = sources[index];
              var props = keysIn(source);
              var propsIndex = -1;
              var propsLength = props.length;
              while (++propsIndex < propsLength) {
                var key = props[propsIndex];
                var value = object[key];
                if (value === void 0 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                  object[key] = source[key];
                }
              }
            }
            return object;
          });
          module2.exports = defaults;
        },
        "./node_modules/_lodash@4.17.20@lodash/each.js": function(module2, exports2, __webpack_require__) {
          module2.exports = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/forEach.js");
        },
        "./node_modules/_lodash@4.17.20@lodash/eq.js": function(module2, exports2) {
          function eq(value, other) {
            return value === other || value !== value && other !== other;
          }
          module2.exports = eq;
        },
        "./node_modules/_lodash@4.17.20@lodash/filter.js": function(module2, exports2, __webpack_require__) {
          var arrayFilter = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_arrayFilter.js"), baseFilter = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseFilter.js"), baseIteratee = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseIteratee.js"), isArray = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isArray.js");
          function filter(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            return func(collection, baseIteratee(predicate, 3));
          }
          module2.exports = filter;
        },
        "./node_modules/_lodash@4.17.20@lodash/find.js": function(module2, exports2, __webpack_require__) {
          var createFind = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_createFind.js"), findIndex = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/findIndex.js");
          var find = createFind(findIndex);
          module2.exports = find;
        },
        "./node_modules/_lodash@4.17.20@lodash/findIndex.js": function(module2, exports2, __webpack_require__) {
          var baseFindIndex = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseFindIndex.js"), baseIteratee = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseIteratee.js"), toInteger = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/toInteger.js");
          var nativeMax = Math.max;
          function findIndex(array, predicate, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index < 0) {
              index = nativeMax(length + index, 0);
            }
            return baseFindIndex(array, baseIteratee(predicate, 3), index);
          }
          module2.exports = findIndex;
        },
        "./node_modules/_lodash@4.17.20@lodash/flatten.js": function(module2, exports2, __webpack_require__) {
          var baseFlatten = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseFlatten.js");
          function flatten(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseFlatten(array, 1) : [];
          }
          module2.exports = flatten;
        },
        "./node_modules/_lodash@4.17.20@lodash/forEach.js": function(module2, exports2, __webpack_require__) {
          var arrayEach = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_arrayEach.js"), baseEach = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseEach.js"), castFunction = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_castFunction.js"), isArray = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isArray.js");
          function forEach(collection, iteratee) {
            var func = isArray(collection) ? arrayEach : baseEach;
            return func(collection, castFunction(iteratee));
          }
          module2.exports = forEach;
        },
        "./node_modules/_lodash@4.17.20@lodash/forIn.js": function(module2, exports2, __webpack_require__) {
          var baseFor = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseFor.js"), castFunction = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_castFunction.js"), keysIn = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/keysIn.js");
          function forIn(object, iteratee) {
            return object == null ? object : baseFor(object, castFunction(iteratee), keysIn);
          }
          module2.exports = forIn;
        },
        "./node_modules/_lodash@4.17.20@lodash/get.js": function(module2, exports2, __webpack_require__) {
          var baseGet = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseGet.js");
          function get(object, path, defaultValue) {
            var result = object == null ? void 0 : baseGet(object, path);
            return result === void 0 ? defaultValue : result;
          }
          module2.exports = get;
        },
        "./node_modules/_lodash@4.17.20@lodash/has.js": function(module2, exports2, __webpack_require__) {
          var baseHas = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseHas.js"), hasPath = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_hasPath.js");
          function has(object, path) {
            return object != null && hasPath(object, path, baseHas);
          }
          module2.exports = has;
        },
        "./node_modules/_lodash@4.17.20@lodash/hasIn.js": function(module2, exports2, __webpack_require__) {
          var baseHasIn = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseHasIn.js"), hasPath = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_hasPath.js");
          function hasIn(object, path) {
            return object != null && hasPath(object, path, baseHasIn);
          }
          module2.exports = hasIn;
        },
        "./node_modules/_lodash@4.17.20@lodash/identity.js": function(module2, exports2) {
          function identity(value) {
            return value;
          }
          module2.exports = identity;
        },
        "./node_modules/_lodash@4.17.20@lodash/isArguments.js": function(module2, exports2, __webpack_require__) {
          var baseIsArguments = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseIsArguments.js"), isObjectLike = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isObjectLike.js");
          var objectProto = Object.prototype;
          var hasOwnProperty = objectProto.hasOwnProperty;
          var propertyIsEnumerable = objectProto.propertyIsEnumerable;
          var isArguments = baseIsArguments(function() {
            return arguments;
          }()) ? baseIsArguments : function(value) {
            return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
          };
          module2.exports = isArguments;
        },
        "./node_modules/_lodash@4.17.20@lodash/isArray.js": function(module2, exports2) {
          var isArray = Array.isArray;
          module2.exports = isArray;
        },
        "./node_modules/_lodash@4.17.20@lodash/isArrayLike.js": function(module2, exports2, __webpack_require__) {
          var isFunction = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isFunction.js"), isLength = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isLength.js");
          function isArrayLike(value) {
            return value != null && isLength(value.length) && !isFunction(value);
          }
          module2.exports = isArrayLike;
        },
        "./node_modules/_lodash@4.17.20@lodash/isArrayLikeObject.js": function(module2, exports2, __webpack_require__) {
          var isArrayLike = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isArrayLike.js"), isObjectLike = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isObjectLike.js");
          function isArrayLikeObject(value) {
            return isObjectLike(value) && isArrayLike(value);
          }
          module2.exports = isArrayLikeObject;
        },
        "./node_modules/_lodash@4.17.20@lodash/isBuffer.js": function(module2, exports2, __webpack_require__) {
          (function(module3) {
            var root = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_root.js"), stubFalse = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/stubFalse.js");
            var freeExports = exports2 && !exports2.nodeType && exports2;
            var freeModule = freeExports && typeof module3 == "object" && module3 && !module3.nodeType && module3;
            var moduleExports = freeModule && freeModule.exports === freeExports;
            var Buffer = moduleExports ? root.Buffer : void 0;
            var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
            var isBuffer = nativeIsBuffer || stubFalse;
            module3.exports = isBuffer;
          }).call(this, __webpack_require__("./node_modules/_webpack@4.46.0@webpack/buildin/module.js")(module2));
        },
        "./node_modules/_lodash@4.17.20@lodash/isEmpty.js": function(module2, exports2, __webpack_require__) {
          var baseKeys = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseKeys.js"), getTag = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_getTag.js"), isArguments = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isArguments.js"), isArray = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isArray.js"), isArrayLike = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isArrayLike.js"), isBuffer = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isBuffer.js"), isPrototype = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_isPrototype.js"), isTypedArray = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isTypedArray.js");
          var mapTag = "[object Map]", setTag = "[object Set]";
          var objectProto = Object.prototype;
          var hasOwnProperty = objectProto.hasOwnProperty;
          function isEmpty(value) {
            if (value == null) {
              return true;
            }
            if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
              return !value.length;
            }
            var tag = getTag(value);
            if (tag == mapTag || tag == setTag) {
              return !value.size;
            }
            if (isPrototype(value)) {
              return !baseKeys(value).length;
            }
            for (var key in value) {
              if (hasOwnProperty.call(value, key)) {
                return false;
              }
            }
            return true;
          }
          module2.exports = isEmpty;
        },
        "./node_modules/_lodash@4.17.20@lodash/isFunction.js": function(module2, exports2, __webpack_require__) {
          var baseGetTag = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseGetTag.js"), isObject = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isObject.js");
          var asyncTag = "[object AsyncFunction]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
          function isFunction(value) {
            if (!isObject(value)) {
              return false;
            }
            var tag = baseGetTag(value);
            return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
          }
          module2.exports = isFunction;
        },
        "./node_modules/_lodash@4.17.20@lodash/isLength.js": function(module2, exports2) {
          var MAX_SAFE_INTEGER = 9007199254740991;
          function isLength(value) {
            return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
          }
          module2.exports = isLength;
        },
        "./node_modules/_lodash@4.17.20@lodash/isMap.js": function(module2, exports2, __webpack_require__) {
          var baseIsMap = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseIsMap.js"), baseUnary = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseUnary.js"), nodeUtil = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_nodeUtil.js");
          var nodeIsMap = nodeUtil && nodeUtil.isMap;
          var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
          module2.exports = isMap;
        },
        "./node_modules/_lodash@4.17.20@lodash/isObject.js": function(module2, exports2) {
          function isObject(value) {
            var type = typeof value;
            return value != null && (type == "object" || type == "function");
          }
          module2.exports = isObject;
        },
        "./node_modules/_lodash@4.17.20@lodash/isObjectLike.js": function(module2, exports2) {
          function isObjectLike(value) {
            return value != null && typeof value == "object";
          }
          module2.exports = isObjectLike;
        },
        "./node_modules/_lodash@4.17.20@lodash/isPlainObject.js": function(module2, exports2, __webpack_require__) {
          var baseGetTag = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseGetTag.js"), getPrototype = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_getPrototype.js"), isObjectLike = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isObjectLike.js");
          var objectTag = "[object Object]";
          var funcProto = Function.prototype, objectProto = Object.prototype;
          var funcToString = funcProto.toString;
          var hasOwnProperty = objectProto.hasOwnProperty;
          var objectCtorString = funcToString.call(Object);
          function isPlainObject(value) {
            if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
              return false;
            }
            var proto = getPrototype(value);
            if (proto === null) {
              return true;
            }
            var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
            return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
          }
          module2.exports = isPlainObject;
        },
        "./node_modules/_lodash@4.17.20@lodash/isSet.js": function(module2, exports2, __webpack_require__) {
          var baseIsSet = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseIsSet.js"), baseUnary = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseUnary.js"), nodeUtil = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_nodeUtil.js");
          var nodeIsSet = nodeUtil && nodeUtil.isSet;
          var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
          module2.exports = isSet;
        },
        "./node_modules/_lodash@4.17.20@lodash/isString.js": function(module2, exports2, __webpack_require__) {
          var baseGetTag = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseGetTag.js"), isArray = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isArray.js"), isObjectLike = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isObjectLike.js");
          var stringTag = "[object String]";
          function isString(value) {
            return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
          }
          module2.exports = isString;
        },
        "./node_modules/_lodash@4.17.20@lodash/isSymbol.js": function(module2, exports2, __webpack_require__) {
          var baseGetTag = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseGetTag.js"), isObjectLike = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isObjectLike.js");
          var symbolTag = "[object Symbol]";
          function isSymbol(value) {
            return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
          }
          module2.exports = isSymbol;
        },
        "./node_modules/_lodash@4.17.20@lodash/isTypedArray.js": function(module2, exports2, __webpack_require__) {
          var baseIsTypedArray = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseIsTypedArray.js"), baseUnary = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseUnary.js"), nodeUtil = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_nodeUtil.js");
          var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
          var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
          module2.exports = isTypedArray;
        },
        "./node_modules/_lodash@4.17.20@lodash/isUndefined.js": function(module2, exports2) {
          function isUndefined(value) {
            return value === void 0;
          }
          module2.exports = isUndefined;
        },
        "./node_modules/_lodash@4.17.20@lodash/keys.js": function(module2, exports2, __webpack_require__) {
          var arrayLikeKeys = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_arrayLikeKeys.js"), baseKeys = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseKeys.js"), isArrayLike = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isArrayLike.js");
          function keys(object) {
            return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
          }
          module2.exports = keys;
        },
        "./node_modules/_lodash@4.17.20@lodash/keysIn.js": function(module2, exports2, __webpack_require__) {
          var arrayLikeKeys = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_arrayLikeKeys.js"), baseKeysIn = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseKeysIn.js"), isArrayLike = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isArrayLike.js");
          function keysIn(object) {
            return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
          }
          module2.exports = keysIn;
        },
        "./node_modules/_lodash@4.17.20@lodash/last.js": function(module2, exports2) {
          function last(array) {
            var length = array == null ? 0 : array.length;
            return length ? array[length - 1] : void 0;
          }
          module2.exports = last;
        },
        "./node_modules/_lodash@4.17.20@lodash/map.js": function(module2, exports2, __webpack_require__) {
          var arrayMap = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_arrayMap.js"), baseIteratee = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseIteratee.js"), baseMap = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseMap.js"), isArray = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isArray.js");
          function map(collection, iteratee) {
            var func = isArray(collection) ? arrayMap : baseMap;
            return func(collection, baseIteratee(iteratee, 3));
          }
          module2.exports = map;
        },
        "./node_modules/_lodash@4.17.20@lodash/mapValues.js": function(module2, exports2, __webpack_require__) {
          var baseAssignValue = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseAssignValue.js"), baseForOwn = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseForOwn.js"), baseIteratee = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseIteratee.js");
          function mapValues(object, iteratee) {
            var result = {};
            iteratee = baseIteratee(iteratee, 3);
            baseForOwn(object, function(value, key, object2) {
              baseAssignValue(result, key, iteratee(value, key, object2));
            });
            return result;
          }
          module2.exports = mapValues;
        },
        "./node_modules/_lodash@4.17.20@lodash/max.js": function(module2, exports2, __webpack_require__) {
          var baseExtremum = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseExtremum.js"), baseGt = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseGt.js"), identity = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/identity.js");
          function max(array) {
            return array && array.length ? baseExtremum(array, identity, baseGt) : void 0;
          }
          module2.exports = max;
        },
        "./node_modules/_lodash@4.17.20@lodash/memoize.js": function(module2, exports2, __webpack_require__) {
          var MapCache = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_MapCache.js");
          var FUNC_ERROR_TEXT = "Expected a function";
          function memoize(func, resolver) {
            if (typeof func != "function" || resolver != null && typeof resolver != "function") {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
            var memoized = function() {
              var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
              if (cache.has(key)) {
                return cache.get(key);
              }
              var result = func.apply(this, args);
              memoized.cache = cache.set(key, result) || cache;
              return result;
            };
            memoized.cache = new (memoize.Cache || MapCache)();
            return memoized;
          }
          memoize.Cache = MapCache;
          module2.exports = memoize;
        },
        "./node_modules/_lodash@4.17.20@lodash/merge.js": function(module2, exports2, __webpack_require__) {
          var baseMerge = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseMerge.js"), createAssigner = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_createAssigner.js");
          var merge = createAssigner(function(object, source, srcIndex) {
            baseMerge(object, source, srcIndex);
          });
          module2.exports = merge;
        },
        "./node_modules/_lodash@4.17.20@lodash/min.js": function(module2, exports2, __webpack_require__) {
          var baseExtremum = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseExtremum.js"), baseLt = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseLt.js"), identity = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/identity.js");
          function min(array) {
            return array && array.length ? baseExtremum(array, identity, baseLt) : void 0;
          }
          module2.exports = min;
        },
        "./node_modules/_lodash@4.17.20@lodash/minBy.js": function(module2, exports2, __webpack_require__) {
          var baseExtremum = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseExtremum.js"), baseIteratee = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseIteratee.js"), baseLt = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseLt.js");
          function minBy(array, iteratee) {
            return array && array.length ? baseExtremum(array, baseIteratee(iteratee, 2), baseLt) : void 0;
          }
          module2.exports = minBy;
        },
        "./node_modules/_lodash@4.17.20@lodash/noop.js": function(module2, exports2) {
          function noop() {
          }
          module2.exports = noop;
        },
        "./node_modules/_lodash@4.17.20@lodash/now.js": function(module2, exports2, __webpack_require__) {
          var root = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_root.js");
          var now = function() {
            return root.Date.now();
          };
          module2.exports = now;
        },
        "./node_modules/_lodash@4.17.20@lodash/pick.js": function(module2, exports2, __webpack_require__) {
          var basePick = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_basePick.js"), flatRest = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_flatRest.js");
          var pick = flatRest(function(object, paths) {
            return object == null ? {} : basePick(object, paths);
          });
          module2.exports = pick;
        },
        "./node_modules/_lodash@4.17.20@lodash/property.js": function(module2, exports2, __webpack_require__) {
          var baseProperty = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseProperty.js"), basePropertyDeep = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_basePropertyDeep.js"), isKey = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_isKey.js"), toKey = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_toKey.js");
          function property(path) {
            return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
          }
          module2.exports = property;
        },
        "./node_modules/_lodash@4.17.20@lodash/range.js": function(module2, exports2, __webpack_require__) {
          var createRange = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_createRange.js");
          var range = createRange();
          module2.exports = range;
        },
        "./node_modules/_lodash@4.17.20@lodash/reduce.js": function(module2, exports2, __webpack_require__) {
          var arrayReduce = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_arrayReduce.js"), baseEach = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseEach.js"), baseIteratee = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseIteratee.js"), baseReduce = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseReduce.js"), isArray = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isArray.js");
          function reduce(collection, iteratee, accumulator) {
            var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
            return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
          }
          module2.exports = reduce;
        },
        "./node_modules/_lodash@4.17.20@lodash/size.js": function(module2, exports2, __webpack_require__) {
          var baseKeys = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseKeys.js"), getTag = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_getTag.js"), isArrayLike = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isArrayLike.js"), isString = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isString.js"), stringSize = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_stringSize.js");
          var mapTag = "[object Map]", setTag = "[object Set]";
          function size(collection) {
            if (collection == null) {
              return 0;
            }
            if (isArrayLike(collection)) {
              return isString(collection) ? stringSize(collection) : collection.length;
            }
            var tag = getTag(collection);
            if (tag == mapTag || tag == setTag) {
              return collection.size;
            }
            return baseKeys(collection).length;
          }
          module2.exports = size;
        },
        "./node_modules/_lodash@4.17.20@lodash/sortBy.js": function(module2, exports2, __webpack_require__) {
          var baseFlatten = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseFlatten.js"), baseOrderBy = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseOrderBy.js"), baseRest = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseRest.js"), isIterateeCall = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_isIterateeCall.js");
          var sortBy = baseRest(function(collection, iteratees) {
            if (collection == null) {
              return [];
            }
            var length = iteratees.length;
            if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
              iteratees = [];
            } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
              iteratees = [iteratees[0]];
            }
            return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
          });
          module2.exports = sortBy;
        },
        "./node_modules/_lodash@4.17.20@lodash/stubArray.js": function(module2, exports2) {
          function stubArray() {
            return [];
          }
          module2.exports = stubArray;
        },
        "./node_modules/_lodash@4.17.20@lodash/stubFalse.js": function(module2, exports2) {
          function stubFalse() {
            return false;
          }
          module2.exports = stubFalse;
        },
        "./node_modules/_lodash@4.17.20@lodash/toFinite.js": function(module2, exports2, __webpack_require__) {
          var toNumber = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/toNumber.js");
          var INFINITY = 1 / 0, MAX_INTEGER = 17976931348623157e292;
          function toFinite(value) {
            if (!value) {
              return value === 0 ? value : 0;
            }
            value = toNumber(value);
            if (value === INFINITY || value === -INFINITY) {
              var sign = value < 0 ? -1 : 1;
              return sign * MAX_INTEGER;
            }
            return value === value ? value : 0;
          }
          module2.exports = toFinite;
        },
        "./node_modules/_lodash@4.17.20@lodash/toInteger.js": function(module2, exports2, __webpack_require__) {
          var toFinite = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/toFinite.js");
          function toInteger(value) {
            var result = toFinite(value), remainder = result % 1;
            return result === result ? remainder ? result - remainder : result : 0;
          }
          module2.exports = toInteger;
        },
        "./node_modules/_lodash@4.17.20@lodash/toNumber.js": function(module2, exports2, __webpack_require__) {
          var isObject = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isObject.js"), isSymbol = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isSymbol.js");
          var NAN = 0 / 0;
          var reTrim = /^\s+|\s+$/g;
          var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
          var reIsBinary = /^0b[01]+$/i;
          var reIsOctal = /^0o[0-7]+$/i;
          var freeParseInt = parseInt;
          function toNumber(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol(value)) {
              return NAN;
            }
            if (isObject(value)) {
              var other = typeof value.valueOf == "function" ? value.valueOf() : value;
              value = isObject(other) ? other + "" : other;
            }
            if (typeof value != "string") {
              return value === 0 ? value : +value;
            }
            value = value.replace(reTrim, "");
            var isBinary = reIsBinary.test(value);
            return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
          }
          module2.exports = toNumber;
        },
        "./node_modules/_lodash@4.17.20@lodash/toPlainObject.js": function(module2, exports2, __webpack_require__) {
          var copyObject = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_copyObject.js"), keysIn = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/keysIn.js");
          function toPlainObject(value) {
            return copyObject(value, keysIn(value));
          }
          module2.exports = toPlainObject;
        },
        "./node_modules/_lodash@4.17.20@lodash/toString.js": function(module2, exports2, __webpack_require__) {
          var baseToString = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseToString.js");
          function toString(value) {
            return value == null ? "" : baseToString(value);
          }
          module2.exports = toString;
        },
        "./node_modules/_lodash@4.17.20@lodash/transform.js": function(module2, exports2, __webpack_require__) {
          var arrayEach = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_arrayEach.js"), baseCreate = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseCreate.js"), baseForOwn = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseForOwn.js"), baseIteratee = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseIteratee.js"), getPrototype = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_getPrototype.js"), isArray = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isArray.js"), isBuffer = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isBuffer.js"), isFunction = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isFunction.js"), isObject = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isObject.js"), isTypedArray = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isTypedArray.js");
          function transform(object, iteratee, accumulator) {
            var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
            iteratee = baseIteratee(iteratee, 4);
            if (accumulator == null) {
              var Ctor = object && object.constructor;
              if (isArrLike) {
                accumulator = isArr ? new Ctor() : [];
              } else if (isObject(object)) {
                accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
              } else {
                accumulator = {};
              }
            }
            (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
              return iteratee(accumulator, value, index, object2);
            });
            return accumulator;
          }
          module2.exports = transform;
        },
        "./node_modules/_lodash@4.17.20@lodash/union.js": function(module2, exports2, __webpack_require__) {
          var baseFlatten = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseFlatten.js"), baseRest = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseRest.js"), baseUniq = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseUniq.js"), isArrayLikeObject = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/isArrayLikeObject.js");
          var union = baseRest(function(arrays) {
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
          });
          module2.exports = union;
        },
        "./node_modules/_lodash@4.17.20@lodash/uniqueId.js": function(module2, exports2, __webpack_require__) {
          var toString = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/toString.js");
          var idCounter = 0;
          function uniqueId(prefix) {
            var id = ++idCounter;
            return toString(prefix) + id;
          }
          module2.exports = uniqueId;
        },
        "./node_modules/_lodash@4.17.20@lodash/values.js": function(module2, exports2, __webpack_require__) {
          var baseValues = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseValues.js"), keys = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/keys.js");
          function values(object) {
            return object == null ? [] : baseValues(object, keys(object));
          }
          module2.exports = values;
        },
        "./node_modules/_lodash@4.17.20@lodash/zipObject.js": function(module2, exports2, __webpack_require__) {
          var assignValue = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_assignValue.js"), baseZipObject = __webpack_require__("./node_modules/_lodash@4.17.20@lodash/_baseZipObject.js");
          function zipObject(props, values) {
            return baseZipObject(props || [], values || [], assignValue);
          }
          module2.exports = zipObject;
        },
        "./node_modules/_parse-svg-path@0.1.2@parse-svg-path/index.js": function(module2, exports2) {
          module2.exports = parse;
          var length = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 };
          var segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
          function parse(path) {
            var data = [];
            path.replace(segment, function(_, command, args) {
              var type = command.toLowerCase();
              args = parseValues(args);
              if (type == "m" && args.length > 2) {
                data.push([command].concat(args.splice(0, 2)));
                type = "l";
                command = command == "m" ? "l" : "L";
              }
              while (true) {
                if (args.length == length[type]) {
                  args.unshift(command);
                  return data.push(args);
                }
                if (args.length < length[type])
                  throw new Error("malformed path data");
                data.push([command].concat(args.splice(0, length[type])));
              }
            });
            return data;
          }
          var number = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
          function parseValues(args) {
            var numbers = args.match(number);
            return numbers ? numbers.map(Number) : [];
          }
        },
        "./node_modules/_point-at-length@1.1.0@point-at-length/index.js": function(module2, exports2, __webpack_require__) {
          var parse = __webpack_require__("./node_modules/_parse-svg-path@0.1.2@parse-svg-path/index.js");
          var isarray = __webpack_require__("./node_modules/_isarray@0.0.1@isarray/index.js");
          var abs = __webpack_require__("./node_modules/_abs-svg-path@0.1.1@abs-svg-path/index.js");
          module2.exports = Points;
          function Points(path) {
            if (!(this instanceof Points))
              return new Points(path);
            this._path = isarray(path) ? path : parse(path);
            this._path = abs(this._path);
            this._path = zvhToL(this._path);
            this._path = longhand(this._path);
          }
          Points.prototype.at = function(pos, opts) {
            return this._walk(pos, opts).pos;
          };
          Points.prototype.length = function() {
            return this._walk(null).length;
          };
          Points.prototype._walk = function(pos, opts) {
            var cur = [0, 0];
            var prev = [0, 0, 0];
            var p0 = [0, 0];
            var len = 0;
            for (var i = 0; i < this._path.length; i++) {
              var p = this._path[i];
              if (p[0] === "M") {
                cur[0] = p[1];
                cur[1] = p[2];
                if (pos === 0) {
                  return { length: len, pos: cur };
                }
              } else if (p[0] === "C") {
                prev[0] = p0[0] = cur[0];
                prev[1] = p0[1] = cur[1];
                prev[2] = len;
                var n = 100;
                for (var j = 0; j <= n; j++) {
                  var t = j / n;
                  var x = xof_C(p, t);
                  var y = yof_C(p, t);
                  len += dist(cur[0], cur[1], x, y);
                  cur[0] = x;
                  cur[1] = y;
                  if (typeof pos === "number" && len >= pos) {
                    var dv = (len - pos) / (len - prev[2]);
                    var npos = [
                      cur[0] * (1 - dv) + prev[0] * dv,
                      cur[1] * (1 - dv) + prev[1] * dv
                    ];
                    return { length: len, pos: npos };
                  }
                  prev[0] = cur[0];
                  prev[1] = cur[1];
                  prev[2] = len;
                }
              } else if (p[0] === "Q") {
                prev[0] = p0[0] = cur[0];
                prev[1] = p0[1] = cur[1];
                prev[2] = len;
                var n = 100;
                for (var j = 0; j <= n; j++) {
                  var t = j / n;
                  var x = xof_Q(p, t);
                  var y = yof_Q(p, t);
                  len += dist(cur[0], cur[1], x, y);
                  cur[0] = x;
                  cur[1] = y;
                  if (typeof pos === "number" && len >= pos) {
                    var dv = (len - pos) / (len - prev[2]);
                    var npos = [
                      cur[0] * (1 - dv) + prev[0] * dv,
                      cur[1] * (1 - dv) + prev[1] * dv
                    ];
                    return { length: len, pos: npos };
                  }
                  prev[0] = cur[0];
                  prev[1] = cur[1];
                  prev[2] = len;
                }
              } else if (p[0] === "L") {
                prev[0] = cur[0];
                prev[1] = cur[1];
                prev[2] = len;
                len += dist(cur[0], cur[1], p[1], p[2]);
                cur[0] = p[1];
                cur[1] = p[2];
                if (typeof pos === "number" && len >= pos) {
                  var dv = (len - pos) / (len - prev[2]);
                  var npos = [
                    cur[0] * (1 - dv) + prev[0] * dv,
                    cur[1] * (1 - dv) + prev[1] * dv
                  ];
                  return { length: len, pos: npos };
                }
                prev[0] = cur[0];
                prev[1] = cur[1];
                prev[2] = len;
              }
            }
            return { length: len, pos: cur };
            function xof_C(p2, t2) {
              return Math.pow(1 - t2, 3) * p0[0] + 3 * Math.pow(1 - t2, 2) * t2 * p2[1] + 3 * (1 - t2) * Math.pow(t2, 2) * p2[3] + Math.pow(t2, 3) * p2[5];
            }
            function yof_C(p2, t2) {
              return Math.pow(1 - t2, 3) * p0[1] + 3 * Math.pow(1 - t2, 2) * t2 * p2[2] + 3 * (1 - t2) * Math.pow(t2, 2) * p2[4] + Math.pow(t2, 3) * p2[6];
            }
            function xof_Q(p2, t2) {
              return Math.pow(1 - t2, 2) * p0[0] + 2 * (1 - t2) * t2 * p2[1] + Math.pow(t2, 2) * p2[3];
            }
            function yof_Q(p2, t2) {
              return Math.pow(1 - t2, 2) * p0[1] + 2 * (1 - t2) * t2 * p2[2] + Math.pow(t2, 2) * p2[4];
            }
          };
          function dist(ax, ay, bx, by) {
            var x = ax - bx;
            var y = ay - by;
            return Math.sqrt(x * x + y * y);
          }
          function longhand(path) {
            var prev, x1 = 0, y1 = 0;
            var conversion = { S: { to: "C", x: 3 }, T: { to: "Q", x: 1 } };
            for (var i = 0, len = path.length; i < len; i++) {
              var cmd = path[i];
              var convert = conversion[cmd[0]];
              if (convert) {
                cmd[0] = convert.to;
                if (prev) {
                  if (prev[0] === convert.to) {
                    x1 = 2 * prev[convert.x + 2] - prev[convert.x];
                    y1 = 2 * prev[convert.x + 3] - prev[convert.x + 1];
                  } else {
                    x1 = prev[prev.length - 2];
                    y1 = prev[prev.length - 1];
                  }
                }
                cmd.splice(1, 0, x1, y1);
              }
              prev = cmd;
            }
            return path;
          }
          function zvhToL(path) {
            var ret = [];
            var startPoint = ["L", 0, 0];
            var last_point;
            for (var i = 0, len = path.length; i < len; i++) {
              var pt = path[i];
              switch (pt[0]) {
                case "M":
                  startPoint = ["L", pt[1], pt[2]];
                  ret.push(pt);
                  break;
                case "Z":
                  ret.push(startPoint);
                  break;
                case "H":
                  last_point = ret[ret.length - 1] || ["L", 0, 0];
                  ret.push(["L", pt[1], last_point[last_point.length - 1]]);
                  break;
                case "V":
                  last_point = ret[ret.length - 1] || ["L", 0, 0];
                  ret.push(["L", last_point[last_point.length - 2], pt[1]]);
                  break;
                default:
                  ret.push(pt);
              }
            }
            return ret;
          }
        },
        "./node_modules/_regression@2.0.1@regression/dist/regression.js": function(module2, exports2, __webpack_require__) {
          var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
          (function(global, factory) {
            if (true) {
              !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module2], __WEBPACK_AMD_DEFINE_FACTORY__ = factory, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function" ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports2, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
            } else {
              var mod;
            }
          })(this, function(module3) {
            "use strict";
            function _defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, {
                  value,
                  enumerable: true,
                  configurable: true,
                  writable: true
                });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            var _extends = Object.assign || function(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) {
                  if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                  }
                }
              }
              return target;
            };
            function _toConsumableArray(arr) {
              if (Array.isArray(arr)) {
                for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
                  arr2[i] = arr[i];
                }
                return arr2;
              } else {
                return Array.from(arr);
              }
            }
            var DEFAULT_OPTIONS = { order: 2, precision: 2, period: null };
            function determinationCoefficient(data, results) {
              var predictions = [];
              var observations = [];
              data.forEach(function(d, i) {
                if (d[1] !== null) {
                  observations.push(d);
                  predictions.push(results[i]);
                }
              });
              var sum = observations.reduce(function(a, observation) {
                return a + observation[1];
              }, 0);
              var mean = sum / observations.length;
              var ssyy = observations.reduce(function(a, observation) {
                var difference = observation[1] - mean;
                return a + difference * difference;
              }, 0);
              var sse = observations.reduce(function(accum, observation, index) {
                var prediction = predictions[index];
                var residual = observation[1] - prediction[1];
                return accum + residual * residual;
              }, 0);
              return 1 - sse / ssyy;
            }
            function gaussianElimination(input, order) {
              var matrix = input;
              var n = input.length - 1;
              var coefficients = [order];
              for (var i = 0; i < n; i++) {
                var maxrow = i;
                for (var j = i + 1; j < n; j++) {
                  if (Math.abs(matrix[i][j]) > Math.abs(matrix[i][maxrow])) {
                    maxrow = j;
                  }
                }
                for (var k = i; k < n + 1; k++) {
                  var tmp = matrix[k][i];
                  matrix[k][i] = matrix[k][maxrow];
                  matrix[k][maxrow] = tmp;
                }
                for (var _j = i + 1; _j < n; _j++) {
                  for (var _k = n; _k >= i; _k--) {
                    matrix[_k][_j] -= matrix[_k][i] * matrix[i][_j] / matrix[i][i];
                  }
                }
              }
              for (var _j2 = n - 1; _j2 >= 0; _j2--) {
                var total = 0;
                for (var _k2 = _j2 + 1; _k2 < n; _k2++) {
                  total += matrix[_k2][_j2] * coefficients[_k2];
                }
                coefficients[_j2] = (matrix[n][_j2] - total) / matrix[_j2][_j2];
              }
              return coefficients;
            }
            function round(number, precision) {
              var factor = Math.pow(10, precision);
              return Math.round(number * factor) / factor;
            }
            var methods = {
              linear: function linear(data, options) {
                var sum = [0, 0, 0, 0, 0];
                var len = 0;
                for (var n = 0; n < data.length; n++) {
                  if (data[n][1] !== null) {
                    len++;
                    sum[0] += data[n][0];
                    sum[1] += data[n][1];
                    sum[2] += data[n][0] * data[n][0];
                    sum[3] += data[n][0] * data[n][1];
                    sum[4] += data[n][1] * data[n][1];
                  }
                }
                var run = len * sum[2] - sum[0] * sum[0];
                var rise = len * sum[3] - sum[0] * sum[1];
                var gradient = run === 0 ? 0 : round(rise / run, options.precision);
                var intercept = round(sum[1] / len - gradient * sum[0] / len, options.precision);
                var predict = function predict2(x) {
                  return [round(x, options.precision), round(gradient * x + intercept, options.precision)];
                };
                var points = data.map(function(point) {
                  return predict(point[0]);
                });
                return {
                  points,
                  predict,
                  equation: [gradient, intercept],
                  r2: round(determinationCoefficient(data, points), options.precision),
                  string: intercept === 0 ? "y = " + gradient + "x" : "y = " + gradient + "x + " + intercept
                };
              },
              exponential: function exponential(data, options) {
                var sum = [0, 0, 0, 0, 0, 0];
                for (var n = 0; n < data.length; n++) {
                  if (data[n][1] !== null) {
                    sum[0] += data[n][0];
                    sum[1] += data[n][1];
                    sum[2] += data[n][0] * data[n][0] * data[n][1];
                    sum[3] += data[n][1] * Math.log(data[n][1]);
                    sum[4] += data[n][0] * data[n][1] * Math.log(data[n][1]);
                    sum[5] += data[n][0] * data[n][1];
                  }
                }
                var denominator = sum[1] * sum[2] - sum[5] * sum[5];
                var a = Math.exp((sum[2] * sum[3] - sum[5] * sum[4]) / denominator);
                var b = (sum[1] * sum[4] - sum[5] * sum[3]) / denominator;
                var coeffA = round(a, options.precision);
                var coeffB = round(b, options.precision);
                var predict = function predict2(x) {
                  return [round(x, options.precision), round(coeffA * Math.exp(coeffB * x), options.precision)];
                };
                var points = data.map(function(point) {
                  return predict(point[0]);
                });
                return {
                  points,
                  predict,
                  equation: [coeffA, coeffB],
                  string: "y = " + coeffA + "e^(" + coeffB + "x)",
                  r2: round(determinationCoefficient(data, points), options.precision)
                };
              },
              logarithmic: function logarithmic(data, options) {
                var sum = [0, 0, 0, 0];
                var len = data.length;
                for (var n = 0; n < len; n++) {
                  if (data[n][1] !== null) {
                    sum[0] += Math.log(data[n][0]);
                    sum[1] += data[n][1] * Math.log(data[n][0]);
                    sum[2] += data[n][1];
                    sum[3] += Math.pow(Math.log(data[n][0]), 2);
                  }
                }
                var a = (len * sum[1] - sum[2] * sum[0]) / (len * sum[3] - sum[0] * sum[0]);
                var coeffB = round(a, options.precision);
                var coeffA = round((sum[2] - coeffB * sum[0]) / len, options.precision);
                var predict = function predict2(x) {
                  return [round(x, options.precision), round(round(coeffA + coeffB * Math.log(x), options.precision), options.precision)];
                };
                var points = data.map(function(point) {
                  return predict(point[0]);
                });
                return {
                  points,
                  predict,
                  equation: [coeffA, coeffB],
                  string: "y = " + coeffA + " + " + coeffB + " ln(x)",
                  r2: round(determinationCoefficient(data, points), options.precision)
                };
              },
              power: function power(data, options) {
                var sum = [0, 0, 0, 0, 0];
                var len = data.length;
                for (var n = 0; n < len; n++) {
                  if (data[n][1] !== null) {
                    sum[0] += Math.log(data[n][0]);
                    sum[1] += Math.log(data[n][1]) * Math.log(data[n][0]);
                    sum[2] += Math.log(data[n][1]);
                    sum[3] += Math.pow(Math.log(data[n][0]), 2);
                  }
                }
                var b = (len * sum[1] - sum[0] * sum[2]) / (len * sum[3] - Math.pow(sum[0], 2));
                var a = (sum[2] - b * sum[0]) / len;
                var coeffA = round(Math.exp(a), options.precision);
                var coeffB = round(b, options.precision);
                var predict = function predict2(x) {
                  return [round(x, options.precision), round(round(coeffA * Math.pow(x, coeffB), options.precision), options.precision)];
                };
                var points = data.map(function(point) {
                  return predict(point[0]);
                });
                return {
                  points,
                  predict,
                  equation: [coeffA, coeffB],
                  string: "y = " + coeffA + "x^" + coeffB,
                  r2: round(determinationCoefficient(data, points), options.precision)
                };
              },
              polynomial: function polynomial(data, options) {
                var lhs = [];
                var rhs = [];
                var a = 0;
                var b = 0;
                var len = data.length;
                var k = options.order + 1;
                for (var i = 0; i < k; i++) {
                  for (var l = 0; l < len; l++) {
                    if (data[l][1] !== null) {
                      a += Math.pow(data[l][0], i) * data[l][1];
                    }
                  }
                  lhs.push(a);
                  a = 0;
                  var c = [];
                  for (var j = 0; j < k; j++) {
                    for (var _l = 0; _l < len; _l++) {
                      if (data[_l][1] !== null) {
                        b += Math.pow(data[_l][0], i + j);
                      }
                    }
                    c.push(b);
                    b = 0;
                  }
                  rhs.push(c);
                }
                rhs.push(lhs);
                var coefficients = gaussianElimination(rhs, k).map(function(v) {
                  return round(v, options.precision);
                });
                var predict = function predict2(x) {
                  return [round(x, options.precision), round(coefficients.reduce(function(sum, coeff, power) {
                    return sum + coeff * Math.pow(x, power);
                  }, 0), options.precision)];
                };
                var points = data.map(function(point) {
                  return predict(point[0]);
                });
                var string = "y = ";
                for (var _i = coefficients.length - 1; _i >= 0; _i--) {
                  if (_i > 1) {
                    string += coefficients[_i] + "x^" + _i + " + ";
                  } else if (_i === 1) {
                    string += coefficients[_i] + "x + ";
                  } else {
                    string += coefficients[_i];
                  }
                }
                return {
                  string,
                  points,
                  predict,
                  equation: [].concat(_toConsumableArray(coefficients)).reverse(),
                  r2: round(determinationCoefficient(data, points), options.precision)
                };
              }
            };
            function createWrapper() {
              var reduce = function reduce2(accumulator, name) {
                return _extends({
                  _round: round
                }, accumulator, _defineProperty({}, name, function(data, supplied) {
                  return methods[name](data, _extends({}, DEFAULT_OPTIONS, supplied));
                }));
              };
              return Object.keys(methods).reduce(reduce, {});
            }
            module3.exports = createWrapper();
          });
        },
        "./node_modules/_simple-statistics@6.1.1@simple-statistics/dist/simple-statistics.min.js": function(module2, exports2, __webpack_require__) {
          !function(t, r) {
            true ? r(exports2) : void 0;
          }(this, function(t) {
            "use strict";
            function r(t2) {
              if (0 === t2.length)
                return 0;
              for (var r2, n2 = t2[0], e2 = 0, a2 = 1; a2 < t2.length; a2++)
                r2 = n2 + t2[a2], Math.abs(n2) >= Math.abs(t2[a2]) ? e2 += n2 - r2 + t2[a2] : e2 += t2[a2] - r2 + n2, n2 = r2;
              return n2 + e2;
            }
            function g(t2) {
              if (0 === t2.length)
                throw new Error("mean requires at least one data point");
              return r(t2) / t2.length;
            }
            function n(t2, r2) {
              var n2, e2, a2 = g(t2), o2 = 0;
              if (2 === r2)
                for (e2 = 0; e2 < t2.length; e2++)
                  o2 += (n2 = t2[e2] - a2) * n2;
              else
                for (e2 = 0; e2 < t2.length; e2++)
                  o2 += Math.pow(t2[e2] - a2, r2);
              return o2;
            }
            function e(t2) {
              if (0 === t2.length)
                throw new Error("variance requires at least one data point");
              return n(t2, 2) / t2.length;
            }
            function a(t2) {
              if (1 === t2.length)
                return 0;
              var r2 = e(t2);
              return Math.sqrt(r2);
            }
            function o(t2) {
              if (0 === t2.length)
                throw new Error("mode requires at least one data point");
              if (1 === t2.length)
                return t2[0];
              for (var r2 = t2[0], n2 = NaN, e2 = 0, a2 = 1, o2 = 1; o2 < t2.length + 1; o2++)
                t2[o2] !== r2 ? (e2 < a2 && (e2 = a2, n2 = r2), a2 = 1, r2 = t2[o2]) : a2++;
              return n2;
            }
            function f(t2) {
              return t2.slice().sort(function(t3, r2) {
                return t3 - r2;
              });
            }
            function u(t2) {
              if (0 === t2.length)
                throw new Error("min requires at least one data point");
              for (var r2 = t2[0], n2 = 1; n2 < t2.length; n2++)
                t2[n2] < r2 && (r2 = t2[n2]);
              return r2;
            }
            function h(t2) {
              if (0 === t2.length)
                throw new Error("max requires at least one data point");
              for (var r2 = t2[0], n2 = 1; n2 < t2.length; n2++)
                t2[n2] > r2 && (r2 = t2[n2]);
              return r2;
            }
            function i(t2, r2) {
              var n2 = t2.length * r2;
              if (0 === t2.length)
                throw new Error("quantile requires at least one data point.");
              if (r2 < 0 || 1 < r2)
                throw new Error("quantiles must be between 0 and 1");
              return 1 === r2 ? t2[t2.length - 1] : 0 === r2 ? t2[0] : n2 % 1 != 0 ? t2[Math.ceil(n2) - 1] : t2.length % 2 == 0 ? (t2[n2 - 1] + t2[n2]) / 2 : t2[n2];
            }
            function c(t2, r2, n2, e2) {
              for (n2 = n2 || 0, e2 = e2 || t2.length - 1; n2 < e2; ) {
                if (600 < e2 - n2) {
                  var a2 = e2 - n2 + 1, o2 = r2 - n2 + 1, i2 = Math.log(a2), u2 = 0.5 * Math.exp(2 * i2 / 3), h2 = 0.5 * Math.sqrt(i2 * u2 * (a2 - u2) / a2);
                  o2 - a2 / 2 < 0 && (h2 *= -1), c(t2, r2, Math.max(n2, Math.floor(r2 - o2 * u2 / a2 + h2)), Math.min(e2, Math.floor(r2 + (a2 - o2) * u2 / a2 + h2)));
                }
                var f2 = t2[r2], s2 = n2, l2 = e2;
                for (p(t2, n2, r2), t2[e2] > f2 && p(t2, n2, e2); s2 < l2; ) {
                  for (p(t2, s2, l2), s2++, l2--; t2[s2] < f2; )
                    s2++;
                  for (; t2[l2] > f2; )
                    l2--;
                }
                t2[n2] === f2 ? p(t2, n2, l2) : p(t2, ++l2, e2), l2 <= r2 && (n2 = l2 + 1), r2 <= l2 && (e2 = l2 - 1);
              }
            }
            function p(t2, r2, n2) {
              var e2 = t2[r2];
              t2[r2] = t2[n2], t2[n2] = e2;
            }
            function s(t2, r2) {
              var n2 = t2.slice();
              if (Array.isArray(r2)) {
                !function(t3, r3) {
                  for (var n3 = [0], e3 = 0; e3 < r3.length; e3++)
                    n3.push(w(t3.length, r3[e3]));
                  n3.push(t3.length - 1), n3.sort(v);
                  var a3 = [0, n3.length - 1];
                  for (; a3.length; ) {
                    var o2 = Math.ceil(a3.pop()), i2 = Math.floor(a3.pop());
                    if (!(o2 - i2 <= 1)) {
                      var u2 = Math.floor((i2 + o2) / 2);
                      l(t3, n3[u2], n3[i2], n3[o2]), a3.push(i2, u2, u2, o2);
                    }
                  }
                }(n2, r2);
                for (var e2 = [], a2 = 0; a2 < r2.length; a2++)
                  e2[a2] = i(n2, r2[a2]);
                return e2;
              }
              return l(n2, w(n2.length, r2), 0, n2.length - 1), i(n2, r2);
            }
            function l(t2, r2, n2, e2) {
              r2 % 1 == 0 ? c(t2, r2, n2, e2) : (c(t2, r2 = Math.floor(r2), n2, e2), c(t2, r2 + 1, r2 + 1, e2));
            }
            function v(t2, r2) {
              return t2 - r2;
            }
            function w(t2, r2) {
              var n2 = t2 * r2;
              return 1 === r2 ? t2 - 1 : 0 === r2 ? 0 : n2 % 1 != 0 ? Math.ceil(n2) - 1 : t2 % 2 == 0 ? n2 - 0.5 : n2;
            }
            function M(t2, r2) {
              if (r2 < t2[0])
                return 0;
              if (r2 > t2[t2.length - 1])
                return 1;
              var n2 = function(t3, r3) {
                var n3 = 0, e3 = 0, a3 = t3.length;
                for (; e3 < a3; )
                  r3 <= t3[n3 = e3 + a3 >>> 1] ? a3 = n3 : e3 = -~n3;
                return e3;
              }(t2, r2);
              if (t2[n2] !== r2)
                return n2 / t2.length;
              n2++;
              var e2 = function(t3, r3) {
                var n3 = 0, e3 = 0, a3 = t3.length;
                for (; e3 < a3; )
                  r3 >= t3[n3 = e3 + a3 >>> 1] ? e3 = -~n3 : a3 = n3;
                return e3;
              }(t2, r2);
              if (e2 === n2)
                return n2 / t2.length;
              var a2 = e2 - n2 + 1;
              return a2 * (e2 + n2) / 2 / a2 / t2.length;
            }
            function m(t2) {
              var r2 = s(t2, 0.75), n2 = s(t2, 0.25);
              if ("number" == typeof r2 && "number" == typeof n2)
                return r2 - n2;
            }
            function d(t2) {
              return +s(t2, 0.5);
            }
            function b(t2) {
              for (var r2 = d(t2), n2 = [], e2 = 0; e2 < t2.length; e2++)
                n2.push(Math.abs(t2[e2] - r2));
              return d(n2);
            }
            function q(t2, r2) {
              r2 = r2 || Math.random;
              for (var n2, e2, a2 = t2.length; 0 < a2; )
                e2 = Math.floor(r2() * a2--), n2 = t2[a2], t2[a2] = t2[e2], t2[e2] = n2;
              return t2;
            }
            function E(t2, r2) {
              return q(t2.slice().slice(), r2);
            }
            function y(t2) {
              for (var r2, n2 = 0, e2 = 0; e2 < t2.length; e2++)
                0 !== e2 && t2[e2] === r2 || (r2 = t2[e2], n2++);
              return n2;
            }
            function S(t2, r2) {
              for (var n2 = [], e2 = 0; e2 < t2; e2++) {
                for (var a2 = [], o2 = 0; o2 < r2; o2++)
                  a2.push(0);
                n2.push(a2);
              }
              return n2;
            }
            function x(t2, r2, n2, e2) {
              var a2;
              if (0 < t2) {
                var o2 = (n2[r2] - n2[t2 - 1]) / (r2 - t2 + 1);
                a2 = e2[r2] - e2[t2 - 1] - (r2 - t2 + 1) * o2 * o2;
              } else
                a2 = e2[r2] - n2[r2] * n2[r2] / (r2 + 1);
              return a2 < 0 ? 0 : a2;
            }
            function P(t2, r2, n2, e2, a2, o2, i2) {
              if (!(r2 < t2)) {
                var u2 = Math.floor((t2 + r2) / 2);
                e2[n2][u2] = e2[n2 - 1][u2 - 1], a2[n2][u2] = u2;
                var h2 = n2;
                n2 < t2 && (h2 = Math.max(h2, a2[n2][t2 - 1] || 0)), h2 = Math.max(h2, a2[n2 - 1][u2] || 0);
                var f2, s2, l2, c2 = u2 - 1;
                r2 < e2.length - 1 && (c2 = Math.min(c2, a2[n2][r2 + 1] || 0));
                for (var g2 = c2; h2 <= g2 && !((f2 = x(g2, u2, o2, i2)) + e2[n2 - 1][h2 - 1] >= e2[n2][u2]); --g2)
                  (s2 = x(h2, u2, o2, i2) + e2[n2 - 1][h2 - 1]) < e2[n2][u2] && (e2[n2][u2] = s2, a2[n2][u2] = h2), h2++, (l2 = f2 + e2[n2 - 1][g2 - 1]) < e2[n2][u2] && (e2[n2][u2] = l2, a2[n2][u2] = g2);
                P(t2, u2 - 1, n2, e2, a2, o2, i2), P(u2 + 1, r2, n2, e2, a2, o2, i2);
              }
            }
            function k(t2, r2) {
              if (t2.length !== r2.length)
                throw new Error("sampleCovariance requires samples with equal lengths");
              if (t2.length < 2)
                throw new Error("sampleCovariance requires at least two data points in each sample");
              for (var n2 = g(t2), e2 = g(r2), a2 = 0, o2 = 0; o2 < t2.length; o2++)
                a2 += (t2[o2] - n2) * (r2[o2] - e2);
              return a2 / (t2.length - 1);
            }
            function I(t2) {
              if (t2.length < 2)
                throw new Error("sampleVariance requires at least two data points");
              return n(t2, 2) / (t2.length - 1);
            }
            function D(t2) {
              var r2 = I(t2);
              return Math.sqrt(r2);
            }
            function C(t2, r2, n2, e2) {
              return (t2 * r2 + n2 * e2) / (r2 + e2);
            }
            function T(t2) {
              if (0 === t2.length)
                throw new Error("rootMeanSquare requires at least one data point");
              for (var r2 = 0, n2 = 0; n2 < t2.length; n2++)
                r2 += Math.pow(t2[n2], 2);
              return Math.sqrt(r2 / t2.length);
            }
            function _() {
              this.totalCount = 0, this.data = {};
            }
            function F() {
              this.weights = [], this.bias = 0;
            }
            _.prototype.train = function(t2, r2) {
              for (var n2 in this.data[r2] || (this.data[r2] = {}), t2) {
                var e2 = t2[n2];
                void 0 === this.data[r2][n2] && (this.data[r2][n2] = {}), void 0 === this.data[r2][n2][e2] && (this.data[r2][n2][e2] = 0), this.data[r2][n2][e2]++;
              }
              this.totalCount++;
            }, _.prototype.score = function(t2) {
              var r2, n2 = {};
              for (var e2 in t2) {
                var a2 = t2[e2];
                for (r2 in this.data)
                  n2[r2] = {}, this.data[r2][e2] ? n2[r2][e2 + "_" + a2] = (this.data[r2][e2][a2] || 0) / this.totalCount : n2[r2][e2 + "_" + a2] = 0;
              }
              var o2 = {};
              for (r2 in n2)
                for (var i2 in o2[r2] = 0, n2[r2])
                  o2[r2] += n2[r2][i2];
              return o2;
            }, F.prototype.predict = function(t2) {
              if (t2.length !== this.weights.length)
                return null;
              for (var r2 = 0, n2 = 0; n2 < this.weights.length; n2++)
                r2 += this.weights[n2] * t2[n2];
              return 0 < (r2 += this.bias) ? 1 : 0;
            }, F.prototype.train = function(t2, r2) {
              if (0 !== r2 && 1 !== r2)
                return null;
              t2.length !== this.weights.length && (this.weights = t2, this.bias = 1);
              var n2 = this.predict(t2);
              if (n2 !== r2) {
                for (var e2 = r2 - n2, a2 = 0; a2 < this.weights.length; a2++)
                  this.weights[a2] += e2 * t2[a2];
                this.bias += e2;
              }
              return this;
            };
            var N = 1e-4;
            function R(t2) {
              if (t2 < 0)
                throw new Error("factorial requires a non-negative value");
              if (Math.floor(t2) !== t2)
                throw new Error("factorial requires an integer input");
              for (var r2 = 1, n2 = 2; n2 <= t2; n2++)
                r2 *= n2;
              return r2;
            }
            var A = [0.9999999999999971, 57.15623566586292, -59.59796035547549, 14.136097974741746, -0.4919138160976202, 3399464998481189e-20, 4652362892704858e-20, -9837447530487956e-20, 1580887032249125e-19, -21026444172410488e-20, 21743961811521265e-20, -1643181065367639e-19, 8441822398385275e-20, -26190838401581408e-21, 36899182659531625e-22], z = Math.log(Math.sqrt(2 * Math.PI));
            var V = { 1: { 0.995: 0, 0.99: 0, 0.975: 0, 0.95: 0, 0.9: 0.02, 0.5: 0.45, 0.1: 2.71, 0.05: 3.84, 0.025: 5.02, 0.01: 6.63, 5e-3: 7.88 }, 2: { 0.995: 0.01, 0.99: 0.02, 0.975: 0.05, 0.95: 0.1, 0.9: 0.21, 0.5: 1.39, 0.1: 4.61, 0.05: 5.99, 0.025: 7.38, 0.01: 9.21, 5e-3: 10.6 }, 3: { 0.995: 0.07, 0.99: 0.11, 0.975: 0.22, 0.95: 0.35, 0.9: 0.58, 0.5: 2.37, 0.1: 6.25, 0.05: 7.81, 0.025: 9.35, 0.01: 11.34, 5e-3: 12.84 }, 4: { 0.995: 0.21, 0.99: 0.3, 0.975: 0.48, 0.95: 0.71, 0.9: 1.06, 0.5: 3.36, 0.1: 7.78, 0.05: 9.49, 0.025: 11.14, 0.01: 13.28, 5e-3: 14.86 }, 5: { 0.995: 0.41, 0.99: 0.55, 0.975: 0.83, 0.95: 1.15, 0.9: 1.61, 0.5: 4.35, 0.1: 9.24, 0.05: 11.07, 0.025: 12.83, 0.01: 15.09, 5e-3: 16.75 }, 6: { 0.995: 0.68, 0.99: 0.87, 0.975: 1.24, 0.95: 1.64, 0.9: 2.2, 0.5: 5.35, 0.1: 10.65, 0.05: 12.59, 0.025: 14.45, 0.01: 16.81, 5e-3: 18.55 }, 7: { 0.995: 0.99, 0.99: 1.25, 0.975: 1.69, 0.95: 2.17, 0.9: 2.83, 0.5: 6.35, 0.1: 12.02, 0.05: 14.07, 0.025: 16.01, 0.01: 18.48, 5e-3: 20.28 }, 8: { 0.995: 1.34, 0.99: 1.65, 0.975: 2.18, 0.95: 2.73, 0.9: 3.49, 0.5: 7.34, 0.1: 13.36, 0.05: 15.51, 0.025: 17.53, 0.01: 20.09, 5e-3: 21.96 }, 9: { 0.995: 1.73, 0.99: 2.09, 0.975: 2.7, 0.95: 3.33, 0.9: 4.17, 0.5: 8.34, 0.1: 14.68, 0.05: 16.92, 0.025: 19.02, 0.01: 21.67, 5e-3: 23.59 }, 10: { 0.995: 2.16, 0.99: 2.56, 0.975: 3.25, 0.95: 3.94, 0.9: 4.87, 0.5: 9.34, 0.1: 15.99, 0.05: 18.31, 0.025: 20.48, 0.01: 23.21, 5e-3: 25.19 }, 11: { 0.995: 2.6, 0.99: 3.05, 0.975: 3.82, 0.95: 4.57, 0.9: 5.58, 0.5: 10.34, 0.1: 17.28, 0.05: 19.68, 0.025: 21.92, 0.01: 24.72, 5e-3: 26.76 }, 12: { 0.995: 3.07, 0.99: 3.57, 0.975: 4.4, 0.95: 5.23, 0.9: 6.3, 0.5: 11.34, 0.1: 18.55, 0.05: 21.03, 0.025: 23.34, 0.01: 26.22, 5e-3: 28.3 }, 13: { 0.995: 3.57, 0.99: 4.11, 0.975: 5.01, 0.95: 5.89, 0.9: 7.04, 0.5: 12.34, 0.1: 19.81, 0.05: 22.36, 0.025: 24.74, 0.01: 27.69, 5e-3: 29.82 }, 14: { 0.995: 4.07, 0.99: 4.66, 0.975: 5.63, 0.95: 6.57, 0.9: 7.79, 0.5: 13.34, 0.1: 21.06, 0.05: 23.68, 0.025: 26.12, 0.01: 29.14, 5e-3: 31.32 }, 15: { 0.995: 4.6, 0.99: 5.23, 0.975: 6.27, 0.95: 7.26, 0.9: 8.55, 0.5: 14.34, 0.1: 22.31, 0.05: 25, 0.025: 27.49, 0.01: 30.58, 5e-3: 32.8 }, 16: { 0.995: 5.14, 0.99: 5.81, 0.975: 6.91, 0.95: 7.96, 0.9: 9.31, 0.5: 15.34, 0.1: 23.54, 0.05: 26.3, 0.025: 28.85, 0.01: 32, 5e-3: 34.27 }, 17: { 0.995: 5.7, 0.99: 6.41, 0.975: 7.56, 0.95: 8.67, 0.9: 10.09, 0.5: 16.34, 0.1: 24.77, 0.05: 27.59, 0.025: 30.19, 0.01: 33.41, 5e-3: 35.72 }, 18: { 0.995: 6.26, 0.99: 7.01, 0.975: 8.23, 0.95: 9.39, 0.9: 10.87, 0.5: 17.34, 0.1: 25.99, 0.05: 28.87, 0.025: 31.53, 0.01: 34.81, 5e-3: 37.16 }, 19: { 0.995: 6.84, 0.99: 7.63, 0.975: 8.91, 0.95: 10.12, 0.9: 11.65, 0.5: 18.34, 0.1: 27.2, 0.05: 30.14, 0.025: 32.85, 0.01: 36.19, 5e-3: 38.58 }, 20: { 0.995: 7.43, 0.99: 8.26, 0.975: 9.59, 0.95: 10.85, 0.9: 12.44, 0.5: 19.34, 0.1: 28.41, 0.05: 31.41, 0.025: 34.17, 0.01: 37.57, 5e-3: 40 }, 21: { 0.995: 8.03, 0.99: 8.9, 0.975: 10.28, 0.95: 11.59, 0.9: 13.24, 0.5: 20.34, 0.1: 29.62, 0.05: 32.67, 0.025: 35.48, 0.01: 38.93, 5e-3: 41.4 }, 22: { 0.995: 8.64, 0.99: 9.54, 0.975: 10.98, 0.95: 12.34, 0.9: 14.04, 0.5: 21.34, 0.1: 30.81, 0.05: 33.92, 0.025: 36.78, 0.01: 40.29, 5e-3: 42.8 }, 23: { 0.995: 9.26, 0.99: 10.2, 0.975: 11.69, 0.95: 13.09, 0.9: 14.85, 0.5: 22.34, 0.1: 32.01, 0.05: 35.17, 0.025: 38.08, 0.01: 41.64, 5e-3: 44.18 }, 24: { 0.995: 9.89, 0.99: 10.86, 0.975: 12.4, 0.95: 13.85, 0.9: 15.66, 0.5: 23.34, 0.1: 33.2, 0.05: 36.42, 0.025: 39.36, 0.01: 42.98, 5e-3: 45.56 }, 25: { 0.995: 10.52, 0.99: 11.52, 0.975: 13.12, 0.95: 14.61, 0.9: 16.47, 0.5: 24.34, 0.1: 34.28, 0.05: 37.65, 0.025: 40.65, 0.01: 44.31, 5e-3: 46.93 }, 26: { 0.995: 11.16, 0.99: 12.2, 0.975: 13.84, 0.95: 15.38, 0.9: 17.29, 0.5: 25.34, 0.1: 35.56, 0.05: 38.89, 0.025: 41.92, 0.01: 45.64, 5e-3: 48.29 }, 27: { 0.995: 11.81, 0.99: 12.88, 0.975: 14.57, 0.95: 16.15, 0.9: 18.11, 0.5: 26.34, 0.1: 36.74, 0.05: 40.11, 0.025: 43.19, 0.01: 46.96, 5e-3: 49.65 }, 28: { 0.995: 12.46, 0.99: 13.57, 0.975: 15.31, 0.95: 16.93, 0.9: 18.94, 0.5: 27.34, 0.1: 37.92, 0.05: 41.34, 0.025: 44.46, 0.01: 48.28, 5e-3: 50.99 }, 29: { 0.995: 13.12, 0.99: 14.26, 0.975: 16.05, 0.95: 17.71, 0.9: 19.77, 0.5: 28.34, 0.1: 39.09, 0.05: 42.56, 0.025: 45.72, 0.01: 49.59, 5e-3: 52.34 }, 30: { 0.995: 13.79, 0.99: 14.95, 0.975: 16.79, 0.95: 18.49, 0.9: 20.6, 0.5: 29.34, 0.1: 40.26, 0.05: 43.77, 0.025: 46.98, 0.01: 50.89, 5e-3: 53.67 }, 40: { 0.995: 20.71, 0.99: 22.16, 0.975: 24.43, 0.95: 26.51, 0.9: 29.05, 0.5: 39.34, 0.1: 51.81, 0.05: 55.76, 0.025: 59.34, 0.01: 63.69, 5e-3: 66.77 }, 50: { 0.995: 27.99, 0.99: 29.71, 0.975: 32.36, 0.95: 34.76, 0.9: 37.69, 0.5: 49.33, 0.1: 63.17, 0.05: 67.5, 0.025: 71.42, 0.01: 76.15, 5e-3: 79.49 }, 60: { 0.995: 35.53, 0.99: 37.48, 0.975: 40.48, 0.95: 43.19, 0.9: 46.46, 0.5: 59.33, 0.1: 74.4, 0.05: 79.08, 0.025: 83.3, 0.01: 88.38, 5e-3: 91.95 }, 70: { 0.995: 43.28, 0.99: 45.44, 0.975: 48.76, 0.95: 51.74, 0.9: 55.33, 0.5: 69.33, 0.1: 85.53, 0.05: 90.53, 0.025: 95.02, 0.01: 100.42, 5e-3: 104.22 }, 80: { 0.995: 51.17, 0.99: 53.54, 0.975: 57.15, 0.95: 60.39, 0.9: 64.28, 0.5: 79.33, 0.1: 96.58, 0.05: 101.88, 0.025: 106.63, 0.01: 112.33, 5e-3: 116.32 }, 90: { 0.995: 59.2, 0.99: 61.75, 0.975: 65.65, 0.95: 69.13, 0.9: 73.29, 0.5: 89.33, 0.1: 107.57, 0.05: 113.14, 0.025: 118.14, 0.01: 124.12, 5e-3: 128.3 }, 100: { 0.995: 67.33, 0.99: 70.06, 0.975: 74.22, 0.95: 77.93, 0.9: 82.36, 0.5: 99.33, 0.1: 118.5, 0.05: 124.34, 0.025: 129.56, 0.01: 135.81, 5e-3: 140.17 } };
            var j = Math.sqrt(2 * Math.PI), B = { gaussian: function(t2) {
              return Math.exp(-0.5 * t2 * t2) / j;
            } }, K = { nrd: function(t2) {
              var r2 = D(t2), n2 = m(t2);
              return "number" == typeof n2 && (r2 = Math.min(r2, n2 / 1.34)), 1.06 * r2 * Math.pow(t2.length, -0.2);
            } };
            function O(e2, t2, r2) {
              var a2, o2;
              if (void 0 === t2)
                a2 = B.gaussian;
              else if ("string" == typeof t2) {
                if (!B[t2])
                  throw new Error('Unknown kernel "' + t2 + '"');
                a2 = B[t2];
              } else
                a2 = t2;
              if (void 0 === r2)
                o2 = K.nrd(e2);
              else if ("string" == typeof r2) {
                if (!K[r2])
                  throw new Error('Unknown bandwidth method "' + r2 + '"');
                o2 = K[r2](e2);
              } else
                o2 = r2;
              return function(t3) {
                var r3 = 0, n2 = 0;
                for (r3 = 0; r3 < e2.length; r3++)
                  n2 += a2((t3 - e2[r3]) / o2);
                return n2 / o2 / e2.length;
              };
            }
            var U = Math.sqrt(2 * Math.PI);
            function G(t2) {
              for (var r2 = t2, n2 = t2, e2 = 1; e2 < 15; e2++)
                r2 += n2 *= t2 * t2 / (2 * e2 + 1);
              return Math.round(1e4 * (0.5 + r2 / U * Math.exp(-t2 * t2 / 2))) / 1e4;
            }
            for (var H = [], L = 0; L <= 3.09; L += 0.01)
              H.push(G(L));
            function W(t2) {
              var r2 = 1 / (1 + 0.5 * Math.abs(t2)), n2 = r2 * Math.exp(-Math.pow(t2, 2) - 1.26551223 + 1.00002368 * r2 + 0.37409196 * Math.pow(r2, 2) + 0.09678418 * Math.pow(r2, 3) - 0.18628806 * Math.pow(r2, 4) + 0.27886807 * Math.pow(r2, 5) - 1.13520398 * Math.pow(r2, 6) + 1.48851587 * Math.pow(r2, 7) - 0.82215223 * Math.pow(r2, 8) + 0.17087277 * Math.pow(r2, 9));
              return 0 <= t2 ? 1 - n2 : n2 - 1;
            }
            function J(t2) {
              var r2 = 8 * (Math.PI - 3) / (3 * Math.PI * (4 - Math.PI)), n2 = Math.sqrt(Math.sqrt(Math.pow(2 / (Math.PI * r2) + Math.log(1 - t2 * t2) / 2, 2) - Math.log(1 - t2 * t2) / r2) - (2 / (Math.PI * r2) + Math.log(1 - t2 * t2) / 2));
              return 0 <= t2 ? n2 : -n2;
            }
            function Q(t2) {
              if ("number" == typeof t2)
                return t2 < 0 ? -1 : 0 === t2 ? 0 : 1;
              throw new TypeError("not a number");
            }
            t.linearRegression = function(t2) {
              var r2, n2, e2 = t2.length;
              if (1 === e2)
                n2 = t2[r2 = 0][1];
              else {
                for (var a2, o2, i2, u2 = 0, h2 = 0, f2 = 0, s2 = 0, l2 = 0; l2 < e2; l2++)
                  u2 += o2 = (a2 = t2[l2])[0], h2 += i2 = a2[1], f2 += o2 * o2, s2 += o2 * i2;
                n2 = h2 / e2 - (r2 = (e2 * s2 - u2 * h2) / (e2 * f2 - u2 * u2)) * u2 / e2;
              }
              return { m: r2, b: n2 };
            }, t.linearRegressionLine = function(r2) {
              return function(t2) {
                return r2.b + r2.m * t2;
              };
            }, t.standardDeviation = a, t.rSquared = function(t2, r2) {
              if (t2.length < 2)
                return 1;
              for (var n2, e2 = 0, a2 = 0; a2 < t2.length; a2++)
                e2 += t2[a2][1];
              n2 = e2 / t2.length;
              for (var o2 = 0, i2 = 0; i2 < t2.length; i2++)
                o2 += Math.pow(n2 - t2[i2][1], 2);
              for (var u2 = 0, h2 = 0; h2 < t2.length; h2++)
                u2 += Math.pow(t2[h2][1] - r2(t2[h2][0]), 2);
              return 1 - u2 / o2;
            }, t.mode = function(t2) {
              return o(f(t2));
            }, t.modeFast = function(t2) {
              for (var r2, n2 = /* @__PURE__ */ new Map(), e2 = 0, a2 = 0; a2 < t2.length; a2++) {
                var o2 = n2.get(t2[a2]);
                void 0 === o2 ? o2 = 1 : o2++, e2 < o2 && (r2 = t2[a2], e2 = o2), n2.set(t2[a2], o2);
              }
              if (0 === e2)
                throw new Error("mode requires at last one data point");
              return r2;
            }, t.modeSorted = o, t.min = u, t.max = h, t.extent = function(t2) {
              if (0 === t2.length)
                throw new Error("extent requires at least one data point");
              for (var r2 = t2[0], n2 = t2[0], e2 = 1; e2 < t2.length; e2++)
                t2[e2] > n2 && (n2 = t2[e2]), t2[e2] < r2 && (r2 = t2[e2]);
              return [r2, n2];
            }, t.minSorted = function(t2) {
              return t2[0];
            }, t.maxSorted = function(t2) {
              return t2[t2.length - 1];
            }, t.extentSorted = function(t2) {
              return [t2[0], t2[t2.length - 1]];
            }, t.sum = r, t.sumSimple = function(t2) {
              for (var r2 = 0, n2 = 0; n2 < t2.length; n2++)
                r2 += t2[n2];
              return r2;
            }, t.product = function(t2) {
              for (var r2 = 1, n2 = 0; n2 < t2.length; n2++)
                r2 *= t2[n2];
              return r2;
            }, t.quantile = s, t.quantileSorted = i, t.quantileRank = function(t2, r2) {
              return M(f(t2), r2);
            }, t.quantileRankSorted = M, t.interquartileRange = m, t.iqr = m, t.medianAbsoluteDeviation = b, t.mad = b, t.chunk = function(t2, r2) {
              var n2 = [];
              if (r2 < 1)
                throw new Error("chunk size must be a positive number");
              if (Math.floor(r2) !== r2)
                throw new Error("chunk size must be an integer");
              for (var e2 = 0; e2 < t2.length; e2 += r2)
                n2.push(t2.slice(e2, e2 + r2));
              return n2;
            }, t.sampleWithReplacement = function(t2, r2, n2) {
              if (0 === t2.length)
                return [];
              n2 = n2 || Math.random;
              for (var e2 = t2.length, a2 = [], o2 = 0; o2 < r2; o2++) {
                var i2 = Math.floor(n2() * e2);
                a2.push(t2[i2]);
              }
              return a2;
            }, t.shuffle = E, t.shuffleInPlace = q, t.sample = function(t2, r2, n2) {
              return E(t2, n2).slice(0, r2);
            }, t.ckmeans = function(t2, r2) {
              if (r2 > t2.length)
                throw new Error("cannot generate more classes than there are data values");
              var n2 = f(t2);
              if (1 === y(n2))
                return [n2];
              var e2 = S(r2, n2.length), a2 = S(r2, n2.length);
              !function(t3, r3, n3) {
                for (var e3, a3 = r3[0].length, o3 = t3[Math.floor(a3 / 2)], i3 = [], u3 = [], h3 = 0; h3 < a3; ++h3)
                  e3 = t3[h3] - o3, 0 === h3 ? (i3.push(e3), u3.push(e3 * e3)) : (i3.push(i3[h3 - 1] + e3), u3.push(u3[h3 - 1] + e3 * e3)), r3[0][h3] = x(0, h3, i3, u3), n3[0][h3] = 0;
                for (var f2 = 1; f2 < r3.length; ++f2)
                  P(f2 < r3.length - 1 ? f2 : a3 - 1, a3 - 1, f2, r3, n3, i3, u3);
              }(n2, e2, a2);
              for (var o2 = [], i2 = a2[0].length - 1, u2 = a2.length - 1; 0 <= u2; u2--) {
                var h2 = a2[u2][i2];
                o2[u2] = n2.slice(h2, i2 + 1), 0 < u2 && (i2 = h2 - 1);
              }
              return o2;
            }, t.uniqueCountSorted = y, t.sumNthPowerDeviations = n, t.equalIntervalBreaks = function(t2, r2) {
              if (t2.length < 2)
                return t2;
              for (var n2 = u(t2), e2 = h(t2), a2 = [n2], o2 = (e2 - n2) / r2, i2 = 1; i2 < r2; i2++)
                a2.push(a2[0] + o2 * i2);
              return a2.push(e2), a2;
            }, t.sampleCovariance = k, t.sampleCorrelation = function(t2, r2) {
              return k(t2, r2) / D(t2) / D(r2);
            }, t.sampleVariance = I, t.sampleStandardDeviation = D, t.sampleSkewness = function(t2) {
              if (t2.length < 3)
                throw new Error("sampleSkewness requires at least three data points");
              for (var r2, n2 = g(t2), e2 = 0, a2 = 0, o2 = 0; o2 < t2.length; o2++)
                e2 += (r2 = t2[o2] - n2) * r2, a2 += r2 * r2 * r2;
              var i2 = t2.length - 1, u2 = Math.sqrt(e2 / i2), h2 = t2.length;
              return h2 * a2 / ((h2 - 1) * (h2 - 2) * Math.pow(u2, 3));
            }, t.sampleKurtosis = function(t2) {
              var r2 = t2.length;
              if (r2 < 4)
                throw new Error("sampleKurtosis requires at least four data points");
              for (var n2, e2 = g(t2), a2 = 0, o2 = 0, i2 = 0; i2 < r2; i2++)
                a2 += (n2 = t2[i2] - e2) * n2, o2 += n2 * n2 * n2 * n2;
              return (r2 - 1) / ((r2 - 2) * (r2 - 3)) * (r2 * (r2 + 1) * o2 / (a2 * a2) - 3 * (r2 - 1));
            }, t.permutationsHeap = function(t2) {
              for (var r2 = new Array(t2.length), n2 = [t2.slice()], e2 = 0; e2 < t2.length; e2++)
                r2[e2] = 0;
              for (e2 = 0; e2 < t2.length; )
                if (r2[e2] < e2) {
                  var a2 = 0;
                  e2 % 2 != 0 && (a2 = r2[e2]);
                  var o2 = t2[a2];
                  t2[a2] = t2[e2], t2[e2] = o2, n2.push(t2.slice()), r2[e2]++, e2 = 0;
                } else
                  r2[e2] = 0, e2++;
              return n2;
            }, t.combinations = function t2(r2, n2) {
              var e2, a2, o2, i2, u2 = [];
              for (e2 = 0; e2 < r2.length; e2++)
                if (1 === n2)
                  u2.push([r2[e2]]);
                else
                  for (o2 = t2(r2.slice(e2 + 1, r2.length), n2 - 1), a2 = 0; a2 < o2.length; a2++)
                    (i2 = o2[a2]).unshift(r2[e2]), u2.push(i2);
              return u2;
            }, t.combinationsReplacement = function t2(r2, n2) {
              for (var e2 = [], a2 = 0; a2 < r2.length; a2++)
                if (1 === n2)
                  e2.push([r2[a2]]);
                else
                  for (var o2 = t2(r2.slice(a2, r2.length), n2 - 1), i2 = 0; i2 < o2.length; i2++)
                    e2.push([r2[a2]].concat(o2[i2]));
              return e2;
            }, t.addToMean = function(t2, r2, n2) {
              return t2 + (n2 - t2) / (r2 + 1);
            }, t.combineMeans = C, t.combineVariances = function(t2, r2, n2, e2, a2, o2) {
              var i2 = C(r2, n2, a2, o2);
              return (n2 * (t2 + Math.pow(r2 - i2, 2)) + o2 * (e2 + Math.pow(a2 - i2, 2))) / (n2 + o2);
            }, t.geometricMean = function(t2) {
              if (0 === t2.length)
                throw new Error("geometricMean requires at least one data point");
              for (var r2 = 1, n2 = 0; n2 < t2.length; n2++) {
                if (t2[n2] <= 0)
                  throw new Error("geometricMean requires only positive numbers as input");
                r2 *= t2[n2];
              }
              return Math.pow(r2, 1 / t2.length);
            }, t.harmonicMean = function(t2) {
              if (0 === t2.length)
                throw new Error("harmonicMean requires at least one data point");
              for (var r2 = 0, n2 = 0; n2 < t2.length; n2++) {
                if (t2[n2] <= 0)
                  throw new Error("harmonicMean requires only positive numbers as input");
                r2 += 1 / t2[n2];
              }
              return t2.length / r2;
            }, t.average = g, t.mean = g, t.median = d, t.medianSorted = function(t2) {
              return i(t2, 0.5);
            }, t.subtractFromMean = function(t2, r2, n2) {
              return (t2 * r2 - n2) / (r2 - 1);
            }, t.rootMeanSquare = T, t.rms = T, t.variance = e, t.tTest = function(t2, r2) {
              return (g(t2) - r2) / (a(t2) / Math.sqrt(t2.length));
            }, t.tTestTwoSample = function(t2, r2, n2) {
              var e2 = t2.length, a2 = r2.length;
              if (!e2 || !a2)
                return null;
              n2 || (n2 = 0);
              var o2 = g(t2), i2 = g(r2), u2 = I(t2), h2 = I(r2);
              if ("number" == typeof o2 && "number" == typeof i2 && "number" == typeof u2 && "number" == typeof h2) {
                var f2 = ((e2 - 1) * u2 + (a2 - 1) * h2) / (e2 + a2 - 2);
                return (o2 - i2 - n2) / Math.sqrt(f2 * (1 / e2 + 1 / a2));
              }
            }, t.BayesianClassifier = _, t.bayesian = _, t.PerceptronModel = F, t.perceptron = F, t.epsilon = N, t.factorial = R, t.gamma = function t2(r2) {
              if ("number" == typeof (n2 = r2) && isFinite(n2) && Math.floor(n2) === n2)
                return r2 <= 0 ? NaN : R(r2 - 1);
              var n2;
              if (--r2 < 0)
                return Math.PI / (Math.sin(Math.PI * -r2) * t2(-r2));
              var e2 = r2 + 0.25;
              return Math.pow(r2 / Math.E, r2) * Math.sqrt(2 * Math.PI * (r2 + 1 / 6)) * (1 + 1 / 144 / Math.pow(e2, 2) - 1 / 12960 / Math.pow(e2, 3) - 257 / 207360 / Math.pow(e2, 4) - 52 / 2612736 / Math.pow(e2, 5) + 5741173 / 9405849600 / Math.pow(e2, 6) + 37529 / 18811699200 / Math.pow(e2, 7));
            }, t.gammaln = function(t2) {
              if (t2 <= 0)
                return 1 / 0;
              t2--;
              for (var r2 = A[0], n2 = 1; n2 < 15; n2++)
                r2 += A[n2] / (t2 + n2);
              var e2 = 5.2421875 + t2;
              return z + Math.log(r2) - e2 + (t2 + 0.5) * Math.log(e2);
            }, t.bernoulliDistribution = function(t2) {
              if (t2 < 0 || 1 < t2)
                throw new Error("bernoulliDistribution requires probability to be between 0 and 1 inclusive");
              return [1 - t2, t2];
            }, t.binomialDistribution = function(t2, r2) {
              if (!(r2 < 0 || 1 < r2 || t2 <= 0 || t2 % 1 != 0)) {
                for (var n2 = 0, e2 = 0, a2 = [], o2 = 1; a2[n2] = o2 * Math.pow(r2, n2) * Math.pow(1 - r2, t2 - n2), e2 += a2[n2], o2 = o2 * (t2 - ++n2 + 1) / n2, e2 < 1 - N; )
                  ;
                return a2;
              }
            }, t.poissonDistribution = function(t2) {
              if (!(t2 <= 0)) {
                for (var r2 = 0, n2 = 0, e2 = [], a2 = 1; e2[r2] = Math.exp(-t2) * Math.pow(t2, r2) / a2, n2 += e2[r2], a2 *= ++r2, n2 < 1 - N; )
                  ;
                return e2;
              }
            }, t.chiSquaredDistributionTable = V, t.chiSquaredGoodnessOfFit = function(t2, r2, n2) {
              for (var e2, a2, o2 = 0, i2 = r2(g(t2)), u2 = [], h2 = [], f2 = 0; f2 < t2.length; f2++)
                void 0 === u2[t2[f2]] && (u2[t2[f2]] = 0), u2[t2[f2]]++;
              for (f2 = 0; f2 < u2.length; f2++)
                void 0 === u2[f2] && (u2[f2] = 0);
              for (a2 in i2)
                a2 in u2 && (h2[+a2] = i2[a2] * t2.length);
              for (a2 = h2.length - 1; 0 <= a2; a2--)
                h2[a2] < 3 && (h2[a2 - 1] += h2[a2], h2.pop(), u2[a2 - 1] += u2[a2], u2.pop());
              for (a2 = 0; a2 < u2.length; a2++)
                o2 += Math.pow(u2[a2] - h2[a2], 2) / h2[a2];
              return e2 = u2.length - 1 - 1, V[e2][n2] < o2;
            }, t.kernelDensityEstimation = O, t.kde = O, t.zScore = function(t2, r2, n2) {
              return (t2 - r2) / n2;
            }, t.cumulativeStdNormalProbability = function(t2) {
              var r2 = Math.abs(t2), n2 = Math.min(Math.round(100 * r2), H.length - 1);
              return 0 <= t2 ? H[n2] : +(1 - H[n2]).toFixed(4);
            }, t.standardNormalTable = H, t.errorFunction = W, t.erf = W, t.inverseErrorFunction = J, t.probit = function(t2) {
              return 0 === t2 ? t2 = N : 1 <= t2 && (t2 = 1 - N), Math.sqrt(2) * J(2 * t2 - 1);
            }, t.permutationTest = function(t2, r2, n2, e2) {
              if (void 0 === e2 && (e2 = 1e4), void 0 === n2 && (n2 = "two_side"), "two_side" !== n2 && "greater" !== n2 && "less" !== n2)
                throw new Error("`alternative` must be either 'two_side', 'greater', or 'less'");
              for (var a2 = g(t2) - g(r2), o2 = new Array(e2), i2 = t2.concat(r2), u2 = Math.floor(i2.length / 2), h2 = 0; h2 < e2; h2++) {
                q(i2);
                var f2 = i2.slice(0, u2), s2 = i2.slice(u2, i2.length), l2 = g(f2) - g(s2);
                o2[h2] = l2;
              }
              var c2 = 0;
              if ("two_side" === n2)
                for (h2 = 0; h2 <= e2; h2++)
                  Math.abs(o2[h2]) >= Math.abs(a2) && (c2 += 1);
              else if ("greater" === n2)
                for (h2 = 0; h2 <= e2; h2++)
                  o2[h2] >= a2 && (c2 += 1);
              else
                for (h2 = 0; h2 <= e2; h2++)
                  o2[h2] <= a2 && (c2 += 1);
              return c2 / e2;
            }, t.bisect = function(t2, r2, n2, e2, a2) {
              if ("function" != typeof t2)
                throw new TypeError("func must be a function");
              for (var o2 = 0; o2 < e2; o2++) {
                var i2 = (r2 + n2) / 2;
                if (0 === t2(i2) || Math.abs((n2 - r2) / 2) < a2)
                  return i2;
                Q(t2(i2)) === Q(t2(r2)) ? r2 = i2 : n2 = i2;
              }
              throw new Error("maximum number of iterations exceeded");
            }, t.quickselect = c, t.sign = Q, t.numericSort = f, Object.defineProperty(t, "__esModule", { value: true });
          });
        },
        "./node_modules/_topojson-client@3.1.0@topojson-client/dist/topojson-client.js": function(module2, exports2, __webpack_require__) {
          (function(global, factory) {
            true ? factory(exports2) : void 0;
          })(this, function(exports3) {
            "use strict";
            function identity(x) {
              return x;
            }
            function transform(transform2) {
              if (transform2 == null)
                return identity;
              var x0, y0, kx = transform2.scale[0], ky = transform2.scale[1], dx = transform2.translate[0], dy = transform2.translate[1];
              return function(input, i) {
                if (!i)
                  x0 = y0 = 0;
                var j = 2, n = input.length, output = new Array(n);
                output[0] = (x0 += input[0]) * kx + dx;
                output[1] = (y0 += input[1]) * ky + dy;
                while (j < n)
                  output[j] = input[j], ++j;
                return output;
              };
            }
            function bbox(topology) {
              var t = transform(topology.transform), key, x0 = Infinity, y0 = x0, x1 = -x0, y1 = -x0;
              function bboxPoint(p) {
                p = t(p);
                if (p[0] < x0)
                  x0 = p[0];
                if (p[0] > x1)
                  x1 = p[0];
                if (p[1] < y0)
                  y0 = p[1];
                if (p[1] > y1)
                  y1 = p[1];
              }
              function bboxGeometry(o) {
                switch (o.type) {
                  case "GeometryCollection":
                    o.geometries.forEach(bboxGeometry);
                    break;
                  case "Point":
                    bboxPoint(o.coordinates);
                    break;
                  case "MultiPoint":
                    o.coordinates.forEach(bboxPoint);
                    break;
                }
              }
              topology.arcs.forEach(function(arc) {
                var i = -1, n = arc.length, p;
                while (++i < n) {
                  p = t(arc[i], i);
                  if (p[0] < x0)
                    x0 = p[0];
                  if (p[0] > x1)
                    x1 = p[0];
                  if (p[1] < y0)
                    y0 = p[1];
                  if (p[1] > y1)
                    y1 = p[1];
                }
              });
              for (key in topology.objects) {
                bboxGeometry(topology.objects[key]);
              }
              return [x0, y0, x1, y1];
            }
            function reverse(array, n) {
              var t, j = array.length, i = j - n;
              while (i < --j)
                t = array[i], array[i++] = array[j], array[j] = t;
            }
            function feature(topology, o) {
              if (typeof o === "string")
                o = topology.objects[o];
              return o.type === "GeometryCollection" ? { type: "FeatureCollection", features: o.geometries.map(function(o2) {
                return feature$1(topology, o2);
              }) } : feature$1(topology, o);
            }
            function feature$1(topology, o) {
              var id = o.id, bbox2 = o.bbox, properties = o.properties == null ? {} : o.properties, geometry = object(topology, o);
              return id == null && bbox2 == null ? { type: "Feature", properties, geometry } : bbox2 == null ? { type: "Feature", id, properties, geometry } : { type: "Feature", id, bbox: bbox2, properties, geometry };
            }
            function object(topology, o) {
              var transformPoint = transform(topology.transform), arcs = topology.arcs;
              function arc(i, points) {
                if (points.length)
                  points.pop();
                for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {
                  points.push(transformPoint(a[k], k));
                }
                if (i < 0)
                  reverse(points, n);
              }
              function point(p) {
                return transformPoint(p);
              }
              function line(arcs2) {
                var points = [];
                for (var i = 0, n = arcs2.length; i < n; ++i)
                  arc(arcs2[i], points);
                if (points.length < 2)
                  points.push(points[0]);
                return points;
              }
              function ring(arcs2) {
                var points = line(arcs2);
                while (points.length < 4)
                  points.push(points[0]);
                return points;
              }
              function polygon(arcs2) {
                return arcs2.map(ring);
              }
              function geometry(o2) {
                var type = o2.type, coordinates;
                switch (type) {
                  case "GeometryCollection":
                    return { type, geometries: o2.geometries.map(geometry) };
                  case "Point":
                    coordinates = point(o2.coordinates);
                    break;
                  case "MultiPoint":
                    coordinates = o2.coordinates.map(point);
                    break;
                  case "LineString":
                    coordinates = line(o2.arcs);
                    break;
                  case "MultiLineString":
                    coordinates = o2.arcs.map(line);
                    break;
                  case "Polygon":
                    coordinates = polygon(o2.arcs);
                    break;
                  case "MultiPolygon":
                    coordinates = o2.arcs.map(polygon);
                    break;
                  default:
                    return null;
                }
                return { type, coordinates };
              }
              return geometry(o);
            }
            function stitch(topology, arcs) {
              var stitchedArcs = {}, fragmentByStart = {}, fragmentByEnd = {}, fragments = [], emptyIndex = -1;
              arcs.forEach(function(i, j) {
                var arc = topology.arcs[i < 0 ? ~i : i], t;
                if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {
                  t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
                }
              });
              arcs.forEach(function(i) {
                var e = ends(i), start = e[0], end = e[1], f, g;
                if (f = fragmentByEnd[start]) {
                  delete fragmentByEnd[f.end];
                  f.push(i);
                  f.end = end;
                  if (g = fragmentByStart[end]) {
                    delete fragmentByStart[g.start];
                    var fg = g === f ? f : f.concat(g);
                    fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
                  } else {
                    fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
                  }
                } else if (f = fragmentByStart[end]) {
                  delete fragmentByStart[f.start];
                  f.unshift(i);
                  f.start = start;
                  if (g = fragmentByEnd[start]) {
                    delete fragmentByEnd[g.end];
                    var gf = g === f ? f : g.concat(f);
                    fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
                  } else {
                    fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
                  }
                } else {
                  f = [i];
                  fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
                }
              });
              function ends(i) {
                var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;
                if (topology.transform)
                  p1 = [0, 0], arc.forEach(function(dp) {
                    p1[0] += dp[0], p1[1] += dp[1];
                  });
                else
                  p1 = arc[arc.length - 1];
                return i < 0 ? [p1, p0] : [p0, p1];
              }
              function flush(fragmentByEnd2, fragmentByStart2) {
                for (var k in fragmentByEnd2) {
                  var f = fragmentByEnd2[k];
                  delete fragmentByStart2[f.start];
                  delete f.start;
                  delete f.end;
                  f.forEach(function(i) {
                    stitchedArcs[i < 0 ? ~i : i] = 1;
                  });
                  fragments.push(f);
                }
              }
              flush(fragmentByEnd, fragmentByStart);
              flush(fragmentByStart, fragmentByEnd);
              arcs.forEach(function(i) {
                if (!stitchedArcs[i < 0 ? ~i : i])
                  fragments.push([i]);
              });
              return fragments;
            }
            function mesh(topology) {
              return object(topology, meshArcs.apply(this, arguments));
            }
            function meshArcs(topology, object2, filter) {
              var arcs, i, n;
              if (arguments.length > 1)
                arcs = extractArcs(topology, object2, filter);
              else
                for (i = 0, arcs = new Array(n = topology.arcs.length); i < n; ++i)
                  arcs[i] = i;
              return { type: "MultiLineString", arcs: stitch(topology, arcs) };
            }
            function extractArcs(topology, object2, filter) {
              var arcs = [], geomsByArc = [], geom;
              function extract0(i) {
                var j = i < 0 ? ~i : i;
                (geomsByArc[j] || (geomsByArc[j] = [])).push({ i, g: geom });
              }
              function extract1(arcs2) {
                arcs2.forEach(extract0);
              }
              function extract2(arcs2) {
                arcs2.forEach(extract1);
              }
              function extract3(arcs2) {
                arcs2.forEach(extract2);
              }
              function geometry(o) {
                switch (geom = o, o.type) {
                  case "GeometryCollection":
                    o.geometries.forEach(geometry);
                    break;
                  case "LineString":
                    extract1(o.arcs);
                    break;
                  case "MultiLineString":
                  case "Polygon":
                    extract2(o.arcs);
                    break;
                  case "MultiPolygon":
                    extract3(o.arcs);
                    break;
                }
              }
              geometry(object2);
              geomsByArc.forEach(filter == null ? function(geoms) {
                arcs.push(geoms[0].i);
              } : function(geoms) {
                if (filter(geoms[0].g, geoms[geoms.length - 1].g))
                  arcs.push(geoms[0].i);
              });
              return arcs;
            }
            function planarRingArea(ring) {
              var i = -1, n = ring.length, a, b = ring[n - 1], area = 0;
              while (++i < n)
                a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];
              return Math.abs(area);
            }
            function merge(topology) {
              return object(topology, mergeArcs.apply(this, arguments));
            }
            function mergeArcs(topology, objects) {
              var polygonsByArc = {}, polygons = [], groups = [];
              objects.forEach(geometry);
              function geometry(o) {
                switch (o.type) {
                  case "GeometryCollection":
                    o.geometries.forEach(geometry);
                    break;
                  case "Polygon":
                    extract(o.arcs);
                    break;
                  case "MultiPolygon":
                    o.arcs.forEach(extract);
                    break;
                }
              }
              function extract(polygon) {
                polygon.forEach(function(ring) {
                  ring.forEach(function(arc) {
                    (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);
                  });
                });
                polygons.push(polygon);
              }
              function area(ring) {
                return planarRingArea(object(topology, { type: "Polygon", arcs: [ring] }).coordinates[0]);
              }
              polygons.forEach(function(polygon) {
                if (!polygon._) {
                  var group = [], neighbors2 = [polygon];
                  polygon._ = 1;
                  groups.push(group);
                  while (polygon = neighbors2.pop()) {
                    group.push(polygon);
                    polygon.forEach(function(ring) {
                      ring.forEach(function(arc) {
                        polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon2) {
                          if (!polygon2._) {
                            polygon2._ = 1;
                            neighbors2.push(polygon2);
                          }
                        });
                      });
                    });
                  }
                }
              });
              polygons.forEach(function(polygon) {
                delete polygon._;
              });
              return {
                type: "MultiPolygon",
                arcs: groups.map(function(polygons2) {
                  var arcs = [], n;
                  polygons2.forEach(function(polygon) {
                    polygon.forEach(function(ring) {
                      ring.forEach(function(arc) {
                        if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {
                          arcs.push(arc);
                        }
                      });
                    });
                  });
                  arcs = stitch(topology, arcs);
                  if ((n = arcs.length) > 1) {
                    for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {
                      if ((ki = area(arcs[i])) > k) {
                        t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;
                      }
                    }
                  }
                  return arcs;
                }).filter(function(arcs) {
                  return arcs.length > 0;
                })
              };
            }
            function bisect(a, x) {
              var lo = 0, hi = a.length;
              while (lo < hi) {
                var mid = lo + hi >>> 1;
                if (a[mid] < x)
                  lo = mid + 1;
                else
                  hi = mid;
              }
              return lo;
            }
            function neighbors(objects) {
              var indexesByArc = {}, neighbors2 = objects.map(function() {
                return [];
              });
              function line(arcs, i2) {
                arcs.forEach(function(a) {
                  if (a < 0)
                    a = ~a;
                  var o = indexesByArc[a];
                  if (o)
                    o.push(i2);
                  else
                    indexesByArc[a] = [i2];
                });
              }
              function polygon(arcs, i2) {
                arcs.forEach(function(arc) {
                  line(arc, i2);
                });
              }
              function geometry(o, i2) {
                if (o.type === "GeometryCollection")
                  o.geometries.forEach(function(o2) {
                    geometry(o2, i2);
                  });
                else if (o.type in geometryType)
                  geometryType[o.type](o.arcs, i2);
              }
              var geometryType = {
                LineString: line,
                MultiLineString: polygon,
                Polygon: polygon,
                MultiPolygon: function(arcs, i2) {
                  arcs.forEach(function(arc) {
                    polygon(arc, i2);
                  });
                }
              };
              objects.forEach(geometry);
              for (var i in indexesByArc) {
                for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {
                  for (var k = j + 1; k < m; ++k) {
                    var ij = indexes[j], ik = indexes[k], n;
                    if ((n = neighbors2[ij])[i = bisect(n, ik)] !== ik)
                      n.splice(i, 0, ik);
                    if ((n = neighbors2[ik])[i = bisect(n, ij)] !== ij)
                      n.splice(i, 0, ij);
                  }
                }
              }
              return neighbors2;
            }
            function untransform(transform2) {
              if (transform2 == null)
                return identity;
              var x0, y0, kx = transform2.scale[0], ky = transform2.scale[1], dx = transform2.translate[0], dy = transform2.translate[1];
              return function(input, i) {
                if (!i)
                  x0 = y0 = 0;
                var j = 2, n = input.length, output = new Array(n), x1 = Math.round((input[0] - dx) / kx), y1 = Math.round((input[1] - dy) / ky);
                output[0] = x1 - x0, x0 = x1;
                output[1] = y1 - y0, y0 = y1;
                while (j < n)
                  output[j] = input[j], ++j;
                return output;
              };
            }
            function quantize(topology, transform2) {
              if (topology.transform)
                throw new Error("already quantized");
              if (!transform2 || !transform2.scale) {
                if (!((n = Math.floor(transform2)) >= 2))
                  throw new Error("n must be \u22652");
                box = topology.bbox || bbox(topology);
                var x0 = box[0], y0 = box[1], x1 = box[2], y1 = box[3], n;
                transform2 = { scale: [x1 - x0 ? (x1 - x0) / (n - 1) : 1, y1 - y0 ? (y1 - y0) / (n - 1) : 1], translate: [x0, y0] };
              } else {
                box = topology.bbox;
              }
              var t = untransform(transform2), box, key, inputs = topology.objects, outputs = {};
              function quantizePoint(point) {
                return t(point);
              }
              function quantizeGeometry(input) {
                var output;
                switch (input.type) {
                  case "GeometryCollection":
                    output = { type: "GeometryCollection", geometries: input.geometries.map(quantizeGeometry) };
                    break;
                  case "Point":
                    output = { type: "Point", coordinates: quantizePoint(input.coordinates) };
                    break;
                  case "MultiPoint":
                    output = { type: "MultiPoint", coordinates: input.coordinates.map(quantizePoint) };
                    break;
                  default:
                    return input;
                }
                if (input.id != null)
                  output.id = input.id;
                if (input.bbox != null)
                  output.bbox = input.bbox;
                if (input.properties != null)
                  output.properties = input.properties;
                return output;
              }
              function quantizeArc(input) {
                var i = 0, j = 1, n2 = input.length, p, output = new Array(n2);
                output[0] = t(input[0], 0);
                while (++i < n2)
                  if ((p = t(input[i], i))[0] || p[1])
                    output[j++] = p;
                if (j === 1)
                  output[j++] = [0, 0];
                output.length = j;
                return output;
              }
              for (key in inputs)
                outputs[key] = quantizeGeometry(inputs[key]);
              return {
                type: "Topology",
                bbox: box,
                transform: transform2,
                objects: outputs,
                arcs: topology.arcs.map(quantizeArc)
              };
            }
            exports3.bbox = bbox;
            exports3.feature = feature;
            exports3.merge = merge;
            exports3.mergeArcs = mergeArcs;
            exports3.mesh = mesh;
            exports3.meshArcs = meshArcs;
            exports3.neighbors = neighbors;
            exports3.quantize = quantize;
            exports3.transform = transform;
            exports3.untransform = untransform;
            Object.defineProperty(exports3, "__esModule", { value: true });
          });
        },
        "./node_modules/_tslib@2.1.0@tslib/tslib.js": function(module2, exports2, __webpack_require__) {
          (function(global) {
            var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
            var __extends;
            var __assign;
            var __rest;
            var __decorate;
            var __param;
            var __metadata;
            var __awaiter;
            var __generator;
            var __exportStar;
            var __values;
            var __read;
            var __spread;
            var __spreadArrays;
            var __spreadArray;
            var __await;
            var __asyncGenerator;
            var __asyncDelegator;
            var __asyncValues;
            var __makeTemplateObject;
            var __importStar;
            var __importDefault;
            var __classPrivateFieldGet;
            var __classPrivateFieldSet;
            var __createBinding;
            (function(factory) {
              var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
              if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports2], __WEBPACK_AMD_DEFINE_RESULT__ = function(exports3) {
                  factory(createExporter(root, createExporter(exports3)));
                }.apply(exports2, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
              } else {
              }
              function createExporter(exports3, previous) {
                if (exports3 !== root) {
                  if (typeof Object.create === "function") {
                    Object.defineProperty(exports3, "__esModule", { value: true });
                  } else {
                    exports3.__esModule = true;
                  }
                }
                return function(id, v) {
                  return exports3[id] = previous ? previous(id, v) : v;
                };
              }
            })(function(exporter) {
              var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
                d.__proto__ = b;
              } || function(d, b) {
                for (var p in b)
                  if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p];
              };
              __extends = function(d, b) {
                if (typeof b !== "function" && b !== null)
                  throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
                extendStatics(d, b);
                function __() {
                  this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
              };
              __assign = Object.assign || function(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                  s = arguments[i];
                  for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                      t[p] = s[p];
                }
                return t;
              };
              __rest = function(s, e) {
                var t = {};
                for (var p in s)
                  if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                    t[p] = s[p];
                if (s != null && typeof Object.getOwnPropertySymbols === "function")
                  for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                      t[p[i]] = s[p[i]];
                  }
                return t;
              };
              __decorate = function(decorators, target, key, desc) {
                var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
                  r = Reflect.decorate(decorators, target, key, desc);
                else
                  for (var i = decorators.length - 1; i >= 0; i--)
                    if (d = decorators[i])
                      r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
              };
              __param = function(paramIndex, decorator) {
                return function(target, key) {
                  decorator(target, key, paramIndex);
                };
              };
              __metadata = function(metadataKey, metadataValue) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
                  return Reflect.metadata(metadataKey, metadataValue);
              };
              __awaiter = function(thisArg, _arguments, P, generator) {
                function adopt(value) {
                  return value instanceof P ? value : new P(function(resolve) {
                    resolve(value);
                  });
                }
                return new (P || (P = Promise))(function(resolve, reject) {
                  function fulfilled(value) {
                    try {
                      step(generator.next(value));
                    } catch (e) {
                      reject(e);
                    }
                  }
                  function rejected(value) {
                    try {
                      step(generator["throw"](value));
                    } catch (e) {
                      reject(e);
                    }
                  }
                  function step(result) {
                    result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
                  }
                  step((generator = generator.apply(thisArg, _arguments || [])).next());
                });
              };
              __generator = function(thisArg, body) {
                var _ = { label: 0, sent: function() {
                  if (t[0] & 1)
                    throw t[1];
                  return t[1];
                }, trys: [], ops: [] }, f, y, t, g;
                return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
                  return this;
                }), g;
                function verb(n) {
                  return function(v) {
                    return step([n, v]);
                  };
                }
                function step(op) {
                  if (f)
                    throw new TypeError("Generator is already executing.");
                  while (_)
                    try {
                      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                      if (y = 0, t)
                        op = [op[0] & 2, t.value];
                      switch (op[0]) {
                        case 0:
                        case 1:
                          t = op;
                          break;
                        case 4:
                          _.label++;
                          return { value: op[1], done: false };
                        case 5:
                          _.label++;
                          y = op[1];
                          op = [0];
                          continue;
                        case 7:
                          op = _.ops.pop();
                          _.trys.pop();
                          continue;
                        default:
                          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                            _ = 0;
                            continue;
                          }
                          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                            _.label = op[1];
                            break;
                          }
                          if (op[0] === 6 && _.label < t[1]) {
                            _.label = t[1];
                            t = op;
                            break;
                          }
                          if (t && _.label < t[2]) {
                            _.label = t[2];
                            _.ops.push(op);
                            break;
                          }
                          if (t[2])
                            _.ops.pop();
                          _.trys.pop();
                          continue;
                      }
                      op = body.call(thisArg, _);
                    } catch (e) {
                      op = [6, e];
                      y = 0;
                    } finally {
                      f = t = 0;
                    }
                  if (op[0] & 5)
                    throw op[1];
                  return { value: op[0] ? op[1] : void 0, done: true };
                }
              };
              __exportStar = function(m, o) {
                for (var p in m)
                  if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                    __createBinding(o, m, p);
              };
              __createBinding = Object.create ? function(o, m, k, k2) {
                if (k2 === void 0)
                  k2 = k;
                Object.defineProperty(o, k2, { enumerable: true, get: function() {
                  return m[k];
                } });
              } : function(o, m, k, k2) {
                if (k2 === void 0)
                  k2 = k;
                o[k2] = m[k];
              };
              __values = function(o) {
                var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
                if (m)
                  return m.call(o);
                if (o && typeof o.length === "number")
                  return {
                    next: function() {
                      if (o && i >= o.length)
                        o = void 0;
                      return { value: o && o[i++], done: !o };
                    }
                  };
                throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
              };
              __read = function(o, n) {
                var m = typeof Symbol === "function" && o[Symbol.iterator];
                if (!m)
                  return o;
                var i = m.call(o), r, ar = [], e;
                try {
                  while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                    ar.push(r.value);
                } catch (error) {
                  e = { error };
                } finally {
                  try {
                    if (r && !r.done && (m = i["return"]))
                      m.call(i);
                  } finally {
                    if (e)
                      throw e.error;
                  }
                }
                return ar;
              };
              __spread = function() {
                for (var ar = [], i = 0; i < arguments.length; i++)
                  ar = ar.concat(__read(arguments[i]));
                return ar;
              };
              __spreadArrays = function() {
                for (var s = 0, i = 0, il = arguments.length; i < il; i++)
                  s += arguments[i].length;
                for (var r = Array(s), k = 0, i = 0; i < il; i++)
                  for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                    r[k] = a[j];
                return r;
              };
              __spreadArray = function(to, from) {
                for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
                  to[j] = from[i];
                return to;
              };
              __await = function(v) {
                return this instanceof __await ? (this.v = v, this) : new __await(v);
              };
              __asyncGenerator = function(thisArg, _arguments, generator) {
                if (!Symbol.asyncIterator)
                  throw new TypeError("Symbol.asyncIterator is not defined.");
                var g = generator.apply(thisArg, _arguments || []), i, q = [];
                return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
                  return this;
                }, i;
                function verb(n) {
                  if (g[n])
                    i[n] = function(v) {
                      return new Promise(function(a, b) {
                        q.push([n, v, a, b]) > 1 || resume(n, v);
                      });
                    };
                }
                function resume(n, v) {
                  try {
                    step(g[n](v));
                  } catch (e) {
                    settle(q[0][3], e);
                  }
                }
                function step(r) {
                  r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
                }
                function fulfill(value) {
                  resume("next", value);
                }
                function reject(value) {
                  resume("throw", value);
                }
                function settle(f, v) {
                  if (f(v), q.shift(), q.length)
                    resume(q[0][0], q[0][1]);
                }
              };
              __asyncDelegator = function(o) {
                var i, p;
                return i = {}, verb("next"), verb("throw", function(e) {
                  throw e;
                }), verb("return"), i[Symbol.iterator] = function() {
                  return this;
                }, i;
                function verb(n, f) {
                  i[n] = o[n] ? function(v) {
                    return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v;
                  } : f;
                }
              };
              __asyncValues = function(o) {
                if (!Symbol.asyncIterator)
                  throw new TypeError("Symbol.asyncIterator is not defined.");
                var m = o[Symbol.asyncIterator], i;
                return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
                  return this;
                }, i);
                function verb(n) {
                  i[n] = o[n] && function(v) {
                    return new Promise(function(resolve, reject) {
                      v = o[n](v), settle(resolve, reject, v.done, v.value);
                    });
                  };
                }
                function settle(resolve, reject, d, v) {
                  Promise.resolve(v).then(function(v2) {
                    resolve({ value: v2, done: d });
                  }, reject);
                }
              };
              __makeTemplateObject = function(cooked, raw) {
                if (Object.defineProperty) {
                  Object.defineProperty(cooked, "raw", { value: raw });
                } else {
                  cooked.raw = raw;
                }
                return cooked;
              };
              var __setModuleDefault = Object.create ? function(o, v) {
                Object.defineProperty(o, "default", { enumerable: true, value: v });
              } : function(o, v) {
                o["default"] = v;
              };
              __importStar = function(mod) {
                if (mod && mod.__esModule)
                  return mod;
                var result = {};
                if (mod != null) {
                  for (var k in mod)
                    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                      __createBinding(result, mod, k);
                }
                __setModuleDefault(result, mod);
                return result;
              };
              __importDefault = function(mod) {
                return mod && mod.__esModule ? mod : { "default": mod };
              };
              __classPrivateFieldGet = function(receiver, privateMap) {
                if (!privateMap.has(receiver)) {
                  throw new TypeError("attempted to get private field on non-instance");
                }
                return privateMap.get(receiver);
              };
              __classPrivateFieldSet = function(receiver, privateMap, value) {
                if (!privateMap.has(receiver)) {
                  throw new TypeError("attempted to set private field on non-instance");
                }
                privateMap.set(receiver, value);
                return value;
              };
              exporter("__extends", __extends);
              exporter("__assign", __assign);
              exporter("__rest", __rest);
              exporter("__decorate", __decorate);
              exporter("__param", __param);
              exporter("__metadata", __metadata);
              exporter("__awaiter", __awaiter);
              exporter("__generator", __generator);
              exporter("__exportStar", __exportStar);
              exporter("__createBinding", __createBinding);
              exporter("__values", __values);
              exporter("__read", __read);
              exporter("__spread", __spread);
              exporter("__spreadArrays", __spreadArrays);
              exporter("__spreadArray", __spreadArray);
              exporter("__await", __await);
              exporter("__asyncGenerator", __asyncGenerator);
              exporter("__asyncDelegator", __asyncDelegator);
              exporter("__asyncValues", __asyncValues);
              exporter("__makeTemplateObject", __makeTemplateObject);
              exporter("__importStar", __importStar);
              exporter("__importDefault", __importDefault);
              exporter("__classPrivateFieldGet", __classPrivateFieldGet);
              exporter("__classPrivateFieldSet", __classPrivateFieldSet);
            });
          }).call(this, __webpack_require__("./node_modules/_webpack@4.46.0@webpack/buildin/global.js"));
        },
        "./node_modules/_webpack@4.46.0@webpack/buildin/global.js": function(module2, exports2) {
          var g;
          g = function() {
            return this;
          }();
          try {
            g = g || new Function("return this")();
          } catch (e) {
            if (typeof window === "object")
              g = window;
          }
          module2.exports = g;
        },
        "./node_modules/_webpack@4.46.0@webpack/buildin/module.js": function(module2, exports2) {
          module2.exports = function(module3) {
            if (!module3.webpackPolyfill) {
              module3.deprecate = function() {
              };
              module3.paths = [];
              if (!module3.children)
                module3.children = [];
              Object.defineProperty(module3, "loaded", {
                enumerable: true,
                get: function() {
                  return module3.l;
                }
              });
              Object.defineProperty(module3, "id", {
                enumerable: true,
                get: function() {
                  return module3.i;
                }
              });
              module3.webpackPolyfill = 1;
            }
            return module3;
          };
        },
        "./node_modules/_wolfy87-eventemitter@5.2.9@wolfy87-eventemitter/EventEmitter.js": function(module2, exports2, __webpack_require__) {
          var __WEBPACK_AMD_DEFINE_RESULT__;
          ;
          (function(exports3) {
            "use strict";
            function EventEmitter() {
            }
            var proto = EventEmitter.prototype;
            var originalGlobalValue = exports3.EventEmitter;
            function indexOfListener(listeners, listener) {
              var i = listeners.length;
              while (i--) {
                if (listeners[i].listener === listener) {
                  return i;
                }
              }
              return -1;
            }
            function alias(name) {
              return function aliasClosure() {
                return this[name].apply(this, arguments);
              };
            }
            proto.getListeners = function getListeners(evt) {
              var events = this._getEvents();
              var response;
              var key;
              if (evt instanceof RegExp) {
                response = {};
                for (key in events) {
                  if (events.hasOwnProperty(key) && evt.test(key)) {
                    response[key] = events[key];
                  }
                }
              } else {
                response = events[evt] || (events[evt] = []);
              }
              return response;
            };
            proto.flattenListeners = function flattenListeners(listeners) {
              var flatListeners = [];
              var i;
              for (i = 0; i < listeners.length; i += 1) {
                flatListeners.push(listeners[i].listener);
              }
              return flatListeners;
            };
            proto.getListenersAsObject = function getListenersAsObject(evt) {
              var listeners = this.getListeners(evt);
              var response;
              if (listeners instanceof Array) {
                response = {};
                response[evt] = listeners;
              }
              return response || listeners;
            };
            function isValidListener(listener) {
              if (typeof listener === "function" || listener instanceof RegExp) {
                return true;
              } else if (listener && typeof listener === "object") {
                return isValidListener(listener.listener);
              } else {
                return false;
              }
            }
            proto.addListener = function addListener(evt, listener) {
              if (!isValidListener(listener)) {
                throw new TypeError("listener must be a function");
              }
              var listeners = this.getListenersAsObject(evt);
              var listenerIsWrapped = typeof listener === "object";
              var key;
              for (key in listeners) {
                if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {
                  listeners[key].push(listenerIsWrapped ? listener : {
                    listener,
                    once: false
                  });
                }
              }
              return this;
            };
            proto.on = alias("addListener");
            proto.addOnceListener = function addOnceListener(evt, listener) {
              return this.addListener(evt, {
                listener,
                once: true
              });
            };
            proto.once = alias("addOnceListener");
            proto.defineEvent = function defineEvent(evt) {
              this.getListeners(evt);
              return this;
            };
            proto.defineEvents = function defineEvents(evts) {
              for (var i = 0; i < evts.length; i += 1) {
                this.defineEvent(evts[i]);
              }
              return this;
            };
            proto.removeListener = function removeListener(evt, listener) {
              var listeners = this.getListenersAsObject(evt);
              var index;
              var key;
              for (key in listeners) {
                if (listeners.hasOwnProperty(key)) {
                  index = indexOfListener(listeners[key], listener);
                  if (index !== -1) {
                    listeners[key].splice(index, 1);
                  }
                }
              }
              return this;
            };
            proto.off = alias("removeListener");
            proto.addListeners = function addListeners(evt, listeners) {
              return this.manipulateListeners(false, evt, listeners);
            };
            proto.removeListeners = function removeListeners(evt, listeners) {
              return this.manipulateListeners(true, evt, listeners);
            };
            proto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {
              var i;
              var value;
              var single = remove ? this.removeListener : this.addListener;
              var multiple = remove ? this.removeListeners : this.addListeners;
              if (typeof evt === "object" && !(evt instanceof RegExp)) {
                for (i in evt) {
                  if (evt.hasOwnProperty(i) && (value = evt[i])) {
                    if (typeof value === "function") {
                      single.call(this, i, value);
                    } else {
                      multiple.call(this, i, value);
                    }
                  }
                }
              } else {
                i = listeners.length;
                while (i--) {
                  single.call(this, evt, listeners[i]);
                }
              }
              return this;
            };
            proto.removeEvent = function removeEvent(evt) {
              var type = typeof evt;
              var events = this._getEvents();
              var key;
              if (type === "string") {
                delete events[evt];
              } else if (evt instanceof RegExp) {
                for (key in events) {
                  if (events.hasOwnProperty(key) && evt.test(key)) {
                    delete events[key];
                  }
                }
              } else {
                delete this._events;
              }
              return this;
            };
            proto.removeAllListeners = alias("removeEvent");
            proto.emitEvent = function emitEvent(evt, args) {
              var listenersMap = this.getListenersAsObject(evt);
              var listeners;
              var listener;
              var i;
              var key;
              var response;
              for (key in listenersMap) {
                if (listenersMap.hasOwnProperty(key)) {
                  listeners = listenersMap[key].slice(0);
                  for (i = 0; i < listeners.length; i++) {
                    listener = listeners[i];
                    if (listener.once === true) {
                      this.removeListener(evt, listener.listener);
                    }
                    response = listener.listener.apply(this, args || []);
                    if (response === this._getOnceReturnValue()) {
                      this.removeListener(evt, listener.listener);
                    }
                  }
                }
              }
              return this;
            };
            proto.trigger = alias("emitEvent");
            proto.emit = function emit(evt) {
              var args = Array.prototype.slice.call(arguments, 1);
              return this.emitEvent(evt, args);
            };
            proto.setOnceReturnValue = function setOnceReturnValue(value) {
              this._onceReturnValue = value;
              return this;
            };
            proto._getOnceReturnValue = function _getOnceReturnValue() {
              if (this.hasOwnProperty("_onceReturnValue")) {
                return this._onceReturnValue;
              } else {
                return true;
              }
            };
            proto._getEvents = function _getEvents() {
              return this._events || (this._events = {});
            };
            EventEmitter.noConflict = function noConflict() {
              exports3.EventEmitter = originalGlobalValue;
              return EventEmitter;
            };
            if (true) {
              !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
                return EventEmitter;
              }.call(exports3, __webpack_require__, exports3, module2), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
            } else {
            }
          })(typeof window !== "undefined" ? window : this || {});
        },
        "./src/api/geo.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var tslib_1 = __webpack_require__("./node_modules/_tslib@2.1.0@tslib/tslib.js");
          var util_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js");
          var d3_geo_1 = __webpack_require__("./node_modules/_d3-geo@1.6.4@d3-geo/build/d3-geo.js");
          var d3_geo_projection_1 = __webpack_require__("./node_modules/_d3-geo-projection@2.1.2@d3-geo-projection/build/d3-geo-projection.js");
          var view_1 = __webpack_require__("./src/view.ts");
          var get_geo_projection_1 = tslib_1.__importDefault(__webpack_require__("./src/util/get-geo-projection.ts"));
          var api = {
            geoArea: function(feature) {
              return d3_geo_1.geoArea(feature);
            },
            geoAreaByName: function(name) {
              return d3_geo_1.geoArea(this.geoFeatureByName(name));
            },
            geoCentroid: function(feature) {
              return d3_geo_1.geoCentroid(feature);
            },
            geoCentroidByName: function(name) {
              return d3_geo_1.geoCentroid(this.geoFeatureByName(name));
            },
            geoDistance: function(p1, p2) {
              return d3_geo_1.geoDistance(p1, p2);
            },
            geoLength: function(feature) {
              return d3_geo_1.geoLength(feature);
            },
            geoLengthByName: function(name) {
              return d3_geo_1.geoLength(this.geoFeatureByName(name));
            },
            geoContains: function(feature, position) {
              return d3_geo_1.geoContains(feature, position);
            },
            geoFeatureByName: function(name) {
              var rows = this.rows;
              var result;
              rows.some(function(feature) {
                if (feature.name === name) {
                  result = feature;
                  return true;
                }
                return false;
              });
              return result;
            },
            geoFeatureByPosition: function(position) {
              var rows = this.rows;
              var result;
              rows.some(function(feature) {
                if (d3_geo_1.geoContains(feature, position)) {
                  result = feature;
                  return true;
                }
                return false;
              });
              return result;
            },
            geoNameByPosition: function(position) {
              var feature = this.geoFeatureByPosition(position);
              if (feature) {
                return feature.name;
              }
            },
            getGeoProjection: get_geo_projection_1.default,
            geoProject: function(feature, projection, exportRaw) {
              projection = get_geo_projection_1.default(projection, exportRaw);
              return d3_geo_projection_1.geoProject(feature, projection);
            },
            geoProjectByName: function(name, projection, exportRaw) {
              projection = get_geo_projection_1.default(projection, exportRaw);
              return d3_geo_projection_1.geoProject(this.geoFeatureByName(name), projection);
            },
            geoProjectPosition: function(position, projection, exportRaw) {
              var func = get_geo_projection_1.default(projection, exportRaw);
              return func(position);
            },
            geoProjectInvert: function(position, projection, exportRaw) {
              var func = get_geo_projection_1.default(projection, exportRaw);
              return func.invert(position);
            }
          };
          util_1.assign(view_1.View.prototype, api);
        },
        "./src/api/hierarchy.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var util_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js");
          var view_1 = __webpack_require__("./src/view.ts");
          util_1.assign(view_1.View.prototype, {
            getAllNodes: function() {
              var nodes = [];
              var root = this.root;
              if (root && root.each) {
                root.each(function(node) {
                  nodes.push(node);
                });
              } else if (root && root.eachNode) {
                root.eachNode(function(node) {
                  nodes.push(node);
                });
              }
              return nodes;
            },
            getAllLinks: function() {
              var links = [];
              var nodes = [this.root];
              var node;
              while (node = nodes.pop()) {
                var children = node.children;
                if (children) {
                  children.forEach(function(child) {
                    links.push({
                      source: node,
                      target: child
                    });
                    nodes.push(child);
                  });
                }
              }
              return links;
            }
          });
          util_1.assign(view_1.View.prototype, {
            getAllEdges: view_1.View.prototype.getAllLinks
          });
        },
        "./src/api/partition.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var tslib_1 = __webpack_require__("./node_modules/_tslib@2.1.0@tslib/tslib.js");
          var util_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js");
          var partition_1 = tslib_1.__importDefault(__webpack_require__("./src/util/partition.ts"));
          var view_1 = __webpack_require__("./src/view.ts");
          util_1.assign(view_1.View.prototype, {
            partition: function(group_by, order_by) {
              if (order_by === void 0) {
                order_by = [];
              }
              return partition_1.default(this.rows, group_by, order_by);
            },
            group: function(group_by, order_by) {
              if (order_by === void 0) {
                order_by = [];
              }
              var groups = this.partition(group_by, order_by);
              return util_1.values(groups);
            },
            groups: function(group_by, order_by) {
              if (order_by === void 0) {
                order_by = [];
              }
              return this.group(group_by, order_by);
            }
          });
        },
        "./src/api/statistics.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var tslib_1 = __webpack_require__("./node_modules/_tslib@2.1.0@tslib/tslib.js");
          var simpleStatistics = tslib_1.__importStar(__webpack_require__("./node_modules/_simple-statistics@6.1.1@simple-statistics/dist/simple-statistics.min.js"));
          var util_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js");
          var view_1 = __webpack_require__("./src/view.ts");
          var p_by_fraction_1 = tslib_1.__importDefault(__webpack_require__("./src/util/p-by-fraction.ts"));
          var constants_1 = tslib_1.__importDefault(__webpack_require__("./src/constants.ts"));
          var STATISTICS_METHODS = constants_1.default.STATISTICS_METHODS;
          function getColumnValues(view, column) {
            var values = view.getColumn(column);
            if (util_1.isArray(values) && util_1.isArray(values[0])) {
              values = util_1.flattenDeep(values);
            }
            return values;
          }
          STATISTICS_METHODS.forEach(function(method) {
            view_1.View.prototype[method] = function(column) {
              return simpleStatistics[method](getColumnValues(this, column));
            };
          });
          var quantile = simpleStatistics.quantile;
          util_1.assign(view_1.View.prototype, {
            average: view_1.View.prototype.mean,
            quantile: function(column, p) {
              return quantile(getColumnValues(this, column), p);
            },
            quantiles: function(column, pArr) {
              var columnArr = getColumnValues(this, column);
              return pArr.map(function(p) {
                return quantile(columnArr, p);
              });
            },
            quantilesByFraction: function(column, fraction) {
              return this.quantiles(column, p_by_fraction_1.default(fraction));
            },
            range: function(column) {
              return [this.min(column), this.max(column)];
            },
            extent: function(column) {
              return this.range(column);
            }
          });
        },
        "./src/connector/default.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var util_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js");
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          data_set_1.DataSet.registerConnector("default", function(data, dataSet) {
            var view;
            if (util_1.isString(data)) {
              view = dataSet.getView(data);
            } else {
              view = data;
            }
            if (!view) {
              throw new TypeError("Invalid dataView");
            }
            return util_1.deepMix([], view.rows);
          });
        },
        "./src/connector/dsv.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var util_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js");
          var d3_dsv_1 = __webpack_require__("./node_modules/_d3-dsv@1.2.0@d3-dsv/dist/d3-dsv.js");
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          data_set_1.DataSet.registerConnector("dsv", function(str, options) {
            if (options === void 0) {
              options = {};
            }
            var delimiter = options.delimiter || ",";
            if (!util_1.isString(delimiter)) {
              throw new TypeError("Invalid delimiter: must be a string!");
            }
            return d3_dsv_1.dsvFormat(delimiter).parse(str);
          });
          data_set_1.DataSet.registerConnector("csv", function(str) {
            return d3_dsv_1.csvParse(str);
          });
          data_set_1.DataSet.registerConnector("tsv", function(str) {
            return d3_dsv_1.tsvParse(str);
          });
        },
        "./src/connector/geo-graticule.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var d3_geo_1 = __webpack_require__("./node_modules/_d3-geo@1.6.4@d3-geo/build/d3-geo.js");
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          function connector(_options, dataView) {
            dataView.dataType = "geo-graticule";
            var data = d3_geo_1.geoGraticule().lines();
            data.map(function(row, index) {
              row.index = "" + index;
              return row;
            });
            dataView.rows = data;
            return data;
          }
          exports2.default = connector;
          data_set_1.DataSet.registerConnector("geo-graticule", connector);
        },
        "./src/connector/geojson.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var tslib_1 = __webpack_require__("./node_modules/_tslib@2.1.0@tslib/tslib.js");
          var point_at_length_1 = tslib_1.__importDefault(__webpack_require__("./node_modules/_point-at-length@1.1.0@point-at-length/index.js"));
          var util_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js");
          var d3_geo_1 = __webpack_require__("./node_modules/_d3-geo@1.6.4@d3-geo/build/d3-geo.js");
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          var geoPathGenerator = d3_geo_1.geoPath();
          function GeoJSONConnector(data, _options, dataView) {
            dataView.dataType = data_set_1.DataSet.CONSTANTS.GEO;
            var features = util_1.deepMix([], data.features);
            features.forEach(function(feature) {
              feature.name = feature.properties.name;
              feature.longitude = [];
              feature.latitude = [];
              var pathData = feature.pathData = geoPathGenerator(feature);
              var points = point_at_length_1.default(pathData);
              points._path.forEach(function(point) {
                feature.longitude.push(point[1]);
                feature.latitude.push(point[2]);
              });
              var centroid = geoPathGenerator.centroid(feature);
              feature.centroidX = centroid[0];
              feature.centroidY = centroid[1];
            });
            return features;
          }
          data_set_1.DataSet.registerConnector("geo", GeoJSONConnector);
          data_set_1.DataSet.registerConnector("geojson", GeoJSONConnector);
          data_set_1.DataSet.registerConnector("GeoJSON", GeoJSONConnector);
          exports2.default = GeoJSONConnector;
        },
        "./src/connector/graph.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var util_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js");
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          var DEFAULT_OPTIONS = {
            nodes: function(d) {
              return d.nodes;
            },
            edges: function(d) {
              return d.edges;
            }
          };
          function connector(data, options, dataView) {
            options = util_1.assign({}, DEFAULT_OPTIONS, options);
            dataView.dataType = data_set_1.DataSet.CONSTANTS.GRAPH;
            var nodes = options.nodes, edges = options.edges;
            if (nodes && !util_1.isFunction(nodes)) {
              throw new TypeError("Invalid nodes: must be a function!");
            }
            if (edges && !util_1.isFunction(edges)) {
              throw new TypeError("Invalid edges: must be a function!");
            }
            dataView.rows = dataView.graph = {
              nodes: nodes(data),
              edges: edges(data)
            };
            util_1.assign(dataView, dataView.graph);
            return dataView.rows;
          }
          data_set_1.DataSet.registerConnector("graph", connector);
          data_set_1.DataSet.registerConnector("diagram", connector);
        },
        "./src/connector/hexjson.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var util_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js");
          var d3_hexjson_1 = __webpack_require__("./node_modules/_d3-hexjson@1.1.1@d3-hexjson/build/d3-hexjson.js");
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          var DEFAULT_OPTIONS = {
            width: 1,
            height: 1
          };
          function processRow(row) {
            row.cx = row.x;
            row.cy = row.y;
            row.x = [];
            row.y = [];
            row.vertices.forEach(function(v) {
              row.x.push(v.x + row.cx);
              row.y.push(v.y + row.cy);
            });
            return row;
          }
          function HexJSONConnector(data, options, dataView) {
            dataView.dataType = data_set_1.DataSet.CONSTANTS.HEX;
            options = util_1.assign({}, DEFAULT_OPTIONS, options);
            var width = options.width, height = options.height;
            var HexJSON = util_1.deepMix([], data);
            dataView._HexJSON = HexJSON;
            var grid = dataView._GridHexJSON = d3_hexjson_1.getGridForHexJSON(HexJSON);
            var rows = dataView.rows = d3_hexjson_1.renderHexJSON(HexJSON, width, height).map(processRow);
            dataView._gridRows = d3_hexjson_1.renderHexJSON(grid, width, height).map(processRow);
            return rows;
          }
          data_set_1.DataSet.registerConnector("hex", HexJSONConnector);
          data_set_1.DataSet.registerConnector("hexjson", HexJSONConnector);
          data_set_1.DataSet.registerConnector("hex-json", HexJSONConnector);
          data_set_1.DataSet.registerConnector("HexJSON", HexJSONConnector);
          exports2.default = HexJSONConnector;
        },
        "./src/connector/hierarchy.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var util_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js");
          var d3_hierarchy_1 = __webpack_require__("./node_modules/_d3-hierarchy@1.1.9@d3-hierarchy/dist/d3-hierarchy.js");
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          function connector(data, options, dataView) {
            dataView.dataType = data_set_1.DataSet.CONSTANTS.HIERARCHY;
            var children = options && options.children ? options.children : null;
            if (children && !util_1.isFunction(children)) {
              throw new TypeError("Invalid children: must be a function!");
            }
            if (!options.pureData) {
              dataView.rows = dataView.root = d3_hierarchy_1.hierarchy(data, children);
            } else {
              dataView.rows = dataView.root = data;
            }
            return data;
          }
          data_set_1.DataSet.registerConnector("hierarchy", connector);
          data_set_1.DataSet.registerConnector("tree", connector);
        },
        "./src/connector/topojson.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var tslib_1 = __webpack_require__("./node_modules/_tslib@2.1.0@tslib/tslib.js");
          var util_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js");
          var topojson_client_1 = __webpack_require__("./node_modules/_topojson-client@3.1.0@topojson-client/dist/topojson-client.js");
          var geojson_1 = tslib_1.__importDefault(__webpack_require__("./src/connector/geojson.ts"));
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          function TopoJSONConnector(data, options, dataView) {
            var object = options.object;
            if (!util_1.isString(object)) {
              throw new TypeError("Invalid object: must be a string!");
            }
            var geoData = topojson_client_1.feature(data, data.objects[object]);
            return geojson_1.default(geoData, void 0, dataView);
          }
          data_set_1.DataSet.registerConnector("topojson", TopoJSONConnector);
          data_set_1.DataSet.registerConnector("TopoJSON", TopoJSONConnector);
        },
        "./src/constants.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.default = {
            HIERARCHY: "hierarchy",
            GEO: "geo",
            HEX: "hex",
            GRAPH: "graph",
            TABLE: "table",
            GEO_GRATICULE: "geo-graticule",
            STATISTICS_METHODS: [
              "max",
              "mean",
              "median",
              "min",
              "mode",
              "product",
              "standardDeviation",
              "sum",
              "sumSimple",
              "variance"
            ]
          };
        },
        "./src/data-set.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.DataSet = void 0;
          var tslib_1 = __webpack_require__("./node_modules/_tslib@2.1.0@tslib/tslib.js");
          var util_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js");
          var wolfy87_eventemitter_1 = tslib_1.__importDefault(__webpack_require__("./node_modules/_wolfy87-eventemitter@5.2.9@wolfy87-eventemitter/EventEmitter.js"));
          var view_1 = __webpack_require__("./src/view.ts");
          var constants_1 = tslib_1.__importDefault(__webpack_require__("./src/constants.ts"));
          var DataSet = function(_super) {
            tslib_1.__extends(DataSet2, _super);
            function DataSet2(initialProps) {
              if (initialProps === void 0) {
                initialProps = { state: {} };
              }
              var _this = _super.call(this) || this;
              _this.isDataSet = true;
              _this._onChangeTimer = null;
              _this.views = {};
              _this.state = {};
              _this.state = initialProps.state;
              return _this;
            }
            DataSet2.registerConnector = function(name, connector) {
              DataSet2.connectors[name] = connector;
            };
            DataSet2.getConnector = function(name) {
              return DataSet2.connectors[name] || DataSet2.connectors.default;
            };
            DataSet2.registerTransform = function(name, transform) {
              DataSet2.transforms[name] = transform;
            };
            DataSet2.getTransform = function(name) {
              return DataSet2.transforms[name] || DataSet2.transforms.default;
            };
            DataSet2.prototype._getUniqueViewName = function() {
              var name = util_1.uniqueId("view_");
              while (this.views[name]) {
                name = util_1.uniqueId("view_");
              }
              return name;
            };
            DataSet2.prototype.createView = function(name, options) {
              if (util_1.isNil(name)) {
                name = this._getUniqueViewName();
              }
              if (util_1.isObject(name)) {
                options = name;
                name = this._getUniqueViewName();
              }
              if (this.views[name]) {
                throw new Error("data view exists: " + name);
              }
              var view = new view_1.View(this, options);
              this.views[name] = view;
              return view;
            };
            DataSet2.prototype.getView = function(name) {
              return this.views[name];
            };
            DataSet2.prototype.setView = function(name, view) {
              this.views[name] = view;
            };
            DataSet2.prototype.setState = function(name, value) {
              var _this = this;
              this.state[name] = value;
              if (this._onChangeTimer) {
                window.clearTimeout(this._onChangeTimer);
                this._onChangeTimer = null;
              }
              this._onChangeTimer = window.setTimeout(function() {
                _this.emit("statechange", name, value);
              }, 16);
            };
            DataSet2.CONSTANTS = constants_1.default;
            DataSet2.connectors = {};
            DataSet2.transforms = {};
            DataSet2.DataSet = DataSet2;
            DataSet2.DataView = view_1.View;
            DataSet2.View = view_1.View;
            DataSet2.version = "____DATASET_VERSION____";
            return DataSet2;
          }(wolfy87_eventemitter_1.default);
          exports2.DataSet = DataSet;
          util_1.assign(DataSet, constants_1.default);
          util_1.assign(DataSet.prototype, {
            view: DataSet.prototype.createView
          });
          view_1.View.DataSet = DataSet;
        },
        "./src/index.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          __webpack_require__("./src/api/geo.ts");
          __webpack_require__("./src/api/hierarchy.ts");
          __webpack_require__("./src/api/partition.ts");
          __webpack_require__("./src/api/statistics.ts");
          __webpack_require__("./src/connector/default.ts");
          __webpack_require__("./src/connector/dsv.ts");
          __webpack_require__("./src/connector/geo-graticule.ts");
          __webpack_require__("./src/connector/geojson.ts");
          __webpack_require__("./src/connector/graph.ts");
          __webpack_require__("./src/connector/hexjson.ts");
          __webpack_require__("./src/connector/hierarchy.ts");
          __webpack_require__("./src/connector/topojson.ts");
          __webpack_require__("./src/transform/default.ts");
          __webpack_require__("./src/transform/filter.ts");
          __webpack_require__("./src/transform/fold.ts");
          __webpack_require__("./src/transform/map.ts");
          __webpack_require__("./src/transform/partition.ts");
          __webpack_require__("./src/transform/percent.ts");
          __webpack_require__("./src/transform/pick.ts");
          __webpack_require__("./src/transform/proportion.ts");
          __webpack_require__("./src/transform/rename.ts");
          __webpack_require__("./src/transform/reverse.ts");
          __webpack_require__("./src/transform/sort.ts");
          __webpack_require__("./src/transform/sort-by.ts");
          __webpack_require__("./src/transform/subset.ts");
          __webpack_require__("./src/transform/fill-rows.ts");
          __webpack_require__("./src/transform/impute.ts");
          __webpack_require__("./src/transform/aggregate.ts");
          __webpack_require__("./src/transform/regression.ts");
          __webpack_require__("./src/transform/kde.ts");
          __webpack_require__("./src/transform/bin/hexagon.ts");
          __webpack_require__("./src/transform/bin/histogram.ts");
          __webpack_require__("./src/transform/bin/quantile.ts");
          __webpack_require__("./src/transform/bin/rectangle.ts");
          __webpack_require__("./src/transform/geo/centroid.ts");
          __webpack_require__("./src/transform/geo/projection.ts");
          __webpack_require__("./src/transform/geo/region.ts");
          __webpack_require__("./src/transform/diagram/arc.ts");
          __webpack_require__("./src/transform/diagram/dagre.ts");
          __webpack_require__("./src/transform/diagram/sankey.ts");
          __webpack_require__("./src/transform/diagram/voronoi.ts");
          __webpack_require__("./src/transform/hierarchy/cluster.ts");
          __webpack_require__("./src/transform/hierarchy/compact-box.ts");
          __webpack_require__("./src/transform/hierarchy/dendrogram.ts");
          __webpack_require__("./src/transform/hierarchy/indented.ts");
          __webpack_require__("./src/transform/hierarchy/pack.ts");
          __webpack_require__("./src/transform/hierarchy/partition.ts");
          __webpack_require__("./src/transform/hierarchy/tree.ts");
          __webpack_require__("./src/transform/hierarchy/treemap.ts");
          __webpack_require__("./src/transform/tag-cloud.ts");
          __webpack_require__("./src/transform/waffle.ts");
          __webpack_require__("./src/transform/kernel-smooth/density.ts");
          __webpack_require__("./src/transform/kernel-smooth/regression.ts");
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          module2.exports = data_set_1.DataSet;
        },
        "./src/transform/aggregate.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var tslib_1 = __webpack_require__("./node_modules/_tslib@2.1.0@tslib/tslib.js");
          var util_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js");
          var simpleStatistics = tslib_1.__importStar(__webpack_require__("./node_modules/_simple-statistics@6.1.1@simple-statistics/dist/simple-statistics.min.js"));
          var partition_1 = tslib_1.__importDefault(__webpack_require__("./src/util/partition.ts"));
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          var registerTransform = data_set_1.DataSet.registerTransform;
          var option_parser_1 = __webpack_require__("./src/util/option-parser.ts");
          var DEFAULT_OPTIONS = {
            as: [],
            fields: [],
            groupBy: [],
            operations: []
          };
          var DEFAULT_OPERATION = "count";
          var aggregates = {
            count: function(data) {
              return data.length;
            },
            distinct: function(data, field) {
              var values = util_1.uniq(data.map(function(row) {
                return row[field];
              }));
              return values.length;
            }
          };
          data_set_1.DataSet.CONSTANTS.STATISTICS_METHODS.forEach(function(method) {
            aggregates[method] = function(data, field) {
              var values = data.map(function(row) {
                return row[field];
              });
              if (util_1.isArray(values) && util_1.isArray(values[0])) {
                values = util_1.flattenDeep(values);
              }
              return simpleStatistics[method](values);
            };
          });
          aggregates.average = aggregates.mean;
          function transform(dataView, options) {
            options = util_1.assign({}, DEFAULT_OPTIONS, options);
            var fields = option_parser_1.getFields(options);
            if (!util_1.isArray(fields)) {
              throw new TypeError("Invalid fields: it must be an array with one or more strings!");
            }
            var outputNames = options.as || [];
            if (util_1.isString(outputNames)) {
              outputNames = [outputNames];
            }
            var operations = options.operations;
            if (util_1.isString(operations)) {
              operations = [operations];
            }
            var DEFAULT_OPERATIONS = [DEFAULT_OPERATION];
            if (!util_1.isArray(operations) || !operations.length) {
              console.warn('operations is not defined, will use [ "count" ] directly.');
              operations = DEFAULT_OPERATIONS;
              outputNames = operations;
            }
            if (!(operations.length === 1 && operations[0] === DEFAULT_OPERATION)) {
              if (operations.length !== fields.length) {
                throw new TypeError("Invalid operations: it's length must be the same as fields!");
              }
              if (outputNames.length !== fields.length) {
                throw new TypeError("Invalid as: it's length must be the same as fields!");
              }
            }
            var groups = partition_1.default(dataView.rows, options.groupBy);
            var results = [];
            util_1.forIn(groups, function(group) {
              var result = group[0];
              operations.forEach(function(operation, i) {
                var outputName = outputNames[i];
                var field = fields[i];
                result[outputName] = aggregates[operation](group, field);
              });
              results.push(result);
            });
            dataView.rows = results;
          }
          registerTransform("aggregate", transform);
          registerTransform("summary", transform);
          exports2.default = {
            VALID_AGGREGATES: util_1.keys(aggregates)
          };
        },
        "./src/transform/bin/hexagon.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var tslib_1 = __webpack_require__("./node_modules/_tslib@2.1.0@tslib/tslib.js");
          var util_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js");
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          var option_parser_1 = __webpack_require__("./src/util/option-parser.ts");
          var DEFAULT_OPTIONS = {
            as: ["x", "y", "count"],
            bins: [30, 30],
            offset: [0, 0],
            sizeByCount: false
          };
          var SQRT3 = Math.sqrt(3);
          var THIRD_PI = Math.PI / 3;
          var ANGLES = [0, THIRD_PI, 2 * THIRD_PI, 3 * THIRD_PI, 4 * THIRD_PI, 5 * THIRD_PI];
          function distance(x0, y0, x1, y1) {
            return Math.sqrt((x0 - x1) * (x0 - x1) + (y0 - y1) * (y0 - y1));
          }
          function nearestBinsCenters(value, scale, offset) {
            var temp = value - offset;
            scale = scale / 2;
            var div = Math.floor(temp / scale);
            var rounded = scale * (div + (Math.abs(div % 2) === 1 ? 1 : 0));
            var roundedScaled = scale * (div + (Math.abs(div % 2) === 1 ? 0 : 1));
            return [rounded + offset, roundedScaled + offset];
          }
          function generateBins(points, binWidth, offset) {
            if (binWidth === void 0) {
              binWidth = [1, 1];
            }
            if (offset === void 0) {
              offset = [0, 0];
            }
            var bins = {};
            var _a = tslib_1.__read(binWidth, 2), binWidthX = _a[0], binWidthY = _a[1];
            var _b = tslib_1.__read(offset, 2), offsetX = _b[0], offsetY = _b[1];
            points.forEach(function(point) {
              var _a2, _b2;
              var _c = tslib_1.__read(point, 2), x = _c[0], y = _c[1];
              var _d = tslib_1.__read(nearestBinsCenters(x, binWidthX, offsetX), 2), xRounded = _d[0], xRoundedScaled = _d[1];
              var _e = tslib_1.__read(nearestBinsCenters(y, binWidthY, offsetY), 2), yRounded = _e[0], yRoundedScaled = _e[1];
              var d1 = distance(x, y, xRounded, yRounded);
              var d2 = distance(x, y, xRoundedScaled, yRoundedScaled);
              var binKey;
              var binX;
              var binY;
              if (d1 < d2) {
                binKey = "x" + xRounded + "y" + yRounded;
                _a2 = tslib_1.__read([xRounded, yRounded], 2), binX = _a2[0], binY = _a2[1];
              } else {
                binKey = "x" + xRoundedScaled + "y" + yRoundedScaled;
                _b2 = tslib_1.__read([xRoundedScaled, yRoundedScaled], 2), binX = _b2[0], binY = _b2[1];
              }
              bins[binKey] = bins[binKey] || {
                x: binX,
                y: binY,
                count: 0
              };
              bins[binKey].count++;
            });
            return bins;
          }
          function transform(dataView, options) {
            options = util_1.assign({}, DEFAULT_OPTIONS, options);
            var fields = option_parser_1.getFields(options);
            if (!util_1.isArray(fields) || fields.length !== 2) {
              throw new TypeError("Invalid fields: it must be an array with 2 strings!");
            }
            var _a = tslib_1.__read(fields, 2), fieldX = _a[0], fieldY = _a[1];
            var rangeFieldX = dataView.range(fieldX);
            var rangeFieldY = dataView.range(fieldY);
            var widthX = rangeFieldX[1] - rangeFieldX[0];
            var widthY = rangeFieldY[1] - rangeFieldY[0];
            var binWidth = options.binWidth || [];
            if (binWidth.length !== 2) {
              var _b = tslib_1.__read(options.bins, 2), binsX = _b[0], binsY = _b[1];
              if (binsX <= 0 || binsY <= 0) {
                throw new TypeError("Invalid bins: must be an array with two positive numbers (e.g. [ 30, 30 ])!");
              }
              binWidth = [widthX / binsX, widthY / binsY];
            }
            var _c = tslib_1.__read(options.offset, 2), offsetX = _c[0], offsetY = _c[1];
            var yScale = 3 * binWidth[0] / (SQRT3 * binWidth[1]);
            var points = dataView.rows.map(function(row) {
              return [row[fieldX], yScale * row[fieldY]];
            });
            var bins = generateBins(points, [binWidth[0], yScale * binWidth[1]], [offsetX, yScale * offsetY]);
            var _d = tslib_1.__read(options.as, 3), asX = _d[0], asY = _d[1], asCount = _d[2];
            if (!asX || !asY || !asCount) {
              throw new TypeError('Invalid as: it must be an array with three elements (e.g. [ "x", "y", "count" ])!');
            }
            var radius = binWidth[0] / SQRT3;
            var hexagonPoints = ANGLES.map(function(angle) {
              return [Math.sin(angle) * radius, -Math.cos(angle) * radius];
            });
            var result = [];
            var maxCount = 0;
            if (options.sizeByCount) {
              util_1.forIn(bins, function(bin) {
                if (bin.count > maxCount) {
                  maxCount = bin.count;
                }
              });
            }
            util_1.forIn(bins, function(bin) {
              var x = bin.x, y = bin.y, count = bin.count;
              var row = {};
              row[asCount] = count;
              if (options.sizeByCount) {
                row[asX] = hexagonPoints.map(function(p) {
                  return x + bin.count / maxCount * p[0];
                });
                row[asY] = hexagonPoints.map(function(p) {
                  return (y + bin.count / maxCount * p[1]) / yScale;
                });
              } else {
                row[asX] = hexagonPoints.map(function(p) {
                  return x + p[0];
                });
                row[asY] = hexagonPoints.map(function(p) {
                  return (y + p[1]) / yScale;
                });
              }
              result.push(row);
            });
            dataView.rows = result;
          }
          data_set_1.DataSet.registerTransform("bin.hexagon", transform);
          data_set_1.DataSet.registerTransform("bin.hex", transform);
          data_set_1.DataSet.registerTransform("hexbin", transform);
        },
        "./src/transform/bin/histogram.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var tslib_1 = __webpack_require__("./node_modules/_tslib@2.1.0@tslib/tslib.js");
          var util_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js");
          var partition_1 = tslib_1.__importDefault(__webpack_require__("./src/util/partition.ts"));
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          var option_parser_1 = __webpack_require__("./src/util/option-parser.ts");
          var DEFAULT_OPTIONS = {
            as: ["x", "count"],
            bins: void 0,
            offset: 0,
            groupBy: []
          };
          function nearestBin(value, scale, offset) {
            var temp = value - offset;
            var div = Math.floor(temp / scale);
            return [div * scale + offset, (div + 1) * scale + offset];
          }
          function sturges(dataLength) {
            return Math.ceil(Math.log(dataLength) / Math.LN2) + 1;
          }
          function transform(dataView, options) {
            options = util_1.assign({}, DEFAULT_OPTIONS, options);
            var field = option_parser_1.getField(options);
            if (dataView.rows.length === 0) {
              return;
            }
            var range = dataView.range(field);
            var width = range[1] - range[0];
            var binWidth = options.binWidth;
            var bins = options.bins;
            if (!binWidth && bins) {
              if (bins <= 0) {
                throw new TypeError("Invalid bins: it must be a positive number!");
              }
              binWidth = width / bins;
            }
            if (!binWidth && !bins) {
              var binNumber = sturges(dataView.rows.length);
              binWidth = width / binNumber;
            }
            var offset = options.offset % binWidth;
            var rows = [];
            var groupBy = options.groupBy;
            var groups = partition_1.default(dataView.rows, groupBy);
            util_1.forIn(groups, function(group) {
              var bins2 = {};
              var column = group.map(function(row) {
                return row[field];
              });
              column.forEach(function(value) {
                var _a2 = tslib_1.__read(nearestBin(value, binWidth, offset), 2), x0 = _a2[0], x1 = _a2[1];
                var binKey = x0 + "-" + x1;
                bins2[binKey] = bins2[binKey] || {
                  x0,
                  x1,
                  count: 0
                };
                bins2[binKey].count++;
              });
              var _a = tslib_1.__read(options.as, 2), asX = _a[0], asCount = _a[1];
              if (!asX || !asCount) {
                throw new TypeError('Invalid as: it must be an array with 2 elements (e.g. [ "x", "count" ])!');
              }
              var meta = util_1.pick(group[0], groupBy);
              util_1.forIn(bins2, function(bin) {
                var row = util_1.assign({}, meta);
                row[asX] = [bin.x0, bin.x1];
                row[asCount] = bin.count;
                rows.push(row);
              });
            });
            dataView.rows = rows;
          }
          data_set_1.DataSet.registerTransform("bin.histogram", transform);
          data_set_1.DataSet.registerTransform("bin.dot", transform);
        },
        "./src/transform/bin/quantile.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var tslib_1 = __webpack_require__("./node_modules/_tslib@2.1.0@tslib/tslib.js");
          var util_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js");
          var simple_statistics_1 = __webpack_require__("./node_modules/_simple-statistics@6.1.1@simple-statistics/dist/simple-statistics.min.js");
          var partition_1 = tslib_1.__importDefault(__webpack_require__("./src/util/partition.ts"));
          var p_by_fraction_1 = tslib_1.__importDefault(__webpack_require__("./src/util/p-by-fraction.ts"));
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          var registerTransform = data_set_1.DataSet.registerTransform;
          var option_parser_1 = __webpack_require__("./src/util/option-parser.ts");
          var DEFAULT_OPTIONS = {
            as: "_bin",
            groupBy: [],
            fraction: 4
          };
          function transform(dataView, options) {
            options = util_1.assign({}, DEFAULT_OPTIONS, options);
            var field = option_parser_1.getField(options);
            var as = options.as;
            if (!util_1.isString(as)) {
              throw new TypeError('Invalid as: it must be a string (e.g. "_bin")!');
            }
            var pArray = options.p;
            var fraction = options.fraction;
            if (!util_1.isArray(pArray) || pArray.length === 0) {
              pArray = p_by_fraction_1.default(fraction);
            }
            var rows = dataView.rows;
            var groupBy = options.groupBy;
            var groups = partition_1.default(rows, groupBy);
            var result = [];
            util_1.forIn(groups, function(group) {
              var resultRow = group[0];
              var binningColumn = group.map(function(row) {
                return row[field];
              });
              var quantiles = pArray.map(function(p) {
                return simple_statistics_1.quantile(binningColumn, p);
              });
              resultRow[as] = quantiles;
              result.push(resultRow);
            });
            dataView.rows = result;
          }
          registerTransform("bin.quantile", transform);
        },
        "./src/transform/bin/rectangle.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var tslib_1 = __webpack_require__("./node_modules/_tslib@2.1.0@tslib/tslib.js");
          var util_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js");
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          var registerTransform = data_set_1.DataSet.registerTransform;
          var option_parser_1 = __webpack_require__("./src/util/option-parser.ts");
          var DEFAULT_OPTIONS = {
            as: ["x", "y", "count"],
            bins: [30, 30],
            offset: [0, 0],
            sizeByCount: false
          };
          function nearestBin(value, scale, offset) {
            var temp = value - offset;
            var div = Math.floor(temp / scale);
            return [div * scale + offset, (div + 1) * scale + offset];
          }
          function transform(dataView, options) {
            options = util_1.assign({}, DEFAULT_OPTIONS, options);
            var _a = tslib_1.__read(option_parser_1.getFields(options), 2), fieldX = _a[0], fieldY = _a[1];
            if (!fieldX || !fieldY) {
              throw new TypeError("Invalid fields: must be an array with 2 strings!");
            }
            var rangeFieldX = dataView.range(fieldX);
            var rangeFieldY = dataView.range(fieldY);
            var widthX = rangeFieldX[1] - rangeFieldX[0];
            var widthY = rangeFieldY[1] - rangeFieldY[0];
            var binWidth = options.binWidth || [];
            if (binWidth.length !== 2) {
              var _b = tslib_1.__read(options.bins, 2), binsX = _b[0], binsY = _b[1];
              if (binsX <= 0 || binsY <= 0) {
                throw new TypeError("Invalid bins: must be an array with 2 positive numbers (e.g. [ 30, 30 ])!");
              }
              binWidth = [widthX / binsX, widthY / binsY];
            }
            var points = dataView.rows.map(function(row) {
              return [row[fieldX], row[fieldY]];
            });
            var bins = {};
            var _c = tslib_1.__read(options.offset, 2), offsetX = _c[0], offsetY = _c[1];
            points.forEach(function(point) {
              var _a2 = tslib_1.__read(nearestBin(point[0], binWidth[0], offsetX), 2), x0 = _a2[0], x1 = _a2[1];
              var _b2 = tslib_1.__read(nearestBin(point[1], binWidth[1], offsetY), 2), y0 = _b2[0], y1 = _b2[1];
              var binKey = x0 + "-" + x1 + "-" + y0 + "-" + y1;
              bins[binKey] = bins[binKey] || {
                x0,
                x1,
                y0,
                y1,
                count: 0
              };
              bins[binKey].count++;
            });
            var rows = [];
            var _d = tslib_1.__read(options.as, 3), asX = _d[0], asY = _d[1], asCount = _d[2];
            if (!asX || !asY || !asCount) {
              throw new TypeError('Invalid as: it must be an array with 3 strings (e.g. [ "x", "y", "count" ])!');
            }
            if (!options.sizeByCount) {
              util_1.forIn(bins, function(bin) {
                var row = {};
                row[asX] = [bin.x0, bin.x1, bin.x1, bin.x0];
                row[asY] = [bin.y0, bin.y0, bin.y1, bin.y1];
                row[asCount] = bin.count;
                rows.push(row);
              });
            } else {
              var maxCount_1 = 0;
              util_1.forIn(bins, function(bin) {
                if (bin.count > maxCount_1) {
                  maxCount_1 = bin.count;
                }
              });
              util_1.forIn(bins, function(bin) {
                var x0 = bin.x0, x1 = bin.x1, y0 = bin.y0, y1 = bin.y1, count = bin.count;
                var scale = count / maxCount_1;
                var _a2 = tslib_1.__read([(x0 + x1) / 2, (y0 + y1) / 2], 2), cx = _a2[0], cy = _a2[1];
                var rx = (x1 - x0) * scale / 2;
                var ry = (y1 - y0) * scale / 2;
                var x01 = cx - rx;
                var x11 = cx + rx;
                var y01 = cy - ry;
                var y11 = cy + ry;
                var row = {};
                row[asX] = [x01, x11, x11, x01];
                row[asY] = [y01, y01, y11, y11];
                row[asCount] = count;
                rows.push(row);
              });
            }
            dataView.rows = rows;
          }
          registerTransform("bin.rectangle", transform);
          registerTransform("bin.rect", transform);
        },
        "./src/transform/default.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          data_set_1.DataSet.registerTransform("default", function(dataView) {
            return dataView;
          });
        },
        "./src/transform/diagram/arc.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var util_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js");
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          var DEFAULT_OPTIONS = {
            y: 0,
            thickness: 0.05,
            weight: false,
            marginRatio: 0.1,
            id: function(node) {
              return node.id;
            },
            source: function(edge) {
              return edge.source;
            },
            target: function(edge) {
              return edge.target;
            },
            sourceWeight: function(edge) {
              return edge.value || 1;
            },
            targetWeight: function(edge) {
              return edge.value || 1;
            },
            sortBy: null
          };
          function _nodesFromEdges(edges, options, map) {
            if (map === void 0) {
              map = {};
            }
            edges.forEach(function(edge) {
              var sId = options.edgeSource(edge);
              var tId = options.edgeTarget(edge);
              if (!map[sId]) {
                map[sId] = {
                  id: sId
                };
              }
              if (!map[tId]) {
                map[tId] = {
                  id: tId
                };
              }
            });
            return util_1.values(map);
          }
          function _processGraph(nodeById, edges, options) {
            util_1.forIn(nodeById, function(node, id) {
              node.inEdges = edges.filter(function(edge) {
                return "" + options.target(edge) === "" + id;
              });
              node.outEdges = edges.filter(function(edge) {
                return "" + options.source(edge) === "" + id;
              });
              node.edges = node.outEdges.concat(node.inEdges);
              node.frequency = node.edges.length;
              node.value = 0;
              node.inEdges.forEach(function(edge) {
                node.value += options.targetWeight(edge);
              });
              node.outEdges.forEach(function(edge) {
                node.value += options.sourceWeight(edge);
              });
            });
          }
          function _sortNodes(nodes, options) {
            var sortMethods = {
              weight: function(a, b) {
                return b.value - a.value;
              },
              frequency: function(a, b) {
                return b.frequency - a.frequency;
              },
              id: function(a, b) {
                return ("" + options.id(a)).localeCompare("" + options.id(b));
              }
            };
            var method = sortMethods[options.sortBy];
            if (!method && util_1.isFunction(options.sortBy)) {
              method = options.sortBy;
            }
            if (method) {
              nodes.sort(method);
            }
          }
          function _layoutNodes(nodes, options) {
            var len = nodes.length;
            if (!len) {
              throw new TypeError("Invalid nodes: it's empty!");
            }
            if (options.weight) {
              var marginRatio_1 = options.marginRatio;
              if (marginRatio_1 < 0 || marginRatio_1 >= 1) {
                throw new TypeError("Invalid marginRatio: it must be in range [0, 1)!");
              }
              var margin_1 = marginRatio_1 / (2 * len);
              var thickness_1 = options.thickness;
              if (thickness_1 <= 0 || thickness_1 >= 1) {
                throw new TypeError("Invalid thickness: it must be in range (0, 1)!");
              }
              var totalValue_1 = 0;
              nodes.forEach(function(node) {
                totalValue_1 += node.value;
              });
              nodes.forEach(function(node) {
                node.weight = node.value / totalValue_1;
                node.width = node.weight * (1 - marginRatio_1);
                node.height = thickness_1;
              });
              nodes.forEach(function(node, index) {
                var deltaX = 0;
                for (var i = index - 1; i >= 0; i--) {
                  deltaX += nodes[i].width + 2 * margin_1;
                }
                var minX = node.minX = margin_1 + deltaX;
                var maxX = node.maxX = node.minX + node.width;
                var minY = node.minY = options.y - thickness_1 / 2;
                var maxY = node.maxY = minY + thickness_1;
                node.x = [minX, maxX, maxX, minX];
                node.y = [minY, minY, maxY, maxY];
              });
            } else {
              var deltaX_1 = 1 / len;
              nodes.forEach(function(node, index) {
                node.x = (index + 0.5) * deltaX_1;
                node.y = options.y;
              });
            }
          }
          function _locatingEdges(nodeById, edges, options) {
            if (options.weight) {
              var valueById_1 = {};
              util_1.forIn(nodeById, function(node, id) {
                valueById_1[id] = node.value;
              });
              edges.forEach(function(edge) {
                var sId = options.source(edge);
                var tId = options.target(edge);
                var sNode = nodeById[sId];
                var tNode = nodeById[tId];
                if (sNode && tNode) {
                  var sValue = valueById_1[sId];
                  var currentSValue = options.sourceWeight(edge);
                  var sStart = sNode.minX + (sNode.value - sValue) / sNode.value * sNode.width;
                  var sEnd = sStart + currentSValue / sNode.value * sNode.width;
                  valueById_1[sId] -= currentSValue;
                  var tValue = valueById_1[tId];
                  var currentTValue = options.targetWeight(edge);
                  var tStart = tNode.minX + (tNode.value - tValue) / tNode.value * tNode.width;
                  var tEnd = tStart + currentTValue / tNode.value * tNode.width;
                  valueById_1[tId] -= currentTValue;
                  var y = options.y;
                  edge.x = [sStart, sEnd, tStart, tEnd];
                  edge.y = [y, y, y, y];
                }
              });
            } else {
              edges.forEach(function(edge) {
                var sNode = nodeById[options.source(edge)];
                var tNode = nodeById[options.target(edge)];
                if (sNode && tNode) {
                  edge.x = [sNode.x, tNode.x];
                  edge.y = [sNode.y, tNode.y];
                }
              });
            }
          }
          function transform(dv, options) {
            options = util_1.assign({}, DEFAULT_OPTIONS, options);
            var nodeById = {};
            var nodes = dv.nodes;
            var edges = dv.edges;
            if (!util_1.isArray(nodes) || nodes.length === 0) {
              nodes = _nodesFromEdges(edges, options, nodeById);
            }
            nodes.forEach(function(node) {
              var id = options.id(node);
              nodeById[id] = node;
            });
            _processGraph(nodeById, edges, options);
            _sortNodes(nodes, options);
            _layoutNodes(nodes, options);
            _locatingEdges(nodeById, edges, options);
            dv.nodes = nodes;
            dv.edges = edges;
          }
          data_set_1.DataSet.registerTransform("diagram.arc", transform);
          data_set_1.DataSet.registerTransform("arc", transform);
        },
        "./src/transform/diagram/dagre.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var tslib_1 = __webpack_require__("./node_modules/_tslib@2.1.0@tslib/tslib.js");
          var util_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js");
          var dagre_1 = tslib_1.__importDefault(__webpack_require__("./node_modules/_dagre@0.8.5@dagre/index.js"));
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          var DEFAULT_OPTIONS = {
            rankdir: "TB",
            align: "TB",
            nodesep: 50,
            edgesep: 10,
            ranksep: 50,
            source: function(edge) {
              return edge.source;
            },
            target: function(edge) {
              return edge.target;
            }
          };
          function transform(dv, options) {
            options = util_1.assign({}, DEFAULT_OPTIONS, options);
            var g = new dagre_1.default.graphlib.Graph();
            g.setGraph({});
            g.setDefaultEdgeLabel(function() {
              return {};
            });
            dv.nodes.forEach(function(node) {
              var nodeId = options.nodeId ? options.nodeId(node) : node.id;
              if (!node.height && !node.width) {
                node.height = node.width = options.edgesep;
              }
              g.setNode(nodeId, node);
            });
            dv.edges.forEach(function(edge) {
              g.setEdge(options.source(edge), options.target(edge));
            });
            dagre_1.default.layout(g);
            var nodes = [];
            var edges = [];
            g.nodes().forEach(function(node) {
              var n = g.node(node);
              var x = n.x, y = n.y, height = n.height, width = n.width;
              n.x = [x - width / 2, x + width / 2, x + width / 2, x - width / 2];
              n.y = [y + height / 2, y + height / 2, y - height / 2, y - height / 2];
              nodes.push(n);
            });
            g.edges().forEach(function(edge) {
              var points = g.edge(edge).points;
              var e = {};
              e.x = points.map(function(p) {
                return p.x;
              });
              e.y = points.map(function(p) {
                return p.y;
              });
              edges.push(e);
            });
            dv.nodes = nodes;
            dv.edges = edges;
          }
          data_set_1.DataSet.registerTransform("diagram.dagre", transform);
          data_set_1.DataSet.registerTransform("dagre", transform);
        },
        "./src/transform/diagram/sankey.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var util_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js");
          var d3_sankey_1 = __webpack_require__("./node_modules/_d3-sankey@0.9.1@d3-sankey/dist/d3-sankey.js");
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          var ALIGN_METHOD = {
            sankeyLeft: d3_sankey_1.sankeyLeft,
            sankeyRight: d3_sankey_1.sankeyRight,
            sankeyCenter: d3_sankey_1.sankeyCenter,
            sankeyJustify: d3_sankey_1.sankeyJustify
          };
          var DEFAULT_OPTIONS = {
            value: function(node) {
              return node.value;
            },
            source: function(edge) {
              return edge.source;
            },
            target: function(edge) {
              return edge.target;
            },
            nodeAlign: "sankeyJustify",
            nodeWidth: 0.02,
            nodePadding: 0.02,
            sort: void 0
          };
          function transform(dv, options) {
            options = util_1.assign({}, DEFAULT_OPTIONS, options);
            var nodeAlign = null;
            if (util_1.isString(options.nodeAlign)) {
              nodeAlign = ALIGN_METHOD[options.nodeAlign];
            } else if (util_1.isFunction(options.nodeAlign)) {
              nodeAlign = options.nodeAlign;
            }
            var sankeyProcessor = d3_sankey_1.sankey().nodeSort(options.sort).links(function(d) {
              return d.edges;
            }).nodeWidth(options.nodeWidth).nodePadding(options.nodePadding).extent([
              [0, 0],
              [1, 1]
            ]);
            if (util_1.isFunction(options.nodeId)) {
              sankeyProcessor.nodeId(options.nodeId);
            }
            if (nodeAlign) {
              sankeyProcessor.nodeAlign(nodeAlign);
            }
            sankeyProcessor(dv);
            dv.nodes.forEach(function(node) {
              var x0 = node.x0, x1 = node.x1, y0 = node.y0, y1 = node.y1;
              node.x = [x0, x1, x1, x0];
              node.y = [y0, y0, y1, y1];
            });
            dv.edges.forEach(function(edge) {
              var source = edge.source, target = edge.target;
              var sx = source.x1;
              var tx = target.x0;
              edge.x = [sx, sx, tx, tx];
              var offset = edge.width / 2;
              edge.y = [edge.y0 + offset, edge.y0 - offset, edge.y1 + offset, edge.y1 - offset];
            });
          }
          data_set_1.DataSet.registerTransform("diagram.sankey", transform);
          data_set_1.DataSet.registerTransform("sankey", transform);
        },
        "./src/transform/diagram/voronoi.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var tslib_1 = __webpack_require__("./node_modules/_tslib@2.1.0@tslib/tslib.js");
          var d3Voronoi = tslib_1.__importStar(__webpack_require__("./node_modules/_d3-voronoi@1.1.4@d3-voronoi/dist/d3-voronoi.js"));
          var util_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js");
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          var registerTransform = data_set_1.DataSet.registerTransform;
          var option_parser_1 = __webpack_require__("./src/util/option-parser.ts");
          var DEFAULT_OPTIONS = {
            as: ["_x", "_y"]
          };
          function transform(dataView, options) {
            options = util_1.assign({}, DEFAULT_OPTIONS, options);
            var as = options.as;
            if (!util_1.isArray(as) || as.length !== 2) {
              throw new TypeError("Invalid as: must be an array with two strings!");
            }
            var xField = as[0];
            var yField = as[1];
            var fields = option_parser_1.getFields(options);
            if (!util_1.isArray(fields) || fields.length !== 2) {
              throw new TypeError("Invalid fields: must be an array with two strings!");
            }
            var x = fields[0];
            var y = fields[1];
            var rows = dataView.rows;
            var data = rows.map(function(row) {
              return [row[x], row[y]];
            });
            var voronoi = d3Voronoi.voronoi();
            if (options.extend) {
              voronoi.extent(options.extend);
            }
            if (options.size) {
              voronoi.size(options.size);
            }
            var polygons = voronoi(data).polygons();
            rows.forEach(function(row, i) {
              var polygon = polygons[i].filter(function(point) {
                return !!point;
              });
              row[xField] = polygon.map(function(point) {
                return point[0];
              });
              row[yField] = polygon.map(function(point) {
                return point[1];
              });
            });
          }
          registerTransform("diagram.voronoi", transform);
          registerTransform("voronoi", transform);
        },
        "./src/transform/fill-rows.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var tslib_1 = __webpack_require__("./node_modules/_tslib@2.1.0@tslib/tslib.js");
          var util_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js");
          var partition_1 = tslib_1.__importDefault(__webpack_require__("./src/util/partition.ts"));
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          var DEFAULT_OPTIONS = {
            fillBy: "group",
            groupBy: [],
            orderBy: []
          };
          function arrayDifference(arr1, arr2) {
            var shadow = arr1.map(function(item) {
              return item;
            });
            arr2.forEach(function(item) {
              var index = shadow.indexOf(item);
              if (index > -1) {
                shadow.splice(index, 1);
              }
            });
            return shadow;
          }
          function transform(dataView, options) {
            options = util_1.assign({}, DEFAULT_OPTIONS, options);
            var rows = dataView.rows;
            var groupBy = options.groupBy;
            var orderBy = options.orderBy;
            var groups = partition_1.default(rows, groupBy, orderBy);
            var maxLength = 0;
            var referenceGroup = [];
            util_1.forIn(groups, function(group) {
              if (group.length > maxLength) {
                maxLength = group.length;
                referenceGroup = group;
              }
            });
            var referenceOrderByKeys = [];
            var referenceRowByOrderByKey = {};
            referenceGroup.forEach(function(row) {
              var key = orderBy.map(function(col) {
                return row[col];
              }).join("-");
              referenceOrderByKeys.push(key);
              referenceRowByOrderByKey[key] = row;
            });
            if (options.fillBy === "order") {
              var first_1 = referenceGroup[0];
              var allOrderByKeys_1 = [];
              var rowByOrderByKey_1 = {};
              rows.forEach(function(row) {
                var key = orderBy.map(function(col) {
                  return row[col];
                }).join("-");
                if (allOrderByKeys_1.indexOf(key) === -1) {
                  allOrderByKeys_1.push(key);
                  rowByOrderByKey_1[key] = row;
                }
              });
              var _missingOrderByKeys = arrayDifference(allOrderByKeys_1, referenceOrderByKeys);
              _missingOrderByKeys.forEach(function(key) {
                var row = {};
                groupBy.forEach(function(col) {
                  row[col] = first_1[col];
                });
                orderBy.forEach(function(col) {
                  row[col] = rowByOrderByKey_1[key][col];
                });
                rows.push(row);
                referenceGroup.push(row);
                referenceOrderByKeys.push(key);
                referenceRowByOrderByKey[key] = row;
              });
              maxLength = referenceGroup.length;
            }
            util_1.forIn(groups, function(group) {
              if (group !== referenceGroup && group.length < maxLength) {
                var first_2 = group[0];
                var orderByKeys_1 = [];
                group.forEach(function(row) {
                  orderByKeys_1.push(orderBy.map(function(col) {
                    return row[col];
                  }).join("-"));
                });
                var missingOrderByKeys = arrayDifference(referenceOrderByKeys, orderByKeys_1);
                missingOrderByKeys.some(function(key, i) {
                  if (i >= maxLength - group.length) {
                    return true;
                  }
                  var referenceRow = referenceRowByOrderByKey[key];
                  var row = {};
                  groupBy.forEach(function(col) {
                    row[col] = first_2[col];
                  });
                  orderBy.forEach(function(col) {
                    row[col] = referenceRow[col];
                  });
                  rows.push(row);
                  return false;
                });
              }
            });
          }
          data_set_1.DataSet.registerTransform("fill-rows", transform);
          data_set_1.DataSet.registerTransform("fillRows", transform);
        },
        "./src/transform/filter.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          function defaultCallback(row) {
            return !!row;
          }
          data_set_1.DataSet.registerTransform("filter", function(dataView, options) {
            dataView.rows = dataView.rows.filter(options.callback || defaultCallback);
          });
        },
        "./src/transform/fold.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var util_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js");
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          var option_parser_1 = __webpack_require__("./src/util/option-parser.ts");
          var DEFAULT_OPTIONS = {
            fields: [],
            key: "key",
            retains: [],
            value: "value"
          };
          data_set_1.DataSet.registerTransform("fold", function(dataView, options) {
            var columns = dataView.getColumnNames();
            options = util_1.assign({}, DEFAULT_OPTIONS, options);
            var fields = option_parser_1.getFields(options);
            if (fields.length === 0) {
              console.warn("warning: option fields is not specified, will fold all columns.");
              fields = columns;
            }
            var key = options.key;
            var value = options.value;
            var retains = options.retains;
            if (!retains || retains.length === 0) {
              retains = util_1.difference(columns, fields);
            }
            var resultRows = [];
            dataView.rows.forEach(function(row) {
              fields.forEach(function(field) {
                var resultRow = util_1.pick(row, retains);
                resultRow[key] = field;
                resultRow[value] = row[field];
                resultRows.push(resultRow);
              });
            });
            dataView.rows = resultRows;
          });
        },
        "./src/transform/geo/centroid.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var util_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js");
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          var registerTransform = data_set_1.DataSet.registerTransform;
          var option_parser_1 = __webpack_require__("./src/util/option-parser.ts");
          var DEFAULT_OPTIONS = {
            as: ["_centroid_x", "_centroid_y"]
          };
          function transform(view, options) {
            options = util_1.assign({}, DEFAULT_OPTIONS, options);
            var field = option_parser_1.getField(options);
            var geoView = options.geoView || options.geoDataView;
            if (util_1.isString(geoView) && view.dataSet) {
              geoView = view.dataSet.getView(geoView);
            }
            if (!geoView || geoView.dataType !== "geo") {
              throw new TypeError("Invalid geoView: must be a DataView of GEO dataType!");
            }
            var as = options.as;
            if (!util_1.isArray(as) || as.length !== 2) {
              throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ "cX", "cY" ])!');
            }
            var centroidX = as[0];
            var centroidY = as[1];
            view.rows.forEach(function(row) {
              var feature = geoView.geoFeatureByName(row[field]);
              if (feature) {
                if (geoView._projectedAs) {
                  row[centroidX] = feature[geoView._projectedAs[2]];
                  row[centroidY] = feature[geoView._projectedAs[3]];
                } else {
                  row[centroidX] = feature.centroidX;
                  row[centroidY] = feature.centroidY;
                }
              }
            });
          }
          registerTransform("geo.centroid", transform);
        },
        "./src/transform/geo/projection.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var tslib_1 = __webpack_require__("./node_modules/_tslib@2.1.0@tslib/tslib.js");
          var util_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js");
          var d3_geo_1 = __webpack_require__("./node_modules/_d3-geo@1.6.4@d3-geo/build/d3-geo.js");
          var point_at_length_1 = tslib_1.__importDefault(__webpack_require__("./node_modules/_point-at-length@1.1.0@point-at-length/index.js"));
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          var registerTransform = data_set_1.DataSet.registerTransform;
          var get_geo_projection_1 = tslib_1.__importDefault(__webpack_require__("./src/util/get-geo-projection.ts"));
          var DEFAULT_OPTIONS = {
            as: ["_x", "_y", "_centroid_x", "_centroid_y"]
          };
          function transform(dataView, options) {
            if (dataView.dataType !== "geo" && dataView.dataType !== "geo-graticule") {
              throw new TypeError("Invalid dataView: this transform is for Geo data only!");
            }
            options = util_1.assign({}, DEFAULT_OPTIONS, options);
            var projection = options.projection;
            if (!projection) {
              throw new TypeError("Invalid projection!");
            }
            projection = get_geo_projection_1.default(projection);
            var geoPathGenerator = d3_geo_1.geoPath(projection);
            var as = options.as;
            if (!util_1.isArray(as) || as.length !== 4) {
              throw new TypeError('Invalid as: it must be an array with 4 strings (e.g. [ "x", "y", "cX", "cY" ])!');
            }
            dataView._projectedAs = as;
            var _a = tslib_1.__read(as, 4), lonField = _a[0], latField = _a[1], centroidX = _a[2], centroidY = _a[3];
            dataView.rows.forEach(function(row) {
              row[lonField] = [];
              row[latField] = [];
              var pathData = geoPathGenerator(row);
              if (pathData) {
                var points = point_at_length_1.default(pathData);
                points._path.forEach(function(point) {
                  row[lonField].push(point[1]);
                  row[latField].push(point[2]);
                });
                var centroid = geoPathGenerator.centroid(row);
                row[centroidX] = centroid[0];
                row[centroidY] = centroid[1];
              }
            });
            dataView.rows = dataView.rows.filter(function(row) {
              return row[lonField].length !== 0;
            });
          }
          registerTransform("geo.projection", transform);
        },
        "./src/transform/geo/region.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var util_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js");
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          var registerTransform = data_set_1.DataSet.registerTransform;
          var option_parser_1 = __webpack_require__("./src/util/option-parser.ts");
          var DEFAULT_OPTIONS = {
            as: ["_x", "_y"]
          };
          function transform(view, options) {
            options = util_1.assign({}, DEFAULT_OPTIONS, options);
            var field = option_parser_1.getField(options);
            var geoView = options.geoView || options.geoDataView;
            if (util_1.isString(geoView)) {
              geoView = view.dataSet.getView(geoView);
            }
            if (!geoView || geoView.dataType !== "geo") {
              throw new TypeError("Invalid geoView: must be a DataView of GEO dataType!");
            }
            var as = options.as;
            if (!util_1.isArray(as) || as.length !== 2) {
              throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ "x", "y" ])!');
            }
            var lonField = as[0];
            var latField = as[1];
            view.rows.forEach(function(row) {
              var feature = geoView.geoFeatureByName(row[field]);
              if (feature) {
                if (geoView._projectedAs) {
                  row[lonField] = feature[geoView._projectedAs[0]];
                  row[latField] = feature[geoView._projectedAs[1]];
                } else {
                  row[lonField] = feature.longitude;
                  row[latField] = feature.latitude;
                }
              }
            });
          }
          registerTransform("geo.region", transform);
        },
        "./src/transform/hierarchy/cluster.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var tslib_1 = __webpack_require__("./node_modules/_tslib@2.1.0@tslib/tslib.js");
          var d3Hierarchy = tslib_1.__importStar(__webpack_require__("./node_modules/_d3-hierarchy@1.1.9@d3-hierarchy/dist/d3-hierarchy.js"));
          var util_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js");
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          var option_parser_1 = __webpack_require__("./src/util/option-parser.ts");
          var DEFAULT_OPTIONS = {
            field: "value",
            size: [1, 1],
            nodeSize: null,
            separation: null,
            as: ["x", "y"]
          };
          function transform(dataView, options) {
            if (dataView.dataType !== data_set_1.DataSet.CONSTANTS.HIERARCHY || !dataView.root) {
              throw new TypeError("Invalid DataView: This transform is for Hierarchy data only!");
            }
            var root = dataView.root;
            options = util_1.assign({}, DEFAULT_OPTIONS, options);
            var as = options.as;
            if (!util_1.isArray(as) || as.length !== 2) {
              throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ "x", "y" ])!');
            }
            var field = void 0;
            try {
              field = option_parser_1.getField(options);
            } catch (e) {
              console.warn(e);
            }
            if (field) {
              root.sum(function(d) {
                return d[field];
              });
            }
            var clusterLayout = d3Hierarchy.cluster();
            clusterLayout.size(options.size);
            if (options.nodeSize) {
              clusterLayout.nodeSize(options.nodeSize);
            }
            if (options.separation) {
              clusterLayout.separation(options.separation);
            }
            clusterLayout(root);
            var x = as[0];
            var y = as[1];
            root.each(function(node) {
              node[x] = node.x;
              node[y] = node.y;
            });
          }
          data_set_1.DataSet.registerTransform("hierarchy.cluster", transform);
          data_set_1.DataSet.registerTransform("dendrogram", transform);
        },
        "./src/transform/hierarchy/compact-box.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var tslib_1 = __webpack_require__("./node_modules/_tslib@2.1.0@tslib/tslib.js");
          var hierarchy_1 = tslib_1.__importDefault(__webpack_require__("./node_modules/_@antv_hierarchy@0.6.6@@antv/hierarchy/build/hierarchy.js"));
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          var DEFAULT_OPTIONS = {};
          function transform(dataView, options) {
            var root = dataView.root;
            options = Object.assign({}, DEFAULT_OPTIONS, options);
            if (dataView.dataType !== data_set_1.DataSet.CONSTANTS.HIERARCHY) {
              throw new TypeError("Invalid DataView: This transform is for Hierarchy data only!");
            }
            dataView.root = hierarchy_1.default.compactBox(root, options);
          }
          data_set_1.DataSet.registerTransform("hierarchy.compact-box", transform);
          data_set_1.DataSet.registerTransform("compact-box-tree", transform);
          data_set_1.DataSet.registerTransform("non-layered-tidy-tree", transform);
          data_set_1.DataSet.registerTransform("mindmap-logical", transform);
        },
        "./src/transform/hierarchy/dendrogram.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var tslib_1 = __webpack_require__("./node_modules/_tslib@2.1.0@tslib/tslib.js");
          var hierarchy_1 = tslib_1.__importDefault(__webpack_require__("./node_modules/_@antv_hierarchy@0.6.6@@antv/hierarchy/build/hierarchy.js"));
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          var DEFAULT_OPTIONS = {};
          function transform(dataView, options) {
            var root = dataView.root;
            options = Object.assign({}, DEFAULT_OPTIONS, options);
            if (dataView.dataType !== data_set_1.DataSet.CONSTANTS.HIERARCHY) {
              throw new TypeError("Invalid DataView: This transform is for Hierarchy data only!");
            }
            dataView.root = hierarchy_1.default.dendrogram(root, options);
          }
          data_set_1.DataSet.registerTransform("hierarchy.dendrogram", transform);
          data_set_1.DataSet.registerTransform("dendrogram", transform);
        },
        "./src/transform/hierarchy/indented.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var tslib_1 = __webpack_require__("./node_modules/_tslib@2.1.0@tslib/tslib.js");
          var hierarchy_1 = tslib_1.__importDefault(__webpack_require__("./node_modules/_@antv_hierarchy@0.6.6@@antv/hierarchy/build/hierarchy.js"));
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          var DEFAULT_OPTIONS = {};
          function transform(dataView, options) {
            var root = dataView.root;
            options = Object.assign({}, DEFAULT_OPTIONS, options);
            if (dataView.dataType !== data_set_1.DataSet.CONSTANTS.HIERARCHY) {
              throw new TypeError("Invalid DataView: This transform is for Hierarchy data only!");
            }
            dataView.root = hierarchy_1.default.indented(root, options);
          }
          data_set_1.DataSet.registerTransform("hierarchy.indented", transform);
          data_set_1.DataSet.registerTransform("indented-tree", transform);
        },
        "./src/transform/hierarchy/pack.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var tslib_1 = __webpack_require__("./node_modules/_tslib@2.1.0@tslib/tslib.js");
          var util_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js");
          var d3Hierarchy = tslib_1.__importStar(__webpack_require__("./node_modules/_d3-hierarchy@1.1.9@d3-hierarchy/dist/d3-hierarchy.js"));
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          var option_parser_1 = __webpack_require__("./src/util/option-parser.ts");
          var DEFAULT_OPTIONS = {
            field: "value",
            size: [1, 1],
            padding: 0,
            as: ["x", "y", "r"]
          };
          function transform(dataView, options) {
            if (dataView.dataType !== data_set_1.DataSet.CONSTANTS.HIERARCHY) {
              throw new TypeError("Invalid DataView: This transform is for Hierarchy data only!");
            }
            var root = dataView.root;
            options = util_1.assign({}, DEFAULT_OPTIONS, options);
            var as = options.as;
            if (!util_1.isArray(as) || as.length !== 3) {
              throw new TypeError('Invalid as: it must be an array with 3 strings (e.g. [ "x", "y", "r" ])!');
            }
            var field;
            try {
              field = option_parser_1.getField(options);
            } catch (e) {
              console.warn(e);
            }
            if (field) {
              root.sum(function(d) {
                return d[field];
              }).sort(function(a, b) {
                return b[field] - a[field];
              });
            }
            var packLayout = d3Hierarchy.pack();
            packLayout.size(options.size);
            if (options.padding) {
              packLayout.padding(options.padding);
            }
            packLayout(root);
            var x = as[0];
            var y = as[1];
            var r = as[2];
            root.each(function(node) {
              node[x] = node.x;
              node[y] = node.y;
              node[r] = node.r;
            });
          }
          data_set_1.DataSet.registerTransform("hierarchy.pack", transform);
          data_set_1.DataSet.registerTransform("hierarchy.circle-packing", transform);
          data_set_1.DataSet.registerTransform("circle-packing", transform);
        },
        "./src/transform/hierarchy/partition.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var tslib_1 = __webpack_require__("./node_modules/_tslib@2.1.0@tslib/tslib.js");
          var d3Hierarchy = tslib_1.__importStar(__webpack_require__("./node_modules/_d3-hierarchy@1.1.9@d3-hierarchy/dist/d3-hierarchy.js"));
          var util_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js");
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          var option_parser_1 = __webpack_require__("./src/util/option-parser.ts");
          var DEFAULT_OPTIONS = {
            field: "value",
            size: [1, 1],
            round: false,
            padding: 0,
            sort: true,
            as: ["x", "y"]
          };
          function transform(dataView, options) {
            if (dataView.dataType !== data_set_1.DataSet.CONSTANTS.HIERARCHY) {
              throw new TypeError("Invalid DataView: This transform is for Hierarchy data only!");
            }
            var root = dataView.root;
            options = util_1.assign({}, DEFAULT_OPTIONS, options);
            var as = options.as;
            if (!util_1.isArray(as) || as.length !== 2) {
              throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ "x", "y" ])!');
            }
            var field;
            try {
              field = option_parser_1.getField(options);
            } catch (e) {
              console.warn(e);
            }
            if (field) {
              root.sum(function(d) {
                return d[field];
              });
            }
            var partitionLayout = d3Hierarchy.partition();
            partitionLayout.size(options.size).round(options.round).padding(options.padding);
            partitionLayout(root);
            var x = as[0];
            var y = as[1];
            root.each(function(node) {
              node[x] = [node.x0, node.x1, node.x1, node.x0];
              node[y] = [node.y1, node.y1, node.y0, node.y0];
              ["x0", "x1", "y0", "y1"].forEach(function(prop) {
                if (as.indexOf(prop) === -1) {
                  delete node[prop];
                }
              });
            });
          }
          data_set_1.DataSet.registerTransform("hierarchy.partition", transform);
          data_set_1.DataSet.registerTransform("adjacency", transform);
        },
        "./src/transform/hierarchy/tree.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var tslib_1 = __webpack_require__("./node_modules/_tslib@2.1.0@tslib/tslib.js");
          var d3Hierarchy = tslib_1.__importStar(__webpack_require__("./node_modules/_d3-hierarchy@1.1.9@d3-hierarchy/dist/d3-hierarchy.js"));
          var util_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js");
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          var option_parser_1 = __webpack_require__("./src/util/option-parser.ts");
          var DEFAULT_OPTIONS = {
            field: "value",
            size: [1, 1],
            nodeSize: null,
            separation: null,
            as: ["x", "y"]
          };
          function transform(dataView, options) {
            if (dataView.dataType !== data_set_1.DataSet.CONSTANTS.HIERARCHY) {
              throw new TypeError("Invalid DataView: This transform is for Hierarchy data only!");
            }
            var root = dataView.root;
            options = util_1.assign({}, DEFAULT_OPTIONS, options);
            var as = options.as;
            if (!util_1.isArray(as) || as.length !== 2) {
              throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ "x", "y" ])!');
            }
            var field;
            try {
              field = option_parser_1.getField(options);
            } catch (e) {
              console.warn(e);
            }
            if (field) {
              root.sum(function(d) {
                return d[field];
              });
            }
            var treeLayout = d3Hierarchy.tree();
            treeLayout.size(options.size);
            if (options.nodeSize) {
              treeLayout.nodeSize(options.nodeSize);
            }
            if (options.separation) {
              treeLayout.separation(options.separation);
            }
            treeLayout(root);
            var x = as[0];
            var y = as[1];
            root.each(function(node) {
              node[x] = node.x;
              node[y] = node.y;
            });
          }
          data_set_1.DataSet.registerTransform("hierarchy.tree", transform);
          data_set_1.DataSet.registerTransform("tree", transform);
        },
        "./src/transform/hierarchy/treemap.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var tslib_1 = __webpack_require__("./node_modules/_tslib@2.1.0@tslib/tslib.js");
          var d3Hierarchy = tslib_1.__importStar(__webpack_require__("./node_modules/_d3-hierarchy@1.1.9@d3-hierarchy/dist/d3-hierarchy.js"));
          var util_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js");
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          var option_parser_1 = __webpack_require__("./src/util/option-parser.ts");
          var DEFAULT_OPTIONS = {
            field: "value",
            tile: "treemapSquarify",
            size: [1, 1],
            round: false,
            padding: 0,
            paddingInner: 0,
            paddingOuter: 0,
            paddingTop: 0,
            paddingRight: 0,
            paddingBottom: 0,
            paddingLeft: 0,
            as: ["x", "y"]
          };
          function transform(dataView, options) {
            if (dataView.dataType !== data_set_1.DataSet.CONSTANTS.HIERARCHY) {
              throw new TypeError("Invalid DataView: This transform is for Hierarchy data only!");
            }
            var root = dataView.root;
            options = util_1.assign({}, DEFAULT_OPTIONS, options);
            var as = options.as;
            if (!util_1.isArray(as) || as.length !== 2) {
              throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ "x", "y" ])!');
            }
            var field;
            try {
              field = option_parser_1.getField(options);
            } catch (e) {
              console.warn(e);
            }
            if (field) {
              root.sum(function(d) {
                return d[field];
              });
            }
            var treemapLayout = d3Hierarchy.treemap();
            treemapLayout.tile(d3Hierarchy[options.tile]).size(options.size).round(options.round).padding(options.padding).paddingInner(options.paddingInner).paddingOuter(options.paddingOuter).paddingTop(options.paddingTop).paddingRight(options.paddingRight).paddingBottom(options.paddingBottom).paddingLeft(options.paddingLeft);
            treemapLayout(root);
            var x = as[0];
            var y = as[1];
            root.each(function(node) {
              node[x] = [node.x0, node.x1, node.x1, node.x0];
              node[y] = [node.y1, node.y1, node.y0, node.y0];
              ["x0", "x1", "y0", "y1"].forEach(function(prop) {
                if (as.indexOf(prop) === -1) {
                  delete node[prop];
                }
              });
            });
          }
          data_set_1.DataSet.registerTransform("hierarchy.treemap", transform);
          data_set_1.DataSet.registerTransform("treemap", transform);
        },
        "./src/transform/impute.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var tslib_1 = __webpack_require__("./node_modules/_tslib@2.1.0@tslib/tslib.js");
          var util_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js");
          var simpleStatistics = tslib_1.__importStar(__webpack_require__("./node_modules/_simple-statistics@6.1.1@simple-statistics/dist/simple-statistics.min.js"));
          var partition_1 = tslib_1.__importDefault(__webpack_require__("./src/util/partition.ts"));
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          var option_parser_1 = __webpack_require__("./src/util/option-parser.ts");
          var DEFAULT_OPTIONS = {
            groupBy: []
          };
          function notUndefinedValues(values) {
            return values.filter(function(value) {
              return !util_1.isUndefined(value);
            });
          }
          var STATISTICS_METHODS = ["mean", "median", "max", "min"];
          var imputations = {};
          STATISTICS_METHODS.forEach(function(method) {
            imputations[method] = function(row, values) {
              return simpleStatistics[method](values);
            };
          });
          imputations.value = function(_row, _values, value) {
            return value;
          };
          function transform(dataView, options) {
            options = util_1.assign({}, DEFAULT_OPTIONS, options);
            var field = option_parser_1.getField(options);
            var method = options.method;
            if (!method) {
              throw new TypeError("Invalid method!");
            }
            if (method === "value" && !util_1.has(options, "value")) {
              throw new TypeError("Invalid value: it is nil.");
            }
            var column = notUndefinedValues(dataView.getColumn(field));
            var groups = partition_1.default(dataView.rows, options.groupBy);
            util_1.forIn(groups, function(group) {
              var fieldValues = notUndefinedValues(group.map(function(row) {
                return row[field];
              }));
              if (fieldValues.length === 0) {
                fieldValues = column;
              }
              group.forEach(function(row) {
                if (util_1.isUndefined(row[field])) {
                  if (util_1.isFunction(method)) {
                    row[field] = method(row, fieldValues, options.value, group);
                  } else if (util_1.isString(method)) {
                    row[field] = imputations[method](row, fieldValues, options.value);
                  } else {
                    throw new TypeError("Invalid method: must be a function or one of " + STATISTICS_METHODS.join(", "));
                  }
                }
              });
            });
          }
          data_set_1.DataSet.registerTransform("impute", transform);
        },
        "./src/transform/kde.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var tslib_1 = __webpack_require__("./node_modules/_tslib@2.1.0@tslib/tslib.js");
          var util_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js");
          var get_series_values_1 = tslib_1.__importDefault(__webpack_require__("./src/util/get-series-values.ts"));
          var kernel_1 = tslib_1.__importDefault(__webpack_require__("./src/util/kernel.ts"));
          var bandwidth = tslib_1.__importStar(__webpack_require__("./src/util/bandwidth.ts"));
          var partition_1 = tslib_1.__importDefault(__webpack_require__("./src/util/partition.ts"));
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          var option_parser_1 = __webpack_require__("./src/util/option-parser.ts");
          var simple_statistics_1 = __webpack_require__("./node_modules/_simple-statistics@6.1.1@simple-statistics/dist/simple-statistics.min.js");
          var DEFAULT_OPTIONS = {
            minSize: 0.01,
            as: ["key", "y", "size"],
            extent: [],
            method: "gaussian",
            bandwidth: "nrd",
            step: 0,
            groupBy: []
          };
          var KERNEL_METHODS = util_1.keys(kernel_1.default);
          var BANDWIDTH_METHODS = util_1.keys(bandwidth);
          function transform(dv, options) {
            options = util_1.assign({}, DEFAULT_OPTIONS, options);
            var fields = option_parser_1.getFields(options);
            if (!util_1.isArray(fields) || fields.length < 1) {
              throw new TypeError("invalid fields: must be an array of at least 1 strings!");
            }
            var as = options.as;
            if (!util_1.isArray(as) || as.length !== 3) {
              throw new TypeError("invalid as: must be an array of 3 strings!");
            }
            var method = options.method;
            if (util_1.isString(method)) {
              if (KERNEL_METHODS.indexOf(method) === -1) {
                throw new TypeError("invalid method: " + method + ". Must be one of " + KERNEL_METHODS.join(", "));
              }
              method = kernel_1.default[method];
            }
            if (!util_1.isFunction(method)) {
              throw new TypeError("invalid method: kernel method must be a function!");
            }
            var extent = options.extent;
            if (!util_1.isArray(extent) || extent.length === 0) {
              var rangeArr_1 = [];
              util_1.each(fields, function(field) {
                var range = dv.range(field);
                rangeArr_1 = rangeArr_1.concat(range);
              });
              extent = [Math.min.apply(Math, tslib_1.__spread(rangeArr_1)), Math.max.apply(Math, tslib_1.__spread(rangeArr_1))];
            }
            var bw = options.bandwidth;
            if (util_1.isString(bw) && bandwidth[bw]) {
              bw = bandwidth[bw](dv.getColumn(fields[0]));
            } else if (util_1.isFunction(bw)) {
              bw = bw(dv.getColumn(fields[0]));
            } else if (!util_1.isNumber(bw) || bw <= 0) {
              bw = bandwidth.nrd(dv.getColumn(fields[0]));
            }
            var seriesValues = get_series_values_1.default(extent, options.step ? options.step : bw);
            var result = [];
            var groupBy = options.groupBy;
            var groups = partition_1.default(dv.rows, groupBy);
            util_1.forIn(groups, function(group) {
              var probalityDensityFunctionByField = {};
              util_1.each(fields, function(field) {
                var row = util_1.pick(group[0], groupBy);
                probalityDensityFunctionByField[field] = simple_statistics_1.kernelDensityEstimation(group.map(function(item) {
                  return item[field];
                }), method, bw);
                var _a = tslib_1.__read(as, 3), key = _a[0], y = _a[1], size = _a[2];
                row[key] = field;
                row[y] = [];
                row[size] = [];
                util_1.each(seriesValues, function(yValue) {
                  var sizeValue = probalityDensityFunctionByField[field](yValue);
                  if (sizeValue >= options.minSize) {
                    row[y].push(yValue);
                    row[size].push(sizeValue);
                  }
                });
                result.push(row);
              });
            });
            dv.rows = result;
          }
          data_set_1.DataSet.registerTransform("kernel-density-estimation", transform);
          data_set_1.DataSet.registerTransform("kde", transform);
          data_set_1.DataSet.registerTransform("KDE", transform);
          exports2.default = {
            KERNEL_METHODS,
            BANDWIDTH_METHODS
          };
        },
        "./src/transform/kernel-smooth/density.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var tslib_1 = __webpack_require__("./node_modules/_tslib@2.1.0@tslib/tslib.js");
          var util_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js");
          var get_series_values_1 = tslib_1.__importDefault(__webpack_require__("./src/util/get-series-values.ts"));
          var kernel_1 = tslib_1.__importDefault(__webpack_require__("./src/util/kernel.ts"));
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          var option_parser_1 = __webpack_require__("./src/util/option-parser.ts");
          var bandwidth_1 = __webpack_require__("./src/util/bandwidth.ts");
          var DEFAULT_OPTIONS = {
            as: ["x", "y", "z"],
            method: "gaussian"
          };
          var KERNEL_METHODS = util_1.keys(kernel_1.default);
          function transform(dv, options) {
            var _a, _b;
            options = util_1.assign({}, DEFAULT_OPTIONS, options);
            var fields = option_parser_1.getFields(options);
            if (!util_1.isArray(fields) || fields.length !== 2) {
              throw new TypeError("invalid fields: must be an array of 2 strings!");
            }
            var _c = tslib_1.__read(options.as, 3), asX = _c[0], asY = _c[1], asZ = _c[2];
            if (!util_1.isString(asX) || !util_1.isString(asY) || !util_1.isString(asZ)) {
              throw new TypeError("invalid as: must be an array of 3 strings!");
            }
            var method;
            if (util_1.isString(options.method)) {
              if (KERNEL_METHODS.indexOf(options.method) === -1) {
                throw new TypeError("invalid method: " + options.method + ". Must be one of " + KERNEL_METHODS.join(", "));
              }
              method = kernel_1.default[options.method];
            }
            var _d = tslib_1.__read(fields, 2), xField = _d[0], yField = _d[1];
            var extent = options.extent, bandwidth = options.bandwidth;
            var extentX;
            var extentY;
            if (extent && Array.isArray(extent) && Array.isArray(extent[0]) && Array.isArray(extent[1])) {
              _a = tslib_1.__read(extent, 2), extentX = _a[0], extentY = _a[1];
            } else {
              extentX = dv.range(xField);
              extentY = dv.range(yField);
            }
            var bwX, bwY;
            if (bandwidth && Array.isArray(bandwidth) && bandwidth.slice(0, 2).every(util_1.isNumber) && bandwidth.slice(0, 2).every(function(item) {
              return item > 0;
            })) {
              _b = tslib_1.__read(bandwidth, 2), bwX = _b[0], bwY = _b[1];
            } else {
              bwX = bandwidth_1.silverman(dv.getColumn(xField));
              bwY = bandwidth_1.silverman(dv.getColumn(yField));
            }
            var seriesValuesX = get_series_values_1.default(extentX, bwX);
            var seriesValuesY = get_series_values_1.default(extentY, bwY);
            var count = dv.rows.length;
            var result = [];
            for (var i = 0; i < seriesValuesX.length; i++) {
              for (var j = 0; j < seriesValuesY.length; j++) {
                var sum = 0;
                var x = seriesValuesX[i];
                var y = seriesValuesY[j];
                for (var k = 0; k < count; k++) {
                  sum += method((x - dv.rows[k][xField]) / bwX) * method((y - dv.rows[k][yField]) / bwY);
                }
                var z = 1 / (count * bwX * bwY) * sum;
                var row = {};
                row[asX] = x;
                row[asY] = y;
                row[asZ] = z;
                result.push(row);
              }
            }
            dv.rows = result;
          }
          data_set_1.DataSet.registerTransform("kernel-smooth.density", transform);
          data_set_1.DataSet.registerTransform("kernel.density", transform);
          exports2.default = {
            KERNEL_METHODS
          };
        },
        "./src/transform/kernel-smooth/regression.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var tslib_1 = __webpack_require__("./node_modules/_tslib@2.1.0@tslib/tslib.js");
          var util_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js");
          var get_series_values_1 = tslib_1.__importDefault(__webpack_require__("./src/util/get-series-values.ts"));
          var kernel_1 = tslib_1.__importDefault(__webpack_require__("./src/util/kernel.ts"));
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          var simple_statistics_1 = __webpack_require__("./node_modules/_simple-statistics@6.1.1@simple-statistics/dist/simple-statistics.min.js");
          var option_parser_1 = __webpack_require__("./src/util/option-parser.ts");
          var bandwidth_1 = __webpack_require__("./src/util/bandwidth.ts");
          var DEFAULT_OPTIONS = {
            as: ["x", "y"],
            method: "gaussian"
          };
          var KERNEL_METHODS = util_1.keys(kernel_1.default);
          function weight(kernel, bandwidth, x_0, x_i) {
            var arg = (x_i - x_0) / bandwidth;
            return kernel(arg);
          }
          function vectorize(fun) {
            return function(x) {
              if (!util_1.isArray(x)) {
                return fun(x);
              }
              return x.map(function(x2) {
                return fun(x2);
              });
            };
          }
          function transform(dv, options) {
            options = util_1.assign({}, DEFAULT_OPTIONS, options);
            var fields = option_parser_1.getFields(options);
            if (!util_1.isArray(fields) || !(fields.length === 1 || fields.length === 2)) {
              throw new TypeError("invalid fields: must be an array of 1 or 2 strings!");
            }
            var _a = tslib_1.__read(options.as, 2), asX = _a[0], asY = _a[1];
            if (!util_1.isString(asX) || !util_1.isString(asY)) {
              throw new TypeError("invalid as: must be an array of 2 strings!");
            }
            var func;
            var method = options.method;
            if (util_1.isString(method)) {
              if (KERNEL_METHODS.indexOf(method) === -1) {
                throw new TypeError("invalid method: " + method + ". Must be one of " + KERNEL_METHODS.join(", "));
              }
              func = kernel_1.default[method];
            }
            var _b = tslib_1.__read(fields, 2), xField = _b[0], yField = _b[1];
            var xs = dv.getColumn(xField);
            var extent = options.extent;
            if (extent || !util_1.isArray(extent)) {
              extent = dv.range(xField);
            }
            var bandwidth = options.bandwidth;
            if (!bandwidth || !util_1.isNumber(bandwidth) || bandwidth <= 0) {
              bandwidth = bandwidth_1.silverman(xs);
            }
            var seriesValues = get_series_values_1.default(extent, bandwidth);
            var xCount = xs.length;
            var weightFunc = weight.bind(null, func, bandwidth);
            var kernelSmoother;
            if (util_1.isNil(yField)) {
              kernelSmoother = vectorize(function(x) {
                var weights = xs.map(function(x_i) {
                  return weightFunc(x, x_i);
                });
                var num = simple_statistics_1.sum(weights);
                var denom = xCount * bandwidth;
                if (!num || !denom)
                  return 0;
                return num / denom;
              });
            } else {
              var ys_1 = dv.getColumn(yField);
              kernelSmoother = vectorize(function(x) {
                var weights = xs.map(function(x_i) {
                  return weightFunc(x, x_i);
                });
                var num = simple_statistics_1.sum(weights.map(function(w, i) {
                  return w * ys_1[i];
                }));
                var denom = simple_statistics_1.sum(weights);
                if (!num || !denom)
                  return 0;
                return num / denom;
              });
            }
            var result = seriesValues.map(function(x) {
              var row = {};
              row[asX] = x;
              row[asY] = kernelSmoother(x);
              return row;
            });
            dv.rows = result;
          }
          data_set_1.DataSet.registerTransform("kernel-smooth.regression", transform);
          data_set_1.DataSet.registerTransform("kernel.regression", transform);
          exports2.default = {
            KERNEL_METHODS
          };
        },
        "./src/transform/map.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          function defaultCallback(row) {
            return row;
          }
          data_set_1.DataSet.registerTransform("map", function(dataView, options) {
            dataView.rows = dataView.rows.map(options.callback || defaultCallback);
          });
        },
        "./src/transform/partition.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var tslib_1 = __webpack_require__("./node_modules/_tslib@2.1.0@tslib/tslib.js");
          var util_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js");
          var partition_1 = tslib_1.__importDefault(__webpack_require__("./src/util/partition.ts"));
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          var DEFAULT_OPTIONS = {
            groupBy: [],
            orderBy: []
          };
          data_set_1.DataSet.registerTransform("partition", function(dataView, options) {
            options = util_1.assign({}, DEFAULT_OPTIONS, options);
            dataView.rows = partition_1.default(dataView.rows, options.groupBy, options.orderBy);
          });
          function group(dataView, options) {
            options = util_1.assign({}, DEFAULT_OPTIONS, options);
            dataView.rows = util_1.values(partition_1.default(dataView.rows, options.groupBy, options.orderBy));
          }
          data_set_1.DataSet.registerTransform("group", group);
          data_set_1.DataSet.registerTransform("groups", group);
        },
        "./src/transform/percent.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var tslib_1 = __webpack_require__("./node_modules/_tslib@2.1.0@tslib/tslib.js");
          var util_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js");
          var simple_statistics_1 = __webpack_require__("./node_modules/_simple-statistics@6.1.1@simple-statistics/dist/simple-statistics.min.js");
          var partition_1 = tslib_1.__importDefault(__webpack_require__("./src/util/partition.ts"));
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          var option_parser_1 = __webpack_require__("./src/util/option-parser.ts");
          var DEFAULT_OPTIONS = {
            groupBy: [],
            as: "_percent"
          };
          function transform(dataView, options) {
            options = util_1.assign({}, DEFAULT_OPTIONS, options);
            var field = option_parser_1.getField(options);
            var dimension = options.dimension, groupBy = options.groupBy;
            var as = options.as;
            if (!util_1.isString(dimension)) {
              throw new TypeError("Invalid dimension: must be a string!");
            }
            if (util_1.isArray(as)) {
              console.warn("Invalid as: must be a string, will use the first element of the array specified.");
              as = as[0];
            }
            if (!util_1.isString(as)) {
              throw new TypeError("Invalid as: must be a string!");
            }
            var rows = dataView.rows;
            var result = [];
            var groups = partition_1.default(rows, groupBy);
            util_1.forIn(groups, function(group) {
              var totalSum = simple_statistics_1.sum(group.map(function(row) {
                return row[field];
              }));
              var innerGroups = partition_1.default(group, [dimension]);
              util_1.forIn(innerGroups, function(innerGroup) {
                var innerSum = simple_statistics_1.sum(innerGroup.map(function(row) {
                  return row[field];
                }));
                var resultRow = innerGroup[0];
                var dimensionValue = resultRow[dimension];
                resultRow[field] = innerSum;
                resultRow[dimension] = dimensionValue;
                if (totalSum === 0) {
                  resultRow[as] = 0;
                } else {
                  resultRow[as] = innerSum / totalSum;
                }
                result.push(resultRow);
              });
            });
            dataView.rows = result;
          }
          data_set_1.DataSet.registerTransform("percent", transform);
        },
        "./src/transform/pick.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var util_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js");
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          var option_parser_1 = __webpack_require__("./src/util/option-parser.ts");
          data_set_1.DataSet.registerTransform("pick", function(dataView, options) {
            var columns = option_parser_1.getFields(options, dataView.getColumnNames());
            dataView.rows = dataView.rows.map(function(row) {
              return util_1.pick(row, columns);
            });
          });
        },
        "./src/transform/proportion.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var tslib_1 = __webpack_require__("./node_modules/_tslib@2.1.0@tslib/tslib.js");
          var util_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js");
          var partition_1 = tslib_1.__importDefault(__webpack_require__("./src/util/partition.ts"));
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          var option_parser_1 = __webpack_require__("./src/util/option-parser.ts");
          var DEFAULT_OPTIONS = {
            groupBy: [],
            as: "_proportion"
          };
          function transform(dataView, options) {
            options = util_1.assign({}, DEFAULT_OPTIONS, options);
            var field = option_parser_1.getField(options);
            var dimension = options.dimension;
            var groupBy = options.groupBy;
            var as = options.as;
            if (!util_1.isString(dimension)) {
              throw new TypeError("Invalid dimension: must be a string!");
            }
            if (util_1.isArray(as)) {
              console.warn("Invalid as: must be a string, will use the first element of the array specified.");
              as = as[0];
            }
            if (!util_1.isString(as)) {
              throw new TypeError("Invalid as: must be a string!");
            }
            var rows = dataView.rows;
            var result = [];
            var groups = partition_1.default(rows, groupBy);
            util_1.forIn(groups, function(group) {
              var totalCount = group.length;
              var innerGroups = partition_1.default(group, [dimension]);
              util_1.forIn(innerGroups, function(innerGroup) {
                var innerCount = innerGroup.length;
                var resultRow = innerGroup[0];
                var dimensionValue = resultRow[dimension];
                resultRow[field] = innerCount;
                resultRow[dimension] = dimensionValue;
                resultRow[as] = innerCount / totalCount;
                result.push(resultRow);
              });
            });
            dataView.rows = result;
          }
          data_set_1.DataSet.registerTransform("proportion", transform);
        },
        "./src/transform/regression.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var tslib_1 = __webpack_require__("./node_modules/_tslib@2.1.0@tslib/tslib.js");
          var regression_1 = tslib_1.__importDefault(__webpack_require__("./node_modules/_regression@2.0.1@regression/dist/regression.js"));
          var util_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js");
          var get_series_values_1 = tslib_1.__importDefault(__webpack_require__("./src/util/get-series-values.ts"));
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          var option_parser_1 = __webpack_require__("./src/util/option-parser.ts");
          var bandwidth_1 = __webpack_require__("./src/util/bandwidth.ts");
          var DEFAULT_OPTIONS = {
            as: ["x", "y"],
            method: "linear",
            order: 2,
            precision: 2
          };
          var REGRESSION_METHODS = ["linear", "exponential", "logarithmic", "power", "polynomial"];
          function transform(dataView, options) {
            options = util_1.assign({}, DEFAULT_OPTIONS, options);
            var fields = option_parser_1.getFields(options);
            if (!util_1.isArray(fields) || fields.length !== 2) {
              throw new TypeError("invalid fields: must be an array of 2 strings.");
            }
            var _a = tslib_1.__read(fields, 2), xField = _a[0], yField = _a[1];
            var method = options.method;
            if (REGRESSION_METHODS.indexOf(method) === -1) {
              throw new TypeError("invalid method: " + method + ". Must be one of " + REGRESSION_METHODS.join(", "));
            }
            var points = dataView.rows.map(function(row) {
              return [row[xField], row[yField]];
            });
            var regressionResult = regression_1.default[method](points, options);
            var extent = options.extent;
            if (!util_1.isArray(extent) || extent.length !== 2) {
              extent = dataView.range(xField);
            }
            var bandwidth = options.bandwidth;
            if (!util_1.isNumber(bandwidth) || bandwidth <= 0) {
              bandwidth = bandwidth_1.silverman(dataView.getColumn(xField));
            }
            var valuesToPredict = get_series_values_1.default(extent, bandwidth);
            var result = [];
            var _b = tslib_1.__read(options.as, 2), asX = _b[0], asY = _b[1];
            valuesToPredict.forEach(function(value) {
              var row = {};
              var _a2 = tslib_1.__read(regressionResult.predict(value), 2), x = _a2[0], y = _a2[1];
              row[asX] = x;
              row[asY] = y;
              if (isFinite(y)) {
                result.push(row);
              }
            });
            dataView.rows = result;
          }
          data_set_1.DataSet.registerTransform("regression", transform);
          exports2.default = {
            REGRESSION_METHODS
          };
        },
        "./src/transform/rename.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var util_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js");
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          function transform(dataView, options) {
            var map = options.map || {};
            var cleanMap = {};
            if (util_1.isPlainObject(map)) {
              util_1.forIn(map, function(value, key) {
                if (util_1.isString(value) && util_1.isString(key)) {
                  cleanMap[key] = value;
                }
              });
            }
            dataView.rows.forEach(function(row) {
              util_1.forIn(cleanMap, function(newKey, key) {
                var temp = row[key];
                delete row[key];
                row[newKey] = temp;
              });
            });
          }
          data_set_1.DataSet.registerTransform("rename", transform);
          data_set_1.DataSet.registerTransform("rename-fields", transform);
        },
        "./src/transform/reverse.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          data_set_1.DataSet.registerTransform("reverse", function(dataView) {
            dataView.rows.reverse();
          });
        },
        "./src/transform/sort-by.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var util_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js");
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          var option_parser_1 = __webpack_require__("./src/util/option-parser.ts");
          var VALID_ORDERS = ["ASC", "DESC"];
          function transform(dataView, options) {
            var fields = option_parser_1.getFields(options, [dataView.getColumnName(0)]);
            if (!util_1.isArray(fields)) {
              throw new TypeError("Invalid fields: must be an array with strings!");
            }
            dataView.rows = util_1.sortBy(dataView.rows, fields);
            var order = options.order;
            if (order && VALID_ORDERS.indexOf(order) === -1) {
              throw new TypeError("Invalid order: " + order + " must be one of " + VALID_ORDERS.join(", "));
            } else if (order === "DESC") {
              dataView.rows.reverse();
            }
          }
          data_set_1.DataSet.registerTransform("sort-by", transform);
          data_set_1.DataSet.registerTransform("sortBy", transform);
        },
        "./src/transform/sort.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          data_set_1.DataSet.registerTransform("sort", function(dataView, options) {
            var columnName = dataView.getColumnName(0);
            dataView.rows.sort(options.callback || function(a, b) {
              return a[columnName] - b[columnName];
            });
          });
        },
        "./src/transform/subset.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          var option_parser_1 = __webpack_require__("./src/util/option-parser.ts");
          data_set_1.DataSet.registerTransform("subset", function(dataView, options) {
            var startIndex = options.startRowIndex || 0;
            var endIndex = options.endRowIndex || dataView.rows.length - 1;
            var columns = option_parser_1.getFields(options, dataView.getColumnNames());
            dataView.rows = dataView.getSubset(startIndex, endIndex, columns);
          });
        },
        "./src/transform/tag-cloud.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var tslib_1 = __webpack_require__("./node_modules/_tslib@2.1.0@tslib/tslib.js");
          var util_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js");
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          var tag_cloud_1 = tslib_1.__importDefault(__webpack_require__("./src/util/tag-cloud.ts"));
          var option_parser_1 = __webpack_require__("./src/util/option-parser.ts");
          var DEFAULT_OPTIONS = {
            fields: ["text", "value"],
            font: function() {
              return "serif";
            },
            padding: 1,
            size: [500, 500],
            spiral: "archimedean",
            timeInterval: 500
          };
          function transform(dataView, options) {
            options = util_1.assign({}, DEFAULT_OPTIONS, options);
            var layout = tag_cloud_1.default();
            if (!options.size[0] || !options.size[1]) {
              dataView.rows = [];
              dataView._tagCloud = layout;
              return;
            }
            ["font", "fontSize", "fontWeight", "padding", "rotate", "size", "spiral", "timeInterval"].forEach(function(key) {
              if (options[key]) {
                layout[key](options[key]);
              }
            });
            var fields = option_parser_1.getFields(options);
            var _a = tslib_1.__read(fields, 2), text = _a[0], value = _a[1];
            if (!util_1.isString(text) || !util_1.isString(value)) {
              throw new TypeError('Invalid fields: must be an array with 2 strings (e.g. [ "text", "value" ])!');
            }
            var words = dataView.rows.map(function(row) {
              row.text = row[text];
              row.value = row[value];
              return row;
            });
            layout.words(words);
            if (options.imageMask) {
              layout.createMask(options.imageMask);
            }
            var result = layout.start();
            var tags = result._tags;
            var bounds = result._bounds || [
              { x: 0, y: 0 },
              { x: options.size[0], y: options.size[1] }
            ];
            tags.forEach(function(tag) {
              tag.x += options.size[0] / 2;
              tag.y += options.size[1] / 2;
            });
            var _b = tslib_1.__read(options.size, 2), w = _b[0], h = _b[1];
            var hasImage = result.hasImage;
            tags.push({
              text: "",
              value: 0,
              x: hasImage ? 0 : bounds[0].x,
              y: hasImage ? 0 : bounds[0].y,
              opacity: 0
            });
            tags.push({
              text: "",
              value: 0,
              x: hasImage ? w : bounds[1].x,
              y: hasImage ? h : bounds[1].y,
              opacity: 0
            });
            dataView.rows = tags;
            dataView._tagCloud = result;
          }
          data_set_1.DataSet.registerTransform("tag-cloud", transform);
          data_set_1.DataSet.registerTransform("word-cloud", transform);
        },
        "./src/transform/waffle.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var tslib_1 = __webpack_require__("./node_modules/_tslib@2.1.0@tslib/tslib.js");
          var util_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js");
          var simple_statistics_1 = __webpack_require__("./node_modules/_simple-statistics@6.1.1@simple-statistics/dist/simple-statistics.min.js");
          var partition_1 = tslib_1.__importDefault(__webpack_require__("./src/util/partition.ts"));
          var data_set_1 = __webpack_require__("./src/data-set.ts");
          var option_parser_1 = __webpack_require__("./src/util/option-parser.ts");
          var DEFAULT_OPTIONS = {
            fields: ["name", "value"],
            rows: 5,
            size: [1, 1],
            scale: 1,
            groupBy: [],
            maxCount: 1e3,
            gapRatio: 0.1,
            as: ["x", "y"]
          };
          function transform(dataView, options) {
            options = util_1.assign({}, DEFAULT_OPTIONS, options);
            var fields = option_parser_1.getFields(options);
            var _a = tslib_1.__read(fields, 2), nameField = _a[0], valueField = _a[1];
            var _b = tslib_1.__read(options.as, 2), asX = _b[0], asY = _b[1];
            var groupBy = options.groupBy;
            var groups = partition_1.default(dataView.rows, groupBy);
            var groupKeys = util_1.keys(groups);
            var _c = tslib_1.__read(options.size, 2), width = _c[0], height = _c[1];
            var maxCount = options.maxCount;
            var groupCount = groupKeys.length;
            var partHeight = height / groupCount;
            var rows = options.rows;
            var gapRatio = options.gapRatio;
            var result = [];
            var scale = options.scale;
            var currentGroupIndex = 0;
            var wStep = 0;
            util_1.forIn(groups, function(group) {
              var totalValue = simple_statistics_1.sum(util_1.map(group, function(row) {
                return row[valueField];
              }));
              var cols = Math.ceil(totalValue * scale / rows);
              if (totalValue * scale > maxCount) {
                scale = maxCount / totalValue;
                cols = Math.ceil(totalValue * scale / rows);
              }
              wStep = width / cols;
            });
            util_1.forIn(groups, function(group) {
              var heightRange = [currentGroupIndex * partHeight, (currentGroupIndex + 1) * partHeight];
              var h = heightRange[1] - heightRange[0];
              var hStep = h * (1 - gapRatio) / rows;
              var currentCol = 0;
              var currentRow = 0;
              util_1.each(group, function(row) {
                var value = row[valueField];
                var count = Math.round(value * scale);
                for (var i = 0; i < count; i++) {
                  if (currentRow === rows) {
                    currentRow = 0;
                    currentCol++;
                  }
                  var resultRow = util_1.pick(row, [nameField, valueField].concat(groupBy));
                  resultRow[asX] = currentCol * wStep + wStep / 2;
                  resultRow[asY] = currentRow * hStep + hStep / 2 + heightRange[0];
                  resultRow._wStep = wStep;
                  resultRow._hStep = hStep;
                  currentRow++;
                  result.push(resultRow);
                }
              });
              currentGroupIndex += 1;
            });
            dataView.rows = result;
          }
          data_set_1.DataSet.registerTransform("waffle", transform);
        },
        "./src/util/bandwidth.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.nrd = exports2.silverman = void 0;
          var simple_statistics_1 = __webpack_require__("./node_modules/_simple-statistics@6.1.1@simple-statistics/dist/simple-statistics.min.js");
          function silverman(arr) {
            var stdev = simple_statistics_1.standardDeviation(arr);
            var num = 4 * Math.pow(stdev, 5);
            var denom = 3 * arr.length;
            return Math.pow(num / denom, 0.2);
          }
          exports2.silverman = silverman;
          function nrd(arr) {
            var s = simple_statistics_1.standardDeviation(arr);
            var iqr = simple_statistics_1.interquartileRange(arr);
            if (typeof iqr === "number") {
              s = Math.min(s, iqr / 1.34);
            }
            return 1.06 * s * Math.pow(arr.length, -0.2);
          }
          exports2.nrd = nrd;
        },
        "./src/util/get-geo-projection.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var tslib_1 = __webpack_require__("./node_modules/_tslib@2.1.0@tslib/tslib.js");
          var util_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js");
          var d3Geo = tslib_1.__importStar(__webpack_require__("./node_modules/_d3-geo@1.6.4@d3-geo/build/d3-geo.js"));
          var d3GeoProjection = tslib_1.__importStar(__webpack_require__("./node_modules/_d3-geo-projection@2.1.2@d3-geo-projection/build/d3-geo-projection.js"));
          var d3CompositeProjection = tslib_1.__importStar(__webpack_require__("./node_modules/_d3-composite-projections@1.4.0@d3-composite-projections/d3-composite-projections.js"));
          exports2.default = function(projection, exportRaw) {
            if (exportRaw === void 0) {
              exportRaw = false;
            }
            if (util_1.isFunction(projection)) {
              return exportRaw ? projection : projection();
            }
            if (util_1.isString(projection)) {
              if (d3Geo[projection]) {
                return exportRaw ? d3Geo[projection] : d3Geo[projection]();
              }
              if (d3GeoProjection[projection]) {
                return exportRaw ? d3GeoProjection[projection] : d3GeoProjection[projection]();
              }
              if (d3CompositeProjection[projection]) {
                return exportRaw ? d3CompositeProjection[projection] : d3CompositeProjection[projection]();
              }
            }
            return null;
          };
        },
        "./src/util/get-series-values.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var tslib_1 = __webpack_require__("./node_modules/_tslib@2.1.0@tslib/tslib.js");
          exports2.default = function(extent, bw) {
            var bandwidth = bw || 1;
            var _a = tslib_1.__read(extent, 2), min = _a[0], max = _a[1];
            var values = [];
            var tmp = min;
            while (tmp < max) {
              values.push(tmp);
              tmp += bandwidth;
            }
            values.push(max);
            return values;
          };
        },
        "./src/util/kernel.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          function uniform(u) {
            return Math.abs(u) <= 1 ? 0.5 : 0;
          }
          function tricubed(u) {
            var abs = 1 - Math.pow(Math.abs(u), 3);
            return Math.pow(abs, 3);
          }
          exports2.default = {
            boxcar: uniform,
            cosine: function(u) {
              if (Math.abs(u) <= 1) {
                return Math.PI / 4 * Math.cos(Math.PI / 2 * u);
              }
              return 0;
            },
            epanechnikov: function(u) {
              return Math.abs(u) < 1 ? 0.75 * (1 - u * u) : 0;
            },
            gaussian: function(u) {
              return 0.3989422804 * Math.exp(-0.5 * u * u);
            },
            quartic: function(u) {
              if (Math.abs(u) < 1) {
                var tmp = 1 - u * u;
                return 15 / 16 * tmp * tmp;
              }
              return 0;
            },
            triangular: function(u) {
              var abs = Math.abs(u);
              return abs < 1 ? 1 - abs : 0;
            },
            tricube: function(u) {
              return Math.abs(u) < 1 ? 70 / 81 * tricubed(u) : 0;
            },
            triweight: function(u) {
              if (Math.abs(u) < 1) {
                var tmp = 1 - u * u;
                return 35 / 32 * tmp * tmp * tmp;
              }
              return 0;
            },
            uniform
          };
        },
        "./src/util/option-parser.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.getFields = exports2.getField = void 0;
          var util_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js");
          var INVALID_FIELD_ERR_MSG = "Invalid field: it must be a string!";
          var INVALID_FIELDS_ERR_MSG = "Invalid fields: it must be an array!";
          function getField(options, defaultField) {
            var field = options.field, fields = options.fields;
            if (util_1.isString(field)) {
              return field;
            }
            if (util_1.isArray(field)) {
              console.warn(INVALID_FIELD_ERR_MSG);
              return field[0];
            }
            console.warn(INVALID_FIELD_ERR_MSG + " will try to get fields instead.");
            if (util_1.isString(fields)) {
              return fields;
            }
            if (util_1.isArray(fields) && fields.length) {
              return fields[0];
            }
            if (defaultField) {
              return defaultField;
            }
            throw new TypeError(INVALID_FIELD_ERR_MSG);
          }
          exports2.getField = getField;
          function getFields(options, defaultFields) {
            var field = options.field, fields = options.fields;
            if (util_1.isArray(fields)) {
              return fields;
            }
            if (util_1.isString(fields)) {
              console.warn(INVALID_FIELDS_ERR_MSG);
              return [fields];
            }
            console.warn(INVALID_FIELDS_ERR_MSG + " will try to get field instead.");
            if (util_1.isString(field)) {
              console.warn(INVALID_FIELDS_ERR_MSG);
              return [field];
            }
            if (util_1.isArray(field) && field.length) {
              console.warn(INVALID_FIELDS_ERR_MSG);
              return field;
            }
            if (defaultFields) {
              return defaultFields;
            }
            throw new TypeError(INVALID_FIELDS_ERR_MSG);
          }
          exports2.getFields = getFields;
        },
        "./src/util/p-by-fraction.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.default = function(fraction) {
            var step = 1 / fraction;
            var pArr = [];
            for (var i = 0; i <= 1; i = i + step) {
              pArr.push(i);
            }
            return pArr;
          };
        },
        "./src/util/partition.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var tslib_1 = __webpack_require__("./node_modules/_tslib@2.1.0@tslib/tslib.js");
          var util_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js");
          var simple_sort_by_1 = tslib_1.__importDefault(__webpack_require__("./src/util/simple-sort-by.ts"));
          exports2.default = function(rows, group_by, order_by) {
            if (order_by === void 0) {
              order_by = [];
            }
            var newRows = rows;
            if (order_by && order_by.length) {
              newRows = simple_sort_by_1.default(rows, order_by);
            }
            var groupingFn;
            if (util_1.isFunction(group_by)) {
              groupingFn = group_by;
            } else if (util_1.isArray(group_by)) {
              groupingFn = function(row) {
                return "_" + group_by.map(function(col) {
                  return row[col];
                }).join("-");
              };
            } else if (util_1.isString(group_by)) {
              groupingFn = function(row) {
                return "_" + row[group_by];
              };
            }
            var groups = util_1.groupBy(newRows, groupingFn);
            return groups;
          };
        },
        "./src/util/simple-sort-by.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var util_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js");
          function sortBy(arr, keys) {
            if (keys === void 0) {
              keys = [];
            }
            var comparer = void 0;
            if (util_1.isFunction(keys)) {
              comparer = keys;
            } else if (util_1.isArray(keys)) {
              comparer = function(a, b) {
                for (var i = 0; i < keys.length; i++) {
                  var key = keys[i];
                  if (a[key] < b[key]) {
                    return -1;
                  }
                  if (a[key] > b[key]) {
                    return 1;
                  }
                }
                return 0;
              };
            } else if (util_1.isString(keys)) {
              comparer = function(a, b) {
                if (a[keys] < b[keys]) {
                  return -1;
                }
                if (a[keys] > b[keys]) {
                  return 1;
                }
                return 0;
              };
            }
            return arr.sort(comparer);
          }
          exports2.default = sortBy;
        },
        "./src/util/tag-cloud.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var tslib_1 = __webpack_require__("./node_modules/_tslib@2.1.0@tslib/tslib.js");
          var cloudRadians = Math.PI / 180, cw = 1 << 11 >> 5, ch = 1 << 11;
          function cloudText(d) {
            return d.text;
          }
          function cloudFont() {
            return "serif";
          }
          function cloudFontNormal() {
            return "normal";
          }
          function cloudFontSize(d) {
            return d.value;
          }
          function cloudRotate() {
            return ~~(Math.random() * 2) * 90;
          }
          function cloudPadding() {
            return 1;
          }
          function cloudSprite(contextAndRatio, d, data, di) {
            if (d.sprite)
              return;
            var c = contextAndRatio.context, ratio = contextAndRatio.ratio;
            c.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);
            var x = 0, y = 0, maxh = 0;
            var n = data.length;
            --di;
            while (++di < n) {
              d = data[di];
              c.save();
              c.font = d.style + " " + d.weight + " " + ~~((d.size + 1) / ratio) + "px " + d.font;
              var w = c.measureText(d.text + "m").width * ratio, h = d.size << 1;
              if (d.rotate) {
                var sr = Math.sin(d.rotate * cloudRadians), cr = Math.cos(d.rotate * cloudRadians), wcr = w * cr, wsr = w * sr, hcr = h * cr, hsr = h * sr;
                w = Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 31 >> 5 << 5;
                h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));
              } else {
                w = w + 31 >> 5 << 5;
              }
              if (h > maxh)
                maxh = h;
              if (x + w >= cw << 5) {
                x = 0;
                y += maxh;
                maxh = 0;
              }
              if (y + h >= ch)
                break;
              c.translate((x + (w >> 1)) / ratio, (y + (h >> 1)) / ratio);
              if (d.rotate)
                c.rotate(d.rotate * cloudRadians);
              c.fillText(d.text, 0, 0);
              if (d.padding) {
                c.lineWidth = 2 * d.padding;
                c.strokeText(d.text, 0, 0);
              }
              c.restore();
              d.width = w;
              d.height = h;
              d.xoff = x;
              d.yoff = y;
              d.x1 = w >> 1;
              d.y1 = h >> 1;
              d.x0 = -d.x1;
              d.y0 = -d.y1;
              d.hasText = true;
              x += w;
            }
            var pixels = c.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data, sprite = [];
            while (--di >= 0) {
              d = data[di];
              if (!d.hasText)
                continue;
              var w = d.width, w32 = w >> 5;
              var h = d.y1 - d.y0;
              for (var i = 0; i < h * w32; i++)
                sprite[i] = 0;
              x = d.xoff;
              if (x == null)
                return;
              y = d.yoff;
              var seen = 0, seenRow = -1;
              for (var j = 0; j < h; j++) {
                for (var i = 0; i < w; i++) {
                  var k = w32 * j + (i >> 5), m = pixels[(y + j) * (cw << 5) + (x + i) << 2] ? 1 << 31 - i % 32 : 0;
                  sprite[k] |= m;
                  seen |= m;
                }
                if (seen)
                  seenRow = j;
                else {
                  d.y0++;
                  h--;
                  j--;
                  y++;
                }
              }
              d.y1 = d.y0 + seenRow;
              d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);
            }
          }
          function cloudCollide(tag, board, sw) {
            sw >>= 5;
            var sprite = tag.sprite, w = tag.width >> 5, lx = tag.x - (w << 4), sx = lx & 127, msx = 32 - sx, h = tag.y1 - tag.y0;
            var x = (tag.y + tag.y0) * sw + (lx >> 5), last;
            for (var j = 0; j < h; j++) {
              last = 0;
              for (var i = 0; i <= w; i++) {
                if ((last << msx | (i < w ? (last = sprite[j * w + i]) >>> sx : 0)) & board[x + i])
                  return true;
              }
              x += sw;
            }
            return false;
          }
          function cloudBounds(bounds, d) {
            var b0 = bounds[0], b1 = bounds[1];
            if (d.x + d.x0 < b0.x)
              b0.x = d.x + d.x0;
            if (d.y + d.y0 < b0.y)
              b0.y = d.y + d.y0;
            if (d.x + d.x1 > b1.x)
              b1.x = d.x + d.x1;
            if (d.y + d.y1 > b1.y)
              b1.y = d.y + d.y1;
          }
          function collideRects(a, b) {
            return a.x + a.x1 > b[0].x && a.x + a.x0 < b[1].x && a.y + a.y1 > b[0].y && a.y + a.y0 < b[1].y;
          }
          function archimedeanSpiral(size) {
            var e = size[0] / size[1];
            return function(t) {
              return [e * (t *= 0.1) * Math.cos(t), t * Math.sin(t)];
            };
          }
          function rectangularSpiral(size) {
            var dy = 4, dx = dy * size[0] / size[1];
            var x = 0, y = 0;
            return function(t) {
              var sign = t < 0 ? -1 : 1;
              switch (Math.sqrt(1 + 4 * sign * t) - sign & 3) {
                case 0:
                  x += dx;
                  break;
                case 1:
                  y += dy;
                  break;
                case 2:
                  x -= dx;
                  break;
                default:
                  y -= dy;
                  break;
              }
              return [x, y];
            };
          }
          function zeroArray(n) {
            var a = [];
            var i = -1;
            while (++i < n)
              a[i] = 0;
            return a;
          }
          function cloudCanvas() {
            return document.createElement("canvas");
          }
          function functor(d) {
            return typeof d === "function" ? d : function() {
              return d;
            };
          }
          var spirals = {
            archimedean: archimedeanSpiral,
            rectangular: rectangularSpiral
          };
          function default_1() {
            var size = [256, 256], text = cloudText, font = cloudFont, fontSize = cloudFontSize, fontStyle = cloudFontNormal, fontWeight = cloudFontNormal, rotate = cloudRotate, padding = cloudPadding, spiral = archimedeanSpiral, words = [], timeInterval = Infinity, random = Math.random, canvas = cloudCanvas;
            var cloud = {};
            cloud.canvas = function(_) {
              return arguments.length ? (canvas = functor(_), cloud) : canvas;
            };
            cloud.start = function() {
              var _a = tslib_1.__read(size, 2), width = _a[0], height = _a[1];
              var contextAndRatio = getContext(canvas()), board = cloud.board ? cloud.board : zeroArray((size[0] >> 5) * size[1]), n = words.length, tags = [], data = words.map(function(d, i2) {
                d.text = text.call(this, d, i2);
                d.font = font.call(this, d, i2);
                d.style = fontStyle.call(this, d, i2);
                d.weight = fontWeight.call(this, d, i2);
                d.rotate = rotate.call(this, d, i2);
                d.size = ~~fontSize.call(this, d, i2);
                d.padding = padding.call(this, d, i2);
                return d;
              }).sort(function(a, b) {
                return b.size - a.size;
              });
              var i = -1, bounds = !cloud.board ? null : [
                {
                  x: 0,
                  y: 0
                },
                {
                  x: width,
                  y: height
                }
              ];
              step();
              function step() {
                var start = Date.now();
                while (Date.now() - start < timeInterval && ++i < n) {
                  var d = data[i];
                  d.x = width * (random() + 0.5) >> 1;
                  d.y = height * (random() + 0.5) >> 1;
                  cloudSprite(contextAndRatio, d, data, i);
                  if (d.hasText && place(board, d, bounds)) {
                    tags.push(d);
                    if (bounds) {
                      if (!cloud.hasImage) {
                        cloudBounds(bounds, d);
                      }
                    } else {
                      bounds = [
                        { x: d.x + d.x0, y: d.y + d.y0 },
                        { x: d.x + d.x1, y: d.y + d.y1 }
                      ];
                    }
                    d.x -= size[0] >> 1;
                    d.y -= size[1] >> 1;
                  }
                }
                cloud._tags = tags;
                cloud._bounds = bounds;
              }
              return cloud;
            };
            function getContext(canvas2) {
              canvas2.width = canvas2.height = 1;
              var ratio = Math.sqrt(canvas2.getContext("2d").getImageData(0, 0, 1, 1).data.length >> 2);
              canvas2.width = (cw << 5) / ratio;
              canvas2.height = ch / ratio;
              var context = canvas2.getContext("2d");
              context.fillStyle = context.strokeStyle = "red";
              context.textAlign = "center";
              return { context, ratio };
            }
            function place(board, tag, bounds) {
              var startX = tag.x, startY = tag.y, maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]), s = spiral(size), dt = random() < 0.5 ? 1 : -1;
              var dxdy, t = -dt, dx, dy;
              while (dxdy = s(t += dt)) {
                dx = ~~dxdy[0];
                dy = ~~dxdy[1];
                if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta)
                  break;
                tag.x = startX + dx;
                tag.y = startY + dy;
                if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 || tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1])
                  continue;
                if (!bounds || !cloudCollide(tag, board, size[0])) {
                  if (!bounds || collideRects(tag, bounds)) {
                    var sprite = tag.sprite, w = tag.width >> 5, sw = size[0] >> 5, lx = tag.x - (w << 4), sx = lx & 127, msx = 32 - sx, h = tag.y1 - tag.y0;
                    var last = void 0, x = (tag.y + tag.y0) * sw + (lx >> 5);
                    for (var j = 0; j < h; j++) {
                      last = 0;
                      for (var i = 0; i <= w; i++) {
                        board[x + i] |= last << msx | (i < w ? (last = sprite[j * w + i]) >>> sx : 0);
                      }
                      x += sw;
                    }
                    delete tag.sprite;
                    return true;
                  }
                }
              }
              return false;
            }
            cloud.createMask = function(img) {
              var can = document.createElement("canvas");
              var _a = tslib_1.__read(size, 2), width = _a[0], height = _a[1];
              if (!width || !height) {
                return;
              }
              var w32 = width >> 5;
              var board = zeroArray((width >> 5) * height);
              can.width = width;
              can.height = height;
              var cxt = can.getContext("2d");
              cxt.drawImage(img, 0, 0, img.width, img.height, 0, 0, width, height);
              var imageData = cxt.getImageData(0, 0, width, height).data;
              for (var j = 0; j < height; j++) {
                for (var i = 0; i < width; i++) {
                  var k = w32 * j + (i >> 5);
                  var tmp = j * width + i << 2;
                  var flag = imageData[tmp] >= 250 && imageData[tmp + 1] >= 250 && imageData[tmp + 2] >= 250;
                  var m = flag ? 1 << 31 - i % 32 : 0;
                  board[k] |= m;
                }
              }
              cloud.board = board;
              cloud.hasImage = true;
            };
            cloud.timeInterval = function(_) {
              return arguments.length ? (timeInterval = _ == null ? Infinity : _, cloud) : timeInterval;
            };
            cloud.words = function(_) {
              return arguments.length ? (words = _, cloud) : words;
            };
            cloud.size = function(_) {
              return arguments.length ? (size = [+_[0], +_[1]], cloud) : size;
            };
            cloud.font = function(_) {
              return arguments.length ? (font = functor(_), cloud) : font;
            };
            cloud.fontStyle = function(_) {
              return arguments.length ? (fontStyle = functor(_), cloud) : fontStyle;
            };
            cloud.fontWeight = function(_) {
              return arguments.length ? (fontWeight = functor(_), cloud) : fontWeight;
            };
            cloud.rotate = function(_) {
              return arguments.length ? (rotate = functor(_), cloud) : rotate;
            };
            cloud.text = function(_) {
              return arguments.length ? (text = functor(_), cloud) : text;
            };
            cloud.spiral = function(_) {
              return arguments.length ? (spiral = spirals[_] || _, cloud) : spiral;
            };
            cloud.fontSize = function(_) {
              return arguments.length ? (fontSize = functor(_), cloud) : fontSize;
            };
            cloud.padding = function(_) {
              return arguments.length ? (padding = functor(_), cloud) : padding;
            };
            cloud.random = function(_) {
              return arguments.length ? (random = _, cloud) : random;
            };
            return cloud;
          }
          exports2.default = default_1;
        },
        "./src/view.ts": function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.View = void 0;
          var tslib_1 = __webpack_require__("./node_modules/_tslib@2.1.0@tslib/tslib.js");
          var wolfy87_eventemitter_1 = tslib_1.__importDefault(__webpack_require__("./node_modules/_wolfy87-eventemitter@5.2.9@wolfy87-eventemitter/EventEmitter.js"));
          var util_1 = __webpack_require__("./node_modules/_@antv_util@2.0.10@@antv/util/lib/index.js");
          function cloneOptions(options) {
            var result = {};
            util_1.forIn(options, function(value, key) {
              if (util_1.isObject(value) && value.isView) {
                result[key] = value;
              } else if (util_1.isArray(value)) {
                result[key] = value.concat([]);
              } else if (util_1.isPlainObject(value)) {
                result[key] = util_1.clone(value);
              } else {
                result[key] = value;
              }
            });
            return result;
          }
          var View = function(_super) {
            tslib_1.__extends(View2, _super);
            function View2(dataSet, options) {
              var _this = _super.call(this) || this;
              _this.isView = true;
              _this.isDataView = true;
              _this.watchingStates = null;
              _this.dataType = "table";
              _this.transforms = [];
              _this.origin = [];
              _this.rows = [];
              if (dataSet && dataSet.isDataSet) {
                _this.dataSet = dataSet;
              } else {
                _this.dataSet = null;
                options = dataSet;
              }
              _this.loose = !_this.dataSet;
              if (options) {
                _this.watchingStates = options.watchingStates;
              }
              if (!_this.loose) {
                var watchingStates_1 = _this.watchingStates;
                dataSet.on("statechange", function(name) {
                  if (util_1.isArray(watchingStates_1)) {
                    if (watchingStates_1.indexOf(name) > -1) {
                      _this._reExecute();
                    }
                  } else {
                    _this._reExecute();
                  }
                });
              }
              return _this;
            }
            View2.prototype._parseStateExpression = function(expr) {
              var dataSet = this.dataSet;
              if (dataSet === null)
                return void 0;
              var matched = /^\$state\.(\w+)/.exec(expr);
              if (matched) {
                return dataSet.state[matched[1]];
              }
              return expr;
            };
            View2.prototype._preparseOptions = function(options) {
              var _this = this;
              var optionsCloned = cloneOptions(options);
              if (this.loose) {
                return optionsCloned;
              }
              util_1.forIn(optionsCloned, function(value, key) {
                if (util_1.isString(value) && /^\$state\./.test(value)) {
                  optionsCloned[key] = _this._parseStateExpression(value);
                }
              });
              return optionsCloned;
            };
            View2.prototype._prepareSource = function(source, options) {
              this._source = { source, options };
              if (!options) {
                if (source instanceof View2 || util_1.isString(source)) {
                  this.origin = View2.DataSet.getConnector("default")(source, this.dataSet);
                } else if (util_1.isArray(source)) {
                  this.origin = source;
                } else if (util_1.isObject(source) && source.type) {
                  var opts = this._preparseOptions(source);
                  this.origin = View2.DataSet.getConnector(opts.type)(opts, this);
                } else {
                  throw new TypeError("Invalid source");
                }
              } else {
                var opts = this._preparseOptions(options);
                this.origin = View2.DataSet.getConnector(opts.type)(source, opts, this);
              }
              this.rows = util_1.deepMix([], this.origin);
              return this;
            };
            View2.prototype.source = function(source, options) {
              this._prepareSource(source, options)._reExecuteTransforms();
              this.trigger("change", []);
              return this;
            };
            View2.prototype.transform = function(options) {
              if (options && options.type) {
                this.transforms.push(options);
                this._executeTransform(options);
              }
              return this;
            };
            View2.prototype._executeTransform = function(options) {
              options = this._preparseOptions(options);
              var transform = View2.DataSet.getTransform(options.type);
              transform(this, options);
            };
            View2.prototype._reExecuteTransforms = function() {
              var _this = this;
              this.transforms.forEach(function(options) {
                _this._executeTransform(options);
              });
            };
            View2.prototype.addRow = function(row) {
              this.rows.push(row);
            };
            View2.prototype.removeRow = function(index) {
              this.rows.splice(index, 1);
            };
            View2.prototype.updateRow = function(index, newRow) {
              util_1.assign(this.rows[index], newRow);
            };
            View2.prototype.findRows = function(query) {
              return this.rows.filter(function(row) {
                return util_1.isMatch(row, query);
              });
            };
            View2.prototype.findRow = function(query) {
              return util_1.find(this.rows, query);
            };
            View2.prototype.getColumnNames = function() {
              var firstRow = this.rows[0];
              if (firstRow) {
                return util_1.keys(firstRow);
              }
              return [];
            };
            View2.prototype.getColumnName = function(index) {
              return this.getColumnNames()[index];
            };
            View2.prototype.getColumnIndex = function(columnName) {
              var columnNames = this.getColumnNames();
              return columnNames.indexOf(columnName);
            };
            View2.prototype.getColumn = function(columnName) {
              return this.rows.map(function(row) {
                return row[columnName];
              });
            };
            View2.prototype.getColumnData = function(columnName) {
              return this.getColumn(columnName);
            };
            View2.prototype.getSubset = function(startRowIndex, endRowIndex, columnNames) {
              var subset = [];
              for (var i = startRowIndex; i <= endRowIndex; i++) {
                subset.push(util_1.pick(this.rows[i], columnNames));
              }
              return subset;
            };
            View2.prototype.toString = function(prettyPrint) {
              if (prettyPrint === void 0) {
                prettyPrint = false;
              }
              if (prettyPrint) {
                return JSON.stringify(this.rows, null, 2);
              }
              return JSON.stringify(this.rows);
            };
            View2.prototype._reExecute = function() {
              var _a = this._source, source = _a.source, options = _a.options;
              this._prepareSource(source, options);
              this._reExecuteTransforms();
              this.trigger("change", []);
            };
            return View2;
          }(wolfy87_eventemitter_1.default);
          exports2.View = View;
        }
      });
    });
  }
});

// dep:@antv_data-set
var antv_data_set_default = require_data_set();
export {
  antv_data_set_default as default
};
/*!
* EventEmitter v5.2.9 - git.io/ee
* Unlicense - http://unlicense.org/
* Oliver Caldwell - https://oli.me.uk/
* @preserve
*/
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
//# sourceMappingURL=@antv_data-set.js.map

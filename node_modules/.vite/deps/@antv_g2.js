import {
  __export
} from "./chunk-BHN6OJC3.js";

// node_modules/tslib/tslib.es6.js
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b10) {
    d2.__proto__ = b10;
  } || function(d2, b10) {
    for (var p in b10)
      if (Object.prototype.hasOwnProperty.call(b10, p))
        d2[p] = b10[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign3(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}

// node_modules/@antv/util/esm/is-array-like.js
var isArrayLike = function(value) {
  return value !== null && typeof value !== "function" && isFinite(value.length);
};
var is_array_like_default = isArrayLike;

// node_modules/@antv/util/esm/contains.js
var contains = function(arr, value) {
  if (!is_array_like_default(arr)) {
    return false;
  }
  return arr.indexOf(value) > -1;
};
var contains_default = contains;

// node_modules/@antv/util/esm/filter.js
var filter = function(arr, func) {
  if (!is_array_like_default(arr)) {
    return arr;
  }
  var result = [];
  for (var index = 0; index < arr.length; index++) {
    var value = arr[index];
    if (func(value, index)) {
      result.push(value);
    }
  }
  return result;
};
var filter_default = filter;

// node_modules/@antv/util/esm/difference.js
var difference = function(arr, values2) {
  if (values2 === void 0) {
    values2 = [];
  }
  return filter_default(arr, function(value) {
    return !contains_default(values2, value);
  });
};
var difference_default = difference;

// node_modules/@antv/util/esm/is-type.js
var toString = {}.toString;
var isType = function(value, type) {
  return toString.call(value) === "[object " + type + "]";
};
var is_type_default = isType;

// node_modules/@antv/util/esm/is-function.js
var is_function_default = function(value) {
  return is_type_default(value, "Function");
};

// node_modules/@antv/util/esm/is-nil.js
var isNil = function(value) {
  return value === null || value === void 0;
};
var is_nil_default = isNil;

// node_modules/@antv/util/esm/is-array.js
var is_array_default = function(value) {
  return Array.isArray ? Array.isArray(value) : is_type_default(value, "Array");
};

// node_modules/@antv/util/esm/is-object.js
var is_object_default = function(value) {
  var type = typeof value;
  return value !== null && type === "object" || type === "function";
};

// node_modules/@antv/util/esm/each.js
function each(elements, func) {
  if (!elements) {
    return;
  }
  var rst;
  if (is_array_default(elements)) {
    for (var i = 0, len3 = elements.length; i < len3; i++) {
      rst = func(elements[i], i);
      if (rst === false) {
        break;
      }
    }
  } else if (is_object_default(elements)) {
    for (var k in elements) {
      if (elements.hasOwnProperty(k)) {
        rst = func(elements[k], k);
        if (rst === false) {
          break;
        }
      }
    }
  }
}
var each_default = each;

// node_modules/@antv/util/esm/keys.js
var keys = Object.keys ? function(obj) {
  return Object.keys(obj);
} : function(obj) {
  var result = [];
  each_default(obj, function(value, key) {
    if (!(is_function_default(obj) && key === "prototype")) {
      result.push(key);
    }
  });
  return result;
};
var keys_default = keys;

// node_modules/@antv/util/esm/is-match.js
function isMatch(obj, attrs) {
  var _keys = keys_default(attrs);
  var length5 = _keys.length;
  if (is_nil_default(obj))
    return !length5;
  for (var i = 0; i < length5; i += 1) {
    var key = _keys[i];
    if (attrs[key] !== obj[key] || !(key in obj)) {
      return false;
    }
  }
  return true;
}
var is_match_default = isMatch;

// node_modules/@antv/util/esm/is-object-like.js
var isObjectLike = function(value) {
  return typeof value === "object" && value !== null;
};
var is_object_like_default = isObjectLike;

// node_modules/@antv/util/esm/is-plain-object.js
var isPlainObject = function(value) {
  if (!is_object_like_default(value) || !is_type_default(value, "Object")) {
    return false;
  }
  if (Object.getPrototypeOf(value) === null) {
    return true;
  }
  var proto = value;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(value) === proto;
};
var is_plain_object_default = isPlainObject;

// node_modules/@antv/util/esm/find.js
function find(arr, predicate) {
  if (!is_array_default(arr))
    return null;
  var _predicate;
  if (is_function_default(predicate)) {
    _predicate = predicate;
  }
  if (is_plain_object_default(predicate)) {
    _predicate = function(a) {
      return is_match_default(a, predicate);
    };
  }
  if (_predicate) {
    for (var i = 0; i < arr.length; i += 1) {
      if (_predicate(arr[i])) {
        return arr[i];
      }
    }
  }
  return null;
}
var find_default = find;

// node_modules/@antv/util/esm/first-value.js
var firstValue = function(data, name) {
  var rst = null;
  for (var i = 0; i < data.length; i++) {
    var obj = data[i];
    var value = obj[name];
    if (!is_nil_default(value)) {
      if (is_array_default(value)) {
        rst = value[0];
      } else {
        rst = value;
      }
      break;
    }
  }
  return rst;
};
var first_value_default = firstValue;

// node_modules/@antv/util/esm/flatten.js
var flatten = function(arr) {
  if (!is_array_default(arr)) {
    return [];
  }
  var rst = [];
  for (var i = 0; i < arr.length; i++) {
    rst = rst.concat(arr[i]);
  }
  return rst;
};
var flatten_default = flatten;

// node_modules/@antv/util/esm/max.js
var max_default = function(arr) {
  if (!is_array_default(arr)) {
    return void 0;
  }
  return arr.reduce(function(prev, curr) {
    return Math.max(prev, curr);
  }, arr[0]);
};

// node_modules/@antv/util/esm/min.js
var min_default = function(arr) {
  if (!is_array_default(arr)) {
    return void 0;
  }
  return arr.reduce(function(prev, curr) {
    return Math.min(prev, curr);
  }, arr[0]);
};

// node_modules/@antv/util/esm/get-range.js
var getRange = function(values2) {
  var filterValues = values2.filter(function(v) {
    return !isNaN(v);
  });
  if (!filterValues.length) {
    return {
      min: 0,
      max: 0
    };
  }
  if (is_array_default(values2[0])) {
    var tmp = [];
    for (var i = 0; i < values2.length; i++) {
      tmp = tmp.concat(values2[i]);
    }
    filterValues = tmp;
  }
  var max3 = max_default(filterValues);
  var min3 = min_default(filterValues);
  return {
    min: min3,
    max: max3
  };
};
var get_range_default = getRange;

// node_modules/@antv/util/esm/pull.js
var arrPrototype = Array.prototype;
var splice = arrPrototype.splice;
var indexOf = arrPrototype.indexOf;

// node_modules/@antv/util/esm/pull-at.js
var splice2 = Array.prototype.splice;
var pullAt = function pullAt2(arr, indexes) {
  if (!is_array_like_default(arr)) {
    return [];
  }
  var length5 = arr ? indexes.length : 0;
  var last2 = length5 - 1;
  while (length5--) {
    var previous = void 0;
    var index = indexes[length5];
    if (length5 === last2 || index !== previous) {
      previous = index;
      splice2.call(arr, index, 1);
    }
  }
  return arr;
};
var pull_at_default = pullAt;

// node_modules/@antv/util/esm/reduce.js
var reduce = function(arr, fn, init) {
  if (!is_array_default(arr) && !is_plain_object_default(arr)) {
    return arr;
  }
  var result = init;
  each_default(arr, function(data, i) {
    result = fn(result, data, i);
  });
  return result;
};
var reduce_default = reduce;

// node_modules/@antv/util/esm/remove.js
var remove = function(arr, predicate) {
  var result = [];
  if (!is_array_like_default(arr)) {
    return result;
  }
  var i = -1;
  var indexes = [];
  var length5 = arr.length;
  while (++i < length5) {
    var value = arr[i];
    if (predicate(value, i, arr)) {
      result.push(value);
      indexes.push(i);
    }
  }
  pull_at_default(arr, indexes);
  return result;
};
var remove_default = remove;

// node_modules/@antv/util/esm/is-string.js
var is_string_default = function(str4) {
  return is_type_default(str4, "String");
};

// node_modules/@antv/util/esm/uniq.js
function uniq(arr, cache3) {
  if (cache3 === void 0) {
    cache3 = /* @__PURE__ */ new Map();
  }
  var r = [];
  if (Array.isArray(arr)) {
    for (var i = 0, len3 = arr.length; i < len3; i++) {
      var item = arr[i];
      if (!cache3.has(item)) {
        r.push(item);
        cache3.set(item, true);
      }
    }
  }
  return r;
}

// node_modules/@antv/util/esm/values-of-key.js
var values_of_key_default = function(data, name) {
  var rst = [];
  var tmpMap = {};
  for (var i = 0; i < data.length; i++) {
    var obj = data[i];
    var value = obj[name];
    if (!is_nil_default(value)) {
      if (!is_array_default(value)) {
        value = [value];
      }
      for (var j = 0; j < value.length; j++) {
        var val = value[j];
        if (!tmpMap[val]) {
          rst.push(val);
          tmpMap[val] = true;
        }
      }
    }
  }
  return rst;
};

// node_modules/@antv/util/esm/head.js
function head(o) {
  if (is_array_like_default(o)) {
    return o[0];
  }
  return void 0;
}

// node_modules/@antv/util/esm/last.js
function last(o) {
  if (is_array_like_default(o)) {
    var arr = o;
    return arr[arr.length - 1];
  }
  return void 0;
}

// node_modules/@antv/util/esm/every.js
var every = function(arr, func) {
  for (var i = 0; i < arr.length; i++) {
    if (!func(arr[i], i))
      return false;
  }
  return true;
};
var every_default = every;

// node_modules/@antv/util/esm/some.js
var some = function(arr, func) {
  for (var i = 0; i < arr.length; i++) {
    if (func(arr[i], i))
      return true;
  }
  return false;
};
var some_default = some;

// node_modules/@antv/util/esm/group-by.js
var hasOwnProperty = Object.prototype.hasOwnProperty;
function groupBy(data, condition) {
  if (!condition || !is_array_default(data)) {
    return {};
  }
  var result = {};
  var predicate = is_function_default(condition) ? condition : function(item2) {
    return item2[condition];
  };
  var key;
  for (var i = 0; i < data.length; i++) {
    var item = data[i];
    key = predicate(item);
    if (hasOwnProperty.call(result, key)) {
      result[key].push(item);
    } else {
      result[key] = [item];
    }
  }
  return result;
}
var group_by_default = groupBy;

// node_modules/@antv/util/esm/group-to-map.js
function groupToMap(data, condition) {
  if (!condition) {
    return {
      0: data
    };
  }
  if (!is_function_default(condition)) {
    var paramscondition_1 = is_array_default(condition) ? condition : condition.replace(/\s+/g, "").split("*");
    condition = function(row) {
      var unique = "_";
      for (var i = 0, l = paramscondition_1.length; i < l; i++) {
        unique += row[paramscondition_1[i]] && row[paramscondition_1[i]].toString();
      }
      return unique;
    };
  }
  return group_by_default(data, condition);
}

// node_modules/@antv/util/esm/group.js
var group_default = function(data, condition) {
  if (!condition) {
    return [data];
  }
  var groups = groupToMap(data, condition);
  var array = [];
  for (var i in groups) {
    array.push(groups[i]);
  }
  return array;
};

// node_modules/@antv/util/esm/clamp.js
var clamp = function(a, min3, max3) {
  if (a < min3) {
    return min3;
  } else if (a > max3) {
    return max3;
  }
  return a;
};
var clamp_default = clamp;

// node_modules/@antv/util/esm/fixed-base.js
var fixedBase = function(v, base) {
  var str4 = base.toString();
  var index = str4.indexOf(".");
  if (index === -1) {
    return Math.round(v);
  }
  var length5 = str4.substr(index + 1).length;
  if (length5 > 20) {
    length5 = 20;
  }
  return parseFloat(v.toFixed(length5));
};
var fixed_base_default = fixedBase;

// node_modules/@antv/util/esm/is-number.js
var isNumber = function(value) {
  return is_type_default(value, "Number");
};
var is_number_default = isNumber;

// node_modules/@antv/util/esm/is-integer.js
var isInteger = Number.isInteger ? Number.isInteger : function(num) {
  return is_number_default(num) && num % 1 === 0;
};

// node_modules/@antv/util/esm/is-number-equal.js
var PRECISION = 1e-5;
function isNumberEqual(a, b, precision) {
  if (precision === void 0) {
    precision = PRECISION;
  }
  return Math.abs(a - b) < precision;
}

// node_modules/@antv/util/esm/mod.js
var mod = function(n, m) {
  return (n % m + m) % m;
};
var mod_default = mod;

// node_modules/@antv/util/esm/to-degree.js
var DEGREE = 180 / Math.PI;

// node_modules/@antv/util/esm/to-radian.js
var RADIAN = Math.PI / 180;
var toRadian = function(degree2) {
  return RADIAN * degree2;
};
var to_radian_default = toRadian;

// node_modules/@antv/util/esm/has.js
var has_default = function(obj, key) {
  return obj.hasOwnProperty(key);
};

// node_modules/@antv/util/esm/has-key.js
var has_key_default = has_default;

// node_modules/@antv/util/esm/values.js
var values = Object.values ? function(obj) {
  return Object.values(obj);
} : function(obj) {
  var result = [];
  each_default(obj, function(value, key) {
    if (!(is_function_default(obj) && key === "prototype")) {
      result.push(value);
    }
  });
  return result;
};
var values_default = values;

// node_modules/@antv/util/esm/to-string.js
var to_string_default = function(value) {
  if (is_nil_default(value))
    return "";
  return value.toString();
};

// node_modules/@antv/util/esm/lower-case.js
var lowerCase = function(str4) {
  return to_string_default(str4).toLowerCase();
};
var lower_case_default = lowerCase;

// node_modules/@antv/util/esm/substitute.js
function substitute(str4, o) {
  if (!str4 || !o) {
    return str4;
  }
  return str4.replace(/\\?\{([^{}]+)\}/g, function(match, name) {
    if (match.charAt(0) === "\\") {
      return match.slice(1);
    }
    return o[name] === void 0 ? "" : o[name];
  });
}
var substitute_default = substitute;

// node_modules/@antv/util/esm/upper-first.js
var upperFirst = function(value) {
  var str4 = to_string_default(value);
  return str4.charAt(0).toUpperCase() + str4.substring(1);
};
var upper_first_default = upperFirst;

// node_modules/@antv/util/esm/get-type.js
var toString2 = {}.toString;
var getType = function(value) {
  return toString2.call(value).replace(/^\[object /, "").replace(/]$/, "");
};
var get_type_default = getType;

// node_modules/@antv/util/esm/is-boolean.js
var isBoolean = function(value) {
  return is_type_default(value, "Boolean");
};
var is_boolean_default = isBoolean;

// node_modules/@antv/util/esm/is-date.js
var isDate = function(value) {
  return is_type_default(value, "Date");
};
var is_date_default = isDate;

// node_modules/@antv/util/esm/is-null.js
var isNull = function(value) {
  return value === null;
};
var is_null_default = isNull;

// node_modules/@antv/util/esm/is-prototype.js
var objectProto = Object.prototype;
var isPrototype = function(value) {
  var Ctor = value && value.constructor;
  var proto = typeof Ctor === "function" && Ctor.prototype || objectProto;
  return value === proto;
};
var is_prototype_default = isPrototype;

// node_modules/@antv/util/esm/is-undefined.js
var isUndefined = function(value) {
  return value === void 0;
};
var is_undefined_default = isUndefined;

// node_modules/@antv/util/esm/is-element.js
var isElement = function(o) {
  return o instanceof Element || o instanceof HTMLDocument;
};
var is_element_default = isElement;

// node_modules/@antv/util/esm/request-animation-frame.js
function requestAnimationFrame(fn) {
  var method = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function(f) {
    return setTimeout(f, 16);
  };
  return method(fn);
}

// node_modules/@antv/util/esm/clear-animation-frame.js
function cancelAnimationFrame(handler) {
  var method = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.msCancelAnimationFrame || clearTimeout;
  method(handler);
}

// node_modules/@antv/util/esm/mix.js
function _mix(dist3, obj) {
  for (var key in obj) {
    if (obj.hasOwnProperty(key) && key !== "constructor" && obj[key] !== void 0) {
      dist3[key] = obj[key];
    }
  }
}
function mix(dist3, src1, src2, src3) {
  if (src1)
    _mix(dist3, src1);
  if (src2)
    _mix(dist3, src2);
  if (src3)
    _mix(dist3, src3);
  return dist3;
}

// node_modules/@antv/util/esm/clone.js
var clone = function(obj) {
  if (typeof obj !== "object" || obj === null) {
    return obj;
  }
  var rst;
  if (is_array_default(obj)) {
    rst = [];
    for (var i = 0, l = obj.length; i < l; i++) {
      if (typeof obj[i] === "object" && obj[i] != null) {
        rst[i] = clone(obj[i]);
      } else {
        rst[i] = obj[i];
      }
    }
  } else {
    rst = {};
    for (var k in obj) {
      if (typeof obj[k] === "object" && obj[k] != null) {
        rst[k] = clone(obj[k]);
      } else {
        rst[k] = obj[k];
      }
    }
  }
  return rst;
};
var clone_default = clone;

// node_modules/@antv/util/esm/debounce.js
function debounce(func, wait, immediate) {
  var timeout2;
  return function() {
    var context = this, args = arguments;
    var later = function() {
      timeout2 = null;
      if (!immediate) {
        func.apply(context, args);
      }
    };
    var callNow = immediate && !timeout2;
    clearTimeout(timeout2);
    timeout2 = setTimeout(later, wait);
    if (callNow) {
      func.apply(context, args);
    }
  };
}
var debounce_default = debounce;

// node_modules/@antv/util/esm/memoize.js
var memoize_default = function(f, resolver) {
  if (!is_function_default(f)) {
    throw new TypeError("Expected a function");
  }
  var memoized = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var key = resolver ? resolver.apply(this, args) : args[0];
    var cache3 = memoized.cache;
    if (cache3.has(key)) {
      return cache3.get(key);
    }
    var result = f.apply(this, args);
    cache3.set(key, result);
    return result;
  };
  memoized.cache = /* @__PURE__ */ new Map();
  return memoized;
};

// node_modules/@antv/util/esm/deep-mix.js
var MAX_MIX_LEVEL = 5;
function _deepMix(dist3, src, level, maxLevel) {
  level = level || 0;
  maxLevel = maxLevel || MAX_MIX_LEVEL;
  for (var key in src) {
    if (src.hasOwnProperty(key)) {
      var value = src[key];
      if (value !== null && is_plain_object_default(value)) {
        if (!is_plain_object_default(dist3[key])) {
          dist3[key] = {};
        }
        if (level < maxLevel) {
          _deepMix(dist3[key], value, level + 1, maxLevel);
        } else {
          dist3[key] = src[key];
        }
      } else if (is_array_default(value)) {
        dist3[key] = [];
        dist3[key] = dist3[key].concat(value);
      } else if (value !== void 0) {
        dist3[key] = value;
      }
    }
  }
}
var deepMix = function(rst) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  for (var i = 0; i < args.length; i += 1) {
    _deepMix(rst, args[i]);
  }
  return rst;
};
var deep_mix_default = deepMix;

// node_modules/@antv/util/esm/index-of.js
var indexOf2 = function(arr, obj) {
  if (!is_array_like_default(arr)) {
    return -1;
  }
  var m = Array.prototype.indexOf;
  if (m) {
    return m.call(arr, obj);
  }
  var index = -1;
  for (var i = 0; i < arr.length; i++) {
    if (arr[i] === obj) {
      index = i;
      break;
    }
  }
  return index;
};
var index_of_default = indexOf2;

// node_modules/@antv/util/esm/is-empty.js
var hasOwnProperty2 = Object.prototype.hasOwnProperty;
function isEmpty(value) {
  if (is_nil_default(value)) {
    return true;
  }
  if (is_array_like_default(value)) {
    return !value.length;
  }
  var type = get_type_default(value);
  if (type === "Map" || type === "Set") {
    return !value.size;
  }
  if (is_prototype_default(value)) {
    return !Object.keys(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty2.call(value, key)) {
      return false;
    }
  }
  return true;
}
var is_empty_default = isEmpty;

// node_modules/@antv/util/esm/is-equal.js
var isEqual = function(value, other) {
  if (value === other) {
    return true;
  }
  if (!value || !other) {
    return false;
  }
  if (is_string_default(value) || is_string_default(other)) {
    return false;
  }
  if (is_array_like_default(value) || is_array_like_default(other)) {
    if (value.length !== other.length) {
      return false;
    }
    var rst = true;
    for (var i = 0; i < value.length; i++) {
      rst = isEqual(value[i], other[i]);
      if (!rst) {
        break;
      }
    }
    return rst;
  }
  if (is_object_like_default(value) || is_object_like_default(other)) {
    var valueKeys = Object.keys(value);
    var otherKeys = Object.keys(other);
    if (valueKeys.length !== otherKeys.length) {
      return false;
    }
    var rst = true;
    for (var i = 0; i < valueKeys.length; i++) {
      rst = isEqual(value[valueKeys[i]], other[valueKeys[i]]);
      if (!rst) {
        break;
      }
    }
    return rst;
  }
  return false;
};
var is_equal_default = isEqual;

// node_modules/@antv/util/esm/map.js
var map = function(arr, func) {
  if (!is_array_like_default(arr)) {
    return arr;
  }
  var result = [];
  for (var index = 0; index < arr.length; index++) {
    var value = arr[index];
    result.push(func(value, index));
  }
  return result;
};
var map_default = map;

// node_modules/@antv/util/esm/map-values.js
var identity = function(v) {
  return v;
};
var map_values_default = function(object, func) {
  if (func === void 0) {
    func = identity;
  }
  var r = {};
  if (is_object_default(object) && !is_nil_default(object)) {
    Object.keys(object).forEach(function(key) {
      r[key] = func(object[key], key);
    });
  }
  return r;
};

// node_modules/@antv/util/esm/get.js
var get_default = function(obj, key, defaultValue) {
  var p = 0;
  var keyArr = is_string_default(key) ? key.split(".") : key;
  while (obj && p < keyArr.length) {
    obj = obj[keyArr[p++]];
  }
  return obj === void 0 || p < keyArr.length ? defaultValue : obj;
};

// node_modules/@antv/util/esm/set.js
var set_default = function(obj, path, value) {
  var o = obj;
  var keyArr = is_string_default(path) ? path.split(".") : path;
  keyArr.forEach(function(key, idx) {
    if (idx < keyArr.length - 1) {
      if (!is_object_default(o[key])) {
        o[key] = is_number_default(keyArr[idx + 1]) ? [] : {};
      }
      o = o[key];
    } else {
      o[key] = value;
    }
  });
  return obj;
};

// node_modules/@antv/util/esm/pick.js
var hasOwnProperty3 = Object.prototype.hasOwnProperty;
var pick_default = function(object, keys2) {
  if (object === null || !is_plain_object_default(object)) {
    return {};
  }
  var result = {};
  each_default(keys2, function(key) {
    if (hasOwnProperty3.call(object, key)) {
      result[key] = object[key];
    }
  });
  return result;
};

// node_modules/@antv/util/esm/throttle.js
var throttle_default = function(func, wait, options) {
  var timeout2, context, args, result;
  var previous = 0;
  if (!options)
    options = {};
  var later = function() {
    previous = options.leading === false ? 0 : Date.now();
    timeout2 = null;
    result = func.apply(context, args);
    if (!timeout2)
      context = args = null;
  };
  var throttled = function() {
    var now2 = Date.now();
    if (!previous && options.leading === false)
      previous = now2;
    var remaining = wait - (now2 - previous);
    context = this;
    args = arguments;
    if (remaining <= 0 || remaining > wait) {
      if (timeout2) {
        clearTimeout(timeout2);
        timeout2 = null;
      }
      previous = now2;
      result = func.apply(context, args);
      if (!timeout2)
        context = args = null;
    } else if (!timeout2 && options.trailing !== false) {
      timeout2 = setTimeout(later, remaining);
    }
    return result;
  };
  throttled.cancel = function() {
    clearTimeout(timeout2);
    previous = 0;
    timeout2 = context = args = null;
  };
  return throttled;
};

// node_modules/@antv/util/esm/to-array.js
var to_array_default = function(value) {
  return is_array_like_default(value) ? Array.prototype.slice.call(value) : [];
};

// node_modules/@antv/util/esm/unique-id.js
var map2 = {};
var unique_id_default = function(prefix) {
  prefix = prefix || "g";
  if (!map2[prefix]) {
    map2[prefix] = 1;
  } else {
    map2[prefix] += 1;
  }
  return prefix + map2[prefix];
};

// node_modules/@antv/util/esm/noop.js
var noop_default = function() {
};

// node_modules/@antv/util/esm/size.js
function size(o) {
  if (is_nil_default(o)) {
    return 0;
  }
  if (is_array_like_default(o)) {
    return o.length;
  }
  return Object.keys(o).length;
}

// node_modules/@antv/util/esm/measure-text-width.js
var ctx;
var measure_text_width_default = memoize_default(function(text, font) {
  if (font === void 0) {
    font = {};
  }
  var fontSize = font.fontSize, fontFamily = font.fontFamily, fontWeight = font.fontWeight, fontStyle = font.fontStyle, fontVariant = font.fontVariant;
  if (!ctx) {
    ctx = document.createElement("canvas").getContext("2d");
  }
  ctx.font = [fontStyle, fontVariant, fontWeight, fontSize + "px", fontFamily].join(" ");
  return ctx.measureText(is_string_default(text) ? text : "").width;
}, function(text, font) {
  if (font === void 0) {
    font = {};
  }
  return __spreadArrays([text], values_default(font)).join("");
});

// node_modules/@antv/util/esm/get-ellipsis-text.js
var get_ellipsis_text_default = function(text, maxWidth, font, str4) {
  if (str4 === void 0) {
    str4 = "...";
  }
  var STEP = 16;
  var PLACEHOLDER_WIDTH = measure_text_width_default(str4, font);
  var leftText = !is_string_default(text) ? to_string_default(text) : text;
  var leftWidth = maxWidth;
  var r = [];
  var currentText;
  var currentWidth;
  if (measure_text_width_default(text, font) <= maxWidth) {
    return text;
  }
  while (true) {
    currentText = leftText.substr(0, STEP);
    currentWidth = measure_text_width_default(currentText, font);
    if (currentWidth + PLACEHOLDER_WIDTH > leftWidth) {
      if (currentWidth > leftWidth) {
        break;
      }
    }
    r.push(currentText);
    leftWidth -= currentWidth;
    leftText = leftText.substr(STEP);
    if (!leftText) {
      return r.join("");
    }
  }
  while (true) {
    currentText = leftText.substr(0, 1);
    currentWidth = measure_text_width_default(currentText, font);
    if (currentWidth + PLACEHOLDER_WIDTH > leftWidth) {
      break;
    }
    r.push(currentText);
    leftWidth -= currentWidth;
    leftText = leftText.substr(1);
    if (!leftText) {
      return r.join("");
    }
  }
  return "" + r.join("") + str4;
};

// node_modules/@antv/util/esm/cache.js
var default_1 = function() {
  function default_12() {
    this.map = {};
  }
  default_12.prototype.has = function(key) {
    return this.map[key] !== void 0;
  };
  default_12.prototype.get = function(key, def) {
    var v = this.map[key];
    return v === void 0 ? def : v;
  };
  default_12.prototype.set = function(key, value) {
    this.map[key] = value;
  };
  default_12.prototype.clear = function() {
    this.map = {};
  };
  default_12.prototype.delete = function(key) {
    delete this.map[key];
  };
  default_12.prototype.size = function() {
    return Object.keys(this.map).length;
  };
  return default_12;
}();
var cache_default = default_1;

// node_modules/@antv/g2/esm/constant.js
var LAYER;
(function(LAYER2) {
  LAYER2["FORE"] = "fore";
  LAYER2["MID"] = "mid";
  LAYER2["BG"] = "bg";
})(LAYER || (LAYER = {}));
var DIRECTION;
(function(DIRECTION2) {
  DIRECTION2["TOP"] = "top";
  DIRECTION2["TOP_LEFT"] = "top-left";
  DIRECTION2["TOP_RIGHT"] = "top-right";
  DIRECTION2["RIGHT"] = "right";
  DIRECTION2["RIGHT_TOP"] = "right-top";
  DIRECTION2["RIGHT_BOTTOM"] = "right-bottom";
  DIRECTION2["LEFT"] = "left";
  DIRECTION2["LEFT_TOP"] = "left-top";
  DIRECTION2["LEFT_BOTTOM"] = "left-bottom";
  DIRECTION2["BOTTOM"] = "bottom";
  DIRECTION2["BOTTOM_LEFT"] = "bottom-left";
  DIRECTION2["BOTTOM_RIGHT"] = "bottom-right";
  DIRECTION2["RADIUS"] = "radius";
  DIRECTION2["CIRCLE"] = "circle";
  DIRECTION2["NONE"] = "none";
})(DIRECTION || (DIRECTION = {}));
var COMPONENT_TYPE;
(function(COMPONENT_TYPE2) {
  COMPONENT_TYPE2["AXIS"] = "axis";
  COMPONENT_TYPE2["GRID"] = "grid";
  COMPONENT_TYPE2["LEGEND"] = "legend";
  COMPONENT_TYPE2["TOOLTIP"] = "tooltip";
  COMPONENT_TYPE2["ANNOTATION"] = "annotation";
  COMPONENT_TYPE2["SLIDER"] = "slider";
  COMPONENT_TYPE2["SCROLLBAR"] = "scrollbar";
  COMPONENT_TYPE2["OTHER"] = "other";
})(COMPONENT_TYPE || (COMPONENT_TYPE = {}));
var GROUP_Z_INDEX = {
  FORE: 3,
  MID: 2,
  BG: 1
};
var VIEW_LIFE_CIRCLE;
(function(VIEW_LIFE_CIRCLE2) {
  VIEW_LIFE_CIRCLE2["BEFORE_RENDER"] = "beforerender";
  VIEW_LIFE_CIRCLE2["AFTER_RENDER"] = "afterrender";
  VIEW_LIFE_CIRCLE2["BEFORE_PAINT"] = "beforepaint";
  VIEW_LIFE_CIRCLE2["AFTER_PAINT"] = "afterpaint";
  VIEW_LIFE_CIRCLE2["BEFORE_CHANGE_DATA"] = "beforechangedata";
  VIEW_LIFE_CIRCLE2["AFTER_CHANGE_DATA"] = "afterchangedata";
  VIEW_LIFE_CIRCLE2["BEFORE_CLEAR"] = "beforeclear";
  VIEW_LIFE_CIRCLE2["AFTER_CLEAR"] = "afterclear";
  VIEW_LIFE_CIRCLE2["BEFORE_DESTROY"] = "beforedestroy";
  VIEW_LIFE_CIRCLE2["BEFORE_CHANGE_SIZE"] = "beforechangesize";
  VIEW_LIFE_CIRCLE2["AFTER_CHANGE_SIZE"] = "afterchangesize";
})(VIEW_LIFE_CIRCLE || (VIEW_LIFE_CIRCLE = {}));
var GEOMETRY_LIFE_CIRCLE;
(function(GEOMETRY_LIFE_CIRCLE2) {
  GEOMETRY_LIFE_CIRCLE2["BEFORE_DRAW_ANIMATE"] = "beforeanimate";
  GEOMETRY_LIFE_CIRCLE2["AFTER_DRAW_ANIMATE"] = "afteranimate";
  GEOMETRY_LIFE_CIRCLE2["BEFORE_RENDER_LABEL"] = "beforerenderlabel";
  GEOMETRY_LIFE_CIRCLE2["AFTER_RENDER_LABEL"] = "afterrenderlabel";
})(GEOMETRY_LIFE_CIRCLE || (GEOMETRY_LIFE_CIRCLE = {}));
var PLOT_EVENTS;
(function(PLOT_EVENTS2) {
  PLOT_EVENTS2["MOUSE_ENTER"] = "plot:mouseenter";
  PLOT_EVENTS2["MOUSE_DOWN"] = "plot:mousedown";
  PLOT_EVENTS2["MOUSE_MOVE"] = "plot:mousemove";
  PLOT_EVENTS2["MOUSE_UP"] = "plot:mouseup";
  PLOT_EVENTS2["MOUSE_LEAVE"] = "plot:mouseleave";
  PLOT_EVENTS2["TOUCH_START"] = "plot:touchstart";
  PLOT_EVENTS2["TOUCH_MOVE"] = "plot:touchmove";
  PLOT_EVENTS2["TOUCH_END"] = "plot:touchend";
  PLOT_EVENTS2["TOUCH_CANCEL"] = "plot:touchcancel";
  PLOT_EVENTS2["CLICK"] = "plot:click";
  PLOT_EVENTS2["DBLCLICK"] = "plot:dblclick";
  PLOT_EVENTS2["CONTEXTMENU"] = "plot:contextmenu";
  PLOT_EVENTS2["LEAVE"] = "plot:leave";
  PLOT_EVENTS2["ENTER"] = "plot:enter";
})(PLOT_EVENTS || (PLOT_EVENTS = {}));
var ELEMENT_STATE;
(function(ELEMENT_STATE2) {
  ELEMENT_STATE2["ACTIVE"] = "active";
  ELEMENT_STATE2["INACTIVE"] = "inactive";
  ELEMENT_STATE2["SELECTED"] = "selected";
  ELEMENT_STATE2["DEFAULT"] = "default";
})(ELEMENT_STATE || (ELEMENT_STATE = {}));
var GROUP_ATTRS = ["color", "shape", "size"];
var FIELD_ORIGIN = "_origin";
var MIN_CHART_WIDTH = 1;
var MIN_CHART_HEIGHT = 1;
var COMPONENT_MAX_VIEW_PERCENTAGE = 0.25;

// node_modules/@antv/g2/esm/engine/index.js
var ENGINES = {};
function getEngine(name) {
  var G = ENGINES[name];
  if (!G) {
    throw new Error("G engine '".concat(name, "' is not exist, please register it at first."));
  }
  return G;
}
function registerEngine(name, engine) {
  ENGINES[name] = engine;
}

// node_modules/@antv/dom-util/esm/add-event-listener.js
function addEventListener(target, eventType, callback) {
  if (target) {
    if (typeof target.addEventListener === "function") {
      target.addEventListener(eventType, callback, false);
      return {
        remove: function() {
          target.removeEventListener(eventType, callback, false);
        }
      };
    }
    if (typeof target.attachEvent === "function") {
      target.attachEvent("on" + eventType, callback);
      return {
        remove: function() {
          target.detachEvent("on" + eventType, callback);
        }
      };
    }
  }
}

// node_modules/@antv/dom-util/esm/create-dom.js
var TABLE;
var TABLE_TR;
var FRAGMENT_REG;
var CONTAINERS;
function initConstants() {
  TABLE = document.createElement("table");
  TABLE_TR = document.createElement("tr");
  FRAGMENT_REG = /^\s*<(\w+|!)[^>]*>/;
  CONTAINERS = {
    tr: document.createElement("tbody"),
    tbody: TABLE,
    thead: TABLE,
    tfoot: TABLE,
    td: TABLE_TR,
    th: TABLE_TR,
    "*": document.createElement("div")
  };
}
function createDom(str4) {
  if (!TABLE) {
    initConstants();
  }
  var name = FRAGMENT_REG.test(str4) && RegExp.$1;
  if (!name || !(name in CONTAINERS)) {
    name = "*";
  }
  var container = CONTAINERS[name];
  str4 = typeof str4 === "string" ? str4.replace(/(^\s*)|(\s*$)/g, "") : str4;
  container.innerHTML = "" + str4;
  var dom = container.childNodes[0];
  if (dom && container.contains(dom)) {
    container.removeChild(dom);
  }
  return dom;
}

// node_modules/@antv/dom-util/esm/get-style.js
function getStyle(dom, name, defaultValue) {
  var v;
  try {
    v = window.getComputedStyle ? window.getComputedStyle(dom, null)[name] : dom.style[name];
  } catch (e) {
  } finally {
    v = v === void 0 ? defaultValue : v;
  }
  return v;
}

// node_modules/@antv/dom-util/esm/get-height.js
function getHeight(el, defaultValue) {
  var height = getStyle(el, "height", defaultValue);
  if (height === "auto") {
    height = el.offsetHeight;
  }
  return parseFloat(height);
}

// node_modules/@antv/dom-util/esm/get-outer-height.js
function getOuterHeight(el, defaultValue) {
  var height = getHeight(el, defaultValue);
  var bTop = parseFloat(getStyle(el, "borderTopWidth")) || 0;
  var pTop = parseFloat(getStyle(el, "paddingTop")) || 0;
  var pBottom = parseFloat(getStyle(el, "paddingBottom")) || 0;
  var bBottom = parseFloat(getStyle(el, "borderBottomWidth")) || 0;
  var mTop = parseFloat(getStyle(el, "marginTop")) || 0;
  var mBottom = parseFloat(getStyle(el, "marginBottom")) || 0;
  return height + bTop + bBottom + pTop + pBottom + mTop + mBottom;
}

// node_modules/@antv/dom-util/esm/get-width.js
function getHeight2(el, defaultValue) {
  var width = getStyle(el, "width", defaultValue);
  if (width === "auto") {
    width = el.offsetWidth;
  }
  return parseFloat(width);
}

// node_modules/@antv/dom-util/esm/get-outer-width.js
function getOuterWidth(el, defaultValue) {
  var width = getHeight2(el, defaultValue);
  var bLeft = parseFloat(getStyle(el, "borderLeftWidth")) || 0;
  var pLeft = parseFloat(getStyle(el, "paddingLeft")) || 0;
  var pRight = parseFloat(getStyle(el, "paddingRight")) || 0;
  var bRight = parseFloat(getStyle(el, "borderRightWidth")) || 0;
  var mRight = parseFloat(getStyle(el, "marginRight")) || 0;
  var mLeft = parseFloat(getStyle(el, "marginLeft")) || 0;
  return width + bLeft + bRight + pLeft + pRight + mLeft + mRight;
}

// node_modules/@antv/dom-util/esm/modify-css.js
function modifyCSS(dom, css) {
  if (dom) {
    for (var key in css) {
      if (css.hasOwnProperty(key)) {
        dom.style[key] = css[key];
      }
    }
  }
  return dom;
}

// node_modules/@antv/g2/esm/util/dom.js
function getElementSize(ele) {
  var style = getComputedStyle(ele);
  return {
    width: (ele.clientWidth || parseInt(style.width, 10)) - parseInt(style.paddingLeft, 10) - parseInt(style.paddingRight, 10),
    height: (ele.clientHeight || parseInt(style.height, 10)) - parseInt(style.paddingTop, 10) - parseInt(style.paddingBottom, 10)
  };
}
function isNumber2(v) {
  return typeof v === "number" && !isNaN(v);
}
function getChartSize(ele, autoFit, width, height) {
  var w = width;
  var h = height;
  if (autoFit) {
    var size2 = getElementSize(ele);
    w = size2.width ? size2.width : w;
    h = size2.height ? size2.height : h;
  }
  return {
    width: Math.max(isNumber2(w) ? w : MIN_CHART_WIDTH, MIN_CHART_WIDTH),
    height: Math.max(isNumber2(h) ? h : MIN_CHART_HEIGHT, MIN_CHART_HEIGHT)
  };
}
function removeDom(dom) {
  var parent = dom.parentNode;
  if (parent) {
    parent.removeChild(dom);
  }
}

// node_modules/@antv/event-emitter/esm/index.js
var WILDCARD = "*";
var EventEmitter = function() {
  function EventEmitter2() {
    this._events = {};
  }
  EventEmitter2.prototype.on = function(evt, callback, once) {
    if (!this._events[evt]) {
      this._events[evt] = [];
    }
    this._events[evt].push({
      callback,
      once: !!once
    });
    return this;
  };
  EventEmitter2.prototype.once = function(evt, callback) {
    return this.on(evt, callback, true);
  };
  EventEmitter2.prototype.emit = function(evt) {
    var _this = this;
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    var events = this._events[evt] || [];
    var wildcardEvents = this._events[WILDCARD] || [];
    var doEmit = function(es) {
      var length5 = es.length;
      for (var i = 0; i < length5; i++) {
        if (!es[i]) {
          continue;
        }
        var _a3 = es[i], callback = _a3.callback, once = _a3.once;
        if (once) {
          es.splice(i, 1);
          if (es.length === 0) {
            delete _this._events[evt];
          }
          length5--;
          i--;
        }
        callback.apply(_this, args);
      }
    };
    doEmit(events);
    doEmit(wildcardEvents);
  };
  EventEmitter2.prototype.off = function(evt, callback) {
    if (!evt) {
      this._events = {};
    } else {
      if (!callback) {
        delete this._events[evt];
      } else {
        var events = this._events[evt] || [];
        var length_1 = events.length;
        for (var i = 0; i < length_1; i++) {
          if (events[i].callback === callback) {
            events.splice(i, 1);
            length_1--;
            i--;
          }
        }
        if (events.length === 0) {
          delete this._events[evt];
        }
      }
    }
    return this;
  };
  EventEmitter2.prototype.getEvents = function() {
    return this._events;
  };
  return EventEmitter2;
}();
var esm_default = EventEmitter;

// node_modules/@antv/g2/esm/base.js
var Base = function(_super) {
  __extends(Base3, _super);
  function Base3(cfg) {
    var _this = _super.call(this) || this;
    _this.destroyed = false;
    var _a3 = cfg.visible, visible = _a3 === void 0 ? true : _a3;
    _this.visible = visible;
    return _this;
  }
  Base3.prototype.show = function() {
    var visible = this.visible;
    if (!visible) {
      this.changeVisible(true);
    }
  };
  Base3.prototype.hide = function() {
    var visible = this.visible;
    if (visible) {
      this.changeVisible(false);
    }
  };
  Base3.prototype.destroy = function() {
    this.off();
    this.destroyed = true;
  };
  Base3.prototype.changeVisible = function(visible) {
    if (this.visible === visible) {
      return;
    }
    this.visible = visible;
  };
  return Base3;
}(esm_default);
var base_default = Base;

// node_modules/@antv/g-base/esm/util/path.js
var path_exports = {};
__export(path_exports, {
  catmullRomToBezier: () => catmullRomToBezier,
  fillPath: () => fillPath,
  fillPathByDiff: () => fillPathByDiff,
  formatPath: () => formatPath,
  intersection: () => intersection,
  parsePathArray: () => parsePathArray,
  parsePathString: () => parsePathString,
  pathToAbsolute: () => pathToAbsolute,
  pathToCurve: () => pathToCurve,
  rectPath: () => rectPath
});
var SPACES = "	\n\v\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029";
var PATH_COMMAND = new RegExp("([a-z])[" + SPACES + ",]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[" + SPACES + "]*,?[" + SPACES + "]*)+)", "ig");
var PATH_VALUES = new RegExp("(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[" + SPACES + "]*,?[" + SPACES + "]*", "ig");
var parsePathString = function(pathString) {
  if (!pathString) {
    return null;
  }
  if (is_array_default(pathString)) {
    return pathString;
  }
  var paramCounts = {
    a: 7,
    c: 6,
    o: 2,
    h: 1,
    l: 2,
    m: 2,
    r: 4,
    q: 4,
    s: 4,
    t: 2,
    v: 1,
    u: 3,
    z: 0
  };
  var data = [];
  String(pathString).replace(PATH_COMMAND, function(a, b, c) {
    var params = [];
    var name = b.toLowerCase();
    c.replace(PATH_VALUES, function(a2, b10) {
      b10 && params.push(+b10);
    });
    if (name === "m" && params.length > 2) {
      data.push([b].concat(params.splice(0, 2)));
      name = "l";
      b = b === "m" ? "l" : "L";
    }
    if (name === "o" && params.length === 1) {
      data.push([b, params[0]]);
    }
    if (name === "r") {
      data.push([b].concat(params));
    } else {
      while (params.length >= paramCounts[name]) {
        data.push([b].concat(params.splice(0, paramCounts[name])));
        if (!paramCounts[name]) {
          break;
        }
      }
    }
    return pathString;
  });
  return data;
};
var catmullRomToBezier = function(crp, z) {
  var d = [];
  for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
    var p = [
      {
        x: +crp[i - 2],
        y: +crp[i - 1]
      },
      {
        x: +crp[i],
        y: +crp[i + 1]
      },
      {
        x: +crp[i + 2],
        y: +crp[i + 3]
      },
      {
        x: +crp[i + 4],
        y: +crp[i + 5]
      }
    ];
    if (z) {
      if (!i) {
        p[0] = {
          x: +crp[iLen - 2],
          y: +crp[iLen - 1]
        };
      } else if (iLen - 4 === i) {
        p[3] = {
          x: +crp[0],
          y: +crp[1]
        };
      } else if (iLen - 2 === i) {
        p[2] = {
          x: +crp[0],
          y: +crp[1]
        };
        p[3] = {
          x: +crp[2],
          y: +crp[3]
        };
      }
    } else {
      if (iLen - 4 === i) {
        p[3] = p[2];
      } else if (!i) {
        p[0] = {
          x: +crp[i],
          y: +crp[i + 1]
        };
      }
    }
    d.push([
      "C",
      (-p[0].x + 6 * p[1].x + p[2].x) / 6,
      (-p[0].y + 6 * p[1].y + p[2].y) / 6,
      (p[1].x + 6 * p[2].x - p[3].x) / 6,
      (p[1].y + 6 * p[2].y - p[3].y) / 6,
      p[2].x,
      p[2].y
    ]);
  }
  return d;
};
var ellipsePath = function(x, y, rx, ry, a) {
  var res = [];
  if (a === null && ry === null) {
    ry = rx;
  }
  x = +x;
  y = +y;
  rx = +rx;
  ry = +ry;
  if (a !== null) {
    var rad = Math.PI / 180;
    var x1 = x + rx * Math.cos(-ry * rad);
    var x2 = x + rx * Math.cos(-a * rad);
    var y1 = y + rx * Math.sin(-ry * rad);
    var y2 = y + rx * Math.sin(-a * rad);
    res = [
      ["M", x1, y1],
      ["A", rx, rx, 0, +(a - ry > 180), 0, x2, y2]
    ];
  } else {
    res = [["M", x, y], ["m", 0, -ry], ["a", rx, ry, 0, 1, 1, 0, 2 * ry], ["a", rx, ry, 0, 1, 1, 0, -2 * ry], ["z"]];
  }
  return res;
};
var pathToAbsolute = function(pathArray) {
  pathArray = parsePathString(pathArray);
  if (!pathArray || !pathArray.length) {
    return [["M", 0, 0]];
  }
  var res = [];
  var x = 0;
  var y = 0;
  var mx = 0;
  var my = 0;
  var start = 0;
  var pa0;
  var dots;
  if (pathArray[0][0] === "M") {
    x = +pathArray[0][1];
    y = +pathArray[0][2];
    mx = x;
    my = y;
    start++;
    res[0] = ["M", x, y];
  }
  var crz = pathArray.length === 3 && pathArray[0][0] === "M" && pathArray[1][0].toUpperCase() === "R" && pathArray[2][0].toUpperCase() === "Z";
  for (var r = void 0, pa = void 0, i = start, ii = pathArray.length; i < ii; i++) {
    res.push(r = []);
    pa = pathArray[i];
    pa0 = pa[0];
    if (pa0 !== pa0.toUpperCase()) {
      r[0] = pa0.toUpperCase();
      switch (r[0]) {
        case "A":
          r[1] = pa[1];
          r[2] = pa[2];
          r[3] = pa[3];
          r[4] = pa[4];
          r[5] = pa[5];
          r[6] = +pa[6] + x;
          r[7] = +pa[7] + y;
          break;
        case "V":
          r[1] = +pa[1] + y;
          break;
        case "H":
          r[1] = +pa[1] + x;
          break;
        case "R":
          dots = [x, y].concat(pa.slice(1));
          for (var j = 2, jj = dots.length; j < jj; j++) {
            dots[j] = +dots[j] + x;
            dots[++j] = +dots[j] + y;
          }
          res.pop();
          res = res.concat(catmullRomToBezier(dots, crz));
          break;
        case "O":
          res.pop();
          dots = ellipsePath(x, y, pa[1], pa[2]);
          dots.push(dots[0]);
          res = res.concat(dots);
          break;
        case "U":
          res.pop();
          res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
          r = ["U"].concat(res[res.length - 1].slice(-2));
          break;
        case "M":
          mx = +pa[1] + x;
          my = +pa[2] + y;
          break;
        default:
          for (var j = 1, jj = pa.length; j < jj; j++) {
            r[j] = +pa[j] + (j % 2 ? x : y);
          }
      }
    } else if (pa0 === "R") {
      dots = [x, y].concat(pa.slice(1));
      res.pop();
      res = res.concat(catmullRomToBezier(dots, crz));
      r = ["R"].concat(pa.slice(-2));
    } else if (pa0 === "O") {
      res.pop();
      dots = ellipsePath(x, y, pa[1], pa[2]);
      dots.push(dots[0]);
      res = res.concat(dots);
    } else if (pa0 === "U") {
      res.pop();
      res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
      r = ["U"].concat(res[res.length - 1].slice(-2));
    } else {
      for (var k = 0, kk = pa.length; k < kk; k++) {
        r[k] = pa[k];
      }
    }
    pa0 = pa0.toUpperCase();
    if (pa0 !== "O") {
      switch (r[0]) {
        case "Z":
          x = +mx;
          y = +my;
          break;
        case "H":
          x = r[1];
          break;
        case "V":
          y = r[1];
          break;
        case "M":
          mx = r[r.length - 2];
          my = r[r.length - 1];
          break;
        default:
          x = r[r.length - 2];
          y = r[r.length - 1];
      }
    }
  }
  return res;
};
var l2c = function(x1, y1, x2, y2) {
  return [x1, y1, x2, y2, x2, y2];
};
var q2c = function(x1, y1, ax, ay, x2, y2) {
  var _13 = 1 / 3;
  var _23 = 2 / 3;
  return [_13 * x1 + _23 * ax, _13 * y1 + _23 * ay, _13 * x2 + _23 * ax, _13 * y2 + _23 * ay, x2, y2];
};
var a2c = function(x1, y1, rx, ry, angle3, large_arc_flag, sweep_flag, x2, y2, recursive) {
  if (rx === ry) {
    rx += 1;
  }
  var _120 = Math.PI * 120 / 180;
  var rad = Math.PI / 180 * (+angle3 || 0);
  var res = [];
  var xy;
  var f1;
  var f2;
  var cx;
  var cy;
  var rotate5 = function(x3, y3, rad2) {
    var X = x3 * Math.cos(rad2) - y3 * Math.sin(rad2);
    var Y = x3 * Math.sin(rad2) + y3 * Math.cos(rad2);
    return {
      x: X,
      y: Y
    };
  };
  if (!recursive) {
    xy = rotate5(x1, y1, -rad);
    x1 = xy.x;
    y1 = xy.y;
    xy = rotate5(x2, y2, -rad);
    x2 = xy.x;
    y2 = xy.y;
    if (x1 === x2 && y1 === y2) {
      x2 += 1;
      y2 += 1;
    }
    var x = (x1 - x2) / 2;
    var y = (y1 - y2) / 2;
    var h = x * x / (rx * rx) + y * y / (ry * ry);
    if (h > 1) {
      h = Math.sqrt(h);
      rx = h * rx;
      ry = h * ry;
    }
    var rx2 = rx * rx;
    var ry2 = ry * ry;
    var k = (large_arc_flag === sweep_flag ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));
    cx = k * rx * y / ry + (x1 + x2) / 2;
    cy = k * -ry * x / rx + (y1 + y2) / 2;
    f1 = Math.asin(((y1 - cy) / ry).toFixed(9));
    f2 = Math.asin(((y2 - cy) / ry).toFixed(9));
    f1 = x1 < cx ? Math.PI - f1 : f1;
    f2 = x2 < cx ? Math.PI - f2 : f2;
    f1 < 0 && (f1 = Math.PI * 2 + f1);
    f2 < 0 && (f2 = Math.PI * 2 + f2);
    if (sweep_flag && f1 > f2) {
      f1 = f1 - Math.PI * 2;
    }
    if (!sweep_flag && f2 > f1) {
      f2 = f2 - Math.PI * 2;
    }
  } else {
    f1 = recursive[0];
    f2 = recursive[1];
    cx = recursive[2];
    cy = recursive[3];
  }
  var df = f2 - f1;
  if (Math.abs(df) > _120) {
    var f2old = f2;
    var x2old = x2;
    var y2old = y2;
    f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
    x2 = cx + rx * Math.cos(f2);
    y2 = cy + ry * Math.sin(f2);
    res = a2c(x2, y2, rx, ry, angle3, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
  }
  df = f2 - f1;
  var c1 = Math.cos(f1);
  var s1 = Math.sin(f1);
  var c2 = Math.cos(f2);
  var s2 = Math.sin(f2);
  var t = Math.tan(df / 4);
  var hx = 4 / 3 * rx * t;
  var hy = 4 / 3 * ry * t;
  var m1 = [x1, y1];
  var m2 = [x1 + hx * s1, y1 - hy * c1];
  var m3 = [x2 + hx * s2, y2 - hy * c2];
  var m4 = [x2, y2];
  m2[0] = 2 * m1[0] - m2[0];
  m2[1] = 2 * m1[1] - m2[1];
  if (recursive) {
    return [m2, m3, m4].concat(res);
  }
  res = [m2, m3, m4].concat(res).join().split(",");
  var newres = [];
  for (var i = 0, ii = res.length; i < ii; i++) {
    newres[i] = i % 2 ? rotate5(res[i - 1], res[i], rad).y : rotate5(res[i], res[i + 1], rad).x;
  }
  return newres;
};
var pathToCurve = function(path, path2) {
  var p = pathToAbsolute(path);
  var p2 = path2 && pathToAbsolute(path2);
  var attrs = {
    x: 0,
    y: 0,
    bx: 0,
    by: 0,
    X: 0,
    Y: 0,
    qx: null,
    qy: null
  };
  var attrs2 = {
    x: 0,
    y: 0,
    bx: 0,
    by: 0,
    X: 0,
    Y: 0,
    qx: null,
    qy: null
  };
  var pcoms1 = [];
  var pcoms2 = [];
  var pfirst = "";
  var pcom = "";
  var ii;
  var processPath = function(path3, d, pcom2) {
    var nx;
    var ny;
    if (!path3) {
      return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
    }
    !(path3[0] in {
      T: 1,
      Q: 1
    }) && (d.qx = d.qy = null);
    switch (path3[0]) {
      case "M":
        d.X = path3[1];
        d.Y = path3[2];
        break;
      case "A":
        path3 = ["C"].concat(a2c.apply(0, [d.x, d.y].concat(path3.slice(1))));
        break;
      case "S":
        if (pcom2 === "C" || pcom2 === "S") {
          nx = d.x * 2 - d.bx;
          ny = d.y * 2 - d.by;
        } else {
          nx = d.x;
          ny = d.y;
        }
        path3 = ["C", nx, ny].concat(path3.slice(1));
        break;
      case "T":
        if (pcom2 === "Q" || pcom2 === "T") {
          d.qx = d.x * 2 - d.qx;
          d.qy = d.y * 2 - d.qy;
        } else {
          d.qx = d.x;
          d.qy = d.y;
        }
        path3 = ["C"].concat(q2c(d.x, d.y, d.qx, d.qy, path3[1], path3[2]));
        break;
      case "Q":
        d.qx = path3[1];
        d.qy = path3[2];
        path3 = ["C"].concat(q2c(d.x, d.y, path3[1], path3[2], path3[3], path3[4]));
        break;
      case "L":
        path3 = ["C"].concat(l2c(d.x, d.y, path3[1], path3[2]));
        break;
      case "H":
        path3 = ["C"].concat(l2c(d.x, d.y, path3[1], d.y));
        break;
      case "V":
        path3 = ["C"].concat(l2c(d.x, d.y, d.x, path3[1]));
        break;
      case "Z":
        path3 = ["C"].concat(l2c(d.x, d.y, d.X, d.Y));
        break;
      default:
        break;
    }
    return path3;
  };
  var fixArc = function(pp, i2) {
    if (pp[i2].length > 7) {
      pp[i2].shift();
      var pi2 = pp[i2];
      while (pi2.length) {
        pcoms1[i2] = "A";
        p2 && (pcoms2[i2] = "A");
        pp.splice(i2++, 0, ["C"].concat(pi2.splice(0, 6)));
      }
      pp.splice(i2, 1);
      ii = Math.max(p.length, p2 && p2.length || 0);
    }
  };
  var fixM = function(path1, path22, a1, a2, i2) {
    if (path1 && path22 && path1[i2][0] === "M" && path22[i2][0] !== "M") {
      path22.splice(i2, 0, ["M", a2.x, a2.y]);
      a1.bx = 0;
      a1.by = 0;
      a1.x = path1[i2][1];
      a1.y = path1[i2][2];
      ii = Math.max(p.length, p2 && p2.length || 0);
    }
  };
  ii = Math.max(p.length, p2 && p2.length || 0);
  for (var i = 0; i < ii; i++) {
    p[i] && (pfirst = p[i][0]);
    if (pfirst !== "C") {
      pcoms1[i] = pfirst;
      i && (pcom = pcoms1[i - 1]);
    }
    p[i] = processPath(p[i], attrs, pcom);
    if (pcoms1[i] !== "A" && pfirst === "C")
      pcoms1[i] = "C";
    fixArc(p, i);
    if (p2) {
      p2[i] && (pfirst = p2[i][0]);
      if (pfirst !== "C") {
        pcoms2[i] = pfirst;
        i && (pcom = pcoms2[i - 1]);
      }
      p2[i] = processPath(p2[i], attrs2, pcom);
      if (pcoms2[i] !== "A" && pfirst === "C") {
        pcoms2[i] = "C";
      }
      fixArc(p2, i);
    }
    fixM(p, p2, attrs, attrs2, i);
    fixM(p2, p, attrs2, attrs, i);
    var seg = p[i];
    var seg2 = p2 && p2[i];
    var seglen = seg.length;
    var seg2len = p2 && seg2.length;
    attrs.x = seg[seglen - 2];
    attrs.y = seg[seglen - 1];
    attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;
    attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;
    attrs2.bx = p2 && (parseFloat(seg2[seg2len - 4]) || attrs2.x);
    attrs2.by = p2 && (parseFloat(seg2[seg2len - 3]) || attrs2.y);
    attrs2.x = p2 && seg2[seg2len - 2];
    attrs2.y = p2 && seg2[seg2len - 1];
  }
  return p2 ? [p, p2] : p;
};
var p2s = /,?([a-z]),?/gi;
var parsePathArray = function(path) {
  return path.join(",").replace(p2s, "$1");
};
var base3 = function(t, p1, p2, p3, p4) {
  var t12 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4;
  var t22 = t * t12 + 6 * p1 - 12 * p2 + 6 * p3;
  return t * t22 - 3 * p1 + 3 * p2;
};
var bezlen = function(x1, y1, x2, y2, x3, y3, x4, y4, z) {
  if (z === null) {
    z = 1;
  }
  z = z > 1 ? 1 : z < 0 ? 0 : z;
  var z2 = z / 2;
  var n = 12;
  var Tvalues = [
    -0.1252,
    0.1252,
    -0.3678,
    0.3678,
    -0.5873,
    0.5873,
    -0.7699,
    0.7699,
    -0.9041,
    0.9041,
    -0.9816,
    0.9816
  ];
  var Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472];
  var sum = 0;
  for (var i = 0; i < n; i++) {
    var ct = z2 * Tvalues[i] + z2;
    var xbase = base3(ct, x1, x2, x3, x4);
    var ybase = base3(ct, y1, y2, y3, y4);
    var comb = xbase * xbase + ybase * ybase;
    sum += Cvalues[i] * Math.sqrt(comb);
  }
  return z2 * sum;
};
var curveDim = function(x0, y0, x1, y1, x2, y2, x3, y3) {
  var tvalues = [];
  var bounds = [[], []];
  var a;
  var b;
  var c;
  var t;
  for (var i = 0; i < 2; ++i) {
    if (i === 0) {
      b = 6 * x0 - 12 * x1 + 6 * x2;
      a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
      c = 3 * x1 - 3 * x0;
    } else {
      b = 6 * y0 - 12 * y1 + 6 * y2;
      a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
      c = 3 * y1 - 3 * y0;
    }
    if (Math.abs(a) < 1e-12) {
      if (Math.abs(b) < 1e-12) {
        continue;
      }
      t = -c / b;
      if (t > 0 && t < 1) {
        tvalues.push(t);
      }
      continue;
    }
    var b2ac = b * b - 4 * c * a;
    var sqrtb2ac = Math.sqrt(b2ac);
    if (b2ac < 0) {
      continue;
    }
    var t12 = (-b + sqrtb2ac) / (2 * a);
    if (t12 > 0 && t12 < 1) {
      tvalues.push(t12);
    }
    var t22 = (-b - sqrtb2ac) / (2 * a);
    if (t22 > 0 && t22 < 1) {
      tvalues.push(t22);
    }
  }
  var j = tvalues.length;
  var jlen = j;
  var mt;
  while (j--) {
    t = tvalues[j];
    mt = 1 - t;
    bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
    bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
  }
  bounds[0][jlen] = x0;
  bounds[1][jlen] = y0;
  bounds[0][jlen + 1] = x3;
  bounds[1][jlen + 1] = y3;
  bounds[0].length = bounds[1].length = jlen + 2;
  return {
    min: {
      x: Math.min.apply(0, bounds[0]),
      y: Math.min.apply(0, bounds[1])
    },
    max: {
      x: Math.max.apply(0, bounds[0]),
      y: Math.max.apply(0, bounds[1])
    }
  };
};
var intersect = function(x1, y1, x2, y2, x3, y3, x4, y4) {
  if (Math.max(x1, x2) < Math.min(x3, x4) || Math.min(x1, x2) > Math.max(x3, x4) || Math.max(y1, y2) < Math.min(y3, y4) || Math.min(y1, y2) > Math.max(y3, y4)) {
    return;
  }
  var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4);
  var ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4);
  var denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
  if (!denominator) {
    return;
  }
  var px = nx / denominator;
  var py = ny / denominator;
  var px2 = +px.toFixed(2);
  var py2 = +py.toFixed(2);
  if (px2 < +Math.min(x1, x2).toFixed(2) || px2 > +Math.max(x1, x2).toFixed(2) || px2 < +Math.min(x3, x4).toFixed(2) || px2 > +Math.max(x3, x4).toFixed(2) || py2 < +Math.min(y1, y2).toFixed(2) || py2 > +Math.max(y1, y2).toFixed(2) || py2 < +Math.min(y3, y4).toFixed(2) || py2 > +Math.max(y3, y4).toFixed(2)) {
    return;
  }
  return {
    x: px,
    y: py
  };
};
var isPointInsideBBox = function(bbox, x, y) {
  return x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;
};
var rectPath = function(x, y, w, h, r) {
  if (r) {
    return [
      ["M", +x + +r, y],
      ["l", w - r * 2, 0],
      ["a", r, r, 0, 0, 1, r, r],
      ["l", 0, h - r * 2],
      ["a", r, r, 0, 0, 1, -r, r],
      ["l", r * 2 - w, 0],
      ["a", r, r, 0, 0, 1, -r, -r],
      ["l", 0, r * 2 - h],
      ["a", r, r, 0, 0, 1, r, -r],
      ["z"]
    ];
  }
  var res = [["M", x, y], ["l", w, 0], ["l", 0, h], ["l", -w, 0], ["z"]];
  res.parsePathArray = parsePathArray;
  return res;
};
var box = function(x, y, width, height) {
  if (x === null) {
    x = y = width = height = 0;
  }
  if (y === null) {
    y = x.y;
    width = x.width;
    height = x.height;
    x = x.x;
  }
  return {
    x,
    y,
    width,
    w: width,
    height,
    h: height,
    x2: x + width,
    y2: y + height,
    cx: x + width / 2,
    cy: y + height / 2,
    r1: Math.min(width, height) / 2,
    r2: Math.max(width, height) / 2,
    r0: Math.sqrt(width * width + height * height) / 2,
    path: rectPath(x, y, width, height),
    vb: [x, y, width, height].join(" ")
  };
};
var isBBoxIntersect = function(bbox1, bbox2) {
  bbox1 = box(bbox1);
  bbox2 = box(bbox2);
  return isPointInsideBBox(bbox2, bbox1.x, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2) || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x) && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
};
var bezierBBox = function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
  if (!is_array_default(p1x)) {
    p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
  }
  var bbox = curveDim.apply(null, p1x);
  return box(bbox.min.x, bbox.min.y, bbox.max.x - bbox.min.x, bbox.max.y - bbox.min.y);
};
var findDotsAtSegment = function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
  var t12 = 1 - t;
  var t13 = Math.pow(t12, 3);
  var t122 = Math.pow(t12, 2);
  var t22 = t * t;
  var t32 = t22 * t;
  var x = t13 * p1x + t122 * 3 * t * c1x + t12 * 3 * t * t * c2x + t32 * p2x;
  var y = t13 * p1y + t122 * 3 * t * c1y + t12 * 3 * t * t * c2y + t32 * p2y;
  var mx = p1x + 2 * t * (c1x - p1x) + t22 * (c2x - 2 * c1x + p1x);
  var my = p1y + 2 * t * (c1y - p1y) + t22 * (c2y - 2 * c1y + p1y);
  var nx = c1x + 2 * t * (c2x - c1x) + t22 * (p2x - 2 * c2x + c1x);
  var ny = c1y + 2 * t * (c2y - c1y) + t22 * (p2y - 2 * c2y + c1y);
  var ax = t12 * p1x + t * c1x;
  var ay = t12 * p1y + t * c1y;
  var cx = t12 * c2x + t * p2x;
  var cy = t12 * c2y + t * p2y;
  var alpha = 90 - Math.atan2(mx - nx, my - ny) * 180 / Math.PI;
  return {
    x,
    y,
    m: {
      x: mx,
      y: my
    },
    n: {
      x: nx,
      y: ny
    },
    start: {
      x: ax,
      y: ay
    },
    end: {
      x: cx,
      y: cy
    },
    alpha
  };
};
var interHelper = function(bez1, bez2, justCount) {
  var bbox1 = bezierBBox(bez1);
  var bbox2 = bezierBBox(bez2);
  if (!isBBoxIntersect(bbox1, bbox2)) {
    return justCount ? 0 : [];
  }
  var l1 = bezlen.apply(0, bez1);
  var l2 = bezlen.apply(0, bez2);
  var n1 = ~~(l1 / 8);
  var n2 = ~~(l2 / 8);
  var dots1 = [];
  var dots2 = [];
  var xy = {};
  var res = justCount ? 0 : [];
  for (var i = 0; i < n1 + 1; i++) {
    var d = findDotsAtSegment.apply(0, bez1.concat(i / n1));
    dots1.push({
      x: d.x,
      y: d.y,
      t: i / n1
    });
  }
  for (var i = 0; i < n2 + 1; i++) {
    var d = findDotsAtSegment.apply(0, bez2.concat(i / n2));
    dots2.push({
      x: d.x,
      y: d.y,
      t: i / n2
    });
  }
  for (var i = 0; i < n1; i++) {
    for (var j = 0; j < n2; j++) {
      var di = dots1[i];
      var di1 = dots1[i + 1];
      var dj = dots2[j];
      var dj1 = dots2[j + 1];
      var ci = Math.abs(di1.x - di.x) < 1e-3 ? "y" : "x";
      var cj = Math.abs(dj1.x - dj.x) < 1e-3 ? "y" : "x";
      var is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);
      if (is) {
        if (xy[is.x.toFixed(4)] === is.y.toFixed(4)) {
          continue;
        }
        xy[is.x.toFixed(4)] = is.y.toFixed(4);
        var t12 = di.t + Math.abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t);
        var t22 = dj.t + Math.abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
        if (t12 >= 0 && t12 <= 1 && t22 >= 0 && t22 <= 1) {
          if (justCount) {
            res += 1;
          } else {
            res.push({
              x: is.x,
              y: is.y,
              t1: t12,
              t2: t22
            });
          }
        }
      }
    }
  }
  return res;
};
var interPathHelper = function(path1, path2, justCount) {
  path1 = pathToCurve(path1);
  path2 = pathToCurve(path2);
  var x1;
  var y1;
  var x2;
  var y2;
  var x1m;
  var y1m;
  var x2m;
  var y2m;
  var bez1;
  var bez2;
  var res = justCount ? 0 : [];
  for (var i = 0, ii = path1.length; i < ii; i++) {
    var pi2 = path1[i];
    if (pi2[0] === "M") {
      x1 = x1m = pi2[1];
      y1 = y1m = pi2[2];
    } else {
      if (pi2[0] === "C") {
        bez1 = [x1, y1].concat(pi2.slice(1));
        x1 = bez1[6];
        y1 = bez1[7];
      } else {
        bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
        x1 = x1m;
        y1 = y1m;
      }
      for (var j = 0, jj = path2.length; j < jj; j++) {
        var pj = path2[j];
        if (pj[0] === "M") {
          x2 = x2m = pj[1];
          y2 = y2m = pj[2];
        } else {
          if (pj[0] === "C") {
            bez2 = [x2, y2].concat(pj.slice(1));
            x2 = bez2[6];
            y2 = bez2[7];
          } else {
            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
            x2 = x2m;
            y2 = y2m;
          }
          var intr = interHelper(bez1, bez2, justCount);
          if (justCount) {
            res += intr;
          } else {
            for (var k = 0, kk = intr.length; k < kk; k++) {
              intr[k].segment1 = i;
              intr[k].segment2 = j;
              intr[k].bez1 = bez1;
              intr[k].bez2 = bez2;
            }
            res = res.concat(intr);
          }
        }
      }
    }
  }
  return res;
};
var intersection = function(path1, path2) {
  return interPathHelper(path1, path2);
};
function decasteljau(points, t) {
  var left = [];
  var right = [];
  function recurse(points2, t4) {
    if (points2.length === 1) {
      left.push(points2[0]);
      right.push(points2[0]);
    } else {
      var middlePoints = [];
      for (var i = 0; i < points2.length - 1; i++) {
        if (i === 0) {
          left.push(points2[0]);
        }
        if (i === points2.length - 2) {
          right.push(points2[i + 1]);
        }
        middlePoints[i] = [
          (1 - t4) * points2[i][0] + t4 * points2[i + 1][0],
          (1 - t4) * points2[i][1] + t4 * points2[i + 1][1]
        ];
      }
      recurse(middlePoints, t4);
    }
  }
  if (points.length) {
    recurse(points, t);
  }
  return { left, right: right.reverse() };
}
function splitCurve(start, end, count) {
  var points = [[start[1], start[2]]];
  count = count || 2;
  var segments = [];
  if (end[0] === "A") {
    points.push(end[6]);
    points.push(end[7]);
  } else if (end[0] === "C") {
    points.push([end[1], end[2]]);
    points.push([end[3], end[4]]);
    points.push([end[5], end[6]]);
  } else if (end[0] === "S" || end[0] === "Q") {
    points.push([end[1], end[2]]);
    points.push([end[3], end[4]]);
  } else {
    points.push([end[1], end[2]]);
  }
  var leftSegments = points;
  var t = 1 / count;
  for (var i = 0; i < count - 1; i++) {
    var rt = t / (1 - t * i);
    var split = decasteljau(leftSegments, rt);
    segments.push(split.left);
    leftSegments = split.right;
  }
  segments.push(leftSegments);
  var result = segments.map(function(segment) {
    var cmd = [];
    if (segment.length === 4) {
      cmd.push("C");
      cmd = cmd.concat(segment[2]);
    }
    if (segment.length >= 3) {
      if (segment.length === 3) {
        cmd.push("Q");
      }
      cmd = cmd.concat(segment[1]);
    }
    if (segment.length === 2) {
      cmd.push("L");
    }
    cmd = cmd.concat(segment[segment.length - 1]);
    return cmd;
  });
  return result;
}
var splitSegment = function(start, end, count) {
  if (count === 1) {
    return [[].concat(start)];
  }
  var segments = [];
  if (end[0] === "L" || end[0] === "C" || end[0] === "Q") {
    segments = segments.concat(splitCurve(start, end, count));
  } else {
    var temp = [].concat(start);
    if (temp[0] === "M") {
      temp[0] = "L";
    }
    for (var i = 0; i <= count - 1; i++) {
      segments.push(temp);
    }
  }
  return segments;
};
var fillPath = function(source, target) {
  if (source.length === 1) {
    return source;
  }
  var sourceLen = source.length - 1;
  var targetLen = target.length - 1;
  var ratio = sourceLen / targetLen;
  var segmentsToFill = [];
  if (source.length === 1 && source[0][0] === "M") {
    for (var i = 0; i < targetLen - sourceLen; i++) {
      source.push(source[0]);
    }
    return source;
  }
  for (var i = 0; i < targetLen; i++) {
    var index = Math.floor(ratio * i);
    segmentsToFill[index] = (segmentsToFill[index] || 0) + 1;
  }
  var filled = segmentsToFill.reduce(function(filled2, count, i2) {
    if (i2 === sourceLen) {
      return filled2.concat(source[sourceLen]);
    }
    return filled2.concat(splitSegment(source[i2], source[i2 + 1], count));
  }, []);
  filled.unshift(source[0]);
  if (target[targetLen] === "Z" || target[targetLen] === "z") {
    filled.push("Z");
  }
  return filled;
};
var isEqual2 = function(obj1, obj2) {
  if (obj1.length !== obj2.length) {
    return false;
  }
  var result = true;
  each_default(obj1, function(item, i) {
    if (item !== obj2[i]) {
      result = false;
      return false;
    }
  });
  return result;
};
function getMinDiff(del, add5, modify) {
  var type = null;
  var min3 = modify;
  if (add5 < min3) {
    min3 = add5;
    type = "add";
  }
  if (del < min3) {
    min3 = del;
    type = "del";
  }
  return {
    type,
    min: min3
  };
}
var levenshteinDistance = function(source, target) {
  var sourceLen = source.length;
  var targetLen = target.length;
  var sourceSegment;
  var targetSegment;
  var temp = 0;
  if (sourceLen === 0 || targetLen === 0) {
    return null;
  }
  var dist3 = [];
  for (var i = 0; i <= sourceLen; i++) {
    dist3[i] = [];
    dist3[i][0] = { min: i };
  }
  for (var j = 0; j <= targetLen; j++) {
    dist3[0][j] = { min: j };
  }
  for (var i = 1; i <= sourceLen; i++) {
    sourceSegment = source[i - 1];
    for (var j = 1; j <= targetLen; j++) {
      targetSegment = target[j - 1];
      if (isEqual2(sourceSegment, targetSegment)) {
        temp = 0;
      } else {
        temp = 1;
      }
      var del = dist3[i - 1][j].min + 1;
      var add5 = dist3[i][j - 1].min + 1;
      var modify = dist3[i - 1][j - 1].min + temp;
      dist3[i][j] = getMinDiff(del, add5, modify);
    }
  }
  return dist3;
};
var fillPathByDiff = function(source, target) {
  var diffMatrix = levenshteinDistance(source, target);
  var sourceLen = source.length;
  var targetLen = target.length;
  var changes = [];
  var index = 1;
  var minPos = 1;
  if (diffMatrix[sourceLen][targetLen].min !== sourceLen) {
    for (var i = 1; i <= sourceLen; i++) {
      var min3 = diffMatrix[i][i].min;
      minPos = i;
      for (var j = index; j <= targetLen; j++) {
        if (diffMatrix[i][j].min < min3) {
          min3 = diffMatrix[i][j].min;
          minPos = j;
        }
      }
      index = minPos;
      if (diffMatrix[i][index].type) {
        changes.push({ index: i - 1, type: diffMatrix[i][index].type });
      }
    }
    for (var i = changes.length - 1; i >= 0; i--) {
      index = changes[i].index;
      if (changes[i].type === "add") {
        source.splice(index, 0, [].concat(source[index]));
      } else {
        source.splice(index, 1);
      }
    }
  }
  sourceLen = source.length;
  var diff2 = targetLen - sourceLen;
  if (sourceLen < targetLen) {
    for (var i = 0; i < diff2; i++) {
      if (source[sourceLen - 1][0] === "z" || source[sourceLen - 1][0] === "Z") {
        source.splice(sourceLen - 2, 0, source[sourceLen - 2]);
      } else {
        source.push(source[sourceLen - 1]);
      }
      sourceLen += 1;
    }
  }
  return source;
};
function _splitPoints(points, former, count) {
  var result = [].concat(points);
  var index;
  var t = 1 / (count + 1);
  var formerEnd = _getSegmentPoints(former)[0];
  for (var i = 1; i <= count; i++) {
    t *= i;
    index = Math.floor(points.length * t);
    if (index === 0) {
      result.unshift([formerEnd[0] * t + points[index][0] * (1 - t), formerEnd[1] * t + points[index][1] * (1 - t)]);
    } else {
      result.splice(index, 0, [
        formerEnd[0] * t + points[index][0] * (1 - t),
        formerEnd[1] * t + points[index][1] * (1 - t)
      ]);
    }
  }
  return result;
}
function _getSegmentPoints(segment) {
  var points = [];
  switch (segment[0]) {
    case "M":
      points.push([segment[1], segment[2]]);
      break;
    case "L":
      points.push([segment[1], segment[2]]);
      break;
    case "A":
      points.push([segment[6], segment[7]]);
      break;
    case "Q":
      points.push([segment[3], segment[4]]);
      points.push([segment[1], segment[2]]);
      break;
    case "T":
      points.push([segment[1], segment[2]]);
      break;
    case "C":
      points.push([segment[5], segment[6]]);
      points.push([segment[1], segment[2]]);
      points.push([segment[3], segment[4]]);
      break;
    case "S":
      points.push([segment[3], segment[4]]);
      points.push([segment[1], segment[2]]);
      break;
    case "H":
      points.push([segment[1], segment[1]]);
      break;
    case "V":
      points.push([segment[1], segment[1]]);
      break;
    default:
  }
  return points;
}
var formatPath = function(fromPath, toPath) {
  if (fromPath.length <= 1) {
    return fromPath;
  }
  var points;
  for (var i = 0; i < toPath.length; i++) {
    if (fromPath[i][0] !== toPath[i][0]) {
      points = _getSegmentPoints(fromPath[i]);
      switch (toPath[i][0]) {
        case "M":
          fromPath[i] = ["M"].concat(points[0]);
          break;
        case "L":
          fromPath[i] = ["L"].concat(points[0]);
          break;
        case "A":
          fromPath[i] = [].concat(toPath[i]);
          fromPath[i][6] = points[0][0];
          fromPath[i][7] = points[0][1];
          break;
        case "Q":
          if (points.length < 2) {
            if (i > 0) {
              points = _splitPoints(points, fromPath[i - 1], 1);
            } else {
              fromPath[i] = toPath[i];
              break;
            }
          }
          fromPath[i] = ["Q"].concat(points.reduce(function(arr, i2) {
            return arr.concat(i2);
          }, []));
          break;
        case "T":
          fromPath[i] = ["T"].concat(points[0]);
          break;
        case "C":
          if (points.length < 3) {
            if (i > 0) {
              points = _splitPoints(points, fromPath[i - 1], 2);
            } else {
              fromPath[i] = toPath[i];
              break;
            }
          }
          fromPath[i] = ["C"].concat(points.reduce(function(arr, i2) {
            return arr.concat(i2);
          }, []));
          break;
        case "S":
          if (points.length < 2) {
            if (i > 0) {
              points = _splitPoints(points, fromPath[i - 1], 1);
            } else {
              fromPath[i] = toPath[i];
              break;
            }
          }
          fromPath[i] = ["S"].concat(points.reduce(function(arr, i2) {
            return arr.concat(i2);
          }, []));
          break;
        default:
          fromPath[i] = toPath[i];
      }
    }
  }
  return fromPath;
};

// node_modules/@antv/g-base/esm/event/graph-event.js
var GraphEvent = function() {
  function GraphEvent2(type, event) {
    this.bubbles = true;
    this.target = null;
    this.currentTarget = null;
    this.delegateTarget = null;
    this.delegateObject = null;
    this.defaultPrevented = false;
    this.propagationStopped = false;
    this.shape = null;
    this.fromShape = null;
    this.toShape = null;
    this.propagationPath = [];
    this.type = type;
    this.name = type;
    this.originalEvent = event;
    this.timeStamp = event.timeStamp;
  }
  GraphEvent2.prototype.preventDefault = function() {
    this.defaultPrevented = true;
    if (this.originalEvent.preventDefault) {
      this.originalEvent.preventDefault();
    }
  };
  GraphEvent2.prototype.stopPropagation = function() {
    this.propagationStopped = true;
  };
  GraphEvent2.prototype.toString = function() {
    var type = this.type;
    return "[Event (type=" + type + ")]";
  };
  GraphEvent2.prototype.save = function() {
  };
  GraphEvent2.prototype.restore = function() {
  };
  return GraphEvent2;
}();
var graph_event_default = GraphEvent;

// node_modules/@antv/g-base/esm/util/util.js
function removeFromArray(arr, obj) {
  var index = arr.indexOf(obj);
  if (index !== -1) {
    arr.splice(index, 1);
  }
}
var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
function isParent(container, shape) {
  if (container.isCanvas()) {
    return true;
  }
  var parent = shape.getParent();
  var isParent2 = false;
  while (parent) {
    if (parent === container) {
      isParent2 = true;
      break;
    }
    parent = parent.getParent();
  }
  return isParent2;
}
function isAllowCapture(element) {
  return element.cfg.visible && element.cfg.capture;
}

// node_modules/@antv/g-base/esm/abstract/base.js
var Base2 = function(_super) {
  __extends(Base3, _super);
  function Base3(cfg) {
    var _this = _super.call(this) || this;
    _this.destroyed = false;
    var defaultCfg = _this.getDefaultCfg();
    _this.cfg = mix(defaultCfg, cfg);
    return _this;
  }
  Base3.prototype.getDefaultCfg = function() {
    return {};
  };
  Base3.prototype.get = function(name) {
    return this.cfg[name];
  };
  Base3.prototype.set = function(name, value) {
    this.cfg[name] = value;
  };
  Base3.prototype.destroy = function() {
    this.cfg = {
      destroyed: true
    };
    this.off();
    this.destroyed = true;
  };
  return Base3;
}(esm_default);
var base_default2 = Base2;

// node_modules/detect-browser/es/index.js
var __spreadArray2 = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var BrowserInfo = function() {
  function BrowserInfo2(name, version3, os) {
    this.name = name;
    this.version = version3;
    this.os = os;
    this.type = "browser";
  }
  return BrowserInfo2;
}();
var NodeInfo = function() {
  function NodeInfo2(version3) {
    this.version = version3;
    this.type = "node";
    this.name = "node";
    this.os = process.platform;
  }
  return NodeInfo2;
}();
var SearchBotDeviceInfo = function() {
  function SearchBotDeviceInfo2(name, version3, os, bot) {
    this.name = name;
    this.version = version3;
    this.os = os;
    this.bot = bot;
    this.type = "bot-device";
  }
  return SearchBotDeviceInfo2;
}();
var BotInfo = function() {
  function BotInfo2() {
    this.type = "bot";
    this.bot = true;
    this.name = "bot";
    this.version = null;
    this.os = null;
  }
  return BotInfo2;
}();
var ReactNativeInfo = function() {
  function ReactNativeInfo2() {
    this.type = "react-native";
    this.name = "react-native";
    this.version = null;
    this.os = null;
  }
  return ReactNativeInfo2;
}();
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
  ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
  ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", SEARCHBOX_UA_REGEX]
];
var operatingSystemRules = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function detect(userAgent) {
  if (!!userAgent) {
    return parseUserAgent(userAgent);
  }
  if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return new ReactNativeInfo();
  }
  if (typeof navigator !== "undefined") {
    return parseUserAgent(navigator.userAgent);
  }
  return getNodeVersion();
}
function matchUserAgent(ua) {
  return ua !== "" && userAgentRules.reduce(function(matched, _a3) {
    var browser2 = _a3[0], regex = _a3[1];
    if (matched) {
      return matched;
    }
    var uaMatch = regex.exec(ua);
    return !!uaMatch && [browser2, uaMatch];
  }, false);
}
function parseUserAgent(ua) {
  var matchedRule = matchUserAgent(ua);
  if (!matchedRule) {
    return null;
  }
  var name = matchedRule[0], match = matchedRule[1];
  if (name === "searchbot") {
    return new BotInfo();
  }
  var versionParts = match[1] && match[1].split(".").join("_").split("_").slice(0, 3);
  if (versionParts) {
    if (versionParts.length < REQUIRED_VERSION_PARTS) {
      versionParts = __spreadArray2(__spreadArray2([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);
    }
  } else {
    versionParts = [];
  }
  var version3 = versionParts.join(".");
  var os = detectOS(ua);
  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
  if (searchBotMatch && searchBotMatch[1]) {
    return new SearchBotDeviceInfo(name, version3, os, searchBotMatch[1]);
  }
  return new BrowserInfo(name, version3, os);
}
function detectOS(ua) {
  for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
    var _a3 = operatingSystemRules[ii], os = _a3[0], regex = _a3[1];
    var match = regex.exec(ua);
    if (match) {
      return os;
    }
  }
  return null;
}
function getNodeVersion() {
  var isNode = typeof process !== "undefined" && process.version;
  return isNode ? new NodeInfo(process.version.slice(1)) : null;
}
function createVersionParts(count) {
  var output = [];
  for (var ii = 0; ii < count; ii++) {
    output.push("0");
  }
  return output;
}

// node_modules/gl-matrix/esm/common.js
var EPSILON = 1e-6;
var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
var RANDOM = Math.random;
var degree = Math.PI / 180;
if (!Math.hypot)
  Math.hypot = function() {
    var y = 0, i = arguments.length;
    while (i--) {
      y += arguments[i] * arguments[i];
    }
    return Math.sqrt(y);
  };

// node_modules/gl-matrix/esm/mat3.js
var mat3_exports = {};
__export(mat3_exports, {
  add: () => add,
  adjoint: () => adjoint,
  clone: () => clone2,
  copy: () => copy,
  create: () => create,
  determinant: () => determinant,
  equals: () => equals,
  exactEquals: () => exactEquals,
  frob: () => frob,
  fromMat2d: () => fromMat2d,
  fromMat4: () => fromMat4,
  fromQuat: () => fromQuat,
  fromRotation: () => fromRotation,
  fromScaling: () => fromScaling,
  fromTranslation: () => fromTranslation,
  fromValues: () => fromValues,
  identity: () => identity2,
  invert: () => invert,
  mul: () => mul,
  multiply: () => multiply,
  multiplyScalar: () => multiplyScalar,
  multiplyScalarAndAdd: () => multiplyScalarAndAdd,
  normalFromMat4: () => normalFromMat4,
  projection: () => projection,
  rotate: () => rotate,
  scale: () => scale,
  set: () => set,
  str: () => str,
  sub: () => sub,
  subtract: () => subtract,
  translate: () => translate,
  transpose: () => transpose
});
function create() {
  var out = new ARRAY_TYPE(9);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}
function clone2(a) {
  var out = new ARRAY_TYPE(9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
function identity2(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function transpose(out, a) {
  if (out === a) {
    var a01 = a[1], a02 = a[2], a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }
  return out;
}
function invert(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;
  var det = a00 * b01 + a01 * b11 + a02 * b21;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
function adjoint(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
function determinant(a) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
function multiply(out, a, b) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  var b00 = b[0], b01 = b[1], b02 = b[2];
  var b10 = b[3], b11 = b[4], b12 = b[5];
  var b20 = b[6], b21 = b[7], b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
function translate(out, a, v) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], x = v[0], y = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}
function rotate(out, a, rad) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], s = Math.sin(rad), c = Math.cos(rad);
  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;
  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
function scale(out, a, v) {
  var x = v[0], y = v[1];
  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];
  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
function fromRotation(out, rad) {
  var s = Math.sin(rad), c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = -s;
  out[4] = c;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;
  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;
  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}
function fromQuat(out, q) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
function normalFromMat4(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
function str(a) {
  return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
}
function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
}
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}
function multiplyScalarAndAdd(out, a, b, scale5) {
  out[0] = a[0] + b[0] * scale5;
  out[1] = a[1] + b[1] * scale5;
  out[2] = a[2] + b[2] * scale5;
  out[3] = a[3] + b[3] * scale5;
  out[4] = a[4] + b[4] * scale5;
  out[5] = a[5] + b[5] * scale5;
  out[6] = a[6] + b[6] * scale5;
  out[7] = a[7] + b[7] * scale5;
  out[8] = a[8] + b[8] * scale5;
  return out;
}
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}
function equals(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7], a8 = a[8];
  var b02 = b[0], b12 = b[1], b22 = b[2], b32 = b[3], b42 = b[4], b52 = b[5], b62 = b[6], b72 = b[7], b82 = b[8];
  return Math.abs(a0 - b02) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b02)) && Math.abs(a1 - b12) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b12)) && Math.abs(a2 - b22) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b22)) && Math.abs(a3 - b32) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b32)) && Math.abs(a4 - b42) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b42)) && Math.abs(a5 - b52) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b52)) && Math.abs(a6 - b62) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b62)) && Math.abs(a7 - b72) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b72)) && Math.abs(a8 - b82) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b82));
}
var mul = multiply;
var sub = subtract;

// node_modules/gl-matrix/esm/vec3.js
var vec3_exports = {};
__export(vec3_exports, {
  add: () => add2,
  angle: () => angle,
  bezier: () => bezier,
  ceil: () => ceil,
  clone: () => clone3,
  copy: () => copy2,
  create: () => create2,
  cross: () => cross,
  dist: () => dist,
  distance: () => distance,
  div: () => div,
  divide: () => divide,
  dot: () => dot,
  equals: () => equals2,
  exactEquals: () => exactEquals2,
  floor: () => floor,
  forEach: () => forEach,
  fromValues: () => fromValues2,
  hermite: () => hermite,
  inverse: () => inverse,
  len: () => len,
  length: () => length,
  lerp: () => lerp,
  max: () => max,
  min: () => min,
  mul: () => mul2,
  multiply: () => multiply2,
  negate: () => negate,
  normalize: () => normalize,
  random: () => random,
  rotateX: () => rotateX,
  rotateY: () => rotateY,
  rotateZ: () => rotateZ,
  round: () => round,
  scale: () => scale2,
  scaleAndAdd: () => scaleAndAdd,
  set: () => set2,
  sqrDist: () => sqrDist,
  sqrLen: () => sqrLen,
  squaredDistance: () => squaredDistance,
  squaredLength: () => squaredLength,
  str: () => str2,
  sub: () => sub2,
  subtract: () => subtract2,
  transformMat3: () => transformMat3,
  transformMat4: () => transformMat4,
  transformQuat: () => transformQuat,
  zero: () => zero
});
function create2() {
  var out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function clone3(a) {
  var out = new ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
function fromValues2(x, y, z) {
  var out = new ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function copy2(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
function set2(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function add2(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
function subtract2(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
function multiply2(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
function scale2(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
function scaleAndAdd(out, a, b, scale5) {
  out[0] = a[0] + b[0] * scale5;
  out[1] = a[1] + b[1] * scale5;
  out[2] = a[2] + b[2] * scale5;
  return out;
}
function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
function inverse(out, a) {
  out[0] = 1 / a[0];
  out[1] = 1 / a[1];
  out[2] = 1 / a[2];
  return out;
}
function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len3 = x * x + y * y + z * z;
  if (len3 > 0) {
    len3 = 1 / Math.sqrt(len3);
  }
  out[0] = a[0] * len3;
  out[1] = a[1] * len3;
  out[2] = a[2] * len3;
  return out;
}
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
function cross(out, a, b) {
  var ax = a[0], ay = a[1], az = a[2];
  var bx = b[0], by = b[1], bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
function random(out, scale5) {
  scale5 = scale5 || 1;
  var r = RANDOM() * 2 * Math.PI;
  var z = RANDOM() * 2 - 1;
  var zScale = Math.sqrt(1 - z * z) * scale5;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale5;
  return out;
}
function transformMat4(out, a, m) {
  var x = a[0], y = a[1], z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
function transformMat3(out, a, m) {
  var x = a[0], y = a[1], z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
function transformQuat(out, a, q) {
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  var x = a[0], y = a[1], z = a[2];
  var uvx = qy * z - qz * y, uvy = qz * x - qx * z, uvz = qx * y - qy * x;
  var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2;
  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2;
  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
function rotateX(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateY(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateZ(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2];
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function angle(a, b) {
  var ax = a[0], ay = a[1], az = a[2], bx = b[0], by = b[1], bz = b[2], mag1 = Math.sqrt(ax * ax + ay * ay + az * az), mag2 = Math.sqrt(bx * bx + by * by + bz * bz), mag = mag1 * mag2, cosine = mag && dot(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}
function str2(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}
function exactEquals2(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
function equals2(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2];
  var b02 = b[0], b12 = b[1], b22 = b[2];
  return Math.abs(a0 - b02) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b02)) && Math.abs(a1 - b12) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b12)) && Math.abs(a2 - b22) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b22));
}
var sub2 = subtract2;
var mul2 = multiply2;
var div = divide;
var dist = distance;
var sqrDist = squaredDistance;
var len = length;
var sqrLen = squaredLength;
var forEach = function() {
  var vec = create2();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 3;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }
    return a;
  };
}();

// node_modules/gl-matrix/esm/vec4.js
function create3() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}
function normalize2(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len3 = x * x + y * y + z * z + w * w;
  if (len3 > 0) {
    len3 = 1 / Math.sqrt(len3);
  }
  out[0] = x * len3;
  out[1] = y * len3;
  out[2] = z * len3;
  out[3] = w * len3;
  return out;
}
var forEach2 = function() {
  var vec = create3();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 4;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }
    return a;
  };
}();

// node_modules/gl-matrix/esm/quat.js
function create4() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}
function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
function slerp(out, a, b, t) {
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = b[0], by = b[1], bz = b[2], bw = b[3];
  var omega, cosom, sinom, scale0, scale1;
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  if (cosom < 0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  if (1 - cosom > EPSILON) {
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    scale0 = 1 - t;
    scale1 = t;
  }
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
function fromMat3(out, m) {
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;
  if (fTrace > 0) {
    fRoot = Math.sqrt(fTrace + 1);
    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    var i = 0;
    if (m[4] > m[0])
      i = 1;
    if (m[8] > m[i * 3 + i])
      i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }
  return out;
}
var normalize3 = normalize2;
var rotationTo = function() {
  var tmpvec3 = create2();
  var xUnitVec3 = fromValues2(1, 0, 0);
  var yUnitVec3 = fromValues2(0, 1, 0);
  return function(out, a, b) {
    var dot6 = dot(a, b);
    if (dot6 < -0.999999) {
      cross(tmpvec3, xUnitVec3, a);
      if (len(tmpvec3) < 1e-6)
        cross(tmpvec3, yUnitVec3, a);
      normalize(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot6 > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      cross(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot6;
      return normalize3(out, out);
    }
  };
}();
var sqlerp = function() {
  var temp1 = create4();
  var temp2 = create4();
  return function(out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
}();
var setAxes = function() {
  var matr = create();
  return function(out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize3(out, fromMat3(out, matr));
  };
}();

// node_modules/gl-matrix/esm/vec2.js
var vec2_exports = {};
__export(vec2_exports, {
  add: () => add4,
  angle: () => angle2,
  ceil: () => ceil2,
  clone: () => clone5,
  copy: () => copy5,
  create: () => create5,
  cross: () => cross2,
  dist: () => dist2,
  distance: () => distance2,
  div: () => div2,
  divide: () => divide2,
  dot: () => dot4,
  equals: () => equals4,
  exactEquals: () => exactEquals4,
  floor: () => floor2,
  forEach: () => forEach3,
  fromValues: () => fromValues4,
  inverse: () => inverse2,
  len: () => len2,
  length: () => length4,
  lerp: () => lerp3,
  max: () => max2,
  min: () => min2,
  mul: () => mul3,
  multiply: () => multiply3,
  negate: () => negate2,
  normalize: () => normalize4,
  random: () => random2,
  rotate: () => rotate2,
  round: () => round2,
  scale: () => scale4,
  scaleAndAdd: () => scaleAndAdd2,
  set: () => set4,
  sqrDist: () => sqrDist2,
  sqrLen: () => sqrLen2,
  squaredDistance: () => squaredDistance2,
  squaredLength: () => squaredLength4,
  str: () => str3,
  sub: () => sub3,
  subtract: () => subtract3,
  transformMat2: () => transformMat2,
  transformMat2d: () => transformMat2d,
  transformMat3: () => transformMat32,
  transformMat4: () => transformMat42,
  zero: () => zero2
});
function create5() {
  var out = new ARRAY_TYPE(2);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}
function clone5(a) {
  var out = new ARRAY_TYPE(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
function fromValues4(x, y) {
  var out = new ARRAY_TYPE(2);
  out[0] = x;
  out[1] = y;
  return out;
}
function copy5(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
function set4(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}
function add4(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}
function subtract3(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}
function multiply3(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}
function divide2(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}
function ceil2(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}
function floor2(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}
function min2(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}
function max2(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}
function round2(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}
function scale4(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}
function scaleAndAdd2(out, a, b, scale5) {
  out[0] = a[0] + b[0] * scale5;
  out[1] = a[1] + b[1] * scale5;
  return out;
}
function distance2(a, b) {
  var x = b[0] - a[0], y = b[1] - a[1];
  return Math.hypot(x, y);
}
function squaredDistance2(a, b) {
  var x = b[0] - a[0], y = b[1] - a[1];
  return x * x + y * y;
}
function length4(a) {
  var x = a[0], y = a[1];
  return Math.hypot(x, y);
}
function squaredLength4(a) {
  var x = a[0], y = a[1];
  return x * x + y * y;
}
function negate2(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}
function inverse2(out, a) {
  out[0] = 1 / a[0];
  out[1] = 1 / a[1];
  return out;
}
function normalize4(out, a) {
  var x = a[0], y = a[1];
  var len3 = x * x + y * y;
  if (len3 > 0) {
    len3 = 1 / Math.sqrt(len3);
  }
  out[0] = a[0] * len3;
  out[1] = a[1] * len3;
  return out;
}
function dot4(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}
function cross2(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
function lerp3(out, a, b, t) {
  var ax = a[0], ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
function random2(out, scale5) {
  scale5 = scale5 || 1;
  var r = RANDOM() * 2 * Math.PI;
  out[0] = Math.cos(r) * scale5;
  out[1] = Math.sin(r) * scale5;
  return out;
}
function transformMat2(out, a, m) {
  var x = a[0], y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}
function transformMat2d(out, a, m) {
  var x = a[0], y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
function transformMat32(out, a, m) {
  var x = a[0], y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
function transformMat42(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}
function rotate2(out, a, b, rad) {
  var p0 = a[0] - b[0], p1 = a[1] - b[1], sinC = Math.sin(rad), cosC = Math.cos(rad);
  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}
function angle2(a, b) {
  var x1 = a[0], y1 = a[1], x2 = b[0], y2 = b[1], mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2), cosine = mag && (x1 * x2 + y1 * y2) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero2(out) {
  out[0] = 0;
  out[1] = 0;
  return out;
}
function str3(a) {
  return "vec2(" + a[0] + ", " + a[1] + ")";
}
function exactEquals4(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
function equals4(a, b) {
  var a0 = a[0], a1 = a[1];
  var b02 = b[0], b12 = b[1];
  return Math.abs(a0 - b02) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b02)) && Math.abs(a1 - b12) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b12));
}
var len2 = length4;
var sub3 = subtract3;
var mul3 = multiply3;
var div2 = divide2;
var dist2 = distance2;
var sqrDist2 = squaredDistance2;
var sqrLen2 = squaredLength4;
var forEach3 = function() {
  var vec = create5();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 2;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }
    return a;
  };
}();

// node_modules/@antv/matrix-util/esm/ext.js
var ext_exports = {};
__export(ext_exports, {
  angleTo: () => angleTo,
  direction: () => direction,
  leftRotate: () => leftRotate,
  leftScale: () => leftScale,
  leftTranslate: () => leftTranslate,
  transform: () => transform,
  vertical: () => vertical
});
function leftTranslate(out, a, v) {
  var transMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  mat3_exports.fromTranslation(transMat, v);
  return mat3_exports.multiply(out, transMat, a);
}
function leftRotate(out, a, rad) {
  var rotateMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  mat3_exports.fromRotation(rotateMat, rad);
  return mat3_exports.multiply(out, rotateMat, a);
}
function leftScale(out, a, v) {
  var scaleMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  mat3_exports.fromScaling(scaleMat, v);
  return mat3_exports.multiply(out, scaleMat, a);
}
function leftMultiply(out, a, a1) {
  return mat3_exports.multiply(out, a1, a);
}
function transform(m, actions) {
  var matrix = m ? [].concat(m) : [1, 0, 0, 0, 1, 0, 0, 0, 1];
  for (var i = 0, len3 = actions.length; i < len3; i++) {
    var action = actions[i];
    switch (action[0]) {
      case "t":
        leftTranslate(matrix, matrix, [action[1], action[2]]);
        break;
      case "s":
        leftScale(matrix, matrix, [action[1], action[2]]);
        break;
      case "r":
        leftRotate(matrix, matrix, action[1]);
        break;
      case "m":
        leftMultiply(matrix, matrix, action[1]);
        break;
      default:
        break;
    }
  }
  return matrix;
}
function direction(v1, v2) {
  return v1[0] * v2[1] - v2[0] * v1[1];
}
function angleTo(v1, v2, direct) {
  var ang = vec2_exports.angle(v1, v2);
  var angleLargeThanPI = direction(v1, v2) >= 0;
  if (direct) {
    if (angleLargeThanPI) {
      return Math.PI * 2 - ang;
    }
    return ang;
  }
  if (angleLargeThanPI) {
    return ang;
  }
  return Math.PI * 2 - ang;
}
function vertical(out, v, flag) {
  if (flag) {
    out[0] = v[1];
    out[1] = -1 * v[0];
  } else {
    out[0] = -1 * v[1];
    out[1] = v[0];
  }
  return out;
}

// node_modules/@antv/g-base/esm/util/matrix.js
function multiplyMatrix(a, b) {
  var out = [];
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a10 = a[3];
  var a11 = a[4];
  var a12 = a[5];
  var a20 = a[6];
  var a21 = a[7];
  var a22 = a[8];
  var b00 = b[0];
  var b01 = b[1];
  var b02 = b[2];
  var b10 = b[3];
  var b11 = b[4];
  var b12 = b[5];
  var b20 = b[6];
  var b21 = b[7];
  var b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
function multiplyVec2(m, v) {
  var out = [];
  var x = v[0];
  var y = v[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
function invert2(a) {
  var out = [];
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a10 = a[3];
  var a11 = a[4];
  var a12 = a[5];
  var a20 = a[6];
  var a21 = a[7];
  var a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;
  var det = a00 * b01 + a01 * b11 + a02 * b21;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}

// node_modules/@antv/g-base/esm/abstract/element.js
var transform2 = ext_exports.transform;
var MATRIX = "matrix";
var CLONE_CFGS = ["zIndex", "capture", "visible", "type"];
var RESERVED_PORPS = ["repeat"];
var DELEGATION_SPLIT = ":";
var WILDCARD2 = "*";
function _cloneArrayAttr(arr) {
  var result = [];
  for (var i = 0; i < arr.length; i++) {
    if (is_array_default(arr[i])) {
      result.push([].concat(arr[i]));
    } else {
      result.push(arr[i]);
    }
  }
  return result;
}
function getFormatFromAttrs(toAttrs, shape) {
  var fromAttrs = {};
  var attrs = shape.attrs;
  for (var k in toAttrs) {
    fromAttrs[k] = attrs[k];
  }
  return fromAttrs;
}
function getFormatToAttrs(props, shape) {
  var toAttrs = {};
  var attrs = shape.attr();
  each_default(props, function(v, k) {
    if (RESERVED_PORPS.indexOf(k) === -1 && !is_equal_default(attrs[k], v)) {
      toAttrs[k] = v;
    }
  });
  return toAttrs;
}
function checkExistedAttrs(animations, animation) {
  if (animation.onFrame) {
    return animations;
  }
  var startTime = animation.startTime, delay = animation.delay, duration = animation.duration;
  var hasOwnProperty4 = Object.prototype.hasOwnProperty;
  each_default(animations, function(item) {
    if (startTime + delay < item.startTime + item.delay + item.duration && duration > item.delay) {
      each_default(animation.toAttrs, function(v, k) {
        if (hasOwnProperty4.call(item.toAttrs, k)) {
          delete item.toAttrs[k];
          delete item.fromAttrs[k];
        }
      });
    }
  });
  return animations;
}
var Element2 = function(_super) {
  __extends(Element4, _super);
  function Element4(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.attrs = {};
    var attrs = _this.getDefaultAttrs();
    mix(attrs, cfg.attrs);
    _this.attrs = attrs;
    _this.initAttrs(attrs);
    _this.initAnimate();
    return _this;
  }
  Element4.prototype.getDefaultCfg = function() {
    return {
      visible: true,
      capture: true,
      zIndex: 0
    };
  };
  Element4.prototype.getDefaultAttrs = function() {
    return {
      matrix: this.getDefaultMatrix(),
      opacity: 1
    };
  };
  Element4.prototype.onCanvasChange = function(changeType) {
  };
  Element4.prototype.initAttrs = function(attrs) {
  };
  Element4.prototype.initAnimate = function() {
    this.set("animable", true);
    this.set("animating", false);
  };
  Element4.prototype.isGroup = function() {
    return false;
  };
  Element4.prototype.getParent = function() {
    return this.get("parent");
  };
  Element4.prototype.getCanvas = function() {
    return this.get("canvas");
  };
  Element4.prototype.attr = function() {
    var _a3;
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var name = args[0], value = args[1];
    if (!name)
      return this.attrs;
    if (is_object_default(name)) {
      for (var k in name) {
        this.setAttr(k, name[k]);
      }
      this.afterAttrsChange(name);
      return this;
    }
    if (args.length === 2) {
      this.setAttr(name, value);
      this.afterAttrsChange((_a3 = {}, _a3[name] = value, _a3));
      return this;
    }
    return this.attrs[name];
  };
  Element4.prototype.isClipped = function(refX, refY) {
    var clip = this.getClip();
    return clip && !clip.isHit(refX, refY);
  };
  Element4.prototype.setAttr = function(name, value) {
    var originValue = this.attrs[name];
    if (originValue !== value) {
      this.attrs[name] = value;
      this.onAttrChange(name, value, originValue);
    }
  };
  Element4.prototype.onAttrChange = function(name, value, originValue) {
    if (name === "matrix") {
      this.set("totalMatrix", null);
    }
  };
  Element4.prototype.afterAttrsChange = function(targetAttrs) {
    if (this.cfg.isClipShape) {
      var applyTo = this.cfg.applyTo;
      if (applyTo) {
        applyTo.onCanvasChange("clip");
      }
    } else {
      this.onCanvasChange("attr");
    }
  };
  Element4.prototype.show = function() {
    this.set("visible", true);
    this.onCanvasChange("show");
    return this;
  };
  Element4.prototype.hide = function() {
    this.set("visible", false);
    this.onCanvasChange("hide");
    return this;
  };
  Element4.prototype.setZIndex = function(zIndex) {
    this.set("zIndex", zIndex);
    var parent = this.getParent();
    if (parent) {
      parent.sort();
    }
    return this;
  };
  Element4.prototype.toFront = function() {
    var parent = this.getParent();
    if (!parent) {
      return;
    }
    var children = parent.getChildren();
    var el = this.get("el");
    var index = children.indexOf(this);
    children.splice(index, 1);
    children.push(this);
    this.onCanvasChange("zIndex");
  };
  Element4.prototype.toBack = function() {
    var parent = this.getParent();
    if (!parent) {
      return;
    }
    var children = parent.getChildren();
    var el = this.get("el");
    var index = children.indexOf(this);
    children.splice(index, 1);
    children.unshift(this);
    this.onCanvasChange("zIndex");
  };
  Element4.prototype.remove = function(destroy) {
    if (destroy === void 0) {
      destroy = true;
    }
    var parent = this.getParent();
    if (parent) {
      removeFromArray(parent.getChildren(), this);
      if (!parent.get("clearing")) {
        this.onCanvasChange("remove");
      }
    } else {
      this.onCanvasChange("remove");
    }
    if (destroy) {
      this.destroy();
    }
  };
  Element4.prototype.resetMatrix = function() {
    this.attr(MATRIX, this.getDefaultMatrix());
    this.onCanvasChange("matrix");
  };
  Element4.prototype.getMatrix = function() {
    return this.attr(MATRIX);
  };
  Element4.prototype.setMatrix = function(m) {
    this.attr(MATRIX, m);
    this.onCanvasChange("matrix");
  };
  Element4.prototype.getTotalMatrix = function() {
    var totalMatrix = this.cfg.totalMatrix;
    if (!totalMatrix) {
      var currentMatrix = this.attr("matrix");
      var parentMatrix = this.cfg.parentMatrix;
      if (parentMatrix && currentMatrix) {
        totalMatrix = multiplyMatrix(parentMatrix, currentMatrix);
      } else {
        totalMatrix = currentMatrix || parentMatrix;
      }
      this.set("totalMatrix", totalMatrix);
    }
    return totalMatrix;
  };
  Element4.prototype.applyMatrix = function(matrix) {
    var currentMatrix = this.attr("matrix");
    var totalMatrix = null;
    if (matrix && currentMatrix) {
      totalMatrix = multiplyMatrix(matrix, currentMatrix);
    } else {
      totalMatrix = currentMatrix || matrix;
    }
    this.set("totalMatrix", totalMatrix);
    this.set("parentMatrix", matrix);
  };
  Element4.prototype.getDefaultMatrix = function() {
    return null;
  };
  Element4.prototype.applyToMatrix = function(v) {
    var matrix = this.attr("matrix");
    if (matrix) {
      return multiplyVec2(matrix, v);
    }
    return v;
  };
  Element4.prototype.invertFromMatrix = function(v) {
    var matrix = this.attr("matrix");
    if (matrix) {
      var invertMatrix = invert2(matrix);
      if (invertMatrix) {
        return multiplyVec2(invertMatrix, v);
      }
    }
    return v;
  };
  Element4.prototype.setClip = function(clipCfg) {
    var canvas = this.getCanvas();
    var clipShape = null;
    if (clipCfg) {
      var ShapeBase4 = this.getShapeBase();
      var shapeType = upper_first_default(clipCfg.type);
      var Cons = ShapeBase4[shapeType];
      if (Cons) {
        clipShape = new Cons({
          type: clipCfg.type,
          isClipShape: true,
          applyTo: this,
          attrs: clipCfg.attrs,
          canvas
        });
      }
    }
    this.set("clipShape", clipShape);
    this.onCanvasChange("clip");
    return clipShape;
  };
  Element4.prototype.getClip = function() {
    var clipShape = this.cfg.clipShape;
    if (!clipShape) {
      return null;
    }
    return clipShape;
  };
  Element4.prototype.clone = function() {
    var _this = this;
    var originAttrs = this.attrs;
    var attrs = {};
    each_default(originAttrs, function(i, k) {
      if (is_array_default(originAttrs[k])) {
        attrs[k] = _cloneArrayAttr(originAttrs[k]);
      } else {
        attrs[k] = originAttrs[k];
      }
    });
    var cons = this.constructor;
    var clone6 = new cons({ attrs });
    each_default(CLONE_CFGS, function(cfgName) {
      clone6.set(cfgName, _this.get(cfgName));
    });
    return clone6;
  };
  Element4.prototype.destroy = function() {
    var destroyed = this.destroyed;
    if (destroyed) {
      return;
    }
    this.attrs = {};
    _super.prototype.destroy.call(this);
  };
  Element4.prototype.isAnimatePaused = function() {
    return this.get("_pause").isPaused;
  };
  Element4.prototype.animate = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (!this.get("timeline") && !this.get("canvas")) {
      return;
    }
    this.set("animating", true);
    var timeline = this.get("timeline");
    if (!timeline) {
      timeline = this.get("canvas").get("timeline");
      this.set("timeline", timeline);
    }
    var animations = this.get("animations") || [];
    if (!timeline.timer) {
      timeline.initTimer();
    }
    var toAttrs = args[0], duration = args[1], _a3 = args[2], easing = _a3 === void 0 ? "easeLinear" : _a3, _b = args[3], callback = _b === void 0 ? noop_default : _b, _c = args[4], delay = _c === void 0 ? 0 : _c;
    var onFrame;
    var repeat;
    var pauseCallback;
    var resumeCallback;
    var animateCfg;
    if (is_function_default(toAttrs)) {
      onFrame = toAttrs;
      toAttrs = {};
    } else if (is_object_default(toAttrs) && toAttrs.onFrame) {
      onFrame = toAttrs.onFrame;
      repeat = toAttrs.repeat;
    }
    if (is_object_default(duration)) {
      animateCfg = duration;
      duration = animateCfg.duration;
      easing = animateCfg.easing || "easeLinear";
      delay = animateCfg.delay || 0;
      repeat = animateCfg.repeat || repeat || false;
      callback = animateCfg.callback || noop_default;
      pauseCallback = animateCfg.pauseCallback || noop_default;
      resumeCallback = animateCfg.resumeCallback || noop_default;
    } else {
      if (is_number_default(callback)) {
        delay = callback;
        callback = null;
      }
      if (is_function_default(easing)) {
        callback = easing;
        easing = "easeLinear";
      } else {
        easing = easing || "easeLinear";
      }
    }
    var formatToAttrs = getFormatToAttrs(toAttrs, this);
    var animation = {
      fromAttrs: getFormatFromAttrs(formatToAttrs, this),
      toAttrs: formatToAttrs,
      duration,
      easing,
      repeat,
      callback,
      pauseCallback,
      resumeCallback,
      delay,
      startTime: timeline.getTime(),
      id: unique_id_default(),
      onFrame,
      pathFormatted: false
    };
    if (animations.length > 0) {
      animations = checkExistedAttrs(animations, animation);
    } else {
      timeline.addAnimator(this);
    }
    animations.push(animation);
    this.set("animations", animations);
    this.set("_pause", { isPaused: false });
  };
  Element4.prototype.stopAnimate = function(toEnd) {
    var _this = this;
    if (toEnd === void 0) {
      toEnd = true;
    }
    var animations = this.get("animations");
    each_default(animations, function(animation) {
      if (toEnd) {
        if (animation.onFrame) {
          _this.attr(animation.onFrame(1));
        } else {
          _this.attr(animation.toAttrs);
        }
      }
      if (animation.callback) {
        animation.callback();
      }
    });
    this.set("animating", false);
    this.set("animations", []);
  };
  Element4.prototype.pauseAnimate = function() {
    var timeline = this.get("timeline");
    var animations = this.get("animations");
    var pauseTime = timeline.getTime();
    each_default(animations, function(animation) {
      animation._paused = true;
      animation._pauseTime = pauseTime;
      if (animation.pauseCallback) {
        animation.pauseCallback();
      }
    });
    this.set("_pause", {
      isPaused: true,
      pauseTime
    });
    return this;
  };
  Element4.prototype.resumeAnimate = function() {
    var timeline = this.get("timeline");
    var current = timeline.getTime();
    var animations = this.get("animations");
    var pauseTime = this.get("_pause").pauseTime;
    each_default(animations, function(animation) {
      animation.startTime = animation.startTime + (current - pauseTime);
      animation._paused = false;
      animation._pauseTime = null;
      if (animation.resumeCallback) {
        animation.resumeCallback();
      }
    });
    this.set("_pause", {
      isPaused: false
    });
    this.set("animations", animations);
    return this;
  };
  Element4.prototype.emitDelegation = function(type, eventObj) {
    var _this = this;
    var paths = eventObj.propagationPath;
    var events = this.getEvents();
    var relativeShape;
    if (type === "mouseenter") {
      relativeShape = eventObj.fromShape;
    } else if (type === "mouseleave") {
      relativeShape = eventObj.toShape;
    }
    var _loop_1 = function(i2) {
      var element = paths[i2];
      var name_1 = element.get("name");
      if (name_1) {
        if ((element.isGroup() || element.isCanvas && element.isCanvas()) && relativeShape && isParent(element, relativeShape)) {
          return "break";
        }
        if (is_array_default(name_1)) {
          each_default(name_1, function(subName) {
            _this.emitDelegateEvent(element, subName, eventObj);
          });
        } else {
          this_1.emitDelegateEvent(element, name_1, eventObj);
        }
      }
    };
    var this_1 = this;
    for (var i = 0; i < paths.length; i++) {
      var state_1 = _loop_1(i);
      if (state_1 === "break")
        break;
    }
  };
  Element4.prototype.emitDelegateEvent = function(element, name, eventObj) {
    var events = this.getEvents();
    var eventName = name + DELEGATION_SPLIT + eventObj.type;
    if (events[eventName] || events[WILDCARD2]) {
      eventObj.name = eventName;
      eventObj.currentTarget = element;
      eventObj.delegateTarget = this;
      eventObj.delegateObject = element.get("delegateObject");
      this.emit(eventName, eventObj);
    }
  };
  Element4.prototype.translate = function(translateX, translateY) {
    if (translateX === void 0) {
      translateX = 0;
    }
    if (translateY === void 0) {
      translateY = 0;
    }
    var matrix = this.getMatrix();
    var newMatrix = transform2(matrix, [["t", translateX, translateY]]);
    this.setMatrix(newMatrix);
    return this;
  };
  Element4.prototype.move = function(targetX, targetY) {
    var x = this.attr("x") || 0;
    var y = this.attr("y") || 0;
    this.translate(targetX - x, targetY - y);
    return this;
  };
  Element4.prototype.moveTo = function(targetX, targetY) {
    return this.move(targetX, targetY);
  };
  Element4.prototype.scale = function(ratioX, ratioY) {
    var matrix = this.getMatrix();
    var newMatrix = transform2(matrix, [["s", ratioX, ratioY || ratioX]]);
    this.setMatrix(newMatrix);
    return this;
  };
  Element4.prototype.rotate = function(radian) {
    var matrix = this.getMatrix();
    var newMatrix = transform2(matrix, [["r", radian]]);
    this.setMatrix(newMatrix);
    return this;
  };
  Element4.prototype.rotateAtStart = function(rotate5) {
    var _a3 = this.attr(), x = _a3.x, y = _a3.y;
    var matrix = this.getMatrix();
    var newMatrix = transform2(matrix, [
      ["t", -x, -y],
      ["r", rotate5],
      ["t", x, y]
    ]);
    this.setMatrix(newMatrix);
    return this;
  };
  Element4.prototype.rotateAtPoint = function(x, y, rotate5) {
    var matrix = this.getMatrix();
    var newMatrix = transform2(matrix, [
      ["t", -x, -y],
      ["r", rotate5],
      ["t", x, y]
    ]);
    this.setMatrix(newMatrix);
    return this;
  };
  return Element4;
}(base_default2);
var element_default = Element2;

// node_modules/@antv/g-base/esm/abstract/container.js
var SHAPE_MAP = {};
var INDEX = "_INDEX";
function setCanvas(element, canvas) {
  element.set("canvas", canvas);
  if (element.isGroup()) {
    var children = element.get("children");
    if (children.length) {
      children.forEach(function(child) {
        setCanvas(child, canvas);
      });
    }
  }
}
function setTimeline(element, timeline) {
  element.set("timeline", timeline);
  if (element.isGroup()) {
    var children = element.get("children");
    if (children.length) {
      children.forEach(function(child) {
        setTimeline(child, timeline);
      });
    }
  }
}
function removeChild(container, element, destroy) {
  if (destroy === void 0) {
    destroy = true;
  }
  if (destroy) {
    element.destroy();
  } else {
    element.set("parent", null);
    element.set("canvas", null);
  }
  removeFromArray(container.getChildren(), element);
}
function getComparer(compare) {
  return function(left, right) {
    var result = compare(left, right);
    return result === 0 ? left[INDEX] - right[INDEX] : result;
  };
}
var Container = function(_super) {
  __extends(Container2, _super);
  function Container2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Container2.prototype.isCanvas = function() {
    return false;
  };
  Container2.prototype.getBBox = function() {
    var minX = Infinity;
    var maxX = -Infinity;
    var minY = Infinity;
    var maxY = -Infinity;
    var xArr = [];
    var yArr = [];
    var children = this.getChildren().filter(function(child) {
      return child.get("visible") && (!child.isGroup() || child.isGroup() && child.getChildren().length > 0);
    });
    if (children.length > 0) {
      each_default(children, function(child) {
        var box3 = child.getBBox();
        xArr.push(box3.minX, box3.maxX);
        yArr.push(box3.minY, box3.maxY);
      });
      minX = min_default(xArr);
      maxX = max_default(xArr);
      minY = min_default(yArr);
      maxY = max_default(yArr);
    } else {
      minX = 0;
      maxX = 0;
      minY = 0;
      maxY = 0;
    }
    var box2 = {
      x: minX,
      y: minY,
      minX,
      minY,
      maxX,
      maxY,
      width: maxX - minX,
      height: maxY - minY
    };
    return box2;
  };
  Container2.prototype.getCanvasBBox = function() {
    var minX = Infinity;
    var maxX = -Infinity;
    var minY = Infinity;
    var maxY = -Infinity;
    var xArr = [];
    var yArr = [];
    var children = this.getChildren().filter(function(child) {
      return child.get("visible") && (!child.isGroup() || child.isGroup() && child.getChildren().length > 0);
    });
    if (children.length > 0) {
      each_default(children, function(child) {
        var box3 = child.getCanvasBBox();
        xArr.push(box3.minX, box3.maxX);
        yArr.push(box3.minY, box3.maxY);
      });
      minX = min_default(xArr);
      maxX = max_default(xArr);
      minY = min_default(yArr);
      maxY = max_default(yArr);
    } else {
      minX = 0;
      maxX = 0;
      minY = 0;
      maxY = 0;
    }
    var box2 = {
      x: minX,
      y: minY,
      minX,
      minY,
      maxX,
      maxY,
      width: maxX - minX,
      height: maxY - minY
    };
    return box2;
  };
  Container2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    cfg["children"] = [];
    return cfg;
  };
  Container2.prototype.onAttrChange = function(name, value, originValue) {
    _super.prototype.onAttrChange.call(this, name, value, originValue);
    if (name === "matrix") {
      var totalMatrix = this.getTotalMatrix();
      this._applyChildrenMarix(totalMatrix);
    }
  };
  Container2.prototype.applyMatrix = function(matrix) {
    var preTotalMatrix = this.getTotalMatrix();
    _super.prototype.applyMatrix.call(this, matrix);
    var totalMatrix = this.getTotalMatrix();
    if (totalMatrix === preTotalMatrix) {
      return;
    }
    this._applyChildrenMarix(totalMatrix);
  };
  Container2.prototype._applyChildrenMarix = function(totalMatrix) {
    var children = this.getChildren();
    each_default(children, function(child) {
      child.applyMatrix(totalMatrix);
    });
  };
  Container2.prototype.addShape = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var type = args[0];
    var cfg = args[1];
    if (is_object_default(type)) {
      cfg = type;
    } else {
      cfg["type"] = type;
    }
    var shapeType = SHAPE_MAP[cfg.type];
    if (!shapeType) {
      shapeType = upper_first_default(cfg.type);
      SHAPE_MAP[cfg.type] = shapeType;
    }
    var ShapeBase4 = this.getShapeBase();
    var shape = new ShapeBase4[shapeType](cfg);
    this.add(shape);
    return shape;
  };
  Container2.prototype.addGroup = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var groupClass = args[0], cfg = args[1];
    var group2;
    if (is_function_default(groupClass)) {
      if (cfg) {
        group2 = new groupClass(cfg);
      } else {
        group2 = new groupClass({
          parent: this
        });
      }
    } else {
      var tmpCfg = groupClass || {};
      var TmpGroupClass = this.getGroupBase();
      group2 = new TmpGroupClass(tmpCfg);
    }
    this.add(group2);
    return group2;
  };
  Container2.prototype.getCanvas = function() {
    var canvas;
    if (this.isCanvas()) {
      canvas = this;
    } else {
      canvas = this.get("canvas");
    }
    return canvas;
  };
  Container2.prototype.getShape = function(x, y, ev) {
    if (!isAllowCapture(this)) {
      return null;
    }
    var children = this.getChildren();
    var shape;
    if (!this.isCanvas()) {
      var v = [x, y, 1];
      v = this.invertFromMatrix(v);
      if (!this.isClipped(v[0], v[1])) {
        shape = this._findShape(children, v[0], v[1], ev);
      }
    } else {
      shape = this._findShape(children, x, y, ev);
    }
    return shape;
  };
  Container2.prototype._findShape = function(children, x, y, ev) {
    var shape = null;
    for (var i = children.length - 1; i >= 0; i--) {
      var child = children[i];
      if (isAllowCapture(child)) {
        if (child.isGroup()) {
          shape = child.getShape(x, y, ev);
        } else if (child.isHit(x, y)) {
          shape = child;
        }
      }
      if (shape) {
        break;
      }
    }
    return shape;
  };
  Container2.prototype.add = function(element) {
    var canvas = this.getCanvas();
    var children = this.getChildren();
    var timeline = this.get("timeline");
    var preParent = element.getParent();
    if (preParent) {
      removeChild(preParent, element, false);
    }
    element.set("parent", this);
    if (canvas) {
      setCanvas(element, canvas);
    }
    if (timeline) {
      setTimeline(element, timeline);
    }
    children.push(element);
    element.onCanvasChange("add");
    this._applyElementMatrix(element);
  };
  Container2.prototype._applyElementMatrix = function(element) {
    var totalMatrix = this.getTotalMatrix();
    if (totalMatrix) {
      element.applyMatrix(totalMatrix);
    }
  };
  Container2.prototype.getChildren = function() {
    return this.get("children");
  };
  Container2.prototype.sort = function() {
    var children = this.getChildren();
    each_default(children, function(child, index) {
      child[INDEX] = index;
      return child;
    });
    children.sort(getComparer(function(obj1, obj2) {
      return obj1.get("zIndex") - obj2.get("zIndex");
    }));
    this.onCanvasChange("sort");
  };
  Container2.prototype.clear = function() {
    this.set("clearing", true);
    if (this.destroyed) {
      return;
    }
    var children = this.getChildren();
    for (var i = children.length - 1; i >= 0; i--) {
      children[i].destroy();
    }
    this.set("children", []);
    this.onCanvasChange("clear");
    this.set("clearing", false);
  };
  Container2.prototype.destroy = function() {
    if (this.get("destroyed")) {
      return;
    }
    this.clear();
    _super.prototype.destroy.call(this);
  };
  Container2.prototype.getFirst = function() {
    return this.getChildByIndex(0);
  };
  Container2.prototype.getLast = function() {
    var children = this.getChildren();
    return this.getChildByIndex(children.length - 1);
  };
  Container2.prototype.getChildByIndex = function(index) {
    var children = this.getChildren();
    return children[index];
  };
  Container2.prototype.getCount = function() {
    var children = this.getChildren();
    return children.length;
  };
  Container2.prototype.contain = function(element) {
    var children = this.getChildren();
    return children.indexOf(element) > -1;
  };
  Container2.prototype.removeChild = function(element, destroy) {
    if (destroy === void 0) {
      destroy = true;
    }
    if (this.contain(element)) {
      element.remove(destroy);
    }
  };
  Container2.prototype.findAll = function(fn) {
    var rst = [];
    var children = this.getChildren();
    each_default(children, function(element) {
      if (fn(element)) {
        rst.push(element);
      }
      if (element.isGroup()) {
        rst = rst.concat(element.findAll(fn));
      }
    });
    return rst;
  };
  Container2.prototype.find = function(fn) {
    var rst = null;
    var children = this.getChildren();
    each_default(children, function(element) {
      if (fn(element)) {
        rst = element;
      } else if (element.isGroup()) {
        rst = element.find(fn);
      }
      if (rst) {
        return false;
      }
    });
    return rst;
  };
  Container2.prototype.findById = function(id) {
    return this.find(function(element) {
      return element.get("id") === id;
    });
  };
  Container2.prototype.findByClassName = function(className) {
    return this.find(function(element) {
      return element.get("className") === className;
    });
  };
  Container2.prototype.findAllByName = function(name) {
    return this.findAll(function(element) {
      return element.get("name") === name;
    });
  };
  return Container2;
}(element_default);
var container_default = Container;

// node_modules/d3-timer/src/timer.js
var frame = 0;
var timeout = 0;
var interval = 0;
var pokeDelay = 1e3;
var taskHead;
var taskTail;
var clockLast = 0;
var clockNow = 0;
var clockSkew = 0;
var clock = typeof performance === "object" && performance.now ? performance : Date;
var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
  setTimeout(f, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function")
      throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail)
        taskTail._next = this;
      else
        taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay, time) {
  var t = new Timer();
  t.restart(callback, delay, time);
  return t;
}
function timerFlush() {
  now();
  ++frame;
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0)
      t._call.call(null, e);
    t = t._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now2 = clock.now(), delay = now2 - clockLast;
  if (delay > pokeDelay)
    clockSkew -= delay, clockLast = now2;
}
function nap() {
  var t02, t12 = taskHead, t22, time = Infinity;
  while (t12) {
    if (t12._call) {
      if (time > t12._time)
        time = t12._time;
      t02 = t12, t12 = t12._next;
    } else {
      t22 = t12._next, t12._next = null;
      t12 = t02 ? t02._next = t22 : taskHead = t22;
    }
  }
  taskTail = t02;
  sleep(time);
}
function sleep(time) {
  if (frame)
    return;
  if (timeout)
    timeout = clearTimeout(timeout);
  var delay = time - clockNow;
  if (delay > 24) {
    if (time < Infinity)
      timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval)
      interval = clearInterval(interval);
  } else {
    if (!interval)
      clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

// node_modules/d3-color/src/define.js
function define_default(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition)
    prototype[key] = definition[key];
  return prototype;
}

// node_modules/d3-color/src/color.js
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex = /^#([0-9a-f]{3,8})$/;
var reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$");
var reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$");
var reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$");
var reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$");
var reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$");
var reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default(Color, color, {
  copy: function(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  formatHex: color_formatHex,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format2) {
  var m, l;
  format2 = (format2 + "").trim().toLowerCase();
  return (m = reHex.exec(format2)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format2)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format2)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format2)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format2)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r, g, b, a) {
  if (a <= 0)
    r = g = b = NaN;
  return new Rgb(r, g, b, a);
}
function rgbConvert(o) {
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Rgb, rgb, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  formatHex: rgb_formatHex,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
}
function rgb_formatRgb() {
  var a = this.opacity;
  a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
  return (a === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a === 1 ? ")" : ", " + a + ")");
}
function hex(value) {
  value = Math.max(0, Math.min(255, Math.round(value) || 0));
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h, s, l, a) {
  if (a <= 0)
    h = s = l = NaN;
  else if (l <= 0 || l >= 1)
    h = s = NaN;
  else if (s <= 0)
    h = NaN;
  return new Hsl(h, s, l, a);
}
function hslConvert(o) {
  if (o instanceof Hsl)
    return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Hsl();
  if (o instanceof Hsl)
    return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min3 = Math.min(r, g, b), max3 = Math.max(r, g, b), h = NaN, s = max3 - min3, l = (max3 + min3) / 2;
  if (s) {
    if (r === max3)
      h = (g - b) / s + (g < b) * 6;
    else if (g === max3)
      h = (b - r) / s + 2;
    else
      h = (r - g) / s + 4;
    s /= l < 0.5 ? max3 + min3 : 2 - max3 - min3;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}
function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Hsl, hsl, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl: function() {
    var a = this.opacity;
    a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "hsl(" : "hsla(") + (this.h || 0) + ", " + (this.s || 0) * 100 + "%, " + (this.l || 0) * 100 + "%" + (a === 1 ? ")" : ", " + a + ")");
  }
}));
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}

// node_modules/d3-color/src/math.js
var deg2rad = Math.PI / 180;
var rad2deg = 180 / Math.PI;

// node_modules/d3-color/src/lab.js
var K = 18;
var Xn = 0.96422;
var Yn = 1;
var Zn = 0.82521;
var t0 = 4 / 29;
var t1 = 6 / 29;
var t2 = 3 * t1 * t1;
var t3 = t1 * t1 * t1;
function labConvert(o) {
  if (o instanceof Lab)
    return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl)
    return hcl2lab(o);
  if (!(o instanceof Rgb))
    o = rgbConvert(o);
  var r = rgb2lrgb(o.r), g = rgb2lrgb(o.g), b = rgb2lrgb(o.b), y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
  if (r === g && g === b)
    x = z = y;
  else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}
function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}
function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Lab, lab, extend(Color, {
  brighter: function(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker: function(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb: function() {
    var y = (this.l + 16) / 116, x = isNaN(this.a) ? y : y + this.a / 500, z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new Rgb(
      lrgb2rgb(3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.033454 * z),
      lrgb2rgb(0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
      this.opacity
    );
  }
}));
function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}
function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}
function lrgb2rgb(x) {
  return 255 * (x <= 31308e-7 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}
function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}
function hclConvert(o) {
  if (o instanceof Hcl)
    return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab))
    o = labConvert(o);
  if (o.a === 0 && o.b === 0)
    return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * rad2deg;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}
function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}
function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}
function hcl2lab(o) {
  if (isNaN(o.h))
    return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * deg2rad;
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}
define_default(Hcl, hcl, extend(Color, {
  brighter: function(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker: function(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb: function() {
    return hcl2lab(this).rgb();
  }
}));

// node_modules/d3-color/src/cubehelix.js
var A = -0.14861;
var B = 1.78277;
var C = -0.29227;
var D = -0.90649;
var E = 1.97294;
var ED = E * D;
var EB = E * B;
var BC_DA = B * C - D * A;
function cubehelixConvert(o) {
  if (o instanceof Cubehelix)
    return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb))
    o = rgbConvert(o);
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB), bl = b - l, k = (E * (g - l) - C * bl) / D, s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}
function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}
function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Cubehelix, cubehelix, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad, l = +this.l, a = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh = Math.cos(h), sinh = Math.sin(h);
    return new Rgb(
      255 * (l + a * (A * cosh + B * sinh)),
      255 * (l + a * (C * cosh + D * sinh)),
      255 * (l + a * (E * cosh)),
      this.opacity
    );
  }
}));

// node_modules/d3-interpolate/src/basis.js
function basis(t12, v0, v1, v2, v3) {
  var t22 = t12 * t12, t32 = t22 * t12;
  return ((1 - 3 * t12 + 3 * t22 - t32) * v0 + (4 - 6 * t22 + 3 * t32) * v1 + (1 + 3 * t12 + 3 * t22 - 3 * t32) * v2 + t32 * v3) / 6;
}
function basis_default(values2) {
  var n = values2.length - 1;
  return function(t) {
    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values2[i], v2 = values2[i + 1], v0 = i > 0 ? values2[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values2[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default(values2) {
  var n = values2.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values2[(i + n - 1) % n], v1 = values2[i % n], v2 = values2[(i + 1) % n], v3 = values2[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/constant.js
function constant_default(x) {
  return function() {
    return x;
  };
}

// node_modules/d3-interpolate/src/color.js
function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}
function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}
function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant_default(isNaN(a) ? b : a);
}
function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : constant_default(isNaN(a) ? b : a);
  };
}
function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : constant_default(isNaN(a) ? b : a);
}

// node_modules/d3-interpolate/src/rgb.js
var rgb_default = function rgbGamma(y) {
  var color2 = gamma(y);
  function rgb2(start, end) {
    var r = color2((start = rgb(start)).r, (end = rgb(end)).r), g = color2(start.g, end.g), b = color2(start.b, end.b), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
}(1);
function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color2;
    for (i = 0; i < n; ++i) {
      color2 = rgb(colors[i]);
      r[i] = color2.r || 0;
      g[i] = color2.g || 0;
      b[i] = color2.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color2.opacity = 1;
    return function(t) {
      color2.r = r(t);
      color2.g = g(t);
      color2.b = b(t);
      return color2 + "";
    };
  };
}
var rgbBasis = rgbSpline(basis_default);
var rgbBasisClosed = rgbSpline(basisClosed_default);

// node_modules/d3-interpolate/src/numberArray.js
function numberArray_default(a, b) {
  if (!b)
    b = [];
  var n = a ? Math.min(b.length, a.length) : 0, c = b.slice(), i;
  return function(t) {
    for (i = 0; i < n; ++i)
      c[i] = a[i] * (1 - t) + b[i] * t;
    return c;
  };
}
function isNumberArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}

// node_modules/d3-interpolate/src/array.js
function array_default(a, b) {
  return (isNumberArray(b) ? numberArray_default : genericArray)(a, b);
}
function genericArray(a, b) {
  var nb = b ? b.length : 0, na = a ? Math.min(nb, a.length) : 0, x = new Array(na), c = new Array(nb), i;
  for (i = 0; i < na; ++i)
    x[i] = value_default(a[i], b[i]);
  for (; i < nb; ++i)
    c[i] = b[i];
  return function(t) {
    for (i = 0; i < na; ++i)
      c[i] = x[i](t);
    return c;
  };
}

// node_modules/d3-interpolate/src/date.js
function date_default(a, b) {
  var d = new Date();
  return a = +a, b = +b, function(t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
}

// node_modules/d3-interpolate/src/number.js
function number_default(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}

// node_modules/d3-interpolate/src/object.js
function object_default(a, b) {
  var i = {}, c = {}, k;
  if (a === null || typeof a !== "object")
    a = {};
  if (b === null || typeof b !== "object")
    b = {};
  for (k in b) {
    if (k in a) {
      i[k] = value_default(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }
  return function(t) {
    for (k in i)
      c[k] = i[k](t);
    return c;
  };
}

// node_modules/d3-interpolate/src/string.js
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");
function zero3(b) {
  return function() {
    return b;
  };
}
function one(b) {
  return function(t) {
    return b(t) + "";
  };
}
function string_default(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
  a = a + "", b = b + "";
  while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      bs = b.slice(bi, bs);
      if (s[i])
        s[i] += bs;
      else
        s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s[i])
        s[i] += bm;
      else
        s[++i] = bm;
    } else {
      s[++i] = null;
      q.push({ i, x: number_default(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i])
      s[i] += bs;
    else
      s[++i] = bs;
  }
  return s.length < 2 ? q[0] ? one(q[0].x) : zero3(b) : (b = q.length, function(t) {
    for (var i2 = 0, o; i2 < b; ++i2)
      s[(o = q[i2]).i] = o.x(t);
    return s.join("");
  });
}

// node_modules/d3-interpolate/src/value.js
function value_default(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? constant_default(b) : (t === "number" ? number_default : t === "string" ? (c = color(b)) ? (b = c, rgb_default) : string_default : b instanceof color ? rgb_default : b instanceof Date ? date_default : isNumberArray(b) ? numberArray_default : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object_default : number_default)(a, b);
}

// node_modules/d3-interpolate/src/transform/decompose.js
var degrees = 180 / Math.PI;
var identity3 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose_default(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b))
    a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d)
    c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d))
    c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c)
    a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX,
    scaleY
  };
}

// node_modules/d3-interpolate/src/transform/parse.js
var cssNode;
var cssRoot;
var cssView;
var svgNode;
function parseCss(value) {
  if (value === "none")
    return identity3;
  if (!cssNode)
    cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
  cssNode.style.transform = value;
  value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
  cssRoot.removeChild(cssNode);
  value = value.slice(7, -1).split(",");
  return decompose_default(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
}
function parseSvg(value) {
  if (value == null)
    return identity3;
  if (!svgNode)
    svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate()))
    return identity3;
  value = value.matrix;
  return decompose_default(value.a, value.b, value.c, value.d, value.e, value.f);
}

// node_modules/d3-interpolate/src/transform/index.js
function interpolateTransform(parse2, pxComma, pxParen, degParen) {
  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }
  function translate3(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate5(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180)
        b += 360;
      else if (b - a > 180)
        a += 360;
      q.push({ i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: number_default(a, b) });
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }
  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({ i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: number_default(a, b) });
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }
  function scale5(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a, b) {
    var s = [], q = [];
    a = parse2(a), b = parse2(b);
    translate3(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate5(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale5(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null;
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n)
        s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

// node_modules/d3-interpolate/src/hsl.js
function hsl2(hue2) {
  return function(start, end) {
    var h = hue2((start = hsl(start)).h, (end = hsl(end)).h), s = nogamma(start.s, end.s), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.s = s(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  };
}
var hsl_default = hsl2(hue);
var hslLong = hsl2(nogamma);

// node_modules/d3-interpolate/src/hcl.js
function hcl2(hue2) {
  return function(start, end) {
    var h = hue2((start = hcl(start)).h, (end = hcl(end)).h), c = nogamma(start.c, end.c), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.c = c(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  };
}
var hcl_default = hcl2(hue);
var hclLong = hcl2(nogamma);

// node_modules/d3-interpolate/src/cubehelix.js
function cubehelix2(hue2) {
  return function cubehelixGamma(y) {
    y = +y;
    function cubehelix3(start, end) {
      var h = hue2((start = cubehelix(start)).h, (end = cubehelix(end)).h), s = nogamma(start.s, end.s), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y));
        start.opacity = opacity(t);
        return start + "";
      };
    }
    cubehelix3.gamma = cubehelixGamma;
    return cubehelix3;
  }(1);
}
var cubehelix_default = cubehelix2(hue);
var cubehelixLong = cubehelix2(nogamma);

// node_modules/d3-ease/src/index.js
var src_exports = {};
__export(src_exports, {
  easeBack: () => backInOut,
  easeBackIn: () => backIn,
  easeBackInOut: () => backInOut,
  easeBackOut: () => backOut,
  easeBounce: () => bounceOut,
  easeBounceIn: () => bounceIn,
  easeBounceInOut: () => bounceInOut,
  easeBounceOut: () => bounceOut,
  easeCircle: () => circleInOut,
  easeCircleIn: () => circleIn,
  easeCircleInOut: () => circleInOut,
  easeCircleOut: () => circleOut,
  easeCubic: () => cubicInOut,
  easeCubicIn: () => cubicIn,
  easeCubicInOut: () => cubicInOut,
  easeCubicOut: () => cubicOut,
  easeElastic: () => elasticOut,
  easeElasticIn: () => elasticIn,
  easeElasticInOut: () => elasticInOut,
  easeElasticOut: () => elasticOut,
  easeExp: () => expInOut,
  easeExpIn: () => expIn,
  easeExpInOut: () => expInOut,
  easeExpOut: () => expOut,
  easeLinear: () => linear2,
  easePoly: () => polyInOut,
  easePolyIn: () => polyIn,
  easePolyInOut: () => polyInOut,
  easePolyOut: () => polyOut,
  easeQuad: () => quadInOut,
  easeQuadIn: () => quadIn,
  easeQuadInOut: () => quadInOut,
  easeQuadOut: () => quadOut,
  easeSin: () => sinInOut,
  easeSinIn: () => sinIn,
  easeSinInOut: () => sinInOut,
  easeSinOut: () => sinOut
});

// node_modules/d3-ease/src/linear.js
function linear2(t) {
  return +t;
}

// node_modules/d3-ease/src/quad.js
function quadIn(t) {
  return t * t;
}
function quadOut(t) {
  return t * (2 - t);
}
function quadInOut(t) {
  return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
}

// node_modules/d3-ease/src/cubic.js
function cubicIn(t) {
  return t * t * t;
}
function cubicOut(t) {
  return --t * t * t + 1;
}
function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

// node_modules/d3-ease/src/poly.js
var exponent = 3;
var polyIn = function custom(e) {
  e = +e;
  function polyIn2(t) {
    return Math.pow(t, e);
  }
  polyIn2.exponent = custom;
  return polyIn2;
}(exponent);
var polyOut = function custom2(e) {
  e = +e;
  function polyOut2(t) {
    return 1 - Math.pow(1 - t, e);
  }
  polyOut2.exponent = custom2;
  return polyOut2;
}(exponent);
var polyInOut = function custom3(e) {
  e = +e;
  function polyInOut2(t) {
    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
  }
  polyInOut2.exponent = custom3;
  return polyInOut2;
}(exponent);

// node_modules/d3-ease/src/sin.js
var pi = Math.PI;
var halfPi = pi / 2;
function sinIn(t) {
  return +t === 1 ? 1 : 1 - Math.cos(t * halfPi);
}
function sinOut(t) {
  return Math.sin(t * halfPi);
}
function sinInOut(t) {
  return (1 - Math.cos(pi * t)) / 2;
}

// node_modules/d3-ease/src/math.js
function tpmt(x) {
  return (Math.pow(2, -10 * x) - 9765625e-10) * 1.0009775171065494;
}

// node_modules/d3-ease/src/exp.js
function expIn(t) {
  return tpmt(1 - +t);
}
function expOut(t) {
  return 1 - tpmt(t);
}
function expInOut(t) {
  return ((t *= 2) <= 1 ? tpmt(1 - t) : 2 - tpmt(t - 1)) / 2;
}

// node_modules/d3-ease/src/circle.js
function circleIn(t) {
  return 1 - Math.sqrt(1 - t * t);
}
function circleOut(t) {
  return Math.sqrt(1 - --t * t);
}
function circleInOut(t) {
  return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
}

// node_modules/d3-ease/src/bounce.js
var b1 = 4 / 11;
var b2 = 6 / 11;
var b3 = 8 / 11;
var b4 = 3 / 4;
var b5 = 9 / 11;
var b6 = 10 / 11;
var b7 = 15 / 16;
var b8 = 21 / 22;
var b9 = 63 / 64;
var b0 = 1 / b1 / b1;
function bounceIn(t) {
  return 1 - bounceOut(1 - t);
}
function bounceOut(t) {
  return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
}
function bounceInOut(t) {
  return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
}

// node_modules/d3-ease/src/back.js
var overshoot = 1.70158;
var backIn = function custom4(s) {
  s = +s;
  function backIn2(t) {
    return (t = +t) * t * (s * (t - 1) + t);
  }
  backIn2.overshoot = custom4;
  return backIn2;
}(overshoot);
var backOut = function custom5(s) {
  s = +s;
  function backOut2(t) {
    return --t * t * ((t + 1) * s + t) + 1;
  }
  backOut2.overshoot = custom5;
  return backOut2;
}(overshoot);
var backInOut = function custom6(s) {
  s = +s;
  function backInOut2(t) {
    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
  }
  backInOut2.overshoot = custom6;
  return backInOut2;
}(overshoot);

// node_modules/d3-ease/src/elastic.js
var tau = 2 * Math.PI;
var amplitude = 1;
var period = 0.3;
var elasticIn = function custom7(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);
  function elasticIn2(t) {
    return a * tpmt(- --t) * Math.sin((s - t) / p);
  }
  elasticIn2.amplitude = function(a2) {
    return custom7(a2, p * tau);
  };
  elasticIn2.period = function(p2) {
    return custom7(a, p2);
  };
  return elasticIn2;
}(amplitude, period);
var elasticOut = function custom8(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);
  function elasticOut2(t) {
    return 1 - a * tpmt(t = +t) * Math.sin((t + s) / p);
  }
  elasticOut2.amplitude = function(a2) {
    return custom8(a2, p * tau);
  };
  elasticOut2.period = function(p2) {
    return custom8(a, p2);
  };
  return elasticOut2;
}(amplitude, period);
var elasticInOut = function custom9(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);
  function elasticInOut2(t) {
    return ((t = t * 2 - 1) < 0 ? a * tpmt(-t) * Math.sin((s - t) / p) : 2 - a * tpmt(t) * Math.sin((s + t) / p)) / 2;
  }
  elasticInOut2.amplitude = function(a2) {
    return custom9(a2, p * tau);
  };
  elasticInOut2.period = function(p2) {
    return custom9(a, p2);
  };
  return elasticInOut2;
}(amplitude, period);

// node_modules/@antv/g-base/esm/animate/register.js
var EASING_MAP = {};
function getEasing(type) {
  return EASING_MAP[type.toLowerCase()] || src_exports[type];
}
function registerEasing(type, easeFn) {
  EASING_MAP[type.toLowerCase()] = easeFn;
}

// node_modules/@antv/g-base/esm/util/color.js
var isColorProp = function(prop) {
  return ["fill", "stroke", "fillStyle", "strokeStyle"].includes(prop);
};
var isGradientColor = function(val) {
  return /^[r,R,L,l]{1}[\s]*\(/.test(val);
};

// node_modules/@antv/g-base/esm/animate/timeline.js
var IDENTITY_MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];
function _update(shape, animation, ratio) {
  var cProps = {};
  var fromAttrs = animation.fromAttrs, toAttrs = animation.toAttrs;
  if (shape.destroyed) {
    return;
  }
  var interf;
  for (var k in toAttrs) {
    if (!is_equal_default(fromAttrs[k], toAttrs[k])) {
      if (k === "path") {
        var toPath = toAttrs[k];
        var fromPath = fromAttrs[k];
        if (toPath.length > fromPath.length) {
          toPath = parsePathString(toAttrs[k]);
          fromPath = parsePathString(fromAttrs[k]);
          fromPath = fillPathByDiff(fromPath, toPath);
          fromPath = formatPath(fromPath, toPath);
          animation.fromAttrs.path = fromPath;
          animation.toAttrs.path = toPath;
        } else if (!animation.pathFormatted) {
          toPath = parsePathString(toAttrs[k]);
          fromPath = parsePathString(fromAttrs[k]);
          fromPath = formatPath(fromPath, toPath);
          animation.fromAttrs.path = fromPath;
          animation.toAttrs.path = toPath;
          animation.pathFormatted = true;
        }
        cProps[k] = [];
        for (var i = 0; i < toPath.length; i++) {
          var toPathPoint = toPath[i];
          var fromPathPoint = fromPath[i];
          var cPathPoint = [];
          for (var j = 0; j < toPathPoint.length; j++) {
            if (is_number_default(toPathPoint[j]) && fromPathPoint && is_number_default(fromPathPoint[j])) {
              interf = value_default(fromPathPoint[j], toPathPoint[j]);
              cPathPoint.push(interf(ratio));
            } else {
              cPathPoint.push(toPathPoint[j]);
            }
          }
          cProps[k].push(cPathPoint);
        }
      } else if (k === "matrix") {
        var matrixFn = array_default(fromAttrs[k] || IDENTITY_MATRIX, toAttrs[k] || IDENTITY_MATRIX);
        var currentMatrix = matrixFn(ratio);
        cProps[k] = currentMatrix;
      } else if (isColorProp(k) && isGradientColor(toAttrs[k])) {
        cProps[k] = toAttrs[k];
      } else if (!is_function_default(toAttrs[k])) {
        interf = value_default(fromAttrs[k], toAttrs[k]);
        cProps[k] = interf(ratio);
      }
    }
  }
  shape.attr(cProps);
}
function update(shape, animation, elapsed) {
  var startTime = animation.startTime, delay = animation.delay;
  if (elapsed < startTime + delay || animation._paused) {
    return false;
  }
  var ratio;
  var duration = animation.duration;
  var easing = animation.easing;
  var easeFn = getEasing(easing);
  elapsed = elapsed - startTime - animation.delay;
  if (animation.repeat) {
    ratio = elapsed % duration / duration;
    ratio = easeFn(ratio);
  } else {
    ratio = elapsed / duration;
    if (ratio < 1) {
      ratio = easeFn(ratio);
    } else {
      if (animation.onFrame) {
        shape.attr(animation.onFrame(1));
      } else {
        shape.attr(animation.toAttrs);
      }
      return true;
    }
  }
  if (animation.onFrame) {
    var attrs = animation.onFrame(ratio);
    shape.attr(attrs);
  } else {
    _update(shape, animation, ratio);
  }
  return false;
}
var Timeline = function() {
  function Timeline2(canvas) {
    this.animators = [];
    this.current = 0;
    this.timer = null;
    this.canvas = canvas;
  }
  Timeline2.prototype.initTimer = function() {
    var _this = this;
    var isFinished = false;
    var shape;
    var animations;
    var animation;
    this.timer = timer(function(elapsed) {
      _this.current = elapsed;
      if (_this.animators.length > 0) {
        for (var i = _this.animators.length - 1; i >= 0; i--) {
          shape = _this.animators[i];
          if (shape.destroyed) {
            _this.removeAnimator(i);
            continue;
          }
          if (!shape.isAnimatePaused()) {
            animations = shape.get("animations");
            for (var j = animations.length - 1; j >= 0; j--) {
              animation = animations[j];
              isFinished = update(shape, animation, elapsed);
              if (isFinished) {
                animations.splice(j, 1);
                isFinished = false;
                if (animation.callback) {
                  animation.callback();
                }
              }
            }
          }
          if (animations.length === 0) {
            _this.removeAnimator(i);
          }
        }
        var autoDraw = _this.canvas.get("autoDraw");
        if (!autoDraw) {
          _this.canvas.draw();
        }
      }
    });
  };
  Timeline2.prototype.addAnimator = function(shape) {
    this.animators.push(shape);
  };
  Timeline2.prototype.removeAnimator = function(index) {
    this.animators.splice(index, 1);
  };
  Timeline2.prototype.isAnimating = function() {
    return !!this.animators.length;
  };
  Timeline2.prototype.stop = function() {
    if (this.timer) {
      this.timer.stop();
    }
  };
  Timeline2.prototype.stopAllAnimations = function(toEnd) {
    if (toEnd === void 0) {
      toEnd = true;
    }
    this.animators.forEach(function(animator) {
      animator.stopAnimate(toEnd);
    });
    this.animators = [];
    this.canvas.draw();
  };
  Timeline2.prototype.getTime = function() {
    return this.current;
  };
  return Timeline2;
}();
var timeline_default = Timeline;

// node_modules/@antv/g-base/esm/event/event-contoller.js
var CLICK_OFFSET = 40;
var LEFT_BTN_CODE = 0;
var EVENTS = [
  "mousedown",
  "mouseup",
  "dblclick",
  "mouseout",
  "mouseover",
  "mousemove",
  "mouseleave",
  "mouseenter",
  "touchstart",
  "touchmove",
  "touchend",
  "dragenter",
  "dragover",
  "dragleave",
  "drop",
  "contextmenu",
  "mousewheel"
];
function emitTargetEvent(target, type, eventObj) {
  eventObj.name = type;
  eventObj.target = target;
  eventObj.currentTarget = target;
  eventObj.delegateTarget = target;
  target.emit(type, eventObj);
}
function bubbleEvent(container, type, eventObj) {
  if (eventObj.bubbles) {
    var relativeShape = void 0;
    var isOverEvent = false;
    if (type === "mouseenter") {
      relativeShape = eventObj.fromShape;
      isOverEvent = true;
    } else if (type === "mouseleave") {
      isOverEvent = true;
      relativeShape = eventObj.toShape;
    }
    if (container.isCanvas() && isOverEvent) {
      return;
    }
    if (relativeShape && isParent(container, relativeShape)) {
      eventObj.bubbles = false;
      return;
    }
    eventObj.name = type;
    eventObj.currentTarget = container;
    eventObj.delegateTarget = container;
    container.emit(type, eventObj);
  }
}
var EventController = function() {
  function EventController2(cfg) {
    var _this = this;
    this.draggingShape = null;
    this.dragging = false;
    this.currentShape = null;
    this.mousedownShape = null;
    this.mousedownPoint = null;
    this._eventCallback = function(ev) {
      var type = ev.type;
      _this._triggerEvent(type, ev);
    };
    this._onDocumentMove = function(ev) {
      var canvas = _this.canvas;
      var el = canvas.get("el");
      if (el !== ev.target) {
        if (_this.dragging || _this.currentShape) {
          var pointInfo = _this._getPointInfo(ev);
          if (_this.dragging) {
            _this._emitEvent("drag", ev, pointInfo, _this.draggingShape);
          }
        }
      }
    };
    this._onDocumentMouseUp = function(ev) {
      var canvas = _this.canvas;
      var el = canvas.get("el");
      if (el !== ev.target) {
        if (_this.dragging) {
          var pointInfo = _this._getPointInfo(ev);
          if (_this.draggingShape) {
            _this._emitEvent("drop", ev, pointInfo, null);
          }
          _this._emitEvent("dragend", ev, pointInfo, _this.draggingShape);
          _this._afterDrag(_this.draggingShape, pointInfo, ev);
        }
      }
    };
    this.canvas = cfg.canvas;
  }
  EventController2.prototype.init = function() {
    this._bindEvents();
  };
  EventController2.prototype._bindEvents = function() {
    var _this = this;
    var el = this.canvas.get("el");
    each_default(EVENTS, function(eventName) {
      el.addEventListener(eventName, _this._eventCallback);
    });
    if (document) {
      document.addEventListener("mousemove", this._onDocumentMove);
      document.addEventListener("mouseup", this._onDocumentMouseUp);
    }
  };
  EventController2.prototype._clearEvents = function() {
    var _this = this;
    var el = this.canvas.get("el");
    each_default(EVENTS, function(eventName) {
      el.removeEventListener(eventName, _this._eventCallback);
    });
    if (document) {
      document.removeEventListener("mousemove", this._onDocumentMove);
      document.removeEventListener("mouseup", this._onDocumentMouseUp);
    }
  };
  EventController2.prototype._getEventObj = function(type, event, point, target, fromShape, toShape) {
    var eventObj = new graph_event_default(type, event);
    eventObj.fromShape = fromShape;
    eventObj.toShape = toShape;
    eventObj.x = point.x;
    eventObj.y = point.y;
    eventObj.clientX = point.clientX;
    eventObj.clientY = point.clientY;
    eventObj.propagationPath.push(target);
    return eventObj;
  };
  EventController2.prototype._getShape = function(point, ev) {
    return this.canvas.getShape(point.x, point.y, ev);
  };
  EventController2.prototype._getPointInfo = function(ev) {
    var canvas = this.canvas;
    var clientPoint = canvas.getClientByEvent(ev);
    var point = canvas.getPointByEvent(ev);
    return {
      x: point.x,
      y: point.y,
      clientX: clientPoint.x,
      clientY: clientPoint.y
    };
  };
  EventController2.prototype._triggerEvent = function(type, ev) {
    var pointInfo = this._getPointInfo(ev);
    var shape = this._getShape(pointInfo, ev);
    var method = this["_on" + type];
    var leaveCanvas = false;
    if (method) {
      method.call(this, pointInfo, shape, ev);
    } else {
      var preShape = this.currentShape;
      if (type === "mouseenter" || type === "dragenter" || type === "mouseover") {
        this._emitEvent(type, ev, pointInfo, null, null, shape);
        if (shape) {
          this._emitEvent(type, ev, pointInfo, shape, null, shape);
        }
        if (type === "mouseenter" && this.draggingShape) {
          this._emitEvent("dragenter", ev, pointInfo, null);
        }
      } else if (type === "mouseleave" || type === "dragleave" || type === "mouseout") {
        leaveCanvas = true;
        if (preShape) {
          this._emitEvent(type, ev, pointInfo, preShape, preShape, null);
        }
        this._emitEvent(type, ev, pointInfo, null, preShape, null);
        if (type === "mouseleave" && this.draggingShape) {
          this._emitEvent("dragleave", ev, pointInfo, null);
        }
      } else {
        this._emitEvent(type, ev, pointInfo, shape, null, null);
      }
    }
    if (!leaveCanvas) {
      this.currentShape = shape;
    }
    if (shape && !shape.get("destroyed")) {
      var canvas = this.canvas;
      var el = canvas.get("el");
      el.style.cursor = shape.attr("cursor") || canvas.get("cursor");
    }
  };
  EventController2.prototype._onmousedown = function(pointInfo, shape, event) {
    if (event.button === LEFT_BTN_CODE) {
      this.mousedownShape = shape;
      this.mousedownPoint = pointInfo;
      this.mousedownTimeStamp = event.timeStamp;
    }
    this._emitEvent("mousedown", event, pointInfo, shape, null, null);
  };
  EventController2.prototype._emitMouseoverEvents = function(event, pointInfo, fromShape, toShape) {
    var el = this.canvas.get("el");
    if (fromShape !== toShape) {
      if (fromShape) {
        this._emitEvent("mouseout", event, pointInfo, fromShape, fromShape, toShape);
        this._emitEvent("mouseleave", event, pointInfo, fromShape, fromShape, toShape);
        if (!toShape || toShape.get("destroyed")) {
          el.style.cursor = this.canvas.get("cursor");
        }
      }
      if (toShape) {
        this._emitEvent("mouseover", event, pointInfo, toShape, fromShape, toShape);
        this._emitEvent("mouseenter", event, pointInfo, toShape, fromShape, toShape);
      }
    }
  };
  EventController2.prototype._emitDragoverEvents = function(event, pointInfo, fromShape, toShape, isCanvasEmit) {
    if (toShape) {
      if (toShape !== fromShape) {
        if (fromShape) {
          this._emitEvent("dragleave", event, pointInfo, fromShape, fromShape, toShape);
        }
        this._emitEvent("dragenter", event, pointInfo, toShape, fromShape, toShape);
      }
      if (!isCanvasEmit) {
        this._emitEvent("dragover", event, pointInfo, toShape);
      }
    } else if (fromShape) {
      this._emitEvent("dragleave", event, pointInfo, fromShape, fromShape, toShape);
    }
    if (isCanvasEmit) {
      this._emitEvent("dragover", event, pointInfo, toShape);
    }
  };
  EventController2.prototype._afterDrag = function(draggingShape, pointInfo, event) {
    if (draggingShape) {
      draggingShape.set("capture", true);
      this.draggingShape = null;
    }
    this.dragging = false;
    var shape = this._getShape(pointInfo, event);
    if (shape !== draggingShape) {
      this._emitMouseoverEvents(event, pointInfo, draggingShape, shape);
    }
    this.currentShape = shape;
  };
  EventController2.prototype._onmouseup = function(pointInfo, shape, event) {
    if (event.button === LEFT_BTN_CODE) {
      var draggingShape = this.draggingShape;
      if (this.dragging) {
        if (draggingShape) {
          this._emitEvent("drop", event, pointInfo, shape);
        }
        this._emitEvent("dragend", event, pointInfo, draggingShape);
        this._afterDrag(draggingShape, pointInfo, event);
      } else {
        this._emitEvent("mouseup", event, pointInfo, shape);
        if (shape === this.mousedownShape) {
          this._emitEvent("click", event, pointInfo, shape);
        }
        this.mousedownShape = null;
        this.mousedownPoint = null;
      }
    }
  };
  EventController2.prototype._ondragover = function(pointInfo, shape, event) {
    event.preventDefault();
    var preShape = this.currentShape;
    this._emitDragoverEvents(event, pointInfo, preShape, shape, true);
  };
  EventController2.prototype._onmousemove = function(pointInfo, shape, event) {
    var canvas = this.canvas;
    var preShape = this.currentShape;
    var draggingShape = this.draggingShape;
    if (this.dragging) {
      if (draggingShape) {
        this._emitDragoverEvents(event, pointInfo, preShape, shape, false);
      }
      this._emitEvent("drag", event, pointInfo, draggingShape);
    } else {
      var mousedownPoint = this.mousedownPoint;
      if (mousedownPoint) {
        var mousedownShape = this.mousedownShape;
        var now2 = event.timeStamp;
        var timeWindow = now2 - this.mousedownTimeStamp;
        var dx = mousedownPoint.clientX - pointInfo.clientX;
        var dy = mousedownPoint.clientY - pointInfo.clientY;
        var dist3 = dx * dx + dy * dy;
        if (timeWindow > 120 || dist3 > CLICK_OFFSET) {
          if (mousedownShape && mousedownShape.get("draggable")) {
            draggingShape = this.mousedownShape;
            draggingShape.set("capture", false);
            this.draggingShape = draggingShape;
            this.dragging = true;
            this._emitEvent("dragstart", event, pointInfo, draggingShape);
            this.mousedownShape = null;
            this.mousedownPoint = null;
          } else if (!mousedownShape && canvas.get("draggable")) {
            this.dragging = true;
            this._emitEvent("dragstart", event, pointInfo, null);
            this.mousedownShape = null;
            this.mousedownPoint = null;
          } else {
            this._emitMouseoverEvents(event, pointInfo, preShape, shape);
            this._emitEvent("mousemove", event, pointInfo, shape);
          }
        } else {
          this._emitMouseoverEvents(event, pointInfo, preShape, shape);
          this._emitEvent("mousemove", event, pointInfo, shape);
        }
      } else {
        this._emitMouseoverEvents(event, pointInfo, preShape, shape);
        this._emitEvent("mousemove", event, pointInfo, shape);
      }
    }
  };
  EventController2.prototype._emitEvent = function(type, event, pointInfo, shape, fromShape, toShape) {
    var eventObj = this._getEventObj(type, event, pointInfo, shape, fromShape, toShape);
    if (shape) {
      eventObj.shape = shape;
      emitTargetEvent(shape, type, eventObj);
      var parent_1 = shape.getParent();
      while (parent_1) {
        parent_1.emitDelegation(type, eventObj);
        if (!eventObj.propagationStopped) {
          bubbleEvent(parent_1, type, eventObj);
        }
        eventObj.propagationPath.push(parent_1);
        parent_1 = parent_1.getParent();
      }
    } else {
      var canvas = this.canvas;
      emitTargetEvent(canvas, type, eventObj);
    }
  };
  EventController2.prototype.destroy = function() {
    this._clearEvents();
    this.canvas = null;
    this.currentShape = null;
    this.draggingShape = null;
    this.mousedownPoint = null;
    this.mousedownShape = null;
    this.mousedownTimeStamp = null;
  };
  return EventController2;
}();
var event_contoller_default = EventController;

// node_modules/@antv/g-base/esm/abstract/canvas.js
var PX_SUFFIX = "px";
var browser = detect();
var isFirefox = browser && browser.name === "firefox";
var Canvas = function(_super) {
  __extends(Canvas4, _super);
  function Canvas4(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.initContainer();
    _this.initDom();
    _this.initEvents();
    _this.initTimeline();
    return _this;
  }
  Canvas4.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    cfg["cursor"] = "default";
    cfg["supportCSSTransform"] = false;
    return cfg;
  };
  Canvas4.prototype.initContainer = function() {
    var container = this.get("container");
    if (is_string_default(container)) {
      container = document.getElementById(container);
      this.set("container", container);
    }
  };
  Canvas4.prototype.initDom = function() {
    var el = this.createDom();
    this.set("el", el);
    var container = this.get("container");
    container.appendChild(el);
    this.setDOMSize(this.get("width"), this.get("height"));
  };
  Canvas4.prototype.initEvents = function() {
    var eventController = new event_contoller_default({
      canvas: this
    });
    eventController.init();
    this.set("eventController", eventController);
  };
  Canvas4.prototype.initTimeline = function() {
    var timeline = new timeline_default(this);
    this.set("timeline", timeline);
  };
  Canvas4.prototype.setDOMSize = function(width, height) {
    var el = this.get("el");
    if (isBrowser) {
      el.style.width = width + PX_SUFFIX;
      el.style.height = height + PX_SUFFIX;
    }
  };
  Canvas4.prototype.changeSize = function(width, height) {
    this.setDOMSize(width, height);
    this.set("width", width);
    this.set("height", height);
    this.onCanvasChange("changeSize");
  };
  Canvas4.prototype.getRenderer = function() {
    return this.get("renderer");
  };
  Canvas4.prototype.getCursor = function() {
    return this.get("cursor");
  };
  Canvas4.prototype.setCursor = function(cursor) {
    this.set("cursor", cursor);
    var el = this.get("el");
    if (isBrowser && el) {
      el.style.cursor = cursor;
    }
  };
  Canvas4.prototype.getPointByEvent = function(ev) {
    var supportCSSTransform = this.get("supportCSSTransform");
    if (supportCSSTransform) {
      if (isFirefox && !is_nil_default(ev.layerX) && ev.layerX !== ev.offsetX) {
        return {
          x: ev.layerX,
          y: ev.layerY
        };
      }
      if (!is_nil_default(ev.offsetX)) {
        return {
          x: ev.offsetX,
          y: ev.offsetY
        };
      }
    }
    var _a3 = this.getClientByEvent(ev), clientX = _a3.x, clientY = _a3.y;
    return this.getPointByClient(clientX, clientY);
  };
  Canvas4.prototype.getClientByEvent = function(ev) {
    var clientInfo = ev;
    if (ev.touches) {
      if (ev.type === "touchend") {
        clientInfo = ev.changedTouches[0];
      } else {
        clientInfo = ev.touches[0];
      }
    }
    return {
      x: clientInfo.clientX,
      y: clientInfo.clientY
    };
  };
  Canvas4.prototype.getPointByClient = function(clientX, clientY) {
    var el = this.get("el");
    var bbox = el.getBoundingClientRect();
    return {
      x: clientX - bbox.left,
      y: clientY - bbox.top
    };
  };
  Canvas4.prototype.getClientByPoint = function(x, y) {
    var el = this.get("el");
    var bbox = el.getBoundingClientRect();
    return {
      x: x + bbox.left,
      y: y + bbox.top
    };
  };
  Canvas4.prototype.draw = function() {
  };
  Canvas4.prototype.removeDom = function() {
    var el = this.get("el");
    el.parentNode.removeChild(el);
  };
  Canvas4.prototype.clearEvents = function() {
    var eventController = this.get("eventController");
    eventController.destroy();
  };
  Canvas4.prototype.isCanvas = function() {
    return true;
  };
  Canvas4.prototype.getParent = function() {
    return null;
  };
  Canvas4.prototype.destroy = function() {
    var timeline = this.get("timeline");
    if (this.get("destroyed")) {
      return;
    }
    this.clear();
    if (timeline) {
      timeline.stop();
    }
    this.clearEvents();
    this.removeDom();
    _super.prototype.destroy.call(this);
  };
  return Canvas4;
}(container_default);
var canvas_default = Canvas;

// node_modules/@antv/g-base/esm/abstract/group.js
var AbstractGroup = function(_super) {
  __extends(AbstractGroup2, _super);
  function AbstractGroup2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AbstractGroup2.prototype.isGroup = function() {
    return true;
  };
  AbstractGroup2.prototype.isEntityGroup = function() {
    return false;
  };
  AbstractGroup2.prototype.clone = function() {
    var clone6 = _super.prototype.clone.call(this);
    var children = this.getChildren();
    for (var i = 0; i < children.length; i++) {
      var child = children[i];
      clone6.add(child.clone());
    }
    return clone6;
  };
  return AbstractGroup2;
}(container_default);
var group_default2 = AbstractGroup;

// node_modules/@antv/g-base/esm/abstract/shape.js
var AbstractShape = function(_super) {
  __extends(AbstractShape2, _super);
  function AbstractShape2(cfg) {
    return _super.call(this, cfg) || this;
  }
  AbstractShape2.prototype._isInBBox = function(refX, refY) {
    var bbox = this.getBBox();
    return bbox.minX <= refX && bbox.maxX >= refX && bbox.minY <= refY && bbox.maxY >= refY;
  };
  AbstractShape2.prototype.afterAttrsChange = function(targetAttrs) {
    _super.prototype.afterAttrsChange.call(this, targetAttrs);
    this.clearCacheBBox();
  };
  AbstractShape2.prototype.getBBox = function() {
    var bbox = this.cfg.bbox;
    if (!bbox) {
      bbox = this.calculateBBox();
      this.set("bbox", bbox);
    }
    return bbox;
  };
  AbstractShape2.prototype.getCanvasBBox = function() {
    var canvasBBox = this.cfg.canvasBBox;
    if (!canvasBBox) {
      canvasBBox = this.calculateCanvasBBox();
      this.set("canvasBBox", canvasBBox);
    }
    return canvasBBox;
  };
  AbstractShape2.prototype.applyMatrix = function(matrix) {
    _super.prototype.applyMatrix.call(this, matrix);
    this.set("canvasBBox", null);
  };
  AbstractShape2.prototype.calculateCanvasBBox = function() {
    var bbox = this.getBBox();
    var totalMatrix = this.getTotalMatrix();
    var minX = bbox.minX, minY = bbox.minY, maxX = bbox.maxX, maxY = bbox.maxY;
    if (totalMatrix) {
      var topLeft = multiplyVec2(totalMatrix, [bbox.minX, bbox.minY]);
      var topRight = multiplyVec2(totalMatrix, [bbox.maxX, bbox.minY]);
      var bottomLeft = multiplyVec2(totalMatrix, [bbox.minX, bbox.maxY]);
      var bottomRight = multiplyVec2(totalMatrix, [bbox.maxX, bbox.maxY]);
      minX = Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
      maxX = Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
      minY = Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
      maxY = Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
    }
    var attrs = this.attrs;
    if (attrs.shadowColor) {
      var _a3 = attrs.shadowBlur, shadowBlur = _a3 === void 0 ? 0 : _a3, _b = attrs.shadowOffsetX, shadowOffsetX = _b === void 0 ? 0 : _b, _c = attrs.shadowOffsetY, shadowOffsetY = _c === void 0 ? 0 : _c;
      var shadowLeft = minX - shadowBlur + shadowOffsetX;
      var shadowRight = maxX + shadowBlur + shadowOffsetX;
      var shadowTop = minY - shadowBlur + shadowOffsetY;
      var shadowBottom = maxY + shadowBlur + shadowOffsetY;
      minX = Math.min(minX, shadowLeft);
      maxX = Math.max(maxX, shadowRight);
      minY = Math.min(minY, shadowTop);
      maxY = Math.max(maxY, shadowBottom);
    }
    return {
      x: minX,
      y: minY,
      minX,
      minY,
      maxX,
      maxY,
      width: maxX - minX,
      height: maxY - minY
    };
  };
  AbstractShape2.prototype.clearCacheBBox = function() {
    this.set("bbox", null);
    this.set("canvasBBox", null);
  };
  AbstractShape2.prototype.isClipShape = function() {
    return this.get("isClipShape");
  };
  AbstractShape2.prototype.isInShape = function(refX, refY) {
    return false;
  };
  AbstractShape2.prototype.isOnlyHitBox = function() {
    return false;
  };
  AbstractShape2.prototype.isHit = function(x, y) {
    var startArrowShape = this.get("startArrowShape");
    var endArrowShape = this.get("endArrowShape");
    var vec = [x, y, 1];
    vec = this.invertFromMatrix(vec);
    var refX = vec[0], refY = vec[1];
    var inBBox = this._isInBBox(refX, refY);
    if (this.isOnlyHitBox()) {
      return inBBox;
    }
    if (inBBox && !this.isClipped(refX, refY)) {
      if (this.isInShape(refX, refY)) {
        return true;
      }
      if (startArrowShape && startArrowShape.isHit(refX, refY)) {
        return true;
      }
      if (endArrowShape && endArrowShape.isHit(refX, refY)) {
        return true;
      }
    }
    return false;
  };
  return AbstractShape2;
}(element_default);
var shape_default = AbstractShape;

// node_modules/@antv/g-base/esm/bbox/register.js
var cache = /* @__PURE__ */ new Map();
function register(type, method) {
  cache.set(type, method);
}
function getMethod(type) {
  return cache.get(type);
}

// node_modules/@antv/g-base/esm/bbox/rect.js
function rect_default(shape) {
  var attrs = shape.attr();
  var x = attrs.x, y = attrs.y, width = attrs.width, height = attrs.height;
  return {
    x,
    y,
    width,
    height
  };
}

// node_modules/@antv/g-base/esm/bbox/circle.js
function circle_default(shape) {
  var _a3 = shape.attr(), x = _a3.x, y = _a3.y, r = _a3.r;
  return {
    x: x - r,
    y: y - r,
    width: r * 2,
    height: r * 2
  };
}

// node_modules/@antv/g-math/esm/util.js
var util_exports = {};
__export(util_exports, {
  distance: () => distance3,
  getBBoxByArray: () => getBBoxByArray,
  getBBoxRange: () => getBBoxRange,
  isNumberEqual: () => isNumberEqual2,
  piMod: () => piMod
});
function minNum(array) {
  return Math.min.apply(null, array);
}
function maxNum(array) {
  return Math.max.apply(null, array);
}
function distance3(x1, y1, x2, y2) {
  var dx = x1 - x2;
  var dy = y1 - y2;
  return Math.sqrt(dx * dx + dy * dy);
}
function isNumberEqual2(v1, v2) {
  return Math.abs(v1 - v2) < 1e-3;
}
function getBBoxByArray(xArr, yArr) {
  var minX = minNum(xArr);
  var minY = minNum(yArr);
  var maxX = maxNum(xArr);
  var maxY = maxNum(yArr);
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function getBBoxRange(x1, y1, x2, y2) {
  return {
    minX: minNum([x1, x2]),
    maxX: maxNum([x1, x2]),
    minY: minNum([y1, y2]),
    maxY: maxNum([y1, y2])
  };
}
function piMod(angle3) {
  return (angle3 + Math.PI * 2) % (Math.PI * 2);
}

// node_modules/@antv/g-math/esm/line.js
var line_default = {
  box: function(x1, y1, x2, y2) {
    return getBBoxByArray([x1, x2], [y1, y2]);
  },
  length: function(x1, y1, x2, y2) {
    return distance3(x1, y1, x2, y2);
  },
  pointAt: function(x1, y1, x2, y2, t) {
    return {
      x: (1 - t) * x1 + t * x2,
      y: (1 - t) * y1 + t * y2
    };
  },
  pointDistance: function(x1, y1, x2, y2, x, y) {
    var cross3 = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);
    if (cross3 < 0) {
      return distance3(x1, y1, x, y);
    }
    var lengthSquare = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
    if (cross3 > lengthSquare) {
      return distance3(x2, y2, x, y);
    }
    return this.pointToLine(x1, y1, x2, y2, x, y);
  },
  pointToLine: function(x1, y1, x2, y2, x, y) {
    var d = [x2 - x1, y2 - y1];
    if (exactEquals4(d, [0, 0])) {
      return Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));
    }
    var u = [-d[1], d[0]];
    normalize4(u, u);
    var a = [x - x1, y - y1];
    return Math.abs(dot4(a, u));
  },
  tangentAngle: function(x1, y1, x2, y2) {
    return Math.atan2(y2 - y1, x2 - x1);
  }
};

// node_modules/@antv/g-math/esm/bezier.js
var EPSILON2 = 1e-4;
function nearestPoint(xArr, yArr, x, y, tCallback, length5) {
  var t;
  var d = Infinity;
  var v0 = [x, y];
  var segNum = 20;
  if (length5 && length5 > 200) {
    segNum = length5 / 10;
  }
  var increaseRate = 1 / segNum;
  var interval2 = increaseRate / 10;
  for (var i = 0; i <= segNum; i++) {
    var _t = i * increaseRate;
    var v1 = [tCallback.apply(null, xArr.concat([_t])), tCallback.apply(null, yArr.concat([_t]))];
    var d1 = distance3(v0[0], v0[1], v1[0], v1[1]);
    if (d1 < d) {
      t = _t;
      d = d1;
    }
  }
  if (t === 0) {
    return {
      x: xArr[0],
      y: yArr[0]
    };
  }
  if (t === 1) {
    var count = xArr.length;
    return {
      x: xArr[count - 1],
      y: yArr[count - 1]
    };
  }
  d = Infinity;
  for (var i = 0; i < 32; i++) {
    if (interval2 < EPSILON2) {
      break;
    }
    var prev = t - interval2;
    var next = t + interval2;
    var v1 = [tCallback.apply(null, xArr.concat([prev])), tCallback.apply(null, yArr.concat([prev]))];
    var d1 = distance3(v0[0], v0[1], v1[0], v1[1]);
    if (prev >= 0 && d1 < d) {
      t = prev;
      d = d1;
    } else {
      var v2 = [tCallback.apply(null, xArr.concat([next])), tCallback.apply(null, yArr.concat([next]))];
      var d2 = distance3(v0[0], v0[1], v2[0], v2[1]);
      if (next <= 1 && d2 < d) {
        t = next;
        d = d2;
      } else {
        interval2 *= 0.5;
      }
    }
  }
  return {
    x: tCallback.apply(null, xArr.concat([t])),
    y: tCallback.apply(null, yArr.concat([t]))
  };
}
function snapLength(xArr, yArr) {
  var totalLength = 0;
  var count = xArr.length;
  for (var i = 0; i < count; i++) {
    var x = xArr[i];
    var y = yArr[i];
    var nextX = xArr[(i + 1) % count];
    var nextY = yArr[(i + 1) % count];
    totalLength += distance3(x, y, nextX, nextY);
  }
  return totalLength / 2;
}

// node_modules/@antv/g-math/esm/quadratic.js
function quadraticAt(p0, p1, p2, t) {
  var onet = 1 - t;
  return onet * onet * p0 + 2 * t * onet * p1 + t * t * p2;
}
function extrema(p0, p1, p2) {
  var a = p0 + p2 - 2 * p1;
  if (isNumberEqual2(a, 0)) {
    return [0.5];
  }
  var rst = (p0 - p1) / a;
  if (rst <= 1 && rst >= 0) {
    return [rst];
  }
  return [];
}
function derivativeAt(p0, p1, p2, t) {
  return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);
}
function divideQuadratic(x1, y1, x2, y2, x3, y3, t) {
  var xt = quadraticAt(x1, x2, x3, t);
  var yt = quadraticAt(y1, y2, y3, t);
  var controlPoint1 = line_default.pointAt(x1, y1, x2, y2, t);
  var controlPoint2 = line_default.pointAt(x2, y2, x3, y3, t);
  return [
    [x1, y1, controlPoint1.x, controlPoint1.y, xt, yt],
    [xt, yt, controlPoint2.x, controlPoint2.y, x3, y3]
  ];
}
function quadraticLength(x1, y1, x2, y2, x3, y3, iterationCount) {
  if (iterationCount === 0) {
    return (distance3(x1, y1, x2, y2) + distance3(x2, y2, x3, y3) + distance3(x1, y1, x3, y3)) / 2;
  }
  var quadratics = divideQuadratic(x1, y1, x2, y2, x3, y3, 0.5);
  var left = quadratics[0];
  var right = quadratics[1];
  left.push(iterationCount - 1);
  right.push(iterationCount - 1);
  return quadraticLength.apply(null, left) + quadraticLength.apply(null, right);
}
var quadratic_default = {
  box: function(x1, y1, x2, y2, x3, y3) {
    var xExtrema2 = extrema(x1, x2, x3)[0];
    var yExtrema2 = extrema(y1, y2, y3)[0];
    var xArr = [x1, x3];
    var yArr = [y1, y3];
    if (xExtrema2 !== void 0) {
      xArr.push(quadraticAt(x1, x2, x3, xExtrema2));
    }
    if (yExtrema2 !== void 0) {
      yArr.push(quadraticAt(y1, y2, y3, yExtrema2));
    }
    return getBBoxByArray(xArr, yArr);
  },
  length: function(x1, y1, x2, y2, x3, y3) {
    return quadraticLength(x1, y1, x2, y2, x3, y3, 3);
  },
  nearestPoint: function(x1, y1, x2, y2, x3, y3, x0, y0) {
    return nearestPoint([x1, x2, x3], [y1, y2, y3], x0, y0, quadraticAt);
  },
  pointDistance: function(x1, y1, x2, y2, x3, y3, x0, y0) {
    var point = this.nearestPoint(x1, y1, x2, y2, x3, y3, x0, y0);
    return distance3(point.x, point.y, x0, y0);
  },
  interpolationAt: quadraticAt,
  pointAt: function(x1, y1, x2, y2, x3, y3, t) {
    return {
      x: quadraticAt(x1, x2, x3, t),
      y: quadraticAt(y1, y2, y3, t)
    };
  },
  divide: function(x1, y1, x2, y2, x3, y3, t) {
    return divideQuadratic(x1, y1, x2, y2, x3, y3, t);
  },
  tangentAngle: function(x1, y1, x2, y2, x3, y3, t) {
    var dx = derivativeAt(x1, x2, x3, t);
    var dy = derivativeAt(y1, y2, y3, t);
    var angle3 = Math.atan2(dy, dx);
    return piMod(angle3);
  }
};

// node_modules/@antv/g-math/esm/cubic.js
function cubicAt(p0, p1, p2, p3, t) {
  var onet = 1 - t;
  return onet * onet * onet * p0 + 3 * p1 * t * onet * onet + 3 * p2 * t * t * onet + p3 * t * t * t;
}
function derivativeAt2(p0, p1, p2, p3, t) {
  var onet = 1 - t;
  return 3 * (onet * onet * (p1 - p0) + 2 * onet * t * (p2 - p1) + t * t * (p3 - p2));
}
function extrema2(p0, p1, p2, p3) {
  var a = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;
  var b = 6 * p0 - 12 * p1 + 6 * p2;
  var c = 3 * p1 - 3 * p0;
  var extremas = [];
  var t12;
  var t22;
  var discSqrt;
  if (isNumberEqual2(a, 0)) {
    if (!isNumberEqual2(b, 0)) {
      t12 = -c / b;
      if (t12 >= 0 && t12 <= 1) {
        extremas.push(t12);
      }
    }
  } else {
    var disc = b * b - 4 * a * c;
    if (isNumberEqual2(disc, 0)) {
      extremas.push(-b / (2 * a));
    } else if (disc > 0) {
      discSqrt = Math.sqrt(disc);
      t12 = (-b + discSqrt) / (2 * a);
      t22 = (-b - discSqrt) / (2 * a);
      if (t12 >= 0 && t12 <= 1) {
        extremas.push(t12);
      }
      if (t22 >= 0 && t22 <= 1) {
        extremas.push(t22);
      }
    }
  }
  return extremas;
}
function divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, t) {
  var xt = cubicAt(x1, x2, x3, x4, t);
  var yt = cubicAt(y1, y2, y3, y4, t);
  var c1 = line_default.pointAt(x1, y1, x2, y2, t);
  var c2 = line_default.pointAt(x2, y2, x3, y3, t);
  var c3 = line_default.pointAt(x3, y3, x4, y4, t);
  var c12 = line_default.pointAt(c1.x, c1.y, c2.x, c2.y, t);
  var c23 = line_default.pointAt(c2.x, c2.y, c3.x, c3.y, t);
  return [
    [x1, y1, c1.x, c1.y, c12.x, c12.y, xt, yt],
    [xt, yt, c23.x, c23.y, c3.x, c3.y, x4, y4]
  ];
}
function cubicLength(x1, y1, x2, y2, x3, y3, x4, y4, iterationCount) {
  if (iterationCount === 0) {
    return snapLength([x1, x2, x3, x4], [y1, y2, y3, y4]);
  }
  var cubics = divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, 0.5);
  var left = cubics[0];
  var right = cubics[1];
  left.push(iterationCount - 1);
  right.push(iterationCount - 1);
  return cubicLength.apply(null, left) + cubicLength.apply(null, right);
}
var cubic_default = {
  extrema: extrema2,
  box: function(x1, y1, x2, y2, x3, y3, x4, y4) {
    var xArr = [x1, x4];
    var yArr = [y1, y4];
    var xExtrema2 = extrema2(x1, x2, x3, x4);
    var yExtrema2 = extrema2(y1, y2, y3, y4);
    for (var i = 0; i < xExtrema2.length; i++) {
      xArr.push(cubicAt(x1, x2, x3, x4, xExtrema2[i]));
    }
    for (var i = 0; i < yExtrema2.length; i++) {
      yArr.push(cubicAt(y1, y2, y3, y4, yExtrema2[i]));
    }
    return getBBoxByArray(xArr, yArr);
  },
  length: function(x1, y1, x2, y2, x3, y3, x4, y4) {
    return cubicLength(x1, y1, x2, y2, x3, y3, x4, y4, 3);
  },
  nearestPoint: function(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length5) {
    return nearestPoint([x1, x2, x3, x4], [y1, y2, y3, y4], x0, y0, cubicAt, length5);
  },
  pointDistance: function(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length5) {
    var point = this.nearestPoint(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length5);
    return distance3(point.x, point.y, x0, y0);
  },
  interpolationAt: cubicAt,
  pointAt: function(x1, y1, x2, y2, x3, y3, x4, y4, t) {
    return {
      x: cubicAt(x1, x2, x3, x4, t),
      y: cubicAt(y1, y2, y3, y4, t)
    };
  },
  divide: function(x1, y1, x2, y2, x3, y3, x4, y4, t) {
    return divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, t);
  },
  tangentAngle: function(x1, y1, x2, y2, x3, y3, x4, y4, t) {
    var dx = derivativeAt2(x1, x2, x3, x4, t);
    var dy = derivativeAt2(y1, y2, y3, y4, t);
    return piMod(Math.atan2(dy, dx));
  }
};

// node_modules/@antv/g-math/esm/ellipse.js
function copysign(v1, v2) {
  var absv = Math.abs(v1);
  return v2 > 0 ? absv : absv * -1;
}
var ellipse_default = {
  box: function(x, y, rx, ry) {
    return {
      x: x - rx,
      y: y - ry,
      width: rx * 2,
      height: ry * 2
    };
  },
  length: function(x, y, rx, ry) {
    return Math.PI * (3 * (rx + ry) - Math.sqrt((3 * rx + ry) * (rx + 3 * ry)));
  },
  nearestPoint: function(x, y, rx, ry, x0, y0) {
    var a = rx;
    var b = ry;
    if (a === 0 || b === 0) {
      return {
        x,
        y
      };
    }
    var relativeX = x0 - x;
    var relativeY = y0 - y;
    var px = Math.abs(relativeX);
    var py = Math.abs(relativeY);
    var squareA = a * a;
    var squareB = b * b;
    var t = Math.PI / 4;
    var nearestX;
    var nearestY;
    for (var i = 0; i < 4; i++) {
      nearestX = a * Math.cos(t);
      nearestY = b * Math.sin(t);
      var ex = (squareA - squareB) * Math.pow(Math.cos(t), 3) / a;
      var ey = (squareB - squareA) * Math.pow(Math.sin(t), 3) / b;
      var rx1 = nearestX - ex;
      var ry1 = nearestY - ey;
      var qx = px - ex;
      var qy = py - ey;
      var r = Math.hypot(ry1, rx1);
      var q = Math.hypot(qy, qx);
      var delta_c = r * Math.asin((rx1 * qy - ry1 * qx) / (r * q));
      var delta_t = delta_c / Math.sqrt(squareA + squareB - nearestX * nearestX - nearestY * nearestY);
      t += delta_t;
      t = Math.min(Math.PI / 2, Math.max(0, t));
    }
    return {
      x: x + copysign(nearestX, relativeX),
      y: y + copysign(nearestY, relativeY)
    };
  },
  pointDistance: function(x, y, rx, ry, x0, y0) {
    var nearestPoint2 = this.nearestPoint(x, y, rx, ry, x0, y0);
    return distance3(nearestPoint2.x, nearestPoint2.y, x0, y0);
  },
  pointAt: function(x, y, rx, ry, t) {
    var angle3 = 2 * Math.PI * t;
    return {
      x: x + rx * Math.cos(angle3),
      y: y + ry * Math.sin(angle3)
    };
  },
  tangentAngle: function(x, y, rx, ry, t) {
    var angle3 = 2 * Math.PI * t;
    var tangentAngle = Math.atan2(ry * Math.cos(angle3), -rx * Math.sin(angle3));
    return piMod(tangentAngle);
  }
};

// node_modules/@antv/g-math/esm/arc.js
function derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle3) {
  return -1 * rx * Math.cos(xRotation) * Math.sin(angle3) - ry * Math.sin(xRotation) * Math.cos(angle3);
}
function derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle3) {
  return -1 * rx * Math.sin(xRotation) * Math.sin(angle3) + ry * Math.cos(xRotation) * Math.cos(angle3);
}
function xExtrema(rx, ry, xRotation) {
  return Math.atan(-ry / rx * Math.tan(xRotation));
}
function yExtrema(rx, ry, xRotation) {
  return Math.atan(ry / (rx * Math.tan(xRotation)));
}
function xAt(cx, cy, rx, ry, xRotation, angle3) {
  return rx * Math.cos(xRotation) * Math.cos(angle3) - ry * Math.sin(xRotation) * Math.sin(angle3) + cx;
}
function yAt(cx, cy, rx, ry, xRotation, angle3) {
  return rx * Math.sin(xRotation) * Math.cos(angle3) + ry * Math.cos(xRotation) * Math.sin(angle3) + cy;
}
function getAngle(rx, ry, x0, y0) {
  var angle3 = Math.atan2(y0 * rx, x0 * ry);
  return (angle3 + Math.PI * 2) % (Math.PI * 2);
}
function getPoint(rx, ry, angle3) {
  return {
    x: rx * Math.cos(angle3),
    y: ry * Math.sin(angle3)
  };
}
function rotate3(x, y, angle3) {
  var cos2 = Math.cos(angle3);
  var sin2 = Math.sin(angle3);
  return [x * cos2 - y * sin2, x * sin2 + y * cos2];
}
var arc_default = {
  box: function(cx, cy, rx, ry, xRotation, startAngle, endAngle) {
    var xDim = xExtrema(rx, ry, xRotation);
    var minX = Infinity;
    var maxX = -Infinity;
    var xs = [startAngle, endAngle];
    for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {
      var xAngle = xDim + i;
      if (startAngle < endAngle) {
        if (startAngle < xAngle && xAngle < endAngle) {
          xs.push(xAngle);
        }
      } else {
        if (endAngle < xAngle && xAngle < startAngle) {
          xs.push(xAngle);
        }
      }
    }
    for (var i = 0; i < xs.length; i++) {
      var x = xAt(cx, cy, rx, ry, xRotation, xs[i]);
      if (x < minX) {
        minX = x;
      }
      if (x > maxX) {
        maxX = x;
      }
    }
    var yDim = yExtrema(rx, ry, xRotation);
    var minY = Infinity;
    var maxY = -Infinity;
    var ys = [startAngle, endAngle];
    for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {
      var yAngle = yDim + i;
      if (startAngle < endAngle) {
        if (startAngle < yAngle && yAngle < endAngle) {
          ys.push(yAngle);
        }
      } else {
        if (endAngle < yAngle && yAngle < startAngle) {
          ys.push(yAngle);
        }
      }
    }
    for (var i = 0; i < ys.length; i++) {
      var y = yAt(cx, cy, rx, ry, xRotation, ys[i]);
      if (y < minY) {
        minY = y;
      }
      if (y > maxY) {
        maxY = y;
      }
    }
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  },
  length: function(cx, cy, rx, ry, xRotation, startAngle, endAngle) {
  },
  nearestPoint: function(cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0) {
    var relativeVector = rotate3(x0 - cx, y0 - cy, -xRotation);
    var x1 = relativeVector[0], y1 = relativeVector[1];
    var relativePoint = ellipse_default.nearestPoint(0, 0, rx, ry, x1, y1);
    var angle3 = getAngle(rx, ry, relativePoint.x, relativePoint.y);
    if (angle3 < startAngle) {
      relativePoint = getPoint(rx, ry, startAngle);
    } else if (angle3 > endAngle) {
      relativePoint = getPoint(rx, ry, endAngle);
    }
    var vector = rotate3(relativePoint.x, relativePoint.y, xRotation);
    return {
      x: vector[0] + cx,
      y: vector[1] + cy
    };
  },
  pointDistance: function(cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0) {
    var nearestPoint2 = this.nearestPoint(cx, cy, rx, ry, x0, y0);
    return distance3(nearestPoint2.x, nearestPoint2.y, x0, y0);
  },
  pointAt: function(cx, cy, rx, ry, xRotation, startAngle, endAngle, t) {
    var angle3 = (endAngle - startAngle) * t + startAngle;
    return {
      x: xAt(cx, cy, rx, ry, xRotation, angle3),
      y: yAt(cx, cy, rx, ry, xRotation, angle3)
    };
  },
  tangentAngle: function(cx, cy, rx, ry, xRotation, startAngle, endAngle, t) {
    var angle3 = (endAngle - startAngle) * t + startAngle;
    var dx = derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle3);
    var dy = derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle3);
    return piMod(Math.atan2(dy, dx));
  }
};

// node_modules/@antv/g-math/esm/segments.js
function analyzePoints(points) {
  var totalLength = 0;
  var segments = [];
  for (var i = 0; i < points.length - 1; i++) {
    var from = points[i];
    var to = points[i + 1];
    var length_1 = distance3(from[0], from[1], to[0], to[1]);
    var seg = {
      from,
      to,
      length: length_1
    };
    segments.push(seg);
    totalLength += length_1;
  }
  return { segments, totalLength };
}
function lengthOfSegment(points) {
  if (points.length < 2) {
    return 0;
  }
  var totalLength = 0;
  for (var i = 0; i < points.length - 1; i++) {
    var from = points[i];
    var to = points[i + 1];
    totalLength += distance3(from[0], from[1], to[0], to[1]);
  }
  return totalLength;
}
function pointAtSegments(points, t) {
  if (t > 1 || t < 0 || points.length < 2) {
    return null;
  }
  var _a3 = analyzePoints(points), segments = _a3.segments, totalLength = _a3.totalLength;
  if (totalLength === 0) {
    return {
      x: points[0][0],
      y: points[0][1]
    };
  }
  var startRatio = 0;
  var point = null;
  for (var i = 0; i < segments.length; i++) {
    var seg = segments[i];
    var from = seg.from, to = seg.to;
    var currentRatio = seg.length / totalLength;
    if (t >= startRatio && t <= startRatio + currentRatio) {
      var localRatio = (t - startRatio) / currentRatio;
      point = line_default.pointAt(from[0], from[1], to[0], to[1], localRatio);
      break;
    }
    startRatio += currentRatio;
  }
  return point;
}
function angleAtSegments(points, t) {
  if (t > 1 || t < 0 || points.length < 2) {
    return 0;
  }
  var _a3 = analyzePoints(points), segments = _a3.segments, totalLength = _a3.totalLength;
  var startRatio = 0;
  var angle3 = 0;
  for (var i = 0; i < segments.length; i++) {
    var seg = segments[i];
    var from = seg.from, to = seg.to;
    var currentRatio = seg.length / totalLength;
    if (t >= startRatio && t <= startRatio + currentRatio) {
      angle3 = Math.atan2(to[1] - from[1], to[0] - from[0]);
      break;
    }
    startRatio += currentRatio;
  }
  return angle3;
}
function distanceAtSegment(points, x, y) {
  var minDistance = Infinity;
  for (var i = 0; i < points.length - 1; i++) {
    var point = points[i];
    var nextPoint = points[i + 1];
    var distance_1 = line_default.pointDistance(point[0], point[1], nextPoint[0], nextPoint[1], x, y);
    if (distance_1 < minDistance) {
      minDistance = distance_1;
    }
  }
  return minDistance;
}

// node_modules/@antv/g-math/esm/polyline.js
var polyline_default = {
  box: function(points) {
    var xArr = [];
    var yArr = [];
    for (var i = 0; i < points.length; i++) {
      var point = points[i];
      xArr.push(point[0]);
      yArr.push(point[1]);
    }
    return getBBoxByArray(xArr, yArr);
  },
  length: function(points) {
    return lengthOfSegment(points);
  },
  pointAt: function(points, t) {
    return pointAtSegments(points, t);
  },
  pointDistance: function(points, x, y) {
    return distanceAtSegment(points, x, y);
  },
  tangentAngle: function(points, t) {
    return angleAtSegments(points, t);
  }
};

// node_modules/@antv/g-base/esm/bbox/util.js
function mergeBBox(bbox1, bbox2) {
  if (!bbox1 || !bbox2) {
    return bbox1 || bbox2;
  }
  return {
    minX: Math.min(bbox1.minX, bbox2.minX),
    minY: Math.min(bbox1.minY, bbox2.minY),
    maxX: Math.max(bbox1.maxX, bbox2.maxX),
    maxY: Math.max(bbox1.maxY, bbox2.maxY)
  };
}
function mergeArrowBBox(shape, bbox) {
  var startArrowShape = shape.get("startArrowShape");
  var endArrowShape = shape.get("endArrowShape");
  var startArrowBBox = null;
  var endArrowBBox = null;
  if (startArrowShape) {
    startArrowBBox = startArrowShape.getCanvasBBox();
    bbox = mergeBBox(bbox, startArrowBBox);
  }
  if (endArrowShape) {
    endArrowBBox = endArrowShape.getCanvasBBox();
    bbox = mergeBBox(bbox, endArrowBBox);
  }
  return bbox;
}

// node_modules/@antv/g-base/esm/bbox/polyline.js
function polyline_default2(shape) {
  var attrs = shape.attr();
  var points = attrs.points;
  var xArr = [];
  var yArr = [];
  for (var i = 0; i < points.length; i++) {
    var point = points[i];
    xArr.push(point[0]);
    yArr.push(point[1]);
  }
  var _a3 = util_exports.getBBoxByArray(xArr, yArr), x = _a3.x, y = _a3.y, width = _a3.width, height = _a3.height;
  var bbox = {
    minX: x,
    minY: y,
    maxX: x + width,
    maxY: y + height
  };
  bbox = mergeArrowBBox(shape, bbox);
  return {
    x: bbox.minX,
    y: bbox.minY,
    width: bbox.maxX - bbox.minX,
    height: bbox.maxY - bbox.minY
  };
}

// node_modules/@antv/g-base/esm/bbox/polygon.js
function polygon_default2(shape) {
  var attrs = shape.attr();
  var points = attrs.points;
  var xArr = [];
  var yArr = [];
  for (var i = 0; i < points.length; i++) {
    var point = points[i];
    xArr.push(point[0]);
    yArr.push(point[1]);
  }
  return util_exports.getBBoxByArray(xArr, yArr);
}

// node_modules/@antv/g-base/esm/util/offscreen.js
var offScreenCtx = null;
function getOffScreenContext() {
  if (!offScreenCtx) {
    var canvas = document.createElement("canvas");
    canvas.width = 1;
    canvas.height = 1;
    offScreenCtx = canvas.getContext("2d");
  }
  return offScreenCtx;
}

// node_modules/@antv/g-base/esm/util/text.js
function getTextHeight(text, fontSize, lineHeight) {
  var lineCount = 1;
  if (is_string_default(text)) {
    lineCount = text.split("\n").length;
  }
  if (lineCount > 1) {
    var spaceingY = getLineSpaceing(fontSize, lineHeight);
    return fontSize * lineCount + spaceingY * (lineCount - 1);
  }
  return fontSize;
}
function getLineSpaceing(fontSize, lineHeight) {
  return lineHeight ? lineHeight - fontSize : fontSize * 0.14;
}
function getTextWidth(text, font) {
  var context = getOffScreenContext();
  var width = 0;
  if (is_nil_default(text) || text === "") {
    return width;
  }
  context.save();
  context.font = font;
  if (is_string_default(text) && text.includes("\n")) {
    var textArr = text.split("\n");
    each_default(textArr, function(subText) {
      var measureWidth = context.measureText(subText).width;
      if (width < measureWidth) {
        width = measureWidth;
      }
    });
  } else {
    width = context.measureText(text).width;
  }
  context.restore();
  return width;
}
function assembleFont(attrs) {
  var fontSize = attrs.fontSize, fontFamily = attrs.fontFamily, fontWeight = attrs.fontWeight, fontStyle = attrs.fontStyle, fontVariant = attrs.fontVariant;
  return [fontStyle, fontVariant, fontWeight, fontSize + "px", fontFamily].join(" ").trim();
}

// node_modules/@antv/g-base/esm/bbox/text.js
function text_default(shape) {
  var attrs = shape.attr();
  var x = attrs.x, y = attrs.y, text = attrs.text, fontSize = attrs.fontSize, lineHeight = attrs.lineHeight;
  var font = attrs.font;
  if (!font) {
    font = assembleFont(attrs);
  }
  var width = getTextWidth(text, font);
  var bbox;
  if (!width) {
    bbox = {
      x,
      y,
      width: 0,
      height: 0
    };
  } else {
    var textAlign = attrs.textAlign, textBaseline = attrs.textBaseline;
    var height = getTextHeight(text, fontSize, lineHeight);
    var point = {
      x,
      y: y - height
    };
    if (textAlign) {
      if (textAlign === "end" || textAlign === "right") {
        point.x -= width;
      } else if (textAlign === "center") {
        point.x -= width / 2;
      }
    }
    if (textBaseline) {
      if (textBaseline === "top") {
        point.y += height;
      } else if (textBaseline === "middle") {
        point.y += height / 2;
      }
    }
    bbox = {
      x: point.x,
      y: point.y,
      width,
      height
    };
  }
  return bbox;
}

// node_modules/@antv/path-util/esm/parse-path.js
var regexTags = /[MLHVQTCSAZ]([^MLHVQTCSAZ]*)/ig;
var regexDot = /[^\s\,]+/ig;
function parsePath(p) {
  var path = p || [];
  if (is_array_default(path)) {
    return path;
  }
  if (is_string_default(path)) {
    path = path.match(regexTags);
    each_default(path, function(item, index) {
      item = item.match(regexDot);
      if (item[0].length > 1) {
        var tag = item[0].charAt(0);
        item.splice(1, 0, item[0].substr(1));
        item[0] = tag;
      }
      each_default(item, function(sub4, i) {
        if (!isNaN(sub4)) {
          item[i] = +sub4;
        }
      });
      path[index] = item;
    });
    return path;
  }
}
var parse_path_default = parsePath;

// node_modules/@antv/path-util/esm/catmull-rom-2-bezier.js
function smoothBezier(points, smooth, isLoop, constraint) {
  var cps = [];
  var hasConstraint = !!constraint;
  var prevPoint;
  var nextPoint;
  var min3;
  var max3;
  var nextCp0;
  var cp1;
  var cp0;
  if (hasConstraint) {
    min3 = constraint[0], max3 = constraint[1];
    for (var i = 0, l = points.length; i < l; i += 1) {
      var point = points[i];
      min3 = vec2_exports.min([0, 0], min3, point);
      max3 = vec2_exports.max([0, 0], max3, point);
    }
  }
  for (var i = 0, len3 = points.length; i < len3; i += 1) {
    var point = points[i];
    if (i === 0 && !isLoop) {
      cp0 = point;
    } else if (i === len3 - 1 && !isLoop) {
      cp1 = point;
      cps.push(cp0);
      cps.push(cp1);
    } else {
      var prevIdx = [i ? i - 1 : len3 - 1, i - 1][isLoop ? 0 : 1];
      prevPoint = points[prevIdx];
      nextPoint = points[isLoop ? (i + 1) % len3 : i + 1];
      var v = [0, 0];
      v = vec2_exports.sub(v, nextPoint, prevPoint);
      v = vec2_exports.scale(v, v, smooth);
      var d0 = vec2_exports.distance(point, prevPoint);
      var d1 = vec2_exports.distance(point, nextPoint);
      var sum = d0 + d1;
      if (sum !== 0) {
        d0 /= sum;
        d1 /= sum;
      }
      var v1 = vec2_exports.scale([0, 0], v, -d0);
      var v2 = vec2_exports.scale([0, 0], v, d1);
      cp1 = vec2_exports.add([0, 0], point, v1);
      nextCp0 = vec2_exports.add([0, 0], point, v2);
      nextCp0 = vec2_exports.min([0, 0], nextCp0, vec2_exports.max([0, 0], nextPoint, point));
      nextCp0 = vec2_exports.max([0, 0], nextCp0, vec2_exports.min([0, 0], nextPoint, point));
      v1 = vec2_exports.sub([0, 0], nextCp0, point);
      v1 = vec2_exports.scale([0, 0], v1, -d0 / d1);
      cp1 = vec2_exports.add([0, 0], point, v1);
      cp1 = vec2_exports.min([0, 0], cp1, vec2_exports.max([0, 0], prevPoint, point));
      cp1 = vec2_exports.max([0, 0], cp1, vec2_exports.min([0, 0], prevPoint, point));
      v2 = vec2_exports.sub([0, 0], point, cp1);
      v2 = vec2_exports.scale([0, 0], v2, d1 / d0);
      nextCp0 = vec2_exports.add([0, 0], point, v2);
      if (hasConstraint) {
        cp1 = vec2_exports.max([0, 0], cp1, min3);
        cp1 = vec2_exports.min([0, 0], cp1, max3);
        nextCp0 = vec2_exports.max([0, 0], nextCp0, min3);
        nextCp0 = vec2_exports.min([0, 0], nextCp0, max3);
      }
      cps.push(cp0);
      cps.push(cp1);
      cp0 = nextCp0;
    }
  }
  if (isLoop) {
    cps.push(cps.shift());
  }
  return cps;
}
function catmullRom2Bezier(crp, z, constraint) {
  if (z === void 0) {
    z = false;
  }
  if (constraint === void 0) {
    constraint = [
      [0, 0],
      [1, 1]
    ];
  }
  var isLoop = !!z;
  var pointList = [];
  for (var i = 0, l = crp.length; i < l; i += 2) {
    pointList.push([crp[i], crp[i + 1]]);
  }
  var controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);
  var len3 = pointList.length;
  var d1 = [];
  var cp1;
  var cp2;
  var p;
  for (var i = 0; i < len3 - 1; i += 1) {
    cp1 = controlPointList[i * 2];
    cp2 = controlPointList[i * 2 + 1];
    p = pointList[i + 1];
    d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);
  }
  if (isLoop) {
    cp1 = controlPointList[len3];
    cp2 = controlPointList[len3 + 1];
    p = pointList[0];
    d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);
  }
  return d1;
}
var catmull_rom_2_bezier_default = catmullRom2Bezier;

// node_modules/@antv/path-util/esm/parse-path-string.js
var SPACES2 = "	\n\v\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029";
var PATH_COMMAND2 = new RegExp("([a-z])[" + SPACES2 + ",]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[" + SPACES2 + "]*,?[" + SPACES2 + "]*)+)", "ig");
var PATH_VALUES2 = new RegExp("(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[" + SPACES2 + "]*,?[" + SPACES2 + "]*", "ig");
function parsePathString2(pathString) {
  if (!pathString) {
    return null;
  }
  if (is_array_default(pathString)) {
    return pathString;
  }
  var paramCounts = {
    a: 7,
    c: 6,
    o: 2,
    h: 1,
    l: 2,
    m: 2,
    r: 4,
    q: 4,
    s: 4,
    t: 2,
    v: 1,
    u: 3,
    z: 0
  };
  var data = [];
  String(pathString).replace(PATH_COMMAND2, function(a, b, c) {
    var params = [];
    var name = b.toLowerCase();
    c.replace(PATH_VALUES2, function(a2, b10) {
      b10 && params.push(+b10);
    });
    if (name === "m" && params.length > 2) {
      data.push([b].concat(params.splice(0, 2)));
      name = "l";
      b = b === "m" ? "l" : "L";
    }
    if (name === "o" && params.length === 1) {
      data.push([b, params[0]]);
    }
    if (name === "r") {
      data.push([b].concat(params));
    } else {
      while (params.length >= paramCounts[name]) {
        data.push([b].concat(params.splice(0, paramCounts[name])));
        if (!paramCounts[name]) {
          break;
        }
      }
    }
    return "";
  });
  return data;
}

// node_modules/@antv/path-util/esm/path-2-absolute.js
var REGEX_MD = /[a-z]/;
function toSymmetry(p, c) {
  return [
    c[0] + (c[0] - p[0]),
    c[1] + (c[1] - p[1])
  ];
}
function pathToAbsolute2(pathString) {
  var pathArray = parsePathString2(pathString);
  if (!pathArray || !pathArray.length) {
    return [
      ["M", 0, 0]
    ];
  }
  var needProcess = false;
  for (var i = 0; i < pathArray.length; i++) {
    var cmd = pathArray[i][0];
    if (REGEX_MD.test(cmd) || ["V", "H", "T", "S"].indexOf(cmd) >= 0) {
      needProcess = true;
      break;
    }
  }
  if (!needProcess) {
    return pathArray;
  }
  var res = [];
  var x = 0;
  var y = 0;
  var mx = 0;
  var my = 0;
  var start = 0;
  var pa0;
  var dots;
  var first = pathArray[0];
  if (first[0] === "M" || first[0] === "m") {
    x = +first[1];
    y = +first[2];
    mx = x;
    my = y;
    start++;
    res[0] = ["M", x, y];
  }
  for (var i = start, ii = pathArray.length; i < ii; i++) {
    var pa = pathArray[i];
    var preParams = res[i - 1];
    var r = [];
    var cmd = pa[0];
    var upCmd = cmd.toUpperCase();
    if (cmd !== upCmd) {
      r[0] = upCmd;
      switch (upCmd) {
        case "A":
          r[1] = pa[1];
          r[2] = pa[2];
          r[3] = pa[3];
          r[4] = pa[4];
          r[5] = pa[5];
          r[6] = +pa[6] + x;
          r[7] = +pa[7] + y;
          break;
        case "V":
          r[1] = +pa[1] + y;
          break;
        case "H":
          r[1] = +pa[1] + x;
          break;
        case "M":
          mx = +pa[1] + x;
          my = +pa[2] + y;
          r[1] = mx;
          r[2] = my;
          break;
        default:
          for (var j = 1, jj = pa.length; j < jj; j++) {
            r[j] = +pa[j] + (j % 2 ? x : y);
          }
      }
    } else {
      r = pathArray[i];
    }
    switch (upCmd) {
      case "Z":
        x = +mx;
        y = +my;
        break;
      case "H":
        x = r[1];
        r = ["L", x, y];
        break;
      case "V":
        y = r[1];
        r = ["L", x, y];
        break;
      case "T":
        x = r[1];
        y = r[2];
        var symetricT = toSymmetry([preParams[1], preParams[2]], [preParams[3], preParams[4]]);
        r = ["Q", symetricT[0], symetricT[1], x, y];
        break;
      case "S":
        x = r[r.length - 2];
        y = r[r.length - 1];
        var length_1 = preParams.length;
        var symetricS = toSymmetry([preParams[length_1 - 4], preParams[length_1 - 3]], [preParams[length_1 - 2], preParams[length_1 - 1]]);
        r = ["C", symetricS[0], symetricS[1], r[1], r[2], x, y];
        break;
      case "M":
        mx = r[r.length - 2];
        my = r[r.length - 1];
        break;
      default:
        x = r[r.length - 2];
        y = r[r.length - 1];
    }
    res.push(r);
  }
  return res;
}

// node_modules/@antv/path-util/esm/process/arc-2-cubic.js
var TAU = Math.PI * 2;

// node_modules/@antv/path-util/esm/get-arc-params.js
function vMag(v) {
  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
}
function vRatio(u, v) {
  return vMag(u) * vMag(v) ? (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v)) : 1;
}
function vAngle(u, v) {
  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
}
function isSamePoint(point1, point2) {
  return point1[0] === point2[0] && point1[1] === point2[1];
}
function getArcParams(startPoint, params) {
  var rx = params[1];
  var ry = params[2];
  var xRotation = mod_default(to_radian_default(params[3]), Math.PI * 2);
  var arcFlag = params[4];
  var sweepFlag = params[5];
  var x1 = startPoint[0];
  var y1 = startPoint[1];
  var x2 = params[6];
  var y2 = params[7];
  var xp = Math.cos(xRotation) * (x1 - x2) / 2 + Math.sin(xRotation) * (y1 - y2) / 2;
  var yp = -1 * Math.sin(xRotation) * (x1 - x2) / 2 + Math.cos(xRotation) * (y1 - y2) / 2;
  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  var diff2 = rx * rx * (yp * yp) + ry * ry * (xp * xp);
  var f = diff2 ? Math.sqrt((rx * rx * (ry * ry) - diff2) / diff2) : 1;
  if (arcFlag === sweepFlag) {
    f *= -1;
  }
  if (isNaN(f)) {
    f = 0;
  }
  var cxp = ry ? f * rx * yp / ry : 0;
  var cyp = rx ? f * -ry * xp / rx : 0;
  var cx = (x1 + x2) / 2 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;
  var cy = (y1 + y2) / 2 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;
  var u = [(xp - cxp) / rx, (yp - cyp) / ry];
  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
  var theta = vAngle([1, 0], u);
  var dTheta = vAngle(u, v);
  if (vRatio(u, v) <= -1) {
    dTheta = Math.PI;
  }
  if (vRatio(u, v) >= 1) {
    dTheta = 0;
  }
  if (sweepFlag === 0 && dTheta > 0) {
    dTheta = dTheta - 2 * Math.PI;
  }
  if (sweepFlag === 1 && dTheta < 0) {
    dTheta = dTheta + 2 * Math.PI;
  }
  return {
    cx,
    cy,
    rx: isSamePoint(startPoint, [x2, y2]) ? 0 : rx,
    ry: isSamePoint(startPoint, [x2, y2]) ? 0 : ry,
    startAngle: theta,
    endAngle: theta + dTheta,
    xRotation,
    arcFlag,
    sweepFlag
  };
}

// node_modules/@antv/path-util/esm/path-2-segments.js
function toSymmetry2(point, center) {
  return [center[0] + (center[0] - point[0]), center[1] + (center[1] - point[1])];
}
function getSegments(path) {
  path = parse_path_default(path);
  var segments = [];
  var currentPoint = null;
  var nextParams = null;
  var startMovePoint = null;
  var lastStartMovePointIndex = 0;
  var count = path.length;
  for (var i = 0; i < count; i++) {
    var params = path[i];
    nextParams = path[i + 1];
    var command = params[0];
    var segment = {
      command,
      prePoint: currentPoint,
      params,
      startTangent: null,
      endTangent: null
    };
    switch (command) {
      case "M":
        startMovePoint = [params[1], params[2]];
        lastStartMovePointIndex = i;
        break;
      case "A":
        var arcParams = getArcParams(currentPoint, params);
        segment["arcParams"] = arcParams;
        break;
      default:
        break;
    }
    if (command === "Z") {
      currentPoint = startMovePoint;
      nextParams = path[lastStartMovePointIndex + 1];
    } else {
      var len3 = params.length;
      currentPoint = [params[len3 - 2], params[len3 - 1]];
    }
    if (nextParams && nextParams[0] === "Z") {
      nextParams = path[lastStartMovePointIndex];
      if (segments[lastStartMovePointIndex]) {
        segments[lastStartMovePointIndex].prePoint = currentPoint;
      }
    }
    segment["currentPoint"] = currentPoint;
    if (segments[lastStartMovePointIndex] && isSamePoint(currentPoint, segments[lastStartMovePointIndex].currentPoint)) {
      segments[lastStartMovePointIndex].prePoint = segment.prePoint;
    }
    var nextPoint = nextParams ? [nextParams[nextParams.length - 2], nextParams[nextParams.length - 1]] : null;
    segment["nextPoint"] = nextPoint;
    var prePoint = segment.prePoint;
    if (["L", "H", "V"].includes(command)) {
      segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
      segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
    } else if (command === "Q") {
      var cp = [params[1], params[2]];
      segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];
      segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];
    } else if (command === "T") {
      var preSegment = segments[i - 1];
      var cp = toSymmetry2(preSegment.currentPoint, prePoint);
      if (preSegment.command === "Q") {
        segment.command = "Q";
        segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];
        segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];
      } else {
        segment.command = "TL";
        segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
        segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
      }
    } else if (command === "C") {
      var cp1 = [params[1], params[2]];
      var cp2 = [params[3], params[4]];
      segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];
      segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
      if (segment.startTangent[0] === 0 && segment.startTangent[1] === 0) {
        segment.startTangent = [cp1[0] - cp2[0], cp1[1] - cp2[1]];
      }
      if (segment.endTangent[0] === 0 && segment.endTangent[1] === 0) {
        segment.endTangent = [cp2[0] - cp1[0], cp2[1] - cp1[1]];
      }
    } else if (command === "S") {
      var preSegment = segments[i - 1];
      var cp1 = toSymmetry2(preSegment.currentPoint, prePoint);
      var cp2 = [params[1], params[2]];
      if (preSegment.command === "C") {
        segment.command = "C";
        segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];
        segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
      } else {
        segment.command = "SQ";
        segment.startTangent = [prePoint[0] - cp2[0], prePoint[1] - cp2[1]];
        segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
      }
    } else if (command === "A") {
      var d = 1e-3;
      var _a3 = segment["arcParams"] || {}, _b = _a3.cx, cx = _b === void 0 ? 0 : _b, _c = _a3.cy, cy = _c === void 0 ? 0 : _c, _d = _a3.rx, rx = _d === void 0 ? 0 : _d, _e = _a3.ry, ry = _e === void 0 ? 0 : _e, _f = _a3.sweepFlag, sweepFlag = _f === void 0 ? 0 : _f, _g = _a3.startAngle, startAngle = _g === void 0 ? 0 : _g, _h = _a3.endAngle, endAngle = _h === void 0 ? 0 : _h;
      if (sweepFlag === 0) {
        d *= -1;
      }
      var dx1 = rx * Math.cos(startAngle - d) + cx;
      var dy1 = ry * Math.sin(startAngle - d) + cy;
      segment.startTangent = [dx1 - startMovePoint[0], dy1 - startMovePoint[1]];
      var dx2 = rx * Math.cos(startAngle + endAngle + d) + cx;
      var dy2 = ry * Math.sin(startAngle + endAngle - d) + cy;
      segment.endTangent = [prePoint[0] - dx2, prePoint[1] - dy2];
    }
    segments.push(segment);
  }
  return segments;
}

// node_modules/@antv/path-util/esm/get-line-intersect.js
var isBetween = function(value, min3, max3) {
  return value >= min3 && value <= max3;
};
function getLineIntersect(p0, p1, p2, p3) {
  var tolerance3 = 1e-3;
  var E2 = {
    x: p2.x - p0.x,
    y: p2.y - p0.y
  };
  var D0 = {
    x: p1.x - p0.x,
    y: p1.y - p0.y
  };
  var D1 = {
    x: p3.x - p2.x,
    y: p3.y - p2.y
  };
  var kross = D0.x * D1.y - D0.y * D1.x;
  var sqrKross = kross * kross;
  var sqrLen0 = D0.x * D0.x + D0.y * D0.y;
  var sqrLen1 = D1.x * D1.x + D1.y * D1.y;
  var point = null;
  if (sqrKross > tolerance3 * sqrLen0 * sqrLen1) {
    var s = (E2.x * D1.y - E2.y * D1.x) / kross;
    var t = (E2.x * D0.y - E2.y * D0.x) / kross;
    if (isBetween(s, 0, 1) && isBetween(t, 0, 1)) {
      point = {
        x: p0.x + s * D0.x,
        y: p0.y + s * D0.y
      };
    }
  }
  return point;
}

// node_modules/@antv/path-util/esm/point-in-polygon.js
var tolerance = 1e-6;
function dcmp(x) {
  if (Math.abs(x) < tolerance) {
    return 0;
  }
  return x < 0 ? -1 : 1;
}
function onSegment(p1, p2, q) {
  if ((q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q[0] && q[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q[1] && q[1] <= Math.max(p1[1], p2[1])) {
    return true;
  }
  return false;
}
function isInPolygon(points, x, y) {
  var isHit = false;
  var n = points.length;
  if (n <= 2) {
    return false;
  }
  for (var i = 0; i < n; i++) {
    var p1 = points[i];
    var p2 = points[(i + 1) % n];
    if (onSegment(p1, p2, [x, y])) {
      return true;
    }
    if (dcmp(p1[1] - y) > 0 !== dcmp(p2[1] - y) > 0 && dcmp(x - (y - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) {
      isHit = !isHit;
    }
  }
  return isHit;
}

// node_modules/@antv/path-util/esm/is-polygons-intersect.js
function parseToLines(points) {
  var lines = [];
  var count = points.length;
  for (var i = 0; i < count - 1; i++) {
    var point = points[i];
    var next = points[i + 1];
    lines.push({
      from: {
        x: point[0],
        y: point[1]
      },
      to: {
        x: next[0],
        y: next[1]
      }
    });
  }
  if (lines.length > 1) {
    var first = points[0];
    var last2 = points[count - 1];
    lines.push({
      from: {
        x: last2[0],
        y: last2[1]
      },
      to: {
        x: first[0],
        y: first[1]
      }
    });
  }
  return lines;
}
function lineIntersectPolygon(lines, line) {
  var isIntersect = false;
  each_default(lines, function(l) {
    if (getLineIntersect(l.from, l.to, line.from, line.to)) {
      isIntersect = true;
      return false;
    }
  });
  return isIntersect;
}
function getBBox(points) {
  var xArr = points.map(function(p) {
    return p[0];
  });
  var yArr = points.map(function(p) {
    return p[1];
  });
  return {
    minX: Math.min.apply(null, xArr),
    maxX: Math.max.apply(null, xArr),
    minY: Math.min.apply(null, yArr),
    maxY: Math.max.apply(null, yArr)
  };
}
function intersectBBox(box1, box2) {
  return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);
}
function isPolygonsIntersect(points1, points2) {
  if (points1.length < 2 || points2.length < 2) {
    return false;
  }
  var bbox1 = getBBox(points1);
  var bbox2 = getBBox(points2);
  if (!intersectBBox(bbox1, bbox2)) {
    return false;
  }
  var isIn = false;
  each_default(points2, function(point) {
    if (isInPolygon(points1, point[0], point[1])) {
      isIn = true;
      return false;
    }
  });
  if (isIn) {
    return true;
  }
  each_default(points1, function(point) {
    if (isInPolygon(points2, point[0], point[1])) {
      isIn = true;
      return false;
    }
  });
  if (isIn) {
    return true;
  }
  var lines1 = parseToLines(points1);
  var lines2 = parseToLines(points2);
  var isIntersect = false;
  each_default(lines2, function(line) {
    if (lineIntersectPolygon(lines1, line)) {
      isIntersect = true;
      return false;
    }
  });
  return isIntersect;
}

// node_modules/@antv/g-base/esm/bbox/path.js
function getPathBox(segments, lineWidth) {
  var xArr = [];
  var yArr = [];
  var segmentsWithAngle = [];
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint;
    var box2 = void 0;
    switch (segment.command) {
      case "Q":
        box2 = quadratic_default.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4]);
        break;
      case "C":
        box2 = cubic_default.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6]);
        break;
      case "A":
        var arcParams = segment.arcParams;
        box2 = arc_default.box(arcParams.cx, arcParams.cy, arcParams.rx, arcParams.ry, arcParams.xRotation, arcParams.startAngle, arcParams.endAngle);
        break;
      default:
        xArr.push(currentPoint[0]);
        yArr.push(currentPoint[1]);
        break;
    }
    if (box2) {
      segment.box = box2;
      xArr.push(box2.x, box2.x + box2.width);
      yArr.push(box2.y, box2.y + box2.height);
    }
    if (lineWidth && (segment.command === "L" || segment.command === "M") && segment.prePoint && segment.nextPoint) {
      segmentsWithAngle.push(segment);
    }
  }
  xArr = xArr.filter(function(item) {
    return !Number.isNaN(item) && item !== Infinity && item !== -Infinity;
  });
  yArr = yArr.filter(function(item) {
    return !Number.isNaN(item) && item !== Infinity && item !== -Infinity;
  });
  var minX = min_default(xArr);
  var minY = min_default(yArr);
  var maxX = max_default(xArr);
  var maxY = max_default(yArr);
  if (segmentsWithAngle.length === 0) {
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
  for (var i = 0; i < segmentsWithAngle.length; i++) {
    var segment = segmentsWithAngle[i];
    var currentPoint = segment.currentPoint;
    var extra = void 0;
    if (currentPoint[0] === minX) {
      extra = getExtraFromSegmentWithAngle(segment, lineWidth);
      minX = minX - extra.xExtra;
    } else if (currentPoint[0] === maxX) {
      extra = getExtraFromSegmentWithAngle(segment, lineWidth);
      maxX = maxX + extra.xExtra;
    }
    if (currentPoint[1] === minY) {
      extra = getExtraFromSegmentWithAngle(segment, lineWidth);
      minY = minY - extra.yExtra;
    } else if (currentPoint[1] === maxY) {
      extra = getExtraFromSegmentWithAngle(segment, lineWidth);
      maxY = maxY + extra.yExtra;
    }
  }
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function getExtraFromSegmentWithAngle(segment, lineWidth) {
  var prePoint = segment.prePoint, currentPoint = segment.currentPoint, nextPoint = segment.nextPoint;
  var currentAndPre = Math.pow(currentPoint[0] - prePoint[0], 2) + Math.pow(currentPoint[1] - prePoint[1], 2);
  var currentAndNext = Math.pow(currentPoint[0] - nextPoint[0], 2) + Math.pow(currentPoint[1] - nextPoint[1], 2);
  var preAndNext = Math.pow(prePoint[0] - nextPoint[0], 2) + Math.pow(prePoint[1] - nextPoint[1], 2);
  var currentAngle = Math.acos((currentAndPre + currentAndNext - preAndNext) / (2 * Math.sqrt(currentAndPre) * Math.sqrt(currentAndNext)));
  if (!currentAngle || Math.sin(currentAngle) === 0 || isNumberEqual(currentAngle, 0)) {
    return {
      xExtra: 0,
      yExtra: 0
    };
  }
  var xAngle = Math.abs(Math.atan2(nextPoint[1] - currentPoint[1], nextPoint[0] - currentPoint[0]));
  var yAngle = Math.abs(Math.atan2(nextPoint[0] - currentPoint[0], nextPoint[1] - currentPoint[1]));
  xAngle = xAngle > Math.PI / 2 ? Math.PI - xAngle : xAngle;
  yAngle = yAngle > Math.PI / 2 ? Math.PI - yAngle : yAngle;
  var extra = {
    xExtra: Math.cos(currentAngle / 2 - xAngle) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0,
    yExtra: Math.cos(yAngle - currentAngle / 2) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0
  };
  return extra;
}
function path_default(shape) {
  var attrs = shape.attr();
  var path = attrs.path, stroke = attrs.stroke;
  var lineWidth = stroke ? attrs.lineWidth : 0;
  var segments = shape.get("segments") || getSegments(path);
  var _a3 = getPathBox(segments, lineWidth), x = _a3.x, y = _a3.y, width = _a3.width, height = _a3.height;
  var bbox = {
    minX: x,
    minY: y,
    maxX: x + width,
    maxY: y + height
  };
  bbox = mergeArrowBBox(shape, bbox);
  return {
    x: bbox.minX,
    y: bbox.minY,
    width: bbox.maxX - bbox.minX,
    height: bbox.maxY - bbox.minY
  };
}

// node_modules/@antv/g-base/esm/bbox/line.js
function line_default2(shape) {
  var attrs = shape.attr();
  var x1 = attrs.x1, y1 = attrs.y1, x2 = attrs.x2, y2 = attrs.y2;
  var minX = Math.min(x1, x2);
  var maxX = Math.max(x1, x2);
  var minY = Math.min(y1, y2);
  var maxY = Math.max(y1, y2);
  var bbox = {
    minX,
    maxX,
    minY,
    maxY
  };
  bbox = mergeArrowBBox(shape, bbox);
  return {
    x: bbox.minX,
    y: bbox.minY,
    width: bbox.maxX - bbox.minX,
    height: bbox.maxY - bbox.minY
  };
}

// node_modules/@antv/g-base/esm/bbox/ellipse.js
function ellipse_default2(shape) {
  var attrs = shape.attr();
  var x = attrs.x, y = attrs.y, rx = attrs.rx, ry = attrs.ry;
  return {
    x: x - rx,
    y: y - ry,
    width: rx * 2,
    height: ry * 2
  };
}

// node_modules/@antv/g-base/esm/bbox/index.js
register("rect", rect_default);
register("image", rect_default);
register("circle", circle_default);
register("marker", circle_default);
register("polyline", polyline_default2);
register("polygon", polygon_default2);
register("text", text_default);
register("path", path_default);
register("line", line_default2);
register("ellipse", ellipse_default2);

// node_modules/@antv/adjust/esm/constant.js
var DEFAULT_Y = 0;
var MARGIN_RATIO = 1 / 2;
var DODGE_RATIO = 1 / 2;
var GAP = 0.05;

// node_modules/@antv/adjust/esm/adjusts/adjust.js
var Adjust = function() {
  function Adjust2(cfg) {
    var xField = cfg.xField, yField = cfg.yField, _a3 = cfg.adjustNames, adjustNames = _a3 === void 0 ? ["x", "y"] : _a3, dimValuesMap = cfg.dimValuesMap;
    this.adjustNames = adjustNames;
    this.xField = xField;
    this.yField = yField;
    this.dimValuesMap = dimValuesMap;
  }
  Adjust2.prototype.isAdjust = function(dim) {
    return this.adjustNames.indexOf(dim) >= 0;
  };
  Adjust2.prototype.getAdjustRange = function(dim, dimValue, values2) {
    var yField = this.yField;
    var index = values2.indexOf(dimValue);
    var length5 = values2.length;
    var pre;
    var next;
    if (!yField && this.isAdjust("y")) {
      pre = 0;
      next = 1;
    } else if (length5 > 1) {
      pre = values2[index === 0 ? 0 : index - 1];
      next = values2[index === length5 - 1 ? length5 - 1 : index + 1];
      if (index !== 0) {
        pre += (dimValue - pre) / 2;
      } else {
        pre -= (next - dimValue) / 2;
      }
      if (index !== length5 - 1) {
        next -= (next - dimValue) / 2;
      } else {
        next += (dimValue - values2[length5 - 2]) / 2;
      }
    } else {
      pre = dimValue === 0 ? 0 : dimValue - 0.5;
      next = dimValue === 0 ? 1 : dimValue + 0.5;
    }
    return {
      pre,
      next
    };
  };
  Adjust2.prototype.adjustData = function(groupedDataArray, mergedData) {
    var _this = this;
    var dimValuesMap = this.getDimValues(mergedData);
    each_default(groupedDataArray, function(dataArray, index) {
      each_default(dimValuesMap, function(values2, dim) {
        _this.adjustDim(dim, values2, dataArray, index);
      });
    });
  };
  Adjust2.prototype.groupData = function(data, dim) {
    each_default(data, function(record) {
      if (record[dim] === void 0) {
        record[dim] = DEFAULT_Y;
      }
    });
    return group_by_default(data, dim);
  };
  Adjust2.prototype.adjustDim = function(dim, values2, data, index) {
  };
  Adjust2.prototype.getDimValues = function(mergedData) {
    var _a3 = this, xField = _a3.xField, yField = _a3.yField;
    var dimValuesMap = mix({}, this.dimValuesMap);
    var dims = [];
    if (xField && this.isAdjust("x")) {
      dims.push(xField);
    }
    if (yField && this.isAdjust("y")) {
      dims.push(yField);
    }
    dims.forEach(function(dim2) {
      if (dimValuesMap && dimValuesMap[dim2]) {
        return;
      }
      dimValuesMap[dim2] = values_of_key_default(mergedData, dim2).sort(function(v1, v2) {
        return v1 - v2;
      });
    });
    if (!yField && this.isAdjust("y")) {
      var dim = "y";
      dimValuesMap[dim] = [DEFAULT_Y, 1];
    }
    return dimValuesMap;
  };
  return Adjust2;
}();
var adjust_default = Adjust;

// node_modules/@antv/adjust/esm/factory.js
var ADJUST_MAP = {};
var getAdjust = function(type) {
  return ADJUST_MAP[type.toLowerCase()];
};
var registerAdjust = function(type, ctor) {
  if (getAdjust(type)) {
    throw new Error("Adjust type '" + type + "' existed.");
  }
  ADJUST_MAP[type.toLowerCase()] = ctor;
};

// node_modules/@antv/adjust/node_modules/tslib/tslib.es6.js
var extendStatics2 = function(d, b) {
  extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b10) {
    d2.__proto__ = b10;
  } || function(d2, b10) {
    for (var p in b10)
      if (b10.hasOwnProperty(p))
        d2[p] = b10[p];
  };
  return extendStatics2(d, b);
};
function __extends2(d, b) {
  extendStatics2(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign2 = function() {
  __assign2 = Object.assign || function __assign3(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};

// node_modules/@antv/adjust/esm/adjusts/dodge.js
var Dodge = function(_super) {
  __extends2(Dodge2, _super);
  function Dodge2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.cacheMap = {};
    _this.adjustDataArray = [];
    _this.mergeData = [];
    var _a3 = cfg.marginRatio, marginRatio = _a3 === void 0 ? MARGIN_RATIO : _a3, _b = cfg.dodgeRatio, dodgeRatio = _b === void 0 ? DODGE_RATIO : _b, dodgeBy = cfg.dodgeBy, intervalPadding = cfg.intervalPadding, dodgePadding = cfg.dodgePadding, xDimensionLength = cfg.xDimensionLength, groupNum = cfg.groupNum, defaultSize = cfg.defaultSize, maxColumnWidth = cfg.maxColumnWidth, minColumnWidth = cfg.minColumnWidth, columnWidthRatio = cfg.columnWidthRatio, customOffset = cfg.customOffset;
    _this.marginRatio = marginRatio;
    _this.dodgeRatio = dodgeRatio;
    _this.dodgeBy = dodgeBy;
    _this.intervalPadding = intervalPadding;
    _this.dodgePadding = dodgePadding;
    _this.xDimensionLegenth = xDimensionLength;
    _this.groupNum = groupNum;
    _this.defaultSize = defaultSize;
    _this.maxColumnWidth = maxColumnWidth;
    _this.minColumnWidth = minColumnWidth;
    _this.columnWidthRatio = columnWidthRatio;
    _this.customOffset = customOffset;
    return _this;
  }
  Dodge2.prototype.process = function(groupDataArray) {
    var groupedDataArray = clone_default(groupDataArray);
    var mergeData = flatten_default(groupedDataArray);
    var dodgeBy = this.dodgeBy;
    var adjustDataArray = dodgeBy ? group_default(mergeData, dodgeBy) : groupedDataArray;
    this.cacheMap = {};
    this.adjustDataArray = adjustDataArray;
    this.mergeData = mergeData;
    this.adjustData(adjustDataArray, mergeData);
    this.adjustDataArray = [];
    this.mergeData = [];
    return groupedDataArray;
  };
  Dodge2.prototype.adjustDim = function(dim, values2, data, frameIndex) {
    var _this = this;
    var customOffset = this.customOffset;
    var map4 = this.getDistribution(dim);
    var groupData = this.groupData(data, dim);
    each_default(groupData, function(group2, key) {
      var range;
      if (values2.length === 1) {
        range = {
          pre: values2[0] - 1,
          next: values2[0] + 1
        };
      } else {
        range = _this.getAdjustRange(dim, parseFloat(key), values2);
      }
      each_default(group2, function(d) {
        var value = d[dim];
        var valueArr = map4[value];
        var valIndex = valueArr.indexOf(frameIndex);
        if (!is_nil_default(customOffset)) {
          var pre = range.pre, next = range.next;
          d[dim] = is_function_default(customOffset) ? customOffset(d, range) : (pre + next) / 2 + customOffset;
        } else {
          d[dim] = _this.getDodgeOffset(range, valIndex, valueArr.length);
        }
      });
    });
    return [];
  };
  Dodge2.prototype.getDodgeOffset = function(range, idx, len3) {
    var _a3 = this, dodgeRatio = _a3.dodgeRatio, marginRatio = _a3.marginRatio, intervalPadding = _a3.intervalPadding, dodgePadding = _a3.dodgePadding;
    var pre = range.pre, next = range.next;
    var tickLength = next - pre;
    var position;
    if (!is_nil_default(intervalPadding) && is_nil_default(dodgePadding) && intervalPadding >= 0) {
      var offset = this.getIntervalOnlyOffset(len3, idx);
      position = pre + offset;
    } else if (!is_nil_default(dodgePadding) && is_nil_default(intervalPadding) && dodgePadding >= 0) {
      var offset = this.getDodgeOnlyOffset(len3, idx);
      position = pre + offset;
    } else if (!is_nil_default(intervalPadding) && !is_nil_default(dodgePadding) && intervalPadding >= 0 && dodgePadding >= 0) {
      var offset = this.getIntervalAndDodgeOffset(len3, idx);
      position = pre + offset;
    } else {
      var width = tickLength * dodgeRatio / len3;
      var margin = marginRatio * width;
      var offset = 1 / 2 * (tickLength - len3 * width - (len3 - 1) * margin) + ((idx + 1) * width + idx * margin) - 1 / 2 * width - 1 / 2 * tickLength;
      position = (pre + next) / 2 + offset;
    }
    return position;
  };
  Dodge2.prototype.getIntervalOnlyOffset = function(len3, idx) {
    var _a3 = this, defaultSize = _a3.defaultSize, intervalPadding = _a3.intervalPadding, xDimensionLegenth = _a3.xDimensionLegenth, groupNum = _a3.groupNum, dodgeRatio = _a3.dodgeRatio, maxColumnWidth = _a3.maxColumnWidth, minColumnWidth = _a3.minColumnWidth, columnWidthRatio = _a3.columnWidthRatio;
    var normalizedIntervalPadding = intervalPadding / xDimensionLegenth;
    var normalizedDodgePadding = (1 - (groupNum - 1) * normalizedIntervalPadding) / groupNum * dodgeRatio / (len3 - 1);
    var geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len3 - 1)) / len3;
    geomWidth = !is_nil_default(columnWidthRatio) ? 1 / groupNum / len3 * columnWidthRatio : geomWidth;
    if (!is_nil_default(maxColumnWidth)) {
      var normalizedMaxWidht = maxColumnWidth / xDimensionLegenth;
      geomWidth = Math.min(geomWidth, normalizedMaxWidht);
    }
    if (!is_nil_default(minColumnWidth)) {
      var normalizedMinWidht = minColumnWidth / xDimensionLegenth;
      geomWidth = Math.max(geomWidth, normalizedMinWidht);
    }
    geomWidth = defaultSize ? defaultSize / xDimensionLegenth : geomWidth;
    normalizedDodgePadding = ((1 - (groupNum - 1) * normalizedIntervalPadding) / groupNum - len3 * geomWidth) / (len3 - 1);
    var offset = ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding + 1 / 2 * normalizedIntervalPadding) * groupNum - normalizedIntervalPadding / 2;
    return offset;
  };
  Dodge2.prototype.getDodgeOnlyOffset = function(len3, idx) {
    var _a3 = this, defaultSize = _a3.defaultSize, dodgePadding = _a3.dodgePadding, xDimensionLegenth = _a3.xDimensionLegenth, groupNum = _a3.groupNum, marginRatio = _a3.marginRatio, maxColumnWidth = _a3.maxColumnWidth, minColumnWidth = _a3.minColumnWidth, columnWidthRatio = _a3.columnWidthRatio;
    var normalizedDodgePadding = dodgePadding / xDimensionLegenth;
    var normalizedIntervalPadding = 1 * marginRatio / (groupNum - 1);
    var geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len3 - 1)) / len3;
    geomWidth = columnWidthRatio ? 1 / groupNum / len3 * columnWidthRatio : geomWidth;
    if (!is_nil_default(maxColumnWidth)) {
      var normalizedMaxWidht = maxColumnWidth / xDimensionLegenth;
      geomWidth = Math.min(geomWidth, normalizedMaxWidht);
    }
    if (!is_nil_default(minColumnWidth)) {
      var normalizedMinWidht = minColumnWidth / xDimensionLegenth;
      geomWidth = Math.max(geomWidth, normalizedMinWidht);
    }
    geomWidth = defaultSize ? defaultSize / xDimensionLegenth : geomWidth;
    normalizedIntervalPadding = (1 - (geomWidth * len3 + normalizedDodgePadding * (len3 - 1)) * groupNum) / (groupNum - 1);
    var offset = ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding + 1 / 2 * normalizedIntervalPadding) * groupNum - normalizedIntervalPadding / 2;
    return offset;
  };
  Dodge2.prototype.getIntervalAndDodgeOffset = function(len3, idx) {
    var _a3 = this, intervalPadding = _a3.intervalPadding, dodgePadding = _a3.dodgePadding, xDimensionLegenth = _a3.xDimensionLegenth, groupNum = _a3.groupNum;
    var normalizedIntervalPadding = intervalPadding / xDimensionLegenth;
    var normalizedDodgePadding = dodgePadding / xDimensionLegenth;
    var geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len3 - 1)) / len3;
    var offset = ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding + 1 / 2 * normalizedIntervalPadding) * groupNum - normalizedIntervalPadding / 2;
    return offset;
  };
  Dodge2.prototype.getDistribution = function(dim) {
    var groupedDataArray = this.adjustDataArray;
    var cacheMap = this.cacheMap;
    var map4 = cacheMap[dim];
    if (!map4) {
      map4 = {};
      each_default(groupedDataArray, function(data, index) {
        var values2 = values_of_key_default(data, dim);
        if (!values2.length) {
          values2.push(0);
        }
        each_default(values2, function(val) {
          if (!map4[val]) {
            map4[val] = [];
          }
          map4[val].push(index);
        });
      });
      cacheMap[dim] = map4;
    }
    return map4;
  };
  return Dodge2;
}(adjust_default);
var dodge_default = Dodge;

// node_modules/@antv/adjust/esm/adjusts/jitter.js
function randomNumber(min3, max3) {
  return (max3 - min3) * Math.random() + min3;
}
var Jitter = function(_super) {
  __extends2(Jitter2, _super);
  function Jitter2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Jitter2.prototype.process = function(groupDataArray) {
    var groupedDataArray = clone_default(groupDataArray);
    var mergeData = flatten_default(groupedDataArray);
    this.adjustData(groupedDataArray, mergeData);
    return groupedDataArray;
  };
  Jitter2.prototype.adjustDim = function(dim, values2, dataArray) {
    var _this = this;
    var groupDataArray = this.groupData(dataArray, dim);
    return each_default(groupDataArray, function(data, dimValue) {
      return _this.adjustGroup(data, dim, parseFloat(dimValue), values2);
    });
  };
  Jitter2.prototype.getAdjustOffset = function(range) {
    var pre = range.pre, next = range.next;
    var margin = (next - pre) * GAP;
    return randomNumber(pre + margin, next - margin);
  };
  Jitter2.prototype.adjustGroup = function(group2, dim, dimValue, values2) {
    var _this = this;
    var range = this.getAdjustRange(dim, dimValue, values2);
    each_default(group2, function(data) {
      data[dim] = _this.getAdjustOffset(range);
    });
    return group2;
  };
  return Jitter2;
}(adjust_default);
var jitter_default = Jitter;

// node_modules/@antv/adjust/esm/adjusts/stack.js
var Cache = cache_default;
var Stack = function(_super) {
  __extends2(Stack2, _super);
  function Stack2(cfg) {
    var _this = _super.call(this, cfg) || this;
    var _a3 = cfg.adjustNames, adjustNames = _a3 === void 0 ? ["y"] : _a3, _b = cfg.height, height = _b === void 0 ? NaN : _b, _c = cfg.size, size2 = _c === void 0 ? 10 : _c, _d = cfg.reverseOrder, reverseOrder = _d === void 0 ? false : _d;
    _this.adjustNames = adjustNames;
    _this.height = height;
    _this.size = size2;
    _this.reverseOrder = reverseOrder;
    return _this;
  }
  Stack2.prototype.process = function(groupDataArray) {
    var _a3 = this, yField = _a3.yField, reverseOrder = _a3.reverseOrder;
    var d = yField ? this.processStack(groupDataArray) : this.processOneDimStack(groupDataArray);
    return reverseOrder ? this.reverse(d) : d;
  };
  Stack2.prototype.reverse = function(groupedDataArray) {
    return groupedDataArray.slice(0).reverse();
  };
  Stack2.prototype.processStack = function(groupDataArray) {
    var _a3 = this, xField = _a3.xField, yField = _a3.yField, reverseOrder = _a3.reverseOrder;
    var groupedDataArray = reverseOrder ? this.reverse(groupDataArray) : groupDataArray;
    var positive = new Cache();
    var negative = new Cache();
    return groupedDataArray.map(function(dataArray) {
      return dataArray.map(function(data) {
        var _a4;
        var x = get_default(data, xField, 0);
        var y = get_default(data, [yField]);
        var xKey = x.toString();
        y = is_array_default(y) ? y[1] : y;
        if (!is_nil_default(y)) {
          var cache3 = y >= 0 ? positive : negative;
          if (!cache3.has(xKey)) {
            cache3.set(xKey, 0);
          }
          var xValue = cache3.get(xKey);
          var newXValue = y + xValue;
          cache3.set(xKey, newXValue);
          return __assign2(__assign2({}, data), (_a4 = {}, _a4[yField] = [xValue, newXValue], _a4));
        }
        return data;
      });
    });
  };
  Stack2.prototype.processOneDimStack = function(groupDataArray) {
    var _this = this;
    var _a3 = this, xField = _a3.xField, height = _a3.height, reverseOrder = _a3.reverseOrder;
    var yField = "y";
    var groupedDataArray = reverseOrder ? this.reverse(groupDataArray) : groupDataArray;
    var cache3 = new Cache();
    return groupedDataArray.map(function(dataArray) {
      return dataArray.map(function(data) {
        var _a4;
        var size2 = _this.size;
        var xValue = data[xField];
        var stackHeight = size2 * 2 / height;
        if (!cache3.has(xValue)) {
          cache3.set(xValue, stackHeight / 2);
        }
        var stackValue = cache3.get(xValue);
        cache3.set(xValue, stackValue + stackHeight);
        return __assign2(__assign2({}, data), (_a4 = {}, _a4[yField] = stackValue, _a4));
      });
    });
  };
  return Stack2;
}(adjust_default);
var stack_default = Stack;

// node_modules/@antv/adjust/esm/adjusts/symmetric.js
var Symmetric = function(_super) {
  __extends2(Symmetric2, _super);
  function Symmetric2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Symmetric2.prototype.process = function(groupDataArray) {
    var mergeData = flatten_default(groupDataArray);
    var _a3 = this, xField = _a3.xField, yField = _a3.yField;
    var cache3 = this.getXValuesMaxMap(mergeData);
    var max3 = Math.max.apply(Math, Object.keys(cache3).map(function(key) {
      return cache3[key];
    }));
    return map_default(groupDataArray, function(dataArray) {
      return map_default(dataArray, function(data) {
        var _a4, _b;
        var yValue = data[yField];
        var xValue = data[xField];
        if (is_array_default(yValue)) {
          var off_1 = (max3 - cache3[xValue]) / 2;
          return __assign2(__assign2({}, data), (_a4 = {}, _a4[yField] = map_default(yValue, function(y) {
            return off_1 + y;
          }), _a4));
        }
        var offset = (max3 - yValue) / 2;
        return __assign2(__assign2({}, data), (_b = {}, _b[yField] = [offset, yValue + offset], _b));
      });
    });
  };
  Symmetric2.prototype.getXValuesMaxMap = function(mergeData) {
    var _this = this;
    var _a3 = this, xField = _a3.xField, yField = _a3.yField;
    var groupDataArray = group_by_default(mergeData, function(data) {
      return data[xField];
    });
    return map_values_default(groupDataArray, function(dataArray) {
      return _this.getDimMaxValue(dataArray, yField);
    });
  };
  Symmetric2.prototype.getDimMaxValue = function(mergeData, dim) {
    var dimValues = map_default(mergeData, function(data) {
      return get_default(data, dim, []);
    });
    var flattenValues = flatten_default(dimValues);
    return Math.max.apply(Math, flattenValues);
  };
  return Symmetric2;
}(adjust_default);
var symmetric_default = Symmetric;

// node_modules/@antv/adjust/esm/index.js
registerAdjust("Dodge", dodge_default);
registerAdjust("Jitter", jitter_default);
registerAdjust("Stack", stack_default);
registerAdjust("Symmetric", symmetric_default);

// node_modules/@antv/attr/esm/attributes/base.js
var toScaleString = function(scale5, value) {
  if (is_string_default(value)) {
    return value;
  }
  return scale5.invert(scale5.scale(value));
};
var Attribute = function() {
  function Attribute2(cfg) {
    this.names = [];
    this.scales = [];
    this.linear = false;
    this.values = [];
    this.callback = function() {
      return [];
    };
    this._parseCfg(cfg);
  }
  Attribute2.prototype.mapping = function() {
    var _this = this;
    var params = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      params[_i] = arguments[_i];
    }
    var values2 = params.map(function(param, idx) {
      return _this._toOriginParam(param, _this.scales[idx]);
    });
    return this.callback.apply(this, values2);
  };
  Attribute2.prototype.getLinearValue = function(percent) {
    var steps = this.values.length - 1;
    var step = Math.floor(steps * percent);
    var leftPercent = steps * percent - step;
    var start = this.values[step];
    var end = step === steps ? start : this.values[step + 1];
    return start + (end - start) * leftPercent;
  };
  Attribute2.prototype.getNames = function() {
    var scales = this.scales;
    var names = this.names;
    var length5 = Math.min(scales.length, names.length);
    var rst = [];
    for (var i = 0; i < length5; i += 1) {
      rst.push(names[i]);
    }
    return rst;
  };
  Attribute2.prototype.getFields = function() {
    return this.scales.map(function(scale5) {
      return scale5.field;
    });
  };
  Attribute2.prototype.getScale = function(name) {
    return this.scales[this.names.indexOf(name)];
  };
  Attribute2.prototype.defaultCallback = function() {
    var _this = this;
    var params = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      params[_i] = arguments[_i];
    }
    if (params.length === 0) {
      return this.values;
    }
    return params.map(function(param, idx) {
      var scale5 = _this.scales[idx];
      return scale5.type === "identity" ? scale5.values[0] : _this._getAttributeValue(scale5, param);
    });
  };
  Attribute2.prototype._parseCfg = function(cfg) {
    var _this = this;
    var _a3 = cfg.type, type = _a3 === void 0 ? "base" : _a3, _b = cfg.names, names = _b === void 0 ? [] : _b, _c = cfg.scales, scales = _c === void 0 ? [] : _c, _d = cfg.values, values2 = _d === void 0 ? [] : _d, callback = cfg.callback;
    this.type = type;
    this.scales = scales;
    this.values = values2;
    this.names = names;
    this.callback = function() {
      var params = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        params[_i] = arguments[_i];
      }
      if (callback) {
        var ret = callback.apply(void 0, params);
        if (!is_nil_default(ret)) {
          return [ret];
        }
      }
      return _this.defaultCallback.apply(_this, params);
    };
  };
  Attribute2.prototype._getAttributeValue = function(scale5, value) {
    if (scale5.isCategory && !this.linear) {
      var idx = scale5.translate(value);
      return this.values[idx % this.values.length];
    }
    var percent = scale5.scale(value);
    return this.getLinearValue(percent);
  };
  Attribute2.prototype._toOriginParam = function(param, scale5) {
    return !scale5.isLinear ? is_array_default(param) ? param.map(function(p) {
      return toScaleString(scale5, p);
    }) : toScaleString(scale5, param) : param;
  };
  return Attribute2;
}();
var base_default3 = Attribute;

// node_modules/@antv/attr/node_modules/tslib/tslib.es6.js
var extendStatics3 = function(d, b) {
  extendStatics3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b10) {
    d2.__proto__ = b10;
  } || function(d2, b10) {
    for (var p in b10)
      if (b10.hasOwnProperty(p))
        d2[p] = b10[p];
  };
  return extendStatics3(d, b);
};
function __extends3(d, b) {
  extendStatics3(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

// node_modules/@antv/color-util/esm/index.js
var RGB_REG = /rgba?\(([\s.,0-9]+)\)/;
var regexLG = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
var regexRG = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
var regexColorStop = /[\d.]+:(#[^\s]+|[^\)]+\))/gi;
var isGradientColor2 = function(val) {
  return /^[r,R,L,l]{1}[\s]*\(/.test(val);
};
var createTmp = function() {
  var i = document.createElement("i");
  i.title = "Web Colour Picker";
  i.style.display = "none";
  document.body.appendChild(i);
  return i;
};
var getValue = function(start, end, percent, index) {
  return start[index] + (end[index] - start[index]) * percent;
};
function arr2rgb(arr) {
  return "#" + toHex(arr[0]) + toHex(arr[1]) + toHex(arr[2]);
}
var rgb2arr = function(str4) {
  return [
    parseInt(str4.substr(1, 2), 16),
    parseInt(str4.substr(3, 2), 16),
    parseInt(str4.substr(5, 2), 16)
  ];
};
var toHex = function(value) {
  var x16Value = Math.round(value).toString(16);
  return x16Value.length === 1 ? "0" + x16Value : x16Value;
};
var calColor = function(points, percent) {
  var fixedPercent = isNaN(Number(percent)) || percent < 0 ? 0 : percent > 1 ? 1 : Number(percent);
  var steps = points.length - 1;
  var step = Math.floor(steps * fixedPercent);
  var left = steps * fixedPercent - step;
  var start = points[step];
  var end = step === steps ? start : points[step + 1];
  return arr2rgb([
    getValue(start, end, left, 0),
    getValue(start, end, left, 1),
    getValue(start, end, left, 2)
  ]);
};
var iEl;
var toRGB = function(color2) {
  if (color2[0] === "#" && color2.length === 7) {
    return color2;
  }
  if (!iEl) {
    iEl = createTmp();
  }
  iEl.style.color = color2;
  var rst = document.defaultView.getComputedStyle(iEl, "").getPropertyValue("color");
  var matches = RGB_REG.exec(rst);
  var cArray = matches[1].split(/\s*,\s*/).map(function(s) {
    return Number(s);
  });
  rst = arr2rgb(cArray);
  return rst;
};
var gradient = function(colors) {
  var colorArray = is_string_default(colors) ? colors.split("-") : colors;
  var points = map_default(colorArray, function(color2) {
    return rgb2arr(color2.indexOf("#") === -1 ? toRGB(color2) : color2);
  });
  return function(percent) {
    return calColor(points, percent);
  };
};
var toCSSGradient = function(gradientColor) {
  if (isGradientColor2(gradientColor)) {
    var cssColor_1;
    var steps = void 0;
    if (gradientColor[0] === "l") {
      var arr = regexLG.exec(gradientColor);
      var angle3 = +arr[1] + 90;
      steps = arr[2];
      cssColor_1 = "linear-gradient(" + angle3 + "deg, ";
    } else if (gradientColor[0] === "r") {
      cssColor_1 = "radial-gradient(";
      var arr = regexRG.exec(gradientColor);
      steps = arr[4];
    }
    var colorStops_1 = steps.match(regexColorStop);
    each_default(colorStops_1, function(item, index) {
      var itemArr = item.split(":");
      cssColor_1 += itemArr[1] + " " + itemArr[0] * 100 + "%";
      if (index !== colorStops_1.length - 1) {
        cssColor_1 += ", ";
      }
    });
    cssColor_1 += ")";
    return cssColor_1;
  }
  return gradientColor;
};
var esm_default2 = {
  rgb2arr,
  gradient,
  toRGB: memoize_default(toRGB),
  toCSSGradient
};

// node_modules/@antv/attr/esm/attributes/color.js
var Color2 = function(_super) {
  __extends3(Color3, _super);
  function Color3(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.type = "color";
    _this.names = ["color"];
    if (is_string_default(_this.values)) {
      _this.linear = true;
    }
    _this.gradient = esm_default2.gradient(_this.values);
    return _this;
  }
  Color3.prototype.getLinearValue = function(percent) {
    return this.gradient(percent);
  };
  return Color3;
}(base_default3);
var color_default = Color2;

// node_modules/@antv/attr/esm/attributes/opacity.js
var Opacity = function(_super) {
  __extends3(Opacity2, _super);
  function Opacity2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.type = "opacity";
    _this.names = ["opacity"];
    return _this;
  }
  return Opacity2;
}(base_default3);
var opacity_default = Opacity;

// node_modules/@antv/attr/esm/attributes/position.js
var Position = function(_super) {
  __extends3(Position2, _super);
  function Position2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.names = ["x", "y"];
    _this.type = "position";
    return _this;
  }
  Position2.prototype.mapping = function(x, y) {
    var _a3 = this.scales, scaleX = _a3[0], scaleY = _a3[1];
    if (is_nil_default(x) || is_nil_default(y)) {
      return [];
    }
    return [
      is_array_default(x) ? x.map(function(xi) {
        return scaleX.scale(xi);
      }) : scaleX.scale(x),
      is_array_default(y) ? y.map(function(yi) {
        return scaleY.scale(yi);
      }) : scaleY.scale(y)
    ];
  };
  return Position2;
}(base_default3);
var position_default = Position;

// node_modules/@antv/attr/esm/attributes/shape.js
var Shape = function(_super) {
  __extends3(Shape2, _super);
  function Shape2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.type = "shape";
    _this.names = ["shape"];
    return _this;
  }
  Shape2.prototype.getLinearValue = function(percent) {
    var idx = Math.round((this.values.length - 1) * percent);
    return this.values[idx];
  };
  return Shape2;
}(base_default3);
var shape_default2 = Shape;

// node_modules/@antv/attr/esm/attributes/size.js
var Size = function(_super) {
  __extends3(Size2, _super);
  function Size2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.type = "size";
    _this.names = ["size"];
    return _this;
  }
  return Size2;
}(base_default3);
var size_default = Size;

// node_modules/@antv/scale/esm/tick-method/register.js
var methodCache = {};
function getTickMethod(key) {
  return methodCache[key];
}
function registerTickMethod(key, method) {
  methodCache[key] = method;
}

// node_modules/@antv/scale/esm/base.js
var Scale = function() {
  function Scale2(cfg) {
    this.type = "base";
    this.isCategory = false;
    this.isLinear = false;
    this.isContinuous = false;
    this.isIdentity = false;
    this.values = [];
    this.range = [0, 1];
    this.ticks = [];
    this.__cfg__ = cfg;
    this.initCfg();
    this.init();
  }
  Scale2.prototype.translate = function(v) {
    return v;
  };
  Scale2.prototype.change = function(cfg) {
    mix(this.__cfg__, cfg);
    this.init();
  };
  Scale2.prototype.clone = function() {
    return this.constructor(this.__cfg__);
  };
  Scale2.prototype.getTicks = function() {
    var _this = this;
    return map_default(this.ticks, function(tick, idx) {
      if (is_object_default(tick)) {
        return tick;
      }
      return {
        text: _this.getText(tick, idx),
        tickValue: tick,
        value: _this.scale(tick)
      };
    });
  };
  Scale2.prototype.getText = function(value, key) {
    var formatter = this.formatter;
    var res = formatter ? formatter(value, key) : value;
    if (is_nil_default(res) || !is_function_default(res.toString)) {
      return "";
    }
    return res.toString();
  };
  Scale2.prototype.getConfig = function(key) {
    return this.__cfg__[key];
  };
  Scale2.prototype.init = function() {
    mix(this, this.__cfg__);
    this.setDomain();
    if (is_empty_default(this.getConfig("ticks"))) {
      this.ticks = this.calculateTicks();
    }
  };
  Scale2.prototype.initCfg = function() {
  };
  Scale2.prototype.setDomain = function() {
  };
  Scale2.prototype.calculateTicks = function() {
    var tickMethod = this.tickMethod;
    var ticks = [];
    if (is_string_default(tickMethod)) {
      var method = getTickMethod(tickMethod);
      if (!method) {
        throw new Error("There is no method to to calculate ticks!");
      }
      ticks = method(this);
    } else if (is_function_default(tickMethod)) {
      ticks = tickMethod(this);
    }
    return ticks;
  };
  Scale2.prototype.rangeMin = function() {
    return this.range[0];
  };
  Scale2.prototype.rangeMax = function() {
    return this.range[1];
  };
  Scale2.prototype.calcPercent = function(value, min3, max3) {
    if (is_number_default(value)) {
      return (value - min3) / (max3 - min3);
    }
    return NaN;
  };
  Scale2.prototype.calcValue = function(percent, min3, max3) {
    return min3 + percent * (max3 - min3);
  };
  return Scale2;
}();
var base_default4 = Scale;

// node_modules/@antv/scale/esm/category/base.js
var Category = function(_super) {
  __extends(Category3, _super);
  function Category3() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "cat";
    _this.isCategory = true;
    return _this;
  }
  Category3.prototype.buildIndexMap = function() {
    if (!this.translateIndexMap) {
      this.translateIndexMap = /* @__PURE__ */ new Map();
      for (var i = 0; i < this.values.length; i++) {
        this.translateIndexMap.set(this.values[i], i);
      }
    }
  };
  Category3.prototype.translate = function(value) {
    this.buildIndexMap();
    var idx = this.translateIndexMap.get(value);
    if (idx === void 0) {
      idx = is_number_default(value) ? value : NaN;
    }
    return idx;
  };
  Category3.prototype.scale = function(value) {
    var order = this.translate(value);
    var percent = this.calcPercent(order, this.min, this.max);
    return this.calcValue(percent, this.rangeMin(), this.rangeMax());
  };
  Category3.prototype.invert = function(scaledValue) {
    var domainRange = this.max - this.min;
    var percent = this.calcPercent(scaledValue, this.rangeMin(), this.rangeMax());
    var idx = Math.round(domainRange * percent) + this.min;
    if (idx < this.min || idx > this.max) {
      return NaN;
    }
    return this.values[idx];
  };
  Category3.prototype.getText = function(value) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    var v = value;
    if (is_number_default(value) && !this.values.includes(value)) {
      v = this.values[v];
    }
    return _super.prototype.getText.apply(this, __spreadArrays([v], args));
  };
  Category3.prototype.initCfg = function() {
    this.tickMethod = "cat";
  };
  Category3.prototype.setDomain = function() {
    if (is_nil_default(this.getConfig("min"))) {
      this.min = 0;
    }
    if (is_nil_default(this.getConfig("max"))) {
      var size2 = this.values.length;
      this.max = size2 > 1 ? size2 - 1 : size2;
    }
    if (this.translateIndexMap) {
      this.translateIndexMap = void 0;
    }
  };
  return Category3;
}(base_default4);
var base_default5 = Category;

// node_modules/fecha/lib/fecha.js
var fecha_exports = {};
__export(fecha_exports, {
  assign: () => assign,
  default: () => fecha_default,
  defaultI18n: () => defaultI18n,
  format: () => format,
  parse: () => parse,
  setGlobalDateI18n: () => setGlobalDateI18n,
  setGlobalDateMasks: () => setGlobalDateMasks
});
var token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|Z|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
var twoDigitsOptional = "\\d\\d?";
var twoDigits = "\\d\\d";
var threeDigits = "\\d{3}";
var fourDigits = "\\d{4}";
var word = "[^\\s]+";
var literal = /\[([^]*?)\]/gm;
function shorten(arr, sLen) {
  var newArr = [];
  for (var i = 0, len3 = arr.length; i < len3; i++) {
    newArr.push(arr[i].substr(0, sLen));
  }
  return newArr;
}
var monthUpdate = function(arrName) {
  return function(v, i18n) {
    var lowerCaseArr = i18n[arrName].map(function(v2) {
      return v2.toLowerCase();
    });
    var index = lowerCaseArr.indexOf(v.toLowerCase());
    if (index > -1) {
      return index;
    }
    return null;
  };
};
function assign(origObj) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  for (var _a3 = 0, args_1 = args; _a3 < args_1.length; _a3++) {
    var obj = args_1[_a3];
    for (var key in obj) {
      origObj[key] = obj[key];
    }
  }
  return origObj;
}
var dayNames = [
  "Sunday",
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday"
];
var monthNames = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
];
var monthNamesShort = shorten(monthNames, 3);
var dayNamesShort = shorten(dayNames, 3);
var defaultI18n = {
  dayNamesShort,
  dayNames,
  monthNamesShort,
  monthNames,
  amPm: ["am", "pm"],
  DoFn: function(dayOfMonth) {
    return dayOfMonth + ["th", "st", "nd", "rd"][dayOfMonth % 10 > 3 ? 0 : (dayOfMonth - dayOfMonth % 10 !== 10 ? 1 : 0) * dayOfMonth % 10];
  }
};
var globalI18n = assign({}, defaultI18n);
var setGlobalDateI18n = function(i18n) {
  return globalI18n = assign(globalI18n, i18n);
};
var regexEscape = function(str4) {
  return str4.replace(/[|\\{()[^$+*?.-]/g, "\\$&");
};
var pad = function(val, len3) {
  if (len3 === void 0) {
    len3 = 2;
  }
  val = String(val);
  while (val.length < len3) {
    val = "0" + val;
  }
  return val;
};
var formatFlags = {
  D: function(dateObj) {
    return String(dateObj.getDate());
  },
  DD: function(dateObj) {
    return pad(dateObj.getDate());
  },
  Do: function(dateObj, i18n) {
    return i18n.DoFn(dateObj.getDate());
  },
  d: function(dateObj) {
    return String(dateObj.getDay());
  },
  dd: function(dateObj) {
    return pad(dateObj.getDay());
  },
  ddd: function(dateObj, i18n) {
    return i18n.dayNamesShort[dateObj.getDay()];
  },
  dddd: function(dateObj, i18n) {
    return i18n.dayNames[dateObj.getDay()];
  },
  M: function(dateObj) {
    return String(dateObj.getMonth() + 1);
  },
  MM: function(dateObj) {
    return pad(dateObj.getMonth() + 1);
  },
  MMM: function(dateObj, i18n) {
    return i18n.monthNamesShort[dateObj.getMonth()];
  },
  MMMM: function(dateObj, i18n) {
    return i18n.monthNames[dateObj.getMonth()];
  },
  YY: function(dateObj) {
    return pad(String(dateObj.getFullYear()), 4).substr(2);
  },
  YYYY: function(dateObj) {
    return pad(dateObj.getFullYear(), 4);
  },
  h: function(dateObj) {
    return String(dateObj.getHours() % 12 || 12);
  },
  hh: function(dateObj) {
    return pad(dateObj.getHours() % 12 || 12);
  },
  H: function(dateObj) {
    return String(dateObj.getHours());
  },
  HH: function(dateObj) {
    return pad(dateObj.getHours());
  },
  m: function(dateObj) {
    return String(dateObj.getMinutes());
  },
  mm: function(dateObj) {
    return pad(dateObj.getMinutes());
  },
  s: function(dateObj) {
    return String(dateObj.getSeconds());
  },
  ss: function(dateObj) {
    return pad(dateObj.getSeconds());
  },
  S: function(dateObj) {
    return String(Math.round(dateObj.getMilliseconds() / 100));
  },
  SS: function(dateObj) {
    return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
  },
  SSS: function(dateObj) {
    return pad(dateObj.getMilliseconds(), 3);
  },
  a: function(dateObj, i18n) {
    return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
  },
  A: function(dateObj, i18n) {
    return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();
  },
  ZZ: function(dateObj) {
    var offset = dateObj.getTimezoneOffset();
    return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60) * 100 + Math.abs(offset) % 60, 4);
  },
  Z: function(dateObj) {
    var offset = dateObj.getTimezoneOffset();
    return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60), 2) + ":" + pad(Math.abs(offset) % 60, 2);
  }
};
var monthParse = function(v) {
  return +v - 1;
};
var emptyDigits = [null, twoDigitsOptional];
var emptyWord = [null, word];
var amPm = [
  "isPm",
  word,
  function(v, i18n) {
    var val = v.toLowerCase();
    if (val === i18n.amPm[0]) {
      return 0;
    } else if (val === i18n.amPm[1]) {
      return 1;
    }
    return null;
  }
];
var timezoneOffset = [
  "timezoneOffset",
  "[^\\s]*?[\\+\\-]\\d\\d:?\\d\\d|[^\\s]*?Z?",
  function(v) {
    var parts = (v + "").match(/([+-]|\d\d)/gi);
    if (parts) {
      var minutes = +parts[1] * 60 + parseInt(parts[2], 10);
      return parts[0] === "+" ? minutes : -minutes;
    }
    return 0;
  }
];
var parseFlags = {
  D: ["day", twoDigitsOptional],
  DD: ["day", twoDigits],
  Do: ["day", twoDigitsOptional + word, function(v) {
    return parseInt(v, 10);
  }],
  M: ["month", twoDigitsOptional, monthParse],
  MM: ["month", twoDigits, monthParse],
  YY: [
    "year",
    twoDigits,
    function(v) {
      var now2 = new Date();
      var cent = +("" + now2.getFullYear()).substr(0, 2);
      return +("" + (+v > 68 ? cent - 1 : cent) + v);
    }
  ],
  h: ["hour", twoDigitsOptional, void 0, "isPm"],
  hh: ["hour", twoDigits, void 0, "isPm"],
  H: ["hour", twoDigitsOptional],
  HH: ["hour", twoDigits],
  m: ["minute", twoDigitsOptional],
  mm: ["minute", twoDigits],
  s: ["second", twoDigitsOptional],
  ss: ["second", twoDigits],
  YYYY: ["year", fourDigits],
  S: ["millisecond", "\\d", function(v) {
    return +v * 100;
  }],
  SS: ["millisecond", twoDigits, function(v) {
    return +v * 10;
  }],
  SSS: ["millisecond", threeDigits],
  d: emptyDigits,
  dd: emptyDigits,
  ddd: emptyWord,
  dddd: emptyWord,
  MMM: ["month", word, monthUpdate("monthNamesShort")],
  MMMM: ["month", word, monthUpdate("monthNames")],
  a: amPm,
  A: amPm,
  ZZ: timezoneOffset,
  Z: timezoneOffset
};
var globalMasks = {
  default: "ddd MMM DD YYYY HH:mm:ss",
  shortDate: "M/D/YY",
  mediumDate: "MMM D, YYYY",
  longDate: "MMMM D, YYYY",
  fullDate: "dddd, MMMM D, YYYY",
  isoDate: "YYYY-MM-DD",
  isoDateTime: "YYYY-MM-DDTHH:mm:ssZ",
  shortTime: "HH:mm",
  mediumTime: "HH:mm:ss",
  longTime: "HH:mm:ss.SSS"
};
var setGlobalDateMasks = function(masks) {
  return assign(globalMasks, masks);
};
var format = function(dateObj, mask, i18n) {
  if (mask === void 0) {
    mask = globalMasks["default"];
  }
  if (i18n === void 0) {
    i18n = {};
  }
  if (typeof dateObj === "number") {
    dateObj = new Date(dateObj);
  }
  if (Object.prototype.toString.call(dateObj) !== "[object Date]" || isNaN(dateObj.getTime())) {
    throw new Error("Invalid Date pass to format");
  }
  mask = globalMasks[mask] || mask;
  var literals = [];
  mask = mask.replace(literal, function($0, $1) {
    literals.push($1);
    return "@@@";
  });
  var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
  mask = mask.replace(token, function($0) {
    return formatFlags[$0](dateObj, combinedI18nSettings);
  });
  return mask.replace(/@@@/g, function() {
    return literals.shift();
  });
};
function parse(dateStr, format2, i18n) {
  if (i18n === void 0) {
    i18n = {};
  }
  if (typeof format2 !== "string") {
    throw new Error("Invalid format in fecha parse");
  }
  format2 = globalMasks[format2] || format2;
  if (dateStr.length > 1e3) {
    return null;
  }
  var today = new Date();
  var dateInfo = {
    year: today.getFullYear(),
    month: 0,
    day: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0,
    isPm: null,
    timezoneOffset: null
  };
  var parseInfo = [];
  var literals = [];
  var newFormat = format2.replace(literal, function($0, $1) {
    literals.push(regexEscape($1));
    return "@@@";
  });
  var specifiedFields = {};
  var requiredFields = {};
  newFormat = regexEscape(newFormat).replace(token, function($0) {
    var info = parseFlags[$0];
    var field2 = info[0], regex = info[1], requiredField = info[3];
    if (specifiedFields[field2]) {
      throw new Error("Invalid format. " + field2 + " specified twice in format");
    }
    specifiedFields[field2] = true;
    if (requiredField) {
      requiredFields[requiredField] = true;
    }
    parseInfo.push(info);
    return "(" + regex + ")";
  });
  Object.keys(requiredFields).forEach(function(field2) {
    if (!specifiedFields[field2]) {
      throw new Error("Invalid format. " + field2 + " is required in specified format");
    }
  });
  newFormat = newFormat.replace(/@@@/g, function() {
    return literals.shift();
  });
  var matches = dateStr.match(new RegExp(newFormat, "i"));
  if (!matches) {
    return null;
  }
  var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
  for (var i = 1; i < matches.length; i++) {
    var _a3 = parseInfo[i - 1], field = _a3[0], parser = _a3[2];
    var value = parser ? parser(matches[i], combinedI18nSettings) : +matches[i];
    if (value == null) {
      return null;
    }
    dateInfo[field] = value;
  }
  if (dateInfo.isPm === 1 && dateInfo.hour != null && +dateInfo.hour !== 12) {
    dateInfo.hour = +dateInfo.hour + 12;
  } else if (dateInfo.isPm === 0 && +dateInfo.hour === 12) {
    dateInfo.hour = 0;
  }
  var dateTZ;
  if (dateInfo.timezoneOffset == null) {
    dateTZ = new Date(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute, dateInfo.second, dateInfo.millisecond);
    var validateFields = [
      ["month", "getMonth"],
      ["day", "getDate"],
      ["hour", "getHours"],
      ["minute", "getMinutes"],
      ["second", "getSeconds"]
    ];
    for (var i = 0, len3 = validateFields.length; i < len3; i++) {
      if (specifiedFields[validateFields[i][0]] && dateInfo[validateFields[i][0]] !== dateTZ[validateFields[i][1]]()) {
        return null;
      }
    }
  } else {
    dateTZ = new Date(Date.UTC(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute - dateInfo.timezoneOffset, dateInfo.second, dateInfo.millisecond));
    if (dateInfo.month > 11 || dateInfo.month < 0 || dateInfo.day > 31 || dateInfo.day < 1 || dateInfo.hour > 23 || dateInfo.hour < 0 || dateInfo.minute > 59 || dateInfo.minute < 0 || dateInfo.second > 59 || dateInfo.second < 0) {
      return null;
    }
  }
  return dateTZ;
}
var fecha = {
  format,
  parse,
  defaultI18n,
  setGlobalDateI18n,
  setGlobalDateMasks
};
var fecha_default = fecha;

// node_modules/@antv/scale/esm/util/bisector.js
function bisector_default(getter) {
  return function(a, x, _lo, _hi) {
    var lo = is_nil_default(_lo) ? 0 : _lo;
    var hi = is_nil_default(_hi) ? a.length : _hi;
    while (lo < hi) {
      var mid2 = lo + hi >>> 1;
      if (getter(a[mid2]) > x) {
        hi = mid2;
      } else {
        lo = mid2 + 1;
      }
    }
    return lo;
  };
}

// node_modules/@antv/scale/esm/util/time.js
var FORMAT_METHOD = "format";
function timeFormat(time, mask) {
  var method = fecha_exports[FORMAT_METHOD] || fecha_default[FORMAT_METHOD];
  return method(time, mask);
}
function toTimeStamp(value) {
  if (is_string_default(value)) {
    if (value.indexOf("T") > 0) {
      value = new Date(value).getTime();
    } else {
      value = new Date(value.replace(/-/gi, "/")).getTime();
    }
  }
  if (is_date_default(value)) {
    value = value.getTime();
  }
  return value;
}
var SECOND = 1e3;
var MINUTE = 60 * SECOND;
var HOUR = 60 * MINUTE;
var DAY = 24 * HOUR;
var MONTH = DAY * 31;
var YEAR = DAY * 365;
var intervals = [
  ["HH:mm:ss", SECOND],
  ["HH:mm:ss", SECOND * 10],
  ["HH:mm:ss", SECOND * 30],
  ["HH:mm", MINUTE],
  ["HH:mm", MINUTE * 10],
  ["HH:mm", MINUTE * 30],
  ["HH", HOUR],
  ["HH", HOUR * 6],
  ["HH", HOUR * 12],
  ["YYYY-MM-DD", DAY],
  ["YYYY-MM-DD", DAY * 4],
  ["YYYY-WW", DAY * 7],
  ["YYYY-MM", MONTH],
  ["YYYY-MM", MONTH * 4],
  ["YYYY-MM", MONTH * 6],
  ["YYYY", DAY * 380]
];
function getTickInterval(min3, max3, tickCount) {
  var target = (max3 - min3) / tickCount;
  var idx = bisector_default(function(o) {
    return o[1];
  })(intervals, target) - 1;
  var interval2 = intervals[idx];
  if (idx < 0) {
    interval2 = intervals[0];
  } else if (idx >= intervals.length) {
    interval2 = last(intervals);
  }
  return interval2;
}

// node_modules/@antv/scale/esm/category/time.js
var TimeCat = function(_super) {
  __extends(TimeCat2, _super);
  function TimeCat2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "timeCat";
    return _this;
  }
  TimeCat2.prototype.translate = function(value) {
    value = toTimeStamp(value);
    var index = this.values.indexOf(value);
    if (index === -1) {
      if (is_number_default(value) && value < this.values.length) {
        index = value;
      } else {
        index = NaN;
      }
    }
    return index;
  };
  TimeCat2.prototype.getText = function(value, tickIndex) {
    var index = this.translate(value);
    if (index > -1) {
      var result = this.values[index];
      var formatter = this.formatter;
      result = formatter ? formatter(result, tickIndex) : timeFormat(result, this.mask);
      return result;
    }
    return value;
  };
  TimeCat2.prototype.initCfg = function() {
    this.tickMethod = "time-cat";
    this.mask = "YYYY-MM-DD";
    this.tickCount = 7;
  };
  TimeCat2.prototype.setDomain = function() {
    var values2 = this.values;
    each_default(values2, function(v, i) {
      values2[i] = toTimeStamp(v);
    });
    values2.sort(function(v1, v2) {
      return v1 - v2;
    });
    _super.prototype.setDomain.call(this);
  };
  return TimeCat2;
}(base_default5);
var time_default = TimeCat;

// node_modules/@antv/scale/esm/continuous/base.js
var Continuous = function(_super) {
  __extends(Continuous2, _super);
  function Continuous2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.isContinuous = true;
    return _this;
  }
  Continuous2.prototype.scale = function(value) {
    if (is_nil_default(value)) {
      return NaN;
    }
    var rangeMin = this.rangeMin();
    var rangeMax = this.rangeMax();
    var max3 = this.max;
    var min3 = this.min;
    if (max3 === min3) {
      return rangeMin;
    }
    var percent = this.getScalePercent(value);
    return rangeMin + percent * (rangeMax - rangeMin);
  };
  Continuous2.prototype.init = function() {
    _super.prototype.init.call(this);
    var ticks = this.ticks;
    var firstTick = head(ticks);
    var lastTick = last(ticks);
    if (firstTick < this.min) {
      this.min = firstTick;
    }
    if (lastTick > this.max) {
      this.max = lastTick;
    }
    if (!is_nil_default(this.minLimit)) {
      this.min = firstTick;
    }
    if (!is_nil_default(this.maxLimit)) {
      this.max = lastTick;
    }
  };
  Continuous2.prototype.setDomain = function() {
    var _a3 = get_range_default(this.values), min3 = _a3.min, max3 = _a3.max;
    if (is_nil_default(this.min)) {
      this.min = min3;
    }
    if (is_nil_default(this.max)) {
      this.max = max3;
    }
    if (this.min > this.max) {
      this.min = min3;
      this.max = max3;
    }
  };
  Continuous2.prototype.calculateTicks = function() {
    var _this = this;
    var ticks = _super.prototype.calculateTicks.call(this);
    if (!this.nice) {
      ticks = filter_default(ticks, function(tick) {
        return tick >= _this.min && tick <= _this.max;
      });
    }
    return ticks;
  };
  Continuous2.prototype.getScalePercent = function(value) {
    var max3 = this.max;
    var min3 = this.min;
    return (value - min3) / (max3 - min3);
  };
  Continuous2.prototype.getInvertPercent = function(value) {
    return (value - this.rangeMin()) / (this.rangeMax() - this.rangeMin());
  };
  return Continuous2;
}(base_default4);
var base_default6 = Continuous;

// node_modules/@antv/scale/esm/continuous/linear.js
var Linear = function(_super) {
  __extends(Linear2, _super);
  function Linear2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "linear";
    _this.isLinear = true;
    return _this;
  }
  Linear2.prototype.invert = function(value) {
    var percent = this.getInvertPercent(value);
    return this.min + percent * (this.max - this.min);
  };
  Linear2.prototype.initCfg = function() {
    this.tickMethod = "wilkinson-extended";
    this.nice = false;
  };
  return Linear2;
}(base_default6);
var linear_default = Linear;

// node_modules/@antv/scale/esm/util/math.js
function calBase(a, b) {
  var e = Math.E;
  var value;
  if (b >= 0) {
    value = Math.pow(e, Math.log(b) / a);
  } else {
    value = Math.pow(e, Math.log(-b) / a) * -1;
  }
  return value;
}
function log(a, b) {
  if (a === 1) {
    return 1;
  }
  return Math.log(b) / Math.log(a);
}
function getLogPositiveMin(values2, base, max3) {
  if (is_nil_default(max3)) {
    max3 = Math.max.apply(null, values2);
  }
  var positiveMin = max3;
  each_default(values2, function(value) {
    if (value > 0 && value < positiveMin) {
      positiveMin = value;
    }
  });
  if (positiveMin === max3) {
    positiveMin = max3 / base;
  }
  if (positiveMin > 1) {
    positiveMin = 1;
  }
  return positiveMin;
}

// node_modules/@antv/scale/esm/continuous/log.js
var Log = function(_super) {
  __extends(Log2, _super);
  function Log2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "log";
    return _this;
  }
  Log2.prototype.invert = function(value) {
    var base = this.base;
    var max3 = log(base, this.max);
    var rangeMin = this.rangeMin();
    var range = this.rangeMax() - rangeMin;
    var min3;
    var positiveMin = this.positiveMin;
    if (positiveMin) {
      if (value === 0) {
        return 0;
      }
      min3 = log(base, positiveMin / base);
      var appendPercent = 1 / (max3 - min3) * range;
      if (value < appendPercent) {
        return value / appendPercent * positiveMin;
      }
    } else {
      min3 = log(base, this.min);
    }
    var percent = (value - rangeMin) / range;
    var tmp = percent * (max3 - min3) + min3;
    return Math.pow(base, tmp);
  };
  Log2.prototype.initCfg = function() {
    this.tickMethod = "log";
    this.base = 10;
    this.tickCount = 6;
    this.nice = true;
  };
  Log2.prototype.setDomain = function() {
    _super.prototype.setDomain.call(this);
    var min3 = this.min;
    if (min3 < 0) {
      throw new Error("When you use log scale, the minimum value must be greater than zero!");
    }
    if (min3 === 0) {
      this.positiveMin = getLogPositiveMin(this.values, this.base, this.max);
    }
  };
  Log2.prototype.getScalePercent = function(value) {
    var max3 = this.max;
    var min3 = this.min;
    if (max3 === min3) {
      return 0;
    }
    if (value <= 0) {
      return 0;
    }
    var base = this.base;
    var positiveMin = this.positiveMin;
    if (positiveMin) {
      min3 = positiveMin * 1 / base;
    }
    var percent;
    if (value < positiveMin) {
      percent = value / positiveMin / (log(base, max3) - log(base, min3));
    } else {
      percent = (log(base, value) - log(base, min3)) / (log(base, max3) - log(base, min3));
    }
    return percent;
  };
  return Log2;
}(base_default6);
var log_default = Log;

// node_modules/@antv/scale/esm/continuous/pow.js
var Pow = function(_super) {
  __extends(Pow2, _super);
  function Pow2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "pow";
    return _this;
  }
  Pow2.prototype.invert = function(value) {
    var percent = this.getInvertPercent(value);
    var exponent2 = this.exponent;
    var max3 = calBase(exponent2, this.max);
    var min3 = calBase(exponent2, this.min);
    var tmp = percent * (max3 - min3) + min3;
    var factor = tmp >= 0 ? 1 : -1;
    return Math.pow(tmp, exponent2) * factor;
  };
  Pow2.prototype.initCfg = function() {
    this.tickMethod = "pow";
    this.exponent = 2;
    this.tickCount = 5;
    this.nice = true;
  };
  Pow2.prototype.getScalePercent = function(value) {
    var max3 = this.max;
    var min3 = this.min;
    if (max3 === min3) {
      return 0;
    }
    var exponent2 = this.exponent;
    var percent = (calBase(exponent2, value) - calBase(exponent2, min3)) / (calBase(exponent2, max3) - calBase(exponent2, min3));
    return percent;
  };
  return Pow2;
}(base_default6);
var pow_default = Pow;

// node_modules/@antv/scale/esm/continuous/time.js
var Time = function(_super) {
  __extends(Time2, _super);
  function Time2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "time";
    return _this;
  }
  Time2.prototype.getText = function(value, index) {
    var numberValue = this.translate(value);
    var formatter = this.formatter;
    return formatter ? formatter(numberValue, index) : timeFormat(numberValue, this.mask);
  };
  Time2.prototype.scale = function(value) {
    var v = value;
    if (is_string_default(v) || is_date_default(v)) {
      v = this.translate(v);
    }
    return _super.prototype.scale.call(this, v);
  };
  Time2.prototype.translate = function(v) {
    return toTimeStamp(v);
  };
  Time2.prototype.initCfg = function() {
    this.tickMethod = "time-pretty";
    this.mask = "YYYY-MM-DD";
    this.tickCount = 7;
    this.nice = false;
  };
  Time2.prototype.setDomain = function() {
    var values2 = this.values;
    var minConfig = this.getConfig("min");
    var maxConfig = this.getConfig("max");
    if (!is_nil_default(minConfig) || !is_number_default(minConfig)) {
      this.min = this.translate(this.min);
    }
    if (!is_nil_default(maxConfig) || !is_number_default(maxConfig)) {
      this.max = this.translate(this.max);
    }
    if (values2 && values2.length) {
      var timeStamps_1 = [];
      var min_1 = Infinity;
      var secondMin_1 = min_1;
      var max_1 = 0;
      each_default(values2, function(v) {
        var timeStamp = toTimeStamp(v);
        if (isNaN(timeStamp)) {
          throw new TypeError("Invalid Time: " + v + " in time scale!");
        }
        if (min_1 > timeStamp) {
          secondMin_1 = min_1;
          min_1 = timeStamp;
        } else if (secondMin_1 > timeStamp) {
          secondMin_1 = timeStamp;
        }
        if (max_1 < timeStamp) {
          max_1 = timeStamp;
        }
        timeStamps_1.push(timeStamp);
      });
      if (values2.length > 1) {
        this.minTickInterval = secondMin_1 - min_1;
      }
      if (is_nil_default(minConfig)) {
        this.min = min_1;
      }
      if (is_nil_default(maxConfig)) {
        this.max = max_1;
      }
    }
  };
  return Time2;
}(linear_default);
var time_default2 = Time;

// node_modules/@antv/scale/esm/continuous/quantize.js
var Quantize = function(_super) {
  __extends(Quantize2, _super);
  function Quantize2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "quantize";
    return _this;
  }
  Quantize2.prototype.invert = function(value) {
    var ticks = this.ticks;
    var length5 = ticks.length;
    var percent = this.getInvertPercent(value);
    var minIndex = Math.floor(percent * (length5 - 1));
    if (minIndex >= length5 - 1) {
      return last(ticks);
    }
    if (minIndex < 0) {
      return head(ticks);
    }
    var minTick = ticks[minIndex];
    var nextTick = ticks[minIndex + 1];
    var minIndexPercent = minIndex / (length5 - 1);
    var maxIndexPercent = (minIndex + 1) / (length5 - 1);
    return minTick + (percent - minIndexPercent) / (maxIndexPercent - minIndexPercent) * (nextTick - minTick);
  };
  Quantize2.prototype.initCfg = function() {
    this.tickMethod = "r-pretty";
    this.tickCount = 5;
    this.nice = true;
  };
  Quantize2.prototype.calculateTicks = function() {
    var ticks = _super.prototype.calculateTicks.call(this);
    if (!this.nice) {
      if (last(ticks) !== this.max) {
        ticks.push(this.max);
      }
      if (head(ticks) !== this.min) {
        ticks.unshift(this.min);
      }
    }
    return ticks;
  };
  Quantize2.prototype.getScalePercent = function(value) {
    var ticks = this.ticks;
    if (value < head(ticks)) {
      return 0;
    }
    if (value > last(ticks)) {
      return 1;
    }
    var minIndex = 0;
    each_default(ticks, function(tick, index) {
      if (value >= tick) {
        minIndex = index;
      } else {
        return false;
      }
    });
    return minIndex / (ticks.length - 1);
  };
  return Quantize2;
}(base_default6);
var quantize_default2 = Quantize;

// node_modules/@antv/scale/esm/continuous/quantile.js
var Quantile = function(_super) {
  __extends(Quantile2, _super);
  function Quantile2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "quantile";
    return _this;
  }
  Quantile2.prototype.initCfg = function() {
    this.tickMethod = "quantile";
    this.tickCount = 5;
    this.nice = true;
  };
  return Quantile2;
}(quantize_default2);
var quantile_default = Quantile;

// node_modules/@antv/scale/esm/factory.js
var map3 = {};
function getClass(key) {
  return map3[key];
}
function registerClass(key, cls) {
  if (getClass(key)) {
    throw new Error("type '" + key + "' existed.");
  }
  map3[key] = cls;
}

// node_modules/@antv/scale/esm/identity/index.js
var Identity = function(_super) {
  __extends(Identity2, _super);
  function Identity2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "identity";
    _this.isIdentity = true;
    return _this;
  }
  Identity2.prototype.calculateTicks = function() {
    return this.values;
  };
  Identity2.prototype.scale = function(value) {
    if (this.values[0] !== value && is_number_default(value)) {
      return value;
    }
    return this.range[0];
  };
  Identity2.prototype.invert = function(value) {
    var range = this.range;
    if (value < range[0] || value > range[1]) {
      return NaN;
    }
    return this.values[0];
  };
  return Identity2;
}(base_default4);
var identity_default2 = Identity;

// node_modules/@antv/scale/esm/tick-method/cat.js
function calculateCatTicks(cfg) {
  var values2 = cfg.values, tickInterval = cfg.tickInterval, tickCount = cfg.tickCount, showLast = cfg.showLast;
  if (is_number_default(tickInterval)) {
    var ticks_1 = filter_default(values2, function(__, i2) {
      return i2 % tickInterval === 0;
    });
    var lastValue = last(values2);
    if (showLast && last(ticks_1) !== lastValue) {
      ticks_1.push(lastValue);
    }
    return ticks_1;
  }
  var len3 = values2.length;
  var min3 = cfg.min, max3 = cfg.max;
  if (is_nil_default(min3)) {
    min3 = 0;
  }
  if (is_nil_default(max3)) {
    max3 = values2.length - 1;
  }
  if (!is_number_default(tickCount) || tickCount >= len3)
    return values2.slice(min3, max3 + 1);
  if (tickCount <= 0 || max3 <= 0)
    return [];
  var interval2 = tickCount === 1 ? len3 : Math.floor(len3 / (tickCount - 1));
  var ticks = [];
  var idx = min3;
  for (var i = 0; i < tickCount; i++) {
    if (idx >= max3)
      break;
    idx = Math.min(min3 + i * interval2, max3);
    if (i === tickCount - 1 && showLast)
      ticks.push(values2[max3]);
    else
      ticks.push(values2[idx]);
  }
  return ticks;
}

// node_modules/@antv/scale/esm/util/d3-linear.js
function d3Linear(cfg) {
  var min3 = cfg.min, max3 = cfg.max, nice = cfg.nice, tickCount = cfg.tickCount;
  var linear4 = new D3Linear();
  linear4.domain([min3, max3]);
  if (nice) {
    linear4.nice(tickCount);
  }
  return linear4.ticks(tickCount);
}
var DEFAULT_COUNT = 5;
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);
var D3Linear = function() {
  function D3Linear2() {
    this._domain = [0, 1];
  }
  D3Linear2.prototype.domain = function(domain) {
    if (domain) {
      this._domain = Array.from(domain, Number);
      return this;
    }
    return this._domain.slice();
  };
  D3Linear2.prototype.nice = function(count) {
    var _a3, _b;
    if (count === void 0) {
      count = DEFAULT_COUNT;
    }
    var d = this._domain.slice();
    var i0 = 0;
    var i1 = this._domain.length - 1;
    var start = this._domain[i0];
    var stop = this._domain[i1];
    var step;
    if (stop < start) {
      _a3 = [stop, start], start = _a3[0], stop = _a3[1];
      _b = [i1, i0], i0 = _b[0], i1 = _b[1];
    }
    step = tickIncrement(start, stop, count);
    if (step > 0) {
      start = Math.floor(start / step) * step;
      stop = Math.ceil(stop / step) * step;
      step = tickIncrement(start, stop, count);
    } else if (step < 0) {
      start = Math.ceil(start * step) / step;
      stop = Math.floor(stop * step) / step;
      step = tickIncrement(start, stop, count);
    }
    if (step > 0) {
      d[i0] = Math.floor(start / step) * step;
      d[i1] = Math.ceil(stop / step) * step;
      this.domain(d);
    } else if (step < 0) {
      d[i0] = Math.ceil(start * step) / step;
      d[i1] = Math.floor(stop * step) / step;
      this.domain(d);
    }
    return this;
  };
  D3Linear2.prototype.ticks = function(count) {
    if (count === void 0) {
      count = DEFAULT_COUNT;
    }
    return d3ArrayTicks(this._domain[0], this._domain[this._domain.length - 1], count || DEFAULT_COUNT);
  };
  return D3Linear2;
}();
function d3ArrayTicks(start, stop, count) {
  var reverse;
  var i = -1;
  var n;
  var ticks;
  var step;
  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0) {
    return [start];
  }
  if (reverse = stop < start) {
    n = start, start = stop, stop = n;
  }
  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) {
    return [];
  }
  if (step > 0) {
    start = Math.ceil(start / step);
    stop = Math.floor(stop / step);
    ticks = new Array(n = Math.ceil(stop - start + 1));
    while (++i < n) {
      ticks[i] = (start + i) * step;
    }
  } else {
    start = Math.floor(start * step);
    stop = Math.ceil(stop * step);
    ticks = new Array(n = Math.ceil(start - stop + 1));
    while (++i < n) {
      ticks[i] = (start - i) / step;
    }
  }
  if (reverse) {
    ticks.reverse();
  }
  return ticks;
}
function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count);
  var power = Math.floor(Math.log(step) / Math.LN10);
  var error = step / Math.pow(10, power);
  return power >= 0 ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}

// node_modules/@antv/scale/esm/util/interval.js
function snapMultiple(v, base, snapType) {
  var div3;
  if (snapType === "ceil") {
    div3 = Math.ceil(v / base);
  } else if (snapType === "floor") {
    div3 = Math.floor(v / base);
  } else {
    div3 = Math.round(v / base);
  }
  return div3 * base;
}
function intervalTicks(min3, max3, interval2) {
  var minTick = snapMultiple(min3, interval2, "floor");
  var maxTick = snapMultiple(max3, interval2, "ceil");
  minTick = fixed_base_default(minTick, interval2);
  maxTick = fixed_base_default(maxTick, interval2);
  var ticks = [];
  var availableInterval = Math.max((maxTick - minTick) / (Math.pow(2, 12) - 1), interval2);
  for (var i = minTick; i <= maxTick; i = i + availableInterval) {
    var tickValue = fixed_base_default(i, availableInterval);
    ticks.push(tickValue);
  }
  return {
    min: minTick,
    max: maxTick,
    ticks
  };
}

// node_modules/@antv/scale/esm/util/strict-limit.js
function strictLimit(cfg, defaultMin, defaultMax) {
  var _a3;
  var minLimit = cfg.minLimit, maxLimit = cfg.maxLimit, min3 = cfg.min, max3 = cfg.max, _b = cfg.tickCount, tickCount = _b === void 0 ? 5 : _b;
  var tickMin = is_nil_default(minLimit) ? is_nil_default(defaultMin) ? min3 : defaultMin : minLimit;
  var tickMax = is_nil_default(maxLimit) ? is_nil_default(defaultMax) ? max3 : defaultMax : maxLimit;
  if (tickMin > tickMax) {
    _a3 = [tickMin, tickMax], tickMax = _a3[0], tickMin = _a3[1];
  }
  if (tickCount <= 2) {
    return [tickMin, tickMax];
  }
  var step = (tickMax - tickMin) / (tickCount - 1);
  var ticks = [];
  for (var i = 0; i < tickCount; i++) {
    ticks.push(tickMin + step * i);
  }
  return ticks;
}

// node_modules/@antv/scale/esm/tick-method/d3-linear.js
function d3LinearTickMethod(cfg) {
  var min3 = cfg.min, max3 = cfg.max, tickInterval = cfg.tickInterval, minLimit = cfg.minLimit, maxLimit = cfg.maxLimit;
  var ticks = d3Linear(cfg);
  if (!is_nil_default(minLimit) || !is_nil_default(maxLimit)) {
    return strictLimit(cfg, head(ticks), last(ticks));
  }
  if (tickInterval) {
    return intervalTicks(min3, max3, tickInterval).ticks;
  }
  return ticks;
}

// node_modules/@antv/scale/esm/util/pretty-number.js
function prettyNumber(n) {
  return Math.abs(n) < 1e-15 ? n : parseFloat(n.toFixed(15));
}

// node_modules/@antv/scale/esm/util/extended.js
var DEFAULT_Q = [1, 5, 2, 2.5, 4, 3];
var eps = Number.EPSILON * 100;
function mod2(n, m) {
  return (n % m + m) % m;
}
function round3(n) {
  return Math.round(n * 1e12) / 1e12;
}
function simplicity(q, Q, j, lmin, lmax, lstep) {
  var n = size(Q);
  var i = index_of_default(Q, q);
  var v = 0;
  var m = mod2(lmin, lstep);
  if ((m < eps || lstep - m < eps) && lmin <= 0 && lmax >= 0) {
    v = 1;
  }
  return 1 - i / (n - 1) - j + v;
}
function simplicityMax(q, Q, j) {
  var n = size(Q);
  var i = index_of_default(Q, q);
  var v = 1;
  return 1 - i / (n - 1) - j + v;
}
function density(k, m, dMin, dMax, lMin, lMax) {
  var r = (k - 1) / (lMax - lMin);
  var rt = (m - 1) / (Math.max(lMax, dMax) - Math.min(dMin, lMin));
  return 2 - Math.max(r / rt, rt / r);
}
function densityMax(k, m) {
  if (k >= m) {
    return 2 - (k - 1) / (m - 1);
  }
  return 1;
}
function coverage(dMin, dMax, lMin, lMax) {
  var range = dMax - dMin;
  return 1 - 0.5 * (Math.pow(dMax - lMax, 2) + Math.pow(dMin - lMin, 2)) / Math.pow(0.1 * range, 2);
}
function coverageMax(dMin, dMax, span) {
  var range = dMax - dMin;
  if (span > range) {
    var half = (span - range) / 2;
    return 1 - Math.pow(half, 2) / Math.pow(0.1 * range, 2);
  }
  return 1;
}
function legibility() {
  return 1;
}
function extended(dMin, dMax, n, onlyLoose, Q, w) {
  if (n === void 0) {
    n = 5;
  }
  if (onlyLoose === void 0) {
    onlyLoose = true;
  }
  if (Q === void 0) {
    Q = DEFAULT_Q;
  }
  if (w === void 0) {
    w = [0.25, 0.2, 0.5, 0.05];
  }
  var m = n < 0 ? 0 : Math.round(n);
  if (Number.isNaN(dMin) || Number.isNaN(dMax) || typeof dMin !== "number" || typeof dMax !== "number" || !m) {
    return {
      min: 0,
      max: 0,
      ticks: []
    };
  }
  if (dMax - dMin < 1e-15 || m === 1) {
    return {
      min: dMin,
      max: dMax,
      ticks: [dMin]
    };
  }
  if (dMax - dMin > 1e148) {
    var count = n || 5;
    var step_1 = (dMax - dMin) / count;
    return {
      min: dMin,
      max: dMax,
      ticks: Array(count).fill(null).map(function(_, idx) {
        return prettyNumber(dMin + step_1 * idx);
      })
    };
  }
  var best = {
    score: -2,
    lmin: 0,
    lmax: 0,
    lstep: 0
  };
  var j = 1;
  while (j < Infinity) {
    for (var i = 0; i < Q.length; i += 1) {
      var q = Q[i];
      var sm = simplicityMax(q, Q, j);
      if (w[0] * sm + w[1] + w[2] + w[3] < best.score) {
        j = Infinity;
        break;
      }
      var k = 2;
      while (k < Infinity) {
        var dm = densityMax(k, m);
        if (w[0] * sm + w[1] + w[2] * dm + w[3] < best.score) {
          break;
        }
        var delta = (dMax - dMin) / (k + 1) / j / q;
        var z = Math.ceil(Math.log10(delta));
        while (z < Infinity) {
          var step = j * q * Math.pow(10, z);
          var cm = coverageMax(dMin, dMax, step * (k - 1));
          if (w[0] * sm + w[1] * cm + w[2] * dm + w[3] < best.score) {
            break;
          }
          var minStart = Math.floor(dMax / step) * j - (k - 1) * j;
          var maxStart = Math.ceil(dMin / step) * j;
          if (minStart <= maxStart) {
            var count = maxStart - minStart;
            for (var i_1 = 0; i_1 <= count; i_1 += 1) {
              var start = minStart + i_1;
              var lMin = start * (step / j);
              var lMax = lMin + step * (k - 1);
              var lStep = step;
              var s = simplicity(q, Q, j, lMin, lMax, lStep);
              var c = coverage(dMin, dMax, lMin, lMax);
              var g = density(k, m, dMin, dMax, lMin, lMax);
              var l = legibility();
              var score = w[0] * s + w[1] * c + w[2] * g + w[3] * l;
              if (score > best.score && (!onlyLoose || lMin <= dMin && lMax >= dMax)) {
                best.lmin = lMin;
                best.lmax = lMax;
                best.lstep = lStep;
                best.score = score;
              }
            }
          }
          z += 1;
        }
        k += 1;
      }
    }
    j += 1;
  }
  var lmax = prettyNumber(best.lmax);
  var lmin = prettyNumber(best.lmin);
  var lstep = prettyNumber(best.lstep);
  var tickCount = Math.floor(round3((lmax - lmin) / lstep)) + 1;
  var ticks = new Array(tickCount);
  ticks[0] = prettyNumber(lmin);
  for (var i = 1; i < tickCount; i++) {
    ticks[i] = prettyNumber(ticks[i - 1] + lstep);
  }
  return {
    min: Math.min(dMin, head(ticks)),
    max: Math.max(dMax, last(ticks)),
    ticks
  };
}

// node_modules/@antv/scale/esm/tick-method/linear.js
function linear3(cfg) {
  var min3 = cfg.min, max3 = cfg.max, tickCount = cfg.tickCount, nice = cfg.nice, tickInterval = cfg.tickInterval, minLimit = cfg.minLimit, maxLimit = cfg.maxLimit;
  var ticks = extended(min3, max3, tickCount, nice).ticks;
  if (!is_nil_default(minLimit) || !is_nil_default(maxLimit)) {
    return strictLimit(cfg, head(ticks), last(ticks));
  }
  if (tickInterval) {
    return intervalTicks(min3, max3, tickInterval).ticks;
  }
  return ticks;
}

// node_modules/@antv/scale/esm/tick-method/log.js
function calculateLogTicks(cfg) {
  var base = cfg.base, tickCount = cfg.tickCount, min3 = cfg.min, max3 = cfg.max, values2 = cfg.values;
  var minTick;
  var maxTick = log(base, max3);
  if (min3 > 0) {
    minTick = Math.floor(log(base, min3));
  } else {
    var positiveMin = getLogPositiveMin(values2, base, max3);
    minTick = Math.floor(log(base, positiveMin));
  }
  var count = maxTick - minTick;
  var avg2 = Math.ceil(count / tickCount);
  var ticks = [];
  for (var i = minTick; i < maxTick + avg2; i = i + avg2) {
    ticks.push(Math.pow(base, i));
  }
  if (min3 <= 0) {
    ticks.unshift(0);
  }
  return ticks;
}

// node_modules/@antv/scale/esm/util/pretty.js
function pretty(min3, max3, m) {
  if (m === void 0) {
    m = 5;
  }
  if (min3 === max3) {
    return {
      max: max3,
      min: min3,
      ticks: [min3]
    };
  }
  var n = m < 0 ? 0 : Math.round(m);
  if (n === 0)
    return { max: max3, min: min3, ticks: [] };
  var h = 1.5;
  var h5 = 0.5 + 1.5 * h;
  var d = max3 - min3;
  var c = d / n;
  var base = Math.pow(10, Math.floor(Math.log10(c)));
  var unit = base;
  if (2 * base - c < h * (c - unit)) {
    unit = 2 * base;
    if (5 * base - c < h5 * (c - unit)) {
      unit = 5 * base;
      if (10 * base - c < h * (c - unit)) {
        unit = 10 * base;
      }
    }
  }
  var nu = Math.ceil(max3 / unit);
  var ns = Math.floor(min3 / unit);
  var hi = Math.max(nu * unit, max3);
  var lo = Math.min(ns * unit, min3);
  var size2 = Math.floor((hi - lo) / unit) + 1;
  var ticks = new Array(size2);
  for (var i = 0; i < size2; i++) {
    ticks[i] = prettyNumber(lo + i * unit);
  }
  return {
    min: lo,
    max: hi,
    ticks
  };
}

// node_modules/@antv/scale/esm/tick-method/pow.js
function calculatePowTicks(cfg) {
  var exponent2 = cfg.exponent, tickCount = cfg.tickCount;
  var max3 = Math.ceil(calBase(exponent2, cfg.max));
  var min3 = Math.floor(calBase(exponent2, cfg.min));
  var ticks = pretty(min3, max3, tickCount).ticks;
  return ticks.map(function(tick) {
    var factor = tick >= 0 ? 1 : -1;
    return Math.pow(tick, exponent2) * factor;
  });
}

// node_modules/@antv/scale/esm/tick-method/quantile.js
function quantileSorted(x, p) {
  var idx = x.length * p;
  if (p === 1) {
    return x[x.length - 1];
  } else if (p === 0) {
    return x[0];
  } else if (idx % 1 !== 0) {
    return x[Math.ceil(idx) - 1];
  } else if (x.length % 2 === 0) {
    return (x[idx - 1] + x[idx]) / 2;
  } else {
    return x[idx];
  }
}
function calculateTicks(cfg) {
  var tickCount = cfg.tickCount, values2 = cfg.values;
  if (!values2 || !values2.length) {
    return [];
  }
  var sorted = values2.slice().sort(function(a, b) {
    return a - b;
  });
  var ticks = [];
  for (var i = 0; i < tickCount; i++) {
    var p = i / (tickCount - 1);
    ticks.push(quantileSorted(sorted, p));
  }
  return ticks;
}

// node_modules/@antv/scale/esm/tick-method/r-prettry.js
function linearPretty(cfg) {
  var min3 = cfg.min, max3 = cfg.max, tickCount = cfg.tickCount, tickInterval = cfg.tickInterval, minLimit = cfg.minLimit, maxLimit = cfg.maxLimit;
  var ticks = pretty(min3, max3, tickCount).ticks;
  if (!is_nil_default(minLimit) || !is_nil_default(maxLimit)) {
    return strictLimit(cfg, head(ticks), last(ticks));
  }
  if (tickInterval) {
    return intervalTicks(min3, max3, tickInterval).ticks;
  }
  return ticks;
}

// node_modules/@antv/scale/esm/tick-method/time.js
function calculateTimeTicks(cfg) {
  var min3 = cfg.min, max3 = cfg.max, minTickInterval = cfg.minTickInterval;
  var tickInterval = cfg.tickInterval;
  var tickCount = cfg.tickCount;
  if (tickInterval) {
    tickCount = Math.ceil((max3 - min3) / tickInterval);
  } else {
    tickInterval = getTickInterval(min3, max3, tickCount)[1];
    var count = (max3 - min3) / tickInterval;
    var ratio = count / tickCount;
    if (ratio > 1) {
      tickInterval = tickInterval * Math.ceil(ratio);
    }
    if (minTickInterval && tickInterval < minTickInterval) {
      tickInterval = minTickInterval;
    }
  }
  tickInterval = Math.max(Math.floor((max3 - min3) / (Math.pow(2, 12) - 1)), tickInterval);
  var ticks = [];
  for (var i = min3; i < max3 + tickInterval; i += tickInterval) {
    ticks.push(i);
  }
  return ticks;
}

// node_modules/@antv/scale/esm/tick-method/time-cat.js
function timeCat(cfg) {
  var ticks = calculateCatTicks(__assign({ showLast: true }, cfg));
  return ticks;
}

// node_modules/@antv/scale/esm/tick-method/time-pretty.js
function getYear(date) {
  return new Date(date).getFullYear();
}
function createYear(year) {
  return new Date(year, 0, 1).getTime();
}
function getMonth(date) {
  return new Date(date).getMonth();
}
function diffMonth(min3, max3) {
  var minYear = getYear(min3);
  var maxYear = getYear(max3);
  var minMonth = getMonth(min3);
  var maxMonth = getMonth(max3);
  return (maxYear - minYear) * 12 + (maxMonth - minMonth) % 12;
}
function creatMonth(year, month) {
  return new Date(year, month, 1).getTime();
}
function diffDay(min3, max3) {
  return Math.ceil((max3 - min3) / DAY);
}
function diffHour(min3, max3) {
  return Math.ceil((max3 - min3) / HOUR);
}
function diffMinus(min3, max3) {
  return Math.ceil((max3 - min3) / (60 * 1e3));
}
function timePretty(cfg) {
  var min3 = cfg.min, max3 = cfg.max, minTickInterval = cfg.minTickInterval, tickCount = cfg.tickCount;
  var tickInterval = cfg.tickInterval;
  var ticks = [];
  if (!tickInterval) {
    tickInterval = (max3 - min3) / tickCount;
    if (minTickInterval && tickInterval < minTickInterval) {
      tickInterval = minTickInterval;
    }
  }
  tickInterval = Math.max(Math.floor((max3 - min3) / (Math.pow(2, 12) - 1)), tickInterval);
  var minYear = getYear(min3);
  if (tickInterval > YEAR) {
    var maxYear = getYear(max3);
    var yearInterval = Math.ceil(tickInterval / YEAR);
    for (var i = minYear; i <= maxYear + yearInterval; i = i + yearInterval) {
      ticks.push(createYear(i));
    }
  } else if (tickInterval > MONTH) {
    var monthInterval = Math.ceil(tickInterval / MONTH);
    var mmMoth = getMonth(min3);
    var dMonths = diffMonth(min3, max3);
    for (var i = 0; i <= dMonths + monthInterval; i = i + monthInterval) {
      ticks.push(creatMonth(minYear, i + mmMoth));
    }
  } else if (tickInterval > DAY) {
    var date = new Date(min3);
    var year = date.getFullYear();
    var month = date.getMonth();
    var mday = date.getDate();
    var day = Math.ceil(tickInterval / DAY);
    var ddays = diffDay(min3, max3);
    for (var i = 0; i < ddays + day; i = i + day) {
      ticks.push(new Date(year, month, mday + i).getTime());
    }
  } else if (tickInterval > HOUR) {
    var date = new Date(min3);
    var year = date.getFullYear();
    var month = date.getMonth();
    var day = date.getDate();
    var hour = date.getHours();
    var hours = Math.ceil(tickInterval / HOUR);
    var dHours = diffHour(min3, max3);
    for (var i = 0; i <= dHours + hours; i = i + hours) {
      ticks.push(new Date(year, month, day, hour + i).getTime());
    }
  } else if (tickInterval > MINUTE) {
    var dMinus = diffMinus(min3, max3);
    var minutes = Math.ceil(tickInterval / MINUTE);
    for (var i = 0; i <= dMinus + minutes; i = i + minutes) {
      ticks.push(min3 + i * MINUTE);
    }
  } else {
    var interval2 = tickInterval;
    if (interval2 < SECOND) {
      interval2 = SECOND;
    }
    var minSecond = Math.floor(min3 / SECOND) * SECOND;
    var dSeconds = Math.ceil((max3 - min3) / SECOND);
    var seconds = Math.ceil(interval2 / SECOND);
    for (var i = 0; i < dSeconds + seconds; i = i + seconds) {
      ticks.push(minSecond + i * SECOND);
    }
  }
  if (ticks.length >= 512) {
    console.warn("Notice: current ticks length(" + ticks.length + ') >= 512, may cause performance issues, even out of memory. Because of the configure "tickInterval"(in milliseconds, current is ' + tickInterval + ") is too small, increase the value to solve the problem!");
  }
  return ticks;
}

// node_modules/@antv/scale/esm/tick-method/index.js
registerTickMethod("cat", calculateCatTicks);
registerTickMethod("time-cat", timeCat);
registerTickMethod("wilkinson-extended", linear3);
registerTickMethod("r-pretty", linearPretty);
registerTickMethod("time", calculateTimeTicks);
registerTickMethod("time-pretty", timePretty);
registerTickMethod("log", calculateLogTicks);
registerTickMethod("pow", calculatePowTicks);
registerTickMethod("quantile", calculateTicks);
registerTickMethod("d3-linear", d3LinearTickMethod);

// node_modules/@antv/scale/esm/index.js
registerClass("cat", base_default5);
registerClass("category", base_default5);
registerClass("identity", identity_default2);
registerClass("linear", linear_default);
registerClass("log", log_default);
registerClass("pow", pow_default);
registerClass("time", time_default2);
registerClass("timeCat", time_default);
registerClass("quantize", quantize_default2);
registerClass("quantile", quantile_default);

// node_modules/@antv/attr/esm/factory.js
var ATTRIBUTE_MAP = {};
var getAttribute = function(type) {
  return ATTRIBUTE_MAP[type.toLowerCase()];
};
var registerAttribute = function(type, ctor) {
  if (getAttribute(type)) {
    throw new Error("Attribute type '" + type + "' existed.");
  }
  ATTRIBUTE_MAP[type.toLowerCase()] = ctor;
};

// node_modules/@antv/attr/esm/index.js
registerAttribute("Color", color_default);
registerAttribute("Opacity", opacity_default);
registerAttribute("Position", position_default);
registerAttribute("Shape", shape_default2);
registerAttribute("Size", size_default);

// node_modules/@antv/coord/esm/coord/base.js
var Coordinate = function() {
  function Coordinate2(cfg) {
    this.type = "coordinate";
    this.isRect = false;
    this.isHelix = false;
    this.isPolar = false;
    this.isReflectX = false;
    this.isReflectY = false;
    var start = cfg.start, end = cfg.end, _a3 = cfg.matrix, matrix = _a3 === void 0 ? [1, 0, 0, 0, 1, 0, 0, 0, 1] : _a3, _b = cfg.isTransposed, isTransposed = _b === void 0 ? false : _b;
    this.start = start;
    this.end = end;
    this.matrix = matrix;
    this.originalMatrix = __spreadArray([], matrix);
    this.isTransposed = isTransposed;
  }
  Coordinate2.prototype.initial = function() {
    this.center = {
      x: (this.start.x + this.end.x) / 2,
      y: (this.start.y + this.end.y) / 2
    };
    this.width = Math.abs(this.end.x - this.start.x);
    this.height = Math.abs(this.end.y - this.start.y);
  };
  Coordinate2.prototype.update = function(cfg) {
    mix(this, cfg);
    this.initial();
  };
  Coordinate2.prototype.convertDim = function(percent, dim) {
    var _a3;
    var _b = this[dim], start = _b.start, end = _b.end;
    if (this.isReflect(dim)) {
      _a3 = [end, start], start = _a3[0], end = _a3[1];
    }
    return start + percent * (end - start);
  };
  Coordinate2.prototype.invertDim = function(value, dim) {
    var _a3;
    var _b = this[dim], start = _b.start, end = _b.end;
    if (this.isReflect(dim)) {
      _a3 = [end, start], start = _a3[0], end = _a3[1];
    }
    return (value - start) / (end - start);
  };
  Coordinate2.prototype.applyMatrix = function(x, y, tag) {
    if (tag === void 0) {
      tag = 0;
    }
    var matrix = this.matrix;
    var vector = [x, y, tag];
    vec3_exports.transformMat3(vector, vector, matrix);
    return vector;
  };
  Coordinate2.prototype.invertMatrix = function(x, y, tag) {
    if (tag === void 0) {
      tag = 0;
    }
    var matrix = this.matrix;
    var inverted = mat3_exports.invert([0, 0, 0, 0, 0, 0, 0, 0, 0], matrix);
    var vector = [x, y, tag];
    if (inverted) {
      vec3_exports.transformMat3(vector, vector, inverted);
    }
    return vector;
  };
  Coordinate2.prototype.convert = function(point) {
    var _a3 = this.convertPoint(point), x = _a3.x, y = _a3.y;
    var vector = this.applyMatrix(x, y, 1);
    return {
      x: vector[0],
      y: vector[1]
    };
  };
  Coordinate2.prototype.invert = function(point) {
    var vector = this.invertMatrix(point.x, point.y, 1);
    return this.invertPoint({
      x: vector[0],
      y: vector[1]
    });
  };
  Coordinate2.prototype.rotate = function(radian) {
    var matrix = this.matrix;
    var center = this.center;
    ext_exports.leftTranslate(matrix, matrix, [-center.x, -center.y]);
    ext_exports.leftRotate(matrix, matrix, radian);
    ext_exports.leftTranslate(matrix, matrix, [center.x, center.y]);
    return this;
  };
  Coordinate2.prototype.reflect = function(dim) {
    if (dim === "x") {
      this.isReflectX = !this.isReflectX;
    } else {
      this.isReflectY = !this.isReflectY;
    }
    return this;
  };
  Coordinate2.prototype.scale = function(s1, s2) {
    var matrix = this.matrix;
    var center = this.center;
    ext_exports.leftTranslate(matrix, matrix, [-center.x, -center.y]);
    ext_exports.leftScale(matrix, matrix, [s1, s2]);
    ext_exports.leftTranslate(matrix, matrix, [center.x, center.y]);
    return this;
  };
  Coordinate2.prototype.translate = function(x, y) {
    var matrix = this.matrix;
    ext_exports.leftTranslate(matrix, matrix, [x, y]);
    return this;
  };
  Coordinate2.prototype.transpose = function() {
    this.isTransposed = !this.isTransposed;
    return this;
  };
  Coordinate2.prototype.getCenter = function() {
    return this.center;
  };
  Coordinate2.prototype.getWidth = function() {
    return this.width;
  };
  Coordinate2.prototype.getHeight = function() {
    return this.height;
  };
  Coordinate2.prototype.getRadius = function() {
    return this.radius;
  };
  Coordinate2.prototype.isReflect = function(dim) {
    return dim === "x" ? this.isReflectX : this.isReflectY;
  };
  Coordinate2.prototype.resetMatrix = function(matrix) {
    this.matrix = matrix ? matrix : __spreadArray([], this.originalMatrix);
  };
  return Coordinate2;
}();
var base_default7 = Coordinate;

// node_modules/@antv/coord/esm/coord/cartesian.js
var Cartesian = function(_super) {
  __extends(Cartesian2, _super);
  function Cartesian2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.isRect = true;
    _this.type = "cartesian";
    _this.initial();
    return _this;
  }
  Cartesian2.prototype.initial = function() {
    _super.prototype.initial.call(this);
    var start = this.start;
    var end = this.end;
    this.x = {
      start: start.x,
      end: end.x
    };
    this.y = {
      start: start.y,
      end: end.y
    };
  };
  Cartesian2.prototype.convertPoint = function(point) {
    var _a3;
    var x = point.x, y = point.y;
    if (this.isTransposed) {
      _a3 = [y, x], x = _a3[0], y = _a3[1];
    }
    return {
      x: this.convertDim(x, "x"),
      y: this.convertDim(y, "y")
    };
  };
  Cartesian2.prototype.invertPoint = function(point) {
    var _a3;
    var x = this.invertDim(point.x, "x");
    var y = this.invertDim(point.y, "y");
    if (this.isTransposed) {
      _a3 = [y, x], x = _a3[0], y = _a3[1];
    }
    return { x, y };
  };
  return Cartesian2;
}(base_default7);
var cartesian_default = Cartesian;

// node_modules/@antv/coord/esm/coord/helix.js
var Helix = function(_super) {
  __extends(Helix2, _super);
  function Helix2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.isHelix = true;
    _this.type = "helix";
    var _a3 = cfg.startAngle, startAngle = _a3 === void 0 ? 1.25 * Math.PI : _a3, _b = cfg.endAngle, endAngle = _b === void 0 ? 7.25 * Math.PI : _b, _c = cfg.innerRadius, innerRadius = _c === void 0 ? 0 : _c, radius = cfg.radius;
    _this.startAngle = startAngle;
    _this.endAngle = endAngle;
    _this.innerRadius = innerRadius;
    _this.radius = radius;
    _this.initial();
    return _this;
  }
  Helix2.prototype.initial = function() {
    _super.prototype.initial.call(this);
    var index = (this.endAngle - this.startAngle) / (2 * Math.PI) + 1;
    var maxRadius = Math.min(this.width, this.height) / 2;
    if (this.radius && this.radius >= 0 && this.radius <= 1) {
      maxRadius = maxRadius * this.radius;
    }
    this.d = Math.floor(maxRadius * (1 - this.innerRadius) / index);
    this.a = this.d / (Math.PI * 2);
    this.x = {
      start: this.startAngle,
      end: this.endAngle
    };
    this.y = {
      start: this.innerRadius * maxRadius,
      end: this.innerRadius * maxRadius + this.d * 0.99
    };
  };
  Helix2.prototype.convertPoint = function(point) {
    var _a3;
    var x = point.x, y = point.y;
    if (this.isTransposed) {
      _a3 = [y, x], x = _a3[0], y = _a3[1];
    }
    var thi = this.convertDim(x, "x");
    var r = this.a * thi;
    var newY = this.convertDim(y, "y");
    return {
      x: this.center.x + Math.cos(thi) * (r + newY),
      y: this.center.y + Math.sin(thi) * (r + newY)
    };
  };
  Helix2.prototype.invertPoint = function(point) {
    var _a3;
    var d = this.d + this.y.start;
    var v = vec2_exports.subtract([0, 0], [point.x, point.y], [this.center.x, this.center.y]);
    var thi = ext_exports.angleTo(v, [1, 0], true);
    var rMin = thi * this.a;
    if (vec2_exports.length(v) < rMin) {
      rMin = vec2_exports.length(v);
    }
    var index = Math.floor((vec2_exports.length(v) - rMin) / d);
    thi = 2 * index * Math.PI + thi;
    var r = this.a * thi;
    var newY = vec2_exports.length(v) - r;
    newY = isNumberEqual(newY, 0) ? 0 : newY;
    var x = this.invertDim(thi, "x");
    var y = this.invertDim(newY, "y");
    x = isNumberEqual(x, 0) ? 0 : x;
    y = isNumberEqual(y, 0) ? 0 : y;
    if (this.isTransposed) {
      _a3 = [y, x], x = _a3[0], y = _a3[1];
    }
    return { x, y };
  };
  return Helix2;
}(base_default7);
var helix_default = Helix;

// node_modules/@antv/coord/esm/coord/polar.js
var Polar = function(_super) {
  __extends(Polar2, _super);
  function Polar2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.isPolar = true;
    _this.type = "polar";
    var _a3 = cfg.startAngle, startAngle = _a3 === void 0 ? -Math.PI / 2 : _a3, _b = cfg.endAngle, endAngle = _b === void 0 ? Math.PI * 3 / 2 : _b, _c = cfg.innerRadius, innerRadius = _c === void 0 ? 0 : _c, radius = cfg.radius;
    _this.startAngle = startAngle;
    _this.endAngle = endAngle;
    _this.innerRadius = innerRadius;
    _this.radius = radius;
    _this.initial();
    return _this;
  }
  Polar2.prototype.initial = function() {
    _super.prototype.initial.call(this);
    while (this.endAngle < this.startAngle) {
      this.endAngle += Math.PI * 2;
    }
    var oneBox = this.getOneBox();
    var oneWidth = oneBox.maxX - oneBox.minX;
    var oneHeight = oneBox.maxY - oneBox.minY;
    var left = Math.abs(oneBox.minX) / oneWidth;
    var top = Math.abs(oneBox.minY) / oneHeight;
    var maxRadius;
    if (this.height / oneHeight > this.width / oneWidth) {
      maxRadius = this.width / oneWidth;
      this.circleCenter = {
        x: this.center.x - (0.5 - left) * this.width,
        y: this.center.y - (0.5 - top) * maxRadius * oneHeight
      };
    } else {
      maxRadius = this.height / oneHeight;
      this.circleCenter = {
        x: this.center.x - (0.5 - left) * maxRadius * oneWidth,
        y: this.center.y - (0.5 - top) * this.height
      };
    }
    this.polarRadius = this.radius;
    if (!this.radius) {
      this.polarRadius = maxRadius;
    } else if (this.radius > 0 && this.radius <= 1) {
      this.polarRadius = maxRadius * this.radius;
    } else if (this.radius <= 0 || this.radius > maxRadius) {
      this.polarRadius = maxRadius;
    }
    this.x = {
      start: this.startAngle,
      end: this.endAngle
    };
    this.y = {
      start: this.innerRadius * this.polarRadius,
      end: this.polarRadius
    };
  };
  Polar2.prototype.getRadius = function() {
    return this.polarRadius;
  };
  Polar2.prototype.convertPoint = function(point) {
    var _a3;
    var center = this.getCenter();
    var x = point.x, y = point.y;
    if (this.isTransposed) {
      _a3 = [y, x], x = _a3[0], y = _a3[1];
    }
    x = this.convertDim(x, "x");
    y = this.convertDim(y, "y");
    return {
      x: center.x + Math.cos(x) * y,
      y: center.y + Math.sin(x) * y
    };
  };
  Polar2.prototype.invertPoint = function(point) {
    var _a3;
    var center = this.getCenter();
    var vPoint = [point.x - center.x, point.y - center.y];
    var _b = this, startAngle = _b.startAngle, endAngle = _b.endAngle;
    if (this.isReflect("x")) {
      _a3 = [endAngle, startAngle], startAngle = _a3[0], endAngle = _a3[1];
    }
    var m = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    ext_exports.leftRotate(m, m, startAngle);
    var vStart3 = [1, 0, 0];
    vec3_exports.transformMat3(vStart3, vStart3, m);
    var vStart2 = [vStart3[0], vStart3[1]];
    var angle3 = ext_exports.angleTo(vStart2, vPoint, endAngle < startAngle);
    if (isNumberEqual(angle3, Math.PI * 2)) {
      angle3 = 0;
    }
    var radius = vec2_exports.length(vPoint);
    var xPercent = angle3 / (endAngle - startAngle);
    xPercent = endAngle - startAngle > 0 ? xPercent : -xPercent;
    var yPercent = this.invertDim(radius, "y");
    var rst = { x: 0, y: 0 };
    rst.x = this.isTransposed ? yPercent : xPercent;
    rst.y = this.isTransposed ? xPercent : yPercent;
    return rst;
  };
  Polar2.prototype.getCenter = function() {
    return this.circleCenter;
  };
  Polar2.prototype.getOneBox = function() {
    var startAngle = this.startAngle;
    var endAngle = this.endAngle;
    if (Math.abs(endAngle - startAngle) >= Math.PI * 2) {
      return {
        minX: -1,
        maxX: 1,
        minY: -1,
        maxY: 1
      };
    }
    var xs = [0, Math.cos(startAngle), Math.cos(endAngle)];
    var ys = [0, Math.sin(startAngle), Math.sin(endAngle)];
    for (var i = Math.min(startAngle, endAngle); i < Math.max(startAngle, endAngle); i += Math.PI / 18) {
      xs.push(Math.cos(i));
      ys.push(Math.sin(i));
    }
    return {
      minX: Math.min.apply(Math, xs),
      maxX: Math.max.apply(Math, xs),
      minY: Math.min.apply(Math, ys),
      maxY: Math.max.apply(Math, ys)
    };
  };
  return Polar2;
}(base_default7);
var polar_default = Polar;

// node_modules/@antv/coord/esm/factory.js
var COORDINATE_MAP = {};
var getCoordinate = function(type) {
  return COORDINATE_MAP[type.toLowerCase()];
};
var registerCoordinate = function(type, ctor) {
  COORDINATE_MAP[type.toLowerCase()] = ctor;
};

// node_modules/@antv/coord/esm/index.js
registerCoordinate("rect", cartesian_default);
registerCoordinate("cartesian", cartesian_default);
registerCoordinate("polar", polar_default);
registerCoordinate("helix", helix_default);

// node_modules/@antv/component/esm/annotation/index.js
var annotation_exports = {};
__export(annotation_exports, {
  Arc: () => arc_default2,
  DataMarker: () => data_marker_default,
  DataRegion: () => data_region_default,
  Html: () => html_default,
  Image: () => image_default,
  Line: () => line_default3,
  Region: () => region_default,
  RegionFilter: () => region_filter_default,
  Shape: () => shape_default3,
  Text: () => text_default2
});

// node_modules/@antv/component/esm/util/event.js
function propagationDelegate(group2, eventName, eventObject) {
  var event = new graph_event_default(eventName, eventObject);
  event.target = group2;
  event.propagationPath.push(group2);
  group2.emitDelegation(eventName, event);
  var parent = group2.getParent();
  while (parent) {
    parent.emitDelegation(eventName, event);
    event.propagationPath.push(parent);
    parent = parent.getParent();
  }
}

// node_modules/@antv/component/esm/util/matrix.js
var identityMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
function getMatrixByAngle(point, angle3, matrix) {
  if (matrix === void 0) {
    matrix = identityMatrix;
  }
  if (!angle3) {
    return null;
  }
  var m = ext_exports.transform(matrix, [
    ["t", -point.x, -point.y],
    ["r", angle3],
    ["t", point.x, point.y]
  ]);
  return m;
}
function getMatrixByTranslate(point, currentMatrix) {
  if (!point.x && !point.y) {
    return null;
  }
  return ext_exports.transform(currentMatrix || identityMatrix, [["t", point.x, point.y]]);
}
function getAngleByMatrix(matrix) {
  var xVector = [1, 0, 0];
  var out = [0, 0, 0];
  vec3_exports.transformMat3(out, xVector, matrix);
  return Math.atan2(out[1], out[0]);
}
function multiplyVec22(matrix, v) {
  var out = [0, 0];
  vec2_exports.transformMat3(out, v, matrix);
  return out;
}
function applyMatrix2BBox(matrix, bbox) {
  var topLeft = multiplyVec22(matrix, [bbox.minX, bbox.minY]);
  var topRight = multiplyVec22(matrix, [bbox.maxX, bbox.minY]);
  var bottomLeft = multiplyVec22(matrix, [bbox.minX, bbox.maxY]);
  var bottomRight = multiplyVec22(matrix, [bbox.maxX, bbox.maxY]);
  var minX = Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
  var maxX = Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
  var minY = Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
  var maxY = Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
  return {
    x: minX,
    y: minY,
    minX,
    minY,
    maxX,
    maxY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function applyRotate(shape, rotate5, x, y) {
  if (rotate5) {
    var matrix = getMatrixByAngle({ x, y }, rotate5, shape.getMatrix());
    shape.setMatrix(matrix);
  }
}
function applyTranslate(shape, x, y) {
  var translateMatrix = getMatrixByTranslate({ x, y });
  shape.attr("matrix", translateMatrix);
}

// node_modules/@antv/component/esm/util/util.js
function formatPadding(padding) {
  var top = 0;
  var left = 0;
  var right = 0;
  var bottom = 0;
  if (is_number_default(padding)) {
    top = left = right = bottom = padding;
  } else if (is_array_default(padding)) {
    top = padding[0];
    right = !is_nil_default(padding[1]) ? padding[1] : padding[0];
    bottom = !is_nil_default(padding[2]) ? padding[2] : padding[0];
    left = !is_nil_default(padding[3]) ? padding[3] : right;
  }
  return [top, right, bottom, left];
}
function clearDom(container) {
  var children = container.childNodes;
  var length5 = children.length;
  for (var i = length5 - 1; i >= 0; i--) {
    container.removeChild(children[i]);
  }
}
function hasClass(elements, cName) {
  return !!elements.className.match(new RegExp("(\\s|^)" + cName + "(\\s|$)"));
}
function regionToBBox(region) {
  var start = region.start, end = region.end;
  var minX = Math.min(start.x, end.x);
  var minY = Math.min(start.y, end.y);
  var maxX = Math.max(start.x, end.x);
  var maxY = Math.max(start.y, end.y);
  return {
    x: minX,
    y: minY,
    minX,
    minY,
    maxX,
    maxY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function pointsToBBox(points) {
  var xs = points.map(function(point) {
    return point.x;
  });
  var ys = points.map(function(point) {
    return point.y;
  });
  var minX = Math.min.apply(Math, xs);
  var minY = Math.min.apply(Math, ys);
  var maxX = Math.max.apply(Math, xs);
  var maxY = Math.max.apply(Math, ys);
  return {
    x: minX,
    y: minY,
    minX,
    minY,
    maxX,
    maxY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function createBBox(x, y, width, height) {
  var maxX = x + width;
  var maxY = y + height;
  return {
    x,
    y,
    width,
    height,
    minX: x,
    minY: y,
    maxX: isNaN(maxX) ? 0 : maxX,
    maxY: isNaN(maxY) ? 0 : maxY
  };
}
function getValueByPercent(min3, max3, percent) {
  return (1 - percent) * min3 + max3 * percent;
}
function getCirclePoint(center, radius, angle3) {
  return {
    x: center.x + Math.cos(angle3) * radius,
    y: center.y + Math.sin(angle3) * radius
  };
}
function distance4(p1, p2) {
  var dx = p2.x - p1.x;
  var dy = p2.y - p1.y;
  return Math.sqrt(dx * dx + dy * dy);
}
var near = function(x, y, e) {
  if (e === void 0) {
    e = Math.pow(Number.EPSILON, 0.5);
  }
  return [x, y].includes(Infinity) ? Math.abs(x) === Math.abs(y) : Math.abs(x - y) < e;
};
function intersectBBox2(box1, box2) {
  var minX = Math.max(box1.minX, box2.minX);
  var minY = Math.max(box1.minY, box2.minY);
  var maxX = Math.min(box1.maxX, box2.maxX);
  var maxY = Math.min(box1.maxY, box2.maxY);
  return createBBox(minX, minY, maxX - minX, maxY - minY);
}
function getBBoxWithClip(element) {
  var clipShape = element.getClip();
  var clipBBox = clipShape && clipShape.getBBox();
  var bbox;
  if (!element.isGroup()) {
    bbox = element.getBBox();
  } else {
    var minX_1 = Infinity;
    var maxX_1 = -Infinity;
    var minY_1 = Infinity;
    var maxY_1 = -Infinity;
    var children = element.getChildren();
    if (children.length > 0) {
      each_default(children, function(child) {
        if (child.get("visible")) {
          if (child.isGroup() && child.get("children").length === 0) {
            return true;
          }
          var box2 = getBBoxWithClip(child);
          var leftTop = child.applyToMatrix([box2.minX, box2.minY, 1]);
          var leftBottom = child.applyToMatrix([box2.minX, box2.maxY, 1]);
          var rightTop = child.applyToMatrix([box2.maxX, box2.minY, 1]);
          var rightBottom = child.applyToMatrix([box2.maxX, box2.maxY, 1]);
          var boxMinX = Math.min(leftTop[0], leftBottom[0], rightTop[0], rightBottom[0]);
          var boxMaxX = Math.max(leftTop[0], leftBottom[0], rightTop[0], rightBottom[0]);
          var boxMinY = Math.min(leftTop[1], leftBottom[1], rightTop[1], rightBottom[1]);
          var boxMaxY = Math.max(leftTop[1], leftBottom[1], rightTop[1], rightBottom[1]);
          if (boxMinX < minX_1) {
            minX_1 = boxMinX;
          }
          if (boxMaxX > maxX_1) {
            maxX_1 = boxMaxX;
          }
          if (boxMinY < minY_1) {
            minY_1 = boxMinY;
          }
          if (boxMaxY > maxY_1) {
            maxY_1 = boxMaxY;
          }
        }
      });
    } else {
      minX_1 = 0;
      maxX_1 = 0;
      minY_1 = 0;
      maxY_1 = 0;
    }
    bbox = createBBox(minX_1, minY_1, maxX_1 - minX_1, maxY_1 - minY_1);
  }
  if (clipBBox) {
    return intersectBBox2(bbox, clipBBox);
  } else {
    return bbox;
  }
}
function updateClip(element, newElement) {
  if (!element.getClip() && !newElement.getClip()) {
    return;
  }
  var newClipShape = newElement.getClip();
  if (!newClipShape) {
    element.setClip(null);
    return;
  }
  var clipCfg = {
    type: newClipShape.get("type"),
    attrs: newClipShape.attr()
  };
  element.setClip(clipCfg);
}
function toPx(number) {
  return number + "px";
}
function getTextPoint(start, end, position, offset) {
  var lineLength = distance4(start, end);
  var offsetPercent = offset / lineLength;
  var percent = 0;
  if (position === "start") {
    percent = 0 - offsetPercent;
  } else if (position === "end") {
    percent = 1 + offsetPercent;
  }
  return {
    x: getValueByPercent(start.x, end.x, percent),
    y: getValueByPercent(start.y, end.y, percent)
  };
}

// node_modules/@antv/component/esm/abstract/component.js
var LOCATION_FIELD_MAP = {
  none: [],
  point: ["x", "y"],
  region: ["start", "end"],
  points: ["points"],
  circle: ["center", "radius", "startAngle", "endAngle"]
};
var Component = function(_super) {
  __extends(Component2, _super);
  function Component2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.initCfg();
    return _this;
  }
  Component2.prototype.getDefaultCfg = function() {
    return {
      id: "",
      name: "",
      type: "",
      locationType: "none",
      offsetX: 0,
      offsetY: 0,
      animate: false,
      capture: true,
      updateAutoRender: false,
      animateOption: {
        appear: null,
        update: {
          duration: 400,
          easing: "easeQuadInOut"
        },
        enter: {
          duration: 400,
          easing: "easeQuadInOut"
        },
        leave: {
          duration: 350,
          easing: "easeQuadIn"
        }
      },
      events: null,
      defaultCfg: {},
      visible: true
    };
  };
  Component2.prototype.clear = function() {
  };
  Component2.prototype.update = function(cfg) {
    var _this = this;
    var defaultCfg = this.get("defaultCfg") || {};
    each_default(cfg, function(value, name) {
      var originCfg = _this.get(name);
      var newCfg = value;
      if (originCfg !== value) {
        if (is_object_default(value) && defaultCfg[name]) {
          newCfg = deep_mix_default({}, defaultCfg[name], value);
        }
        _this.set(name, newCfg);
      }
    });
    this.updateInner(cfg);
    this.afterUpdate(cfg);
  };
  Component2.prototype.updateInner = function(cfg) {
  };
  Component2.prototype.afterUpdate = function(cfg) {
    if (has_key_default(cfg, "visible")) {
      if (cfg.visible) {
        this.show();
      } else {
        this.hide();
      }
    }
    if (has_key_default(cfg, "capture")) {
      this.setCapture(cfg.capture);
    }
  };
  Component2.prototype.getLayoutBBox = function() {
    return this.getBBox();
  };
  Component2.prototype.getLocationType = function() {
    return this.get("locationType");
  };
  Component2.prototype.getOffset = function() {
    return {
      offsetX: this.get("offsetX"),
      offsetY: this.get("offsetY")
    };
  };
  Component2.prototype.setOffset = function(offsetX, offsetY) {
    this.update({
      offsetX,
      offsetY
    });
  };
  Component2.prototype.setLocation = function(cfg) {
    var location = __assign({}, cfg);
    this.update(location);
  };
  Component2.prototype.getLocation = function() {
    var _this = this;
    var location = {};
    var locationType = this.get("locationType");
    var fields = LOCATION_FIELD_MAP[locationType];
    each_default(fields, function(field) {
      location[field] = _this.get(field);
    });
    return location;
  };
  Component2.prototype.isList = function() {
    return false;
  };
  Component2.prototype.isSlider = function() {
    return false;
  };
  Component2.prototype.init = function() {
  };
  Component2.prototype.initCfg = function() {
    var _this = this;
    var defaultCfg = this.get("defaultCfg");
    each_default(defaultCfg, function(value, name) {
      var cfg = _this.get(name);
      if (is_object_default(cfg)) {
        var newCfg = deep_mix_default({}, value, cfg);
        _this.set(name, newCfg);
      }
    });
  };
  return Component2;
}(base_default2);
var component_default = Component;

// node_modules/@antv/component/esm/abstract/group-component.js
var STATUS_UPDATE = "update_status";
var COPY_PROPERTIES = ["visible", "tip", "delegateObject"];
var COPY_PROPERTIES_EXCLUDES = ["container", "group", "shapesMap", "isRegister", "isUpdating", "destroyed"];
var GroupComponent = function(_super) {
  __extends(GroupComponent2, _super);
  function GroupComponent2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  GroupComponent2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign(__assign({}, cfg), {
      container: null,
      shapesMap: {},
      group: null,
      capture: true,
      isRegister: false,
      isUpdating: false,
      isInit: true
    });
  };
  GroupComponent2.prototype.remove = function() {
    this.clear();
    var group2 = this.get("group");
    group2.remove();
  };
  GroupComponent2.prototype.clear = function() {
    var group2 = this.get("group");
    group2.clear();
    this.set("shapesMap", {});
    this.clearOffScreenCache();
    this.set("isInit", true);
  };
  GroupComponent2.prototype.getChildComponentById = function(id) {
    var group2 = this.getElementById(id);
    var inst = group2 && group2.get("component");
    return inst;
  };
  GroupComponent2.prototype.getElementById = function(id) {
    return this.get("shapesMap")[id];
  };
  GroupComponent2.prototype.getElementByLocalId = function(localId) {
    var id = this.getElementId(localId);
    return this.getElementById(id);
  };
  GroupComponent2.prototype.getElementsByName = function(name) {
    var rst = [];
    each_default(this.get("shapesMap"), function(elem) {
      if (elem.get("name") === name) {
        rst.push(elem);
      }
    });
    return rst;
  };
  GroupComponent2.prototype.getContainer = function() {
    return this.get("container");
  };
  GroupComponent2.prototype.updateInner = function(cfg) {
    this.offScreenRender();
    if (this.get("updateAutoRender")) {
      this.render();
    }
  };
  GroupComponent2.prototype.render = function() {
    var offScreenGroup = this.get("offScreenGroup");
    if (!offScreenGroup) {
      offScreenGroup = this.offScreenRender();
    }
    var group2 = this.get("group");
    this.updateElements(offScreenGroup, group2);
    this.deleteElements();
    this.applyOffset();
    if (!this.get("eventInitted")) {
      this.initEvent();
      this.set("eventInitted", true);
    }
    this.set("isInit", false);
  };
  GroupComponent2.prototype.show = function() {
    var group2 = this.get("group");
    group2.show();
    this.set("visible", true);
  };
  GroupComponent2.prototype.hide = function() {
    var group2 = this.get("group");
    group2.hide();
    this.set("visible", false);
  };
  GroupComponent2.prototype.setCapture = function(capture) {
    var group2 = this.get("group");
    group2.set("capture", capture);
    this.set("capture", capture);
  };
  GroupComponent2.prototype.destroy = function() {
    this.removeEvent();
    this.remove();
    _super.prototype.destroy.call(this);
  };
  GroupComponent2.prototype.getBBox = function() {
    return this.get("group").getCanvasBBox();
  };
  GroupComponent2.prototype.getLayoutBBox = function() {
    var group2 = this.get("group");
    var bbox = this.getInnerLayoutBBox();
    var matrix = group2.getTotalMatrix();
    if (matrix) {
      bbox = applyMatrix2BBox(matrix, bbox);
    }
    return bbox;
  };
  GroupComponent2.prototype.on = function(evt, callback, once) {
    var group2 = this.get("group");
    group2.on(evt, callback, once);
    return this;
  };
  GroupComponent2.prototype.off = function(evt, callback) {
    var group2 = this.get("group");
    group2 && group2.off(evt, callback);
    return this;
  };
  GroupComponent2.prototype.emit = function(eventName, eventObject) {
    var group2 = this.get("group");
    group2.emit(eventName, eventObject);
  };
  GroupComponent2.prototype.init = function() {
    _super.prototype.init.call(this);
    if (!this.get("group")) {
      this.initGroup();
    }
    this.offScreenRender();
  };
  GroupComponent2.prototype.getInnerLayoutBBox = function() {
    return this.get("offScreenBBox") || this.get("group").getBBox();
  };
  GroupComponent2.prototype.delegateEmit = function(eventName, eventObject) {
    var group2 = this.get("group");
    eventObject.target = group2;
    group2.emit(eventName, eventObject);
    propagationDelegate(group2, eventName, eventObject);
  };
  GroupComponent2.prototype.createOffScreenGroup = function() {
    var group2 = this.get("group");
    var GroupClass = group2.getGroupBase();
    var newGroup = new GroupClass({
      delegateObject: this.getDelegateObject()
    });
    return newGroup;
  };
  GroupComponent2.prototype.applyOffset = function() {
    var offsetX = this.get("offsetX");
    var offsetY = this.get("offsetY");
    this.moveElementTo(this.get("group"), {
      x: offsetX,
      y: offsetY
    });
  };
  GroupComponent2.prototype.initGroup = function() {
    var container = this.get("container");
    this.set("group", container.addGroup({
      id: this.get("id"),
      name: this.get("name"),
      capture: this.get("capture"),
      visible: this.get("visible"),
      isComponent: true,
      component: this,
      delegateObject: this.getDelegateObject()
    }));
  };
  GroupComponent2.prototype.offScreenRender = function() {
    this.clearOffScreenCache();
    var offScreenGroup = this.createOffScreenGroup();
    this.renderInner(offScreenGroup);
    this.set("offScreenGroup", offScreenGroup);
    this.set("offScreenBBox", getBBoxWithClip(offScreenGroup));
    return offScreenGroup;
  };
  GroupComponent2.prototype.addGroup = function(parent, cfg) {
    this.appendDelegateObject(parent, cfg);
    var group2 = parent.addGroup(cfg);
    if (this.get("isRegister")) {
      this.registerElement(group2);
    }
    return group2;
  };
  GroupComponent2.prototype.addShape = function(parent, cfg) {
    this.appendDelegateObject(parent, cfg);
    var shape = parent.addShape(cfg);
    if (this.get("isRegister")) {
      this.registerElement(shape);
    }
    return shape;
  };
  GroupComponent2.prototype.addComponent = function(parent, cfg) {
    var id = cfg.id, Ctor = cfg.component, restCfg = __rest(cfg, ["id", "component"]);
    var inst = new Ctor(__assign(__assign({}, restCfg), { id, container: parent, updateAutoRender: this.get("updateAutoRender") }));
    inst.init();
    inst.render();
    if (this.get("isRegister")) {
      this.registerElement(inst.get("group"));
    }
    return inst;
  };
  GroupComponent2.prototype.initEvent = function() {
  };
  GroupComponent2.prototype.removeEvent = function() {
    var group2 = this.get("group");
    group2.off();
  };
  GroupComponent2.prototype.getElementId = function(localId) {
    var id = this.get("id");
    var name = this.get("name");
    return id + "-" + name + "-" + localId;
  };
  GroupComponent2.prototype.registerElement = function(element) {
    var id = element.get("id");
    this.get("shapesMap")[id] = element;
  };
  GroupComponent2.prototype.unregisterElement = function(element) {
    var id = element.get("id");
    delete this.get("shapesMap")[id];
  };
  GroupComponent2.prototype.moveElementTo = function(element, point) {
    var matrix = getMatrixByTranslate(point);
    element.attr("matrix", matrix);
  };
  GroupComponent2.prototype.addAnimation = function(elmentName, newElement, animateCfg) {
    var originOpacity = newElement.attr("opacity");
    if (is_nil_default(originOpacity)) {
      originOpacity = 1;
    }
    newElement.attr("opacity", 0);
    newElement.animate({ opacity: originOpacity }, animateCfg);
  };
  GroupComponent2.prototype.removeAnimation = function(elementName, originElement, animateCfg) {
    originElement.animate({ opacity: 0 }, animateCfg);
  };
  GroupComponent2.prototype.updateAnimation = function(elementName, originElement, newAttrs, animateCfg) {
    originElement.animate(newAttrs, animateCfg);
  };
  GroupComponent2.prototype.updateElements = function(newGroup, originGroup) {
    var _this = this;
    var animate = this.get("animate");
    var animateOption = this.get("animateOption");
    var children = newGroup.getChildren().slice(0);
    var preElement;
    each_default(children, function(element) {
      var elementId = element.get("id");
      var originElement = _this.getElementById(elementId);
      var elementName = element.get("name");
      if (originElement) {
        if (element.get("isComponent")) {
          var childComponent = element.get("component");
          var origChildComponent = originElement.get("component");
          var newCfg = pick_default(childComponent.cfg, difference_default(keys_default(childComponent.cfg), COPY_PROPERTIES_EXCLUDES));
          origChildComponent.update(newCfg);
          originElement.set(STATUS_UPDATE, "update");
        } else {
          var replaceAttrs = _this.getReplaceAttrs(originElement, element);
          if (animate && animateOption.update) {
            _this.updateAnimation(elementName, originElement, replaceAttrs, animateOption.update);
          } else {
            originElement.attr(replaceAttrs);
          }
          if (element.isGroup()) {
            _this.updateElements(element, originElement);
          }
          each_default(COPY_PROPERTIES, function(name) {
            originElement.set(name, element.get(name));
          });
          updateClip(originElement, element);
          preElement = originElement;
          originElement.set(STATUS_UPDATE, "update");
        }
      } else {
        originGroup.add(element);
        var siblings = originGroup.getChildren();
        siblings.splice(siblings.length - 1, 1);
        if (preElement) {
          var index = siblings.indexOf(preElement);
          siblings.splice(index + 1, 0, element);
        } else {
          siblings.unshift(element);
        }
        _this.registerElement(element);
        element.set(STATUS_UPDATE, "add");
        if (element.get("isComponent")) {
          var childComponent = element.get("component");
          childComponent.set("container", originGroup);
        } else if (element.isGroup()) {
          _this.registerNewGroup(element);
        }
        preElement = element;
        if (animate) {
          var animateCfg = _this.get("isInit") ? animateOption.appear : animateOption.enter;
          if (animateCfg) {
            _this.addAnimation(elementName, element, animateCfg);
          }
        }
      }
    });
  };
  GroupComponent2.prototype.clearUpdateStatus = function(group2) {
    var children = group2.getChildren();
    each_default(children, function(el) {
      el.set(STATUS_UPDATE, null);
    });
  };
  GroupComponent2.prototype.clearOffScreenCache = function() {
    var offScreenGroup = this.get("offScreenGroup");
    if (offScreenGroup) {
      offScreenGroup.destroy();
    }
    this.set("offScreenGroup", null);
    this.set("offScreenBBox", null);
  };
  GroupComponent2.prototype.getDelegateObject = function() {
    var _a3;
    var name = this.get("name");
    var delegateObject = (_a3 = {}, _a3[name] = this, _a3.component = this, _a3);
    return delegateObject;
  };
  GroupComponent2.prototype.appendDelegateObject = function(parent, cfg) {
    var parentObject = parent.get("delegateObject");
    if (!cfg.delegateObject) {
      cfg.delegateObject = {};
    }
    mix(cfg.delegateObject, parentObject);
  };
  GroupComponent2.prototype.getReplaceAttrs = function(originElement, newElement) {
    var originAttrs = originElement.attr();
    var newAttrs = newElement.attr();
    each_default(originAttrs, function(v, k) {
      if (newAttrs[k] === void 0) {
        newAttrs[k] = void 0;
      }
    });
    return newAttrs;
  };
  GroupComponent2.prototype.registerNewGroup = function(group2) {
    var _this = this;
    var children = group2.getChildren();
    each_default(children, function(element) {
      _this.registerElement(element);
      element.set(STATUS_UPDATE, "add");
      if (element.isGroup()) {
        _this.registerNewGroup(element);
      }
    });
  };
  GroupComponent2.prototype.deleteElements = function() {
    var _this = this;
    var shapesMap = this.get("shapesMap");
    var deleteArray = [];
    each_default(shapesMap, function(element, id) {
      if (!element.get(STATUS_UPDATE) || element.destroyed) {
        deleteArray.push([id, element]);
      } else {
        element.set(STATUS_UPDATE, null);
      }
    });
    var animate = this.get("animate");
    var animateOption = this.get("animateOption");
    each_default(deleteArray, function(item) {
      var id = item[0], element = item[1];
      if (!element.destroyed) {
        var elementName = element.get("name");
        if (animate && animateOption.leave) {
          var callbackAnimCfg = mix({
            callback: function() {
              _this.removeElement(element);
            }
          }, animateOption.leave);
          _this.removeAnimation(elementName, element, callbackAnimCfg);
        } else {
          _this.removeElement(element);
        }
      }
      delete shapesMap[id];
    });
  };
  GroupComponent2.prototype.removeElement = function(element) {
    if (element.get("isGroup")) {
      var component = element.get("component");
      if (component) {
        component.destroy();
      }
    }
    element.remove();
  };
  return GroupComponent2;
}(component_default);
var group_component_default = GroupComponent;

// node_modules/@antv/component/esm/util/text.js
var ELLIPSIS_CODE = "\u2026";
function strLen(str4) {
  var len3 = 0;
  for (var i = 0; i < str4.length; i++) {
    len3 += charAtLength(str4, i);
  }
  return len3;
}
function charAtLength(str4, i) {
  if (str4.charCodeAt(i) > 0 && str4.charCodeAt(i) < 128) {
    return 1;
  } else {
    return 2;
  }
}
function ellipsisString(str4, reseveLength, position) {
  if (position === void 0) {
    position = "tail";
  }
  var count = str4.length;
  var rst = "";
  if (position === "tail") {
    for (var i = 0, index = 0; i < reseveLength; ) {
      var charLength = charAtLength(str4, index);
      if (i + charLength <= reseveLength) {
        rst += str4[index];
        i += charAtLength(str4, index);
        index++;
      } else {
        break;
      }
    }
    rst += ELLIPSIS_CODE;
  } else if (position === "head") {
    for (var i = 0, index = count - 1; i < reseveLength; ) {
      var charLength = charAtLength(str4, index);
      if (i + charLength <= reseveLength) {
        rst += str4[index];
        i += charAtLength(str4, index);
        index--;
      } else {
        break;
      }
    }
    rst = ELLIPSIS_CODE + rst;
  } else {
    var startStr = "";
    var endStr = "";
    for (var i = 0, startIndex = 0, endIndex = count - 1; i < reseveLength; ) {
      var startCodeLen = charAtLength(str4, startIndex);
      var hasAdd = false;
      if (startCodeLen + i <= reseveLength) {
        startStr += str4[startIndex];
        startIndex++;
        i += startCodeLen;
        hasAdd = true;
      }
      var endCodeLen = charAtLength(str4, endIndex);
      if (endCodeLen + i <= reseveLength) {
        endStr = str4[endIndex] + endStr;
        i += endCodeLen;
        endIndex--;
        hasAdd = true;
      }
      if (!hasAdd) {
        break;
      }
    }
    rst = startStr + ELLIPSIS_CODE + endStr;
  }
  return rst;
}

// node_modules/@antv/component/esm/util/label.js
var ELLIPSIS_CODE2 = "\u2026";
var ELLIPSIS_CODE_LENGTH = 2;
var OPTIMIZE_THRESHOLD = 400;
function getMaxLabelWidthOptimized(labels) {
  var texts = labels.map(function(label) {
    var text = label.attr("text");
    return is_nil_default(text) ? "" : "" + text;
  });
  var maxLen = 0;
  var maxIdx = 0;
  for (var i = 0; i < texts.length; i += 1) {
    var len3 = 0;
    for (var j = 0; j <= texts[i].length; j += 1) {
      var code2 = texts[i].charCodeAt(j);
      if (code2 >= 19968 && code2 <= 40869) {
        len3 += 2;
      } else {
        len3 += 1;
      }
    }
    if (len3 > maxLen) {
      maxLen = len3;
      maxIdx = i;
    }
  }
  return labels[maxIdx].getBBox().width;
}
function getMaxLabelWidth(labels) {
  if (labels.length > OPTIMIZE_THRESHOLD) {
    return getMaxLabelWidthOptimized(labels);
  }
  var max3 = 0;
  each_default(labels, function(label) {
    var bbox = label.getBBox();
    var width = bbox.width;
    if (max3 < width) {
      max3 = width;
    }
  });
  return max3;
}
function getLabelLength(isVertical2, label) {
  var bbox = label.getCanvasBBox();
  return isVertical2 ? bbox.width : bbox.height;
}
function ellipsisLabel(isVertical2, label, limitLength, position) {
  var _a3;
  if (position === void 0) {
    position = "tail";
  }
  var text = (_a3 = label.attr("text")) !== null && _a3 !== void 0 ? _a3 : "";
  if (position === "tail") {
    var font = pick_default(label.attr(), ["fontSize", "fontFamily", "fontWeight", "fontStyle", "fontVariant"]);
    var ellipsisText = get_ellipsis_text_default(text, limitLength, font, "\u2026");
    if (text !== ellipsisText) {
      label.attr("text", ellipsisText);
      label.set("tip", text);
      return true;
    }
    label.set("tip", null);
    return false;
  }
  var labelLength = getLabelLength(isVertical2, label);
  var codeLength = strLen(text);
  var ellipsisFlag = false;
  if (limitLength < labelLength) {
    var reserveLength = Math.floor(limitLength / labelLength * codeLength) - ELLIPSIS_CODE_LENGTH;
    var newText = void 0;
    if (reserveLength >= 0) {
      newText = ellipsisString(text, reserveLength, position);
    } else {
      newText = ELLIPSIS_CODE2;
    }
    if (newText) {
      label.attr("text", newText);
      ellipsisFlag = true;
    }
  }
  if (ellipsisFlag) {
    label.set("tip", text);
  } else {
    label.set("tip", null);
  }
  return ellipsisFlag;
}

// node_modules/@antv/component/esm/util/graphic.js
function renderTag(container, tagCfg) {
  var x = tagCfg.x, y = tagCfg.y, content = tagCfg.content, style = tagCfg.style, id = tagCfg.id, name = tagCfg.name, rotate5 = tagCfg.rotate, maxLength = tagCfg.maxLength, autoEllipsis = tagCfg.autoEllipsis, isVertical2 = tagCfg.isVertical, ellipsisPosition = tagCfg.ellipsisPosition, background = tagCfg.background;
  var tagGroup = container.addGroup({
    id: id + "-group",
    name: name + "-group",
    attrs: {
      x,
      y
    }
  });
  var text = tagGroup.addShape({
    type: "text",
    id,
    name,
    attrs: __assign({ x: 0, y: 0, text: content }, style)
  });
  var padding = formatPadding(get_default(background, "padding", 0));
  if (maxLength && autoEllipsis) {
    var maxTextLength = maxLength - (padding[1] + padding[3]);
    ellipsisLabel(!isVertical2, text, maxTextLength, ellipsisPosition);
  }
  if (background) {
    var backgroundStyle = get_default(background, "style", {});
    var _a3 = text.getCanvasBBox(), minX = _a3.minX, minY = _a3.minY, width = _a3.width, height = _a3.height;
    var tagBg = tagGroup.addShape("rect", {
      id: id + "-bg",
      name: id + "-bg",
      attrs: __assign({ x: minX - padding[3], y: minY - padding[0], width: width + padding[1] + padding[3], height: height + padding[0] + padding[2] }, backgroundStyle)
    });
    tagBg.toBack();
  }
  applyTranslate(tagGroup, x, y);
  applyRotate(tagGroup, rotate5, x, y);
}

// node_modules/@antv/component/esm/util/theme.js
var theme_default = {
  fontFamily: '\n  BlinkMacSystemFont, "Segoe UI", Roboto,"Helvetica Neue",\n  Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei",\n  SimSun, "sans-serif"',
  textColor: "#2C3542",
  activeTextColor: "#333333",
  uncheckedColor: "#D8D8D8",
  lineColor: "#416180",
  regionColor: "#CCD7EB",
  verticalAxisRotate: -Math.PI / 4,
  horizontalAxisRotate: Math.PI / 4,
  descriptionIconStroke: "#fff",
  descriptionIconFill: "rgba(58, 73, 101, .25)"
};

// node_modules/@antv/component/esm/annotation/line.js
var LineAnnotation = function(_super) {
  __extends(LineAnnotation2, _super);
  function LineAnnotation2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  LineAnnotation2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign(__assign({}, cfg), { name: "annotation", type: "line", locationType: "region", start: null, end: null, style: {}, text: null, defaultCfg: {
      style: {
        fill: theme_default.textColor,
        fontSize: 12,
        textAlign: "center",
        textBaseline: "bottom",
        fontFamily: theme_default.fontFamily
      },
      text: {
        position: "center",
        autoRotate: true,
        content: null,
        offsetX: 0,
        offsetY: 0,
        style: {
          stroke: theme_default.lineColor,
          lineWidth: 1
        }
      }
    } });
  };
  LineAnnotation2.prototype.renderInner = function(group2) {
    this.renderLine(group2);
    if (this.get("text")) {
      this.renderLabel(group2);
    }
  };
  LineAnnotation2.prototype.renderLine = function(group2) {
    var start = this.get("start");
    var end = this.get("end");
    var style = this.get("style");
    this.addShape(group2, {
      type: "line",
      id: this.getElementId("line"),
      name: "annotation-line",
      attrs: __assign({ x1: start.x, y1: start.y, x2: end.x, y2: end.y }, style)
    });
  };
  LineAnnotation2.prototype.getLabelPoint = function(start, end, position) {
    var percent;
    if (position === "start") {
      percent = 0;
    } else if (position === "center") {
      percent = 0.5;
    } else if (is_string_default(position) && position.indexOf("%") !== -1) {
      percent = parseInt(position, 10) / 100;
    } else if (is_number_default(position)) {
      percent = position;
    } else {
      percent = 1;
    }
    if (percent > 1 || percent < 0) {
      percent = 1;
    }
    return {
      x: getValueByPercent(start.x, end.x, percent),
      y: getValueByPercent(start.y, end.y, percent)
    };
  };
  LineAnnotation2.prototype.renderLabel = function(group2) {
    var text = this.get("text");
    var start = this.get("start");
    var end = this.get("end");
    var position = text.position, content = text.content, style = text.style, offsetX = text.offsetX, offsetY = text.offsetY, autoRotate = text.autoRotate, maxLength = text.maxLength, autoEllipsis = text.autoEllipsis, ellipsisPosition = text.ellipsisPosition, background = text.background, _a3 = text.isVertical, isVertical2 = _a3 === void 0 ? false : _a3;
    var point = this.getLabelPoint(start, end, position);
    var x = point.x + offsetX;
    var y = point.y + offsetY;
    var cfg = {
      id: this.getElementId("line-text"),
      name: "annotation-line-text",
      x,
      y,
      content,
      style,
      maxLength,
      autoEllipsis,
      ellipsisPosition,
      background,
      isVertical: isVertical2
    };
    if (autoRotate) {
      var vector = [end.x - start.x, end.y - start.y];
      cfg.rotate = Math.atan2(vector[1], vector[0]);
    }
    renderTag(group2, cfg);
  };
  return LineAnnotation2;
}(group_component_default);
var line_default3 = LineAnnotation;

// node_modules/@antv/component/esm/annotation/text.js
var TextAnnotation = function(_super) {
  __extends(TextAnnotation2, _super);
  function TextAnnotation2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  TextAnnotation2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign(__assign({}, cfg), { name: "annotation", type: "text", locationType: "point", x: 0, y: 0, content: "", rotate: null, style: {}, background: null, maxLength: null, autoEllipsis: true, isVertical: false, ellipsisPosition: "tail", defaultCfg: {
      style: {
        fill: theme_default.textColor,
        fontSize: 12,
        textAlign: "center",
        textBaseline: "middle",
        fontFamily: theme_default.fontFamily
      }
    } });
  };
  TextAnnotation2.prototype.setLocation = function(location) {
    this.set("x", location.x);
    this.set("y", location.y);
    this.resetLocation();
  };
  TextAnnotation2.prototype.renderInner = function(group2) {
    var _a3 = this.getLocation(), x = _a3.x, y = _a3.y;
    var content = this.get("content");
    var style = this.get("style");
    var id = this.getElementId("text");
    var name = this.get("name") + "-text";
    var maxLength = this.get("maxLength");
    var autoEllipsis = this.get("autoEllipsis");
    var isVertical2 = this.get("isVertical");
    var ellipsisPosition = this.get("ellipsisPosition");
    var background = this.get("background");
    var rotate5 = this.get("rotate");
    var cfg = {
      id,
      name,
      x,
      y,
      content,
      style,
      maxLength,
      autoEllipsis,
      isVertical: isVertical2,
      ellipsisPosition,
      background,
      rotate: rotate5
    };
    renderTag(group2, cfg);
  };
  TextAnnotation2.prototype.resetLocation = function() {
    var textGroup = this.getElementByLocalId("text-group");
    if (textGroup) {
      var _a3 = this.getLocation(), x = _a3.x, y = _a3.y;
      var rotate5 = this.get("rotate");
      applyTranslate(textGroup, x, y);
      applyRotate(textGroup, rotate5, x, y);
    }
  };
  return TextAnnotation2;
}(group_component_default);
var text_default2 = TextAnnotation;

// node_modules/@antv/component/esm/annotation/arc.js
var ArcAnnotation = function(_super) {
  __extends(ArcAnnotation2, _super);
  function ArcAnnotation2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ArcAnnotation2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign(__assign({}, cfg), { name: "annotation", type: "arc", locationType: "circle", center: null, radius: 100, startAngle: -Math.PI / 2, endAngle: Math.PI * 3 / 2, style: {
      stroke: "#999",
      lineWidth: 1
    } });
  };
  ArcAnnotation2.prototype.renderInner = function(group2) {
    this.renderArc(group2);
  };
  ArcAnnotation2.prototype.getArcPath = function() {
    var _a3 = this.getLocation(), center = _a3.center, radius = _a3.radius, startAngle = _a3.startAngle, endAngle = _a3.endAngle;
    var startPoint = getCirclePoint(center, radius, startAngle);
    var endPoint = getCirclePoint(center, radius, endAngle);
    var largeFlag = endAngle - startAngle > Math.PI ? 1 : 0;
    var path = [["M", startPoint.x, startPoint.y]];
    if (endAngle - startAngle === Math.PI * 2) {
      var middlePoint = getCirclePoint(center, radius, startAngle + Math.PI);
      path.push(["A", radius, radius, 0, largeFlag, 1, middlePoint.x, middlePoint.y]);
      path.push(["A", radius, radius, 0, largeFlag, 1, endPoint.x, endPoint.y]);
    } else {
      path.push(["A", radius, radius, 0, largeFlag, 1, endPoint.x, endPoint.y]);
    }
    return path;
  };
  ArcAnnotation2.prototype.renderArc = function(group2) {
    var path = this.getArcPath();
    var style = this.get("style");
    this.addShape(group2, {
      type: "path",
      id: this.getElementId("arc"),
      name: "annotation-arc",
      attrs: __assign({ path }, style)
    });
  };
  return ArcAnnotation2;
}(group_component_default);
var arc_default2 = ArcAnnotation;

// node_modules/@antv/component/esm/annotation/region.js
var RegionAnnotation = function(_super) {
  __extends(RegionAnnotation2, _super);
  function RegionAnnotation2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  RegionAnnotation2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign(__assign({}, cfg), { name: "annotation", type: "region", locationType: "region", start: null, end: null, style: {}, defaultCfg: {
      style: {
        lineWidth: 0,
        fill: theme_default.regionColor,
        opacity: 0.4
      }
    } });
  };
  RegionAnnotation2.prototype.renderInner = function(group2) {
    this.renderRegion(group2);
  };
  RegionAnnotation2.prototype.renderRegion = function(group2) {
    var start = this.get("start");
    var end = this.get("end");
    var style = this.get("style");
    var bbox = regionToBBox({ start, end });
    this.addShape(group2, {
      type: "rect",
      id: this.getElementId("region"),
      name: "annotation-region",
      attrs: __assign({ x: bbox.x, y: bbox.y, width: bbox.width, height: bbox.height }, style)
    });
  };
  return RegionAnnotation2;
}(group_component_default);
var region_default = RegionAnnotation;

// node_modules/@antv/component/esm/annotation/image.js
var ImageAnnotation = function(_super) {
  __extends(ImageAnnotation2, _super);
  function ImageAnnotation2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ImageAnnotation2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign(__assign({}, cfg), { name: "annotation", type: "image", locationType: "region", start: null, end: null, src: null, style: {} });
  };
  ImageAnnotation2.prototype.renderInner = function(group2) {
    this.renderImage(group2);
  };
  ImageAnnotation2.prototype.getImageAttrs = function() {
    var start = this.get("start");
    var end = this.get("end");
    var style = this.get("style");
    var bbox = regionToBBox({ start, end });
    var src = this.get("src");
    return __assign({ x: bbox.x, y: bbox.y, img: src, width: bbox.width, height: bbox.height }, style);
  };
  ImageAnnotation2.prototype.renderImage = function(group2) {
    this.addShape(group2, {
      type: "image",
      id: this.getElementId("image"),
      name: "annotation-image",
      attrs: this.getImageAttrs()
    });
  };
  return ImageAnnotation2;
}(group_component_default);
var image_default = ImageAnnotation;

// node_modules/@antv/component/esm/annotation/data-marker.js
var DataMarkerAnnotation = function(_super) {
  __extends(DataMarkerAnnotation2, _super);
  function DataMarkerAnnotation2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  DataMarkerAnnotation2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign(__assign({}, cfg), { name: "annotation", type: "dataMarker", locationType: "point", x: 0, y: 0, point: {}, line: {}, text: {}, direction: "upward", autoAdjust: true, coordinateBBox: null, defaultCfg: {
      point: {
        display: true,
        style: {
          r: 3,
          fill: "#FFFFFF",
          stroke: "#1890FF",
          lineWidth: 2
        }
      },
      line: {
        display: true,
        length: 20,
        style: {
          stroke: theme_default.lineColor,
          lineWidth: 1
        }
      },
      text: {
        content: "",
        display: true,
        style: {
          fill: theme_default.textColor,
          opacity: 0.65,
          fontSize: 12,
          textAlign: "start",
          fontFamily: theme_default.fontFamily
        }
      }
    } });
  };
  DataMarkerAnnotation2.prototype.renderInner = function(group2) {
    if (get_default(this.get("line"), "display")) {
      this.renderLine(group2);
    }
    if (get_default(this.get("text"), "display")) {
      this.renderText(group2);
    }
    if (get_default(this.get("point"), "display")) {
      this.renderPoint(group2);
    }
    if (this.get("autoAdjust")) {
      this.autoAdjust(group2);
    }
  };
  DataMarkerAnnotation2.prototype.applyOffset = function() {
    this.moveElementTo(this.get("group"), {
      x: this.get("x") + this.get("offsetX"),
      y: this.get("y") + this.get("offsetY")
    });
  };
  DataMarkerAnnotation2.prototype.renderPoint = function(group2) {
    var point = this.getShapeAttrs().point;
    this.addShape(group2, {
      type: "circle",
      id: this.getElementId("point"),
      name: "annotation-point",
      attrs: point
    });
  };
  DataMarkerAnnotation2.prototype.renderLine = function(group2) {
    var line = this.getShapeAttrs().line;
    this.addShape(group2, {
      type: "path",
      id: this.getElementId("line"),
      name: "annotation-line",
      attrs: line
    });
  };
  DataMarkerAnnotation2.prototype.renderText = function(group2) {
    var textAttrs = this.getShapeAttrs().text;
    var x = textAttrs.x, y = textAttrs.y, text = textAttrs.text, style = __rest(textAttrs, ["x", "y", "text"]);
    var _a3 = this.get("text"), background = _a3.background, maxLength = _a3.maxLength, autoEllipsis = _a3.autoEllipsis, isVertival = _a3.isVertival, ellipsisPosition = _a3.ellipsisPosition;
    var tagCfg = {
      x,
      y,
      id: this.getElementId("text"),
      name: "annotation-text",
      content: text,
      style,
      background,
      maxLength,
      autoEllipsis,
      isVertival,
      ellipsisPosition
    };
    renderTag(group2, tagCfg);
  };
  DataMarkerAnnotation2.prototype.autoAdjust = function(group2) {
    var direction2 = this.get("direction");
    var x = this.get("x");
    var y = this.get("y");
    var lineLength = get_default(this.get("line"), "length", 0);
    var coordinateBBox = this.get("coordinateBBox");
    var _a3 = group2.getBBox(), minX = _a3.minX, maxX = _a3.maxX, minY = _a3.minY, maxY = _a3.maxY;
    var textGroup = group2.findById(this.getElementId("text-group"));
    var textShape = group2.findById(this.getElementId("text"));
    var lineShape = group2.findById(this.getElementId("line"));
    if (!coordinateBBox) {
      return;
    }
    if (textGroup) {
      if (x + minX <= coordinateBBox.minX) {
        var overflow = coordinateBBox.minX - (x + minX);
        applyTranslate(textGroup, textGroup.attr("x") + overflow, textGroup.attr("y"));
      }
      if (x + maxX >= coordinateBBox.maxX) {
        var overflow = x + maxX - coordinateBBox.maxX;
        applyTranslate(textGroup, textGroup.attr("x") - overflow, textGroup.attr("y"));
      }
    }
    if (direction2 === "upward" && y + minY <= coordinateBBox.minY || direction2 !== "upward" && y + maxY >= coordinateBBox.maxY) {
      var textBaseline = void 0;
      var factor = void 0;
      if (direction2 === "upward" && y + minY <= coordinateBBox.minY) {
        textBaseline = "top";
        factor = 1;
      } else {
        textBaseline = "bottom";
        factor = -1;
      }
      textShape.attr("textBaseline", textBaseline);
      if (lineShape) {
        lineShape.attr("path", [
          ["M", 0, 0],
          ["L", 0, lineLength * factor]
        ]);
      }
      applyTranslate(textGroup, textGroup.attr("x"), (lineLength + 2) * factor);
    }
  };
  DataMarkerAnnotation2.prototype.getShapeAttrs = function() {
    var lineDisplay = get_default(this.get("line"), "display");
    var pointStyle = get_default(this.get("point"), "style", {});
    var lineStyle = get_default(this.get("line"), "style", {});
    var textStyle2 = get_default(this.get("text"), "style", {});
    var direction2 = this.get("direction");
    var lineLength = lineDisplay ? get_default(this.get("line"), "length", 0) : 0;
    var factor = direction2 === "upward" ? -1 : 1;
    return {
      point: __assign({ x: 0, y: 0 }, pointStyle),
      line: __assign({ path: [
        ["M", 0, 0],
        ["L", 0, lineLength * factor]
      ] }, lineStyle),
      text: __assign({ x: 0, y: (lineLength + 2) * factor, text: get_default(this.get("text"), "content", ""), textBaseline: direction2 === "upward" ? "bottom" : "top" }, textStyle2)
    };
  };
  return DataMarkerAnnotation2;
}(group_component_default);
var data_marker_default = DataMarkerAnnotation;

// node_modules/@antv/component/esm/annotation/data-region.js
var DataRegionAnnotation = function(_super) {
  __extends(DataRegionAnnotation2, _super);
  function DataRegionAnnotation2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  DataRegionAnnotation2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign(__assign({}, cfg), { name: "annotation", type: "dataRegion", locationType: "points", points: [], lineLength: 0, region: {}, text: {}, defaultCfg: {
      region: {
        style: {
          lineWidth: 0,
          fill: theme_default.regionColor,
          opacity: 0.4
        }
      },
      text: {
        content: "",
        style: {
          textAlign: "center",
          textBaseline: "bottom",
          fontSize: 12,
          fill: theme_default.textColor,
          fontFamily: theme_default.fontFamily
        }
      }
    } });
  };
  DataRegionAnnotation2.prototype.renderInner = function(group2) {
    var regionStyle = get_default(this.get("region"), "style", {});
    var textStyle2 = get_default(this.get("text"), "style", {});
    var lineLength = this.get("lineLength") || 0;
    var points = this.get("points");
    if (!points.length) {
      return;
    }
    var bbox = pointsToBBox(points);
    var path = [];
    path.push(["M", points[0].x, bbox.minY - lineLength]);
    points.forEach(function(point) {
      path.push(["L", point.x, point.y]);
    });
    path.push(["L", points[points.length - 1].x, points[points.length - 1].y - lineLength]);
    this.addShape(group2, {
      type: "path",
      id: this.getElementId("region"),
      name: "annotation-region",
      attrs: __assign({ path }, regionStyle)
    });
    var textCfg = __assign({ id: this.getElementId("text"), name: "annotation-text", x: (bbox.minX + bbox.maxX) / 2, y: bbox.minY - lineLength }, this.get("text"));
    renderTag(group2, textCfg);
  };
  return DataRegionAnnotation2;
}(group_component_default);
var data_region_default = DataRegionAnnotation;

// node_modules/@antv/component/esm/annotation/region-filter.js
var RegionFilterAnnotation = function(_super) {
  __extends(RegionFilterAnnotation2, _super);
  function RegionFilterAnnotation2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  RegionFilterAnnotation2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign(__assign({}, cfg), { name: "annotation", type: "regionFilter", locationType: "region", start: null, end: null, color: null, shape: [] });
  };
  RegionFilterAnnotation2.prototype.renderInner = function(group2) {
    var _this = this;
    var start = this.get("start");
    var end = this.get("end");
    var layer = this.addGroup(group2, {
      id: this.getElementId("region-filter"),
      capture: false
    });
    each_default(this.get("shapes"), function(shape, shapeIdx) {
      var type = shape.get("type");
      var attrs = clone_default(shape.attr());
      _this.adjustShapeAttrs(attrs);
      _this.addShape(layer, {
        id: _this.getElementId("shape-" + type + "-" + shapeIdx),
        capture: false,
        type,
        attrs
      });
    });
    var clipBBox = regionToBBox({ start, end });
    layer.setClip({
      type: "rect",
      attrs: {
        x: clipBBox.minX,
        y: clipBBox.minY,
        width: clipBBox.width,
        height: clipBBox.height
      }
    });
  };
  RegionFilterAnnotation2.prototype.adjustShapeAttrs = function(attr) {
    var color2 = this.get("color");
    if (attr.fill) {
      attr.fill = attr.fillStyle = color2;
    }
    attr.stroke = attr.strokeStyle = color2;
  };
  return RegionFilterAnnotation2;
}(group_component_default);
var region_filter_default = RegionFilterAnnotation;

// node_modules/@antv/component/esm/annotation/shape.js
var ShapeAnnotation = function(_super) {
  __extends(ShapeAnnotation2, _super);
  function ShapeAnnotation2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ShapeAnnotation2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign(__assign({}, cfg), { name: "annotation", type: "shape", draw: noop_default });
  };
  ShapeAnnotation2.prototype.renderInner = function(group2) {
    var render = this.get("render");
    if (is_function_default(render)) {
      render(group2);
    }
  };
  return ShapeAnnotation2;
}(group_component_default);
var shape_default3 = ShapeAnnotation;

// node_modules/@antv/component/esm/abstract/html-component.js
var HtmlComponent = function(_super) {
  __extends(HtmlComponent2, _super);
  function HtmlComponent2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  HtmlComponent2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign(__assign({}, cfg), { container: null, containerTpl: "<div></div>", updateAutoRender: true, containerClassName: "", parent: null });
  };
  HtmlComponent2.prototype.getContainer = function() {
    return this.get("container");
  };
  HtmlComponent2.prototype.show = function() {
    var container = this.get("container");
    container.style.display = "";
    this.set("visible", true);
  };
  HtmlComponent2.prototype.hide = function() {
    var container = this.get("container");
    container.style.display = "none";
    this.set("visible", false);
  };
  HtmlComponent2.prototype.setCapture = function(capture) {
    var container = this.getContainer();
    var value = capture ? "auto" : "none";
    container.style.pointerEvents = value;
    this.set("capture", capture);
  };
  HtmlComponent2.prototype.getBBox = function() {
    var container = this.getContainer();
    var x = parseFloat(container.style.left) || 0;
    var y = parseFloat(container.style.top) || 0;
    return createBBox(x, y, container.clientWidth, container.clientHeight);
  };
  HtmlComponent2.prototype.clear = function() {
    var container = this.get("container");
    clearDom(container);
  };
  HtmlComponent2.prototype.destroy = function() {
    this.removeEvent();
    this.removeDom();
    _super.prototype.destroy.call(this);
  };
  HtmlComponent2.prototype.init = function() {
    _super.prototype.init.call(this);
    this.initContainer();
    this.initDom();
    this.resetStyles();
    this.applyStyles();
    this.initEvent();
    this.initCapture();
    this.initVisible();
  };
  HtmlComponent2.prototype.initCapture = function() {
    this.setCapture(this.get("capture"));
  };
  HtmlComponent2.prototype.initVisible = function() {
    if (!this.get("visible")) {
      this.hide();
    } else {
      this.show();
    }
  };
  HtmlComponent2.prototype.initDom = function() {
  };
  HtmlComponent2.prototype.initContainer = function() {
    var container = this.get("container");
    if (is_nil_default(container)) {
      container = this.createDom();
      var parent_1 = this.get("parent");
      if (is_string_default(parent_1)) {
        parent_1 = document.getElementById(parent_1);
        this.set("parent", parent_1);
      }
      parent_1.appendChild(container);
      if (this.get("containerId")) {
        container.setAttribute("id", this.get("containerId"));
      }
      this.set("container", container);
    } else if (is_string_default(container)) {
      container = document.getElementById(container);
      this.set("container", container);
    }
    if (!this.get("parent")) {
      this.set("parent", container.parentNode);
    }
  };
  HtmlComponent2.prototype.resetStyles = function() {
    var style = this.get("domStyles");
    var defaultStyles = this.get("defaultStyles");
    if (!style) {
      style = defaultStyles;
    } else {
      style = deep_mix_default({}, defaultStyles, style);
    }
    this.set("domStyles", style);
  };
  HtmlComponent2.prototype.applyStyles = function() {
    var domStyles = this.get("domStyles");
    if (!domStyles) {
      return;
    }
    var container = this.getContainer();
    this.applyChildrenStyles(container, domStyles);
    var containerClassName = this.get("containerClassName");
    if (containerClassName && hasClass(container, containerClassName)) {
      var containerCss = domStyles[containerClassName];
      modifyCSS(container, containerCss);
    }
  };
  HtmlComponent2.prototype.applyChildrenStyles = function(element, styles) {
    each_default(styles, function(style, name) {
      var elements = element.getElementsByClassName(name);
      each_default(elements, function(el) {
        modifyCSS(el, style);
      });
    });
  };
  HtmlComponent2.prototype.applyStyle = function(cssName, dom) {
    var domStyles = this.get("domStyles");
    modifyCSS(dom, domStyles[cssName]);
  };
  HtmlComponent2.prototype.createDom = function() {
    var containerTpl = this.get("containerTpl");
    return createDom(containerTpl);
  };
  HtmlComponent2.prototype.initEvent = function() {
  };
  HtmlComponent2.prototype.removeDom = function() {
    var container = this.get("container");
    container && container.parentNode && container.parentNode.removeChild(container);
  };
  HtmlComponent2.prototype.removeEvent = function() {
  };
  HtmlComponent2.prototype.updateInner = function(cfg) {
    if (has_key_default(cfg, "domStyles")) {
      this.resetStyles();
      this.applyStyles();
    }
    this.resetPosition();
  };
  HtmlComponent2.prototype.resetPosition = function() {
  };
  ;
  return HtmlComponent2;
}(component_default);
var html_component_default = HtmlComponent;

// node_modules/@antv/component/esm/annotation/html.js
var HtmlAnnotation = function(_super) {
  __extends(HtmlAnnotation2, _super);
  function HtmlAnnotation2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  HtmlAnnotation2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign(__assign({}, cfg), { name: "annotation", type: "html", locationType: "point", x: 0, y: 0, containerTpl: '<div class="g2-html-annotation" style="position:absolute"></div>', alignX: "left", alignY: "top", html: "", zIndex: 7 });
  };
  HtmlAnnotation2.prototype.render = function() {
    var container = this.getContainer();
    var html = this.get("html");
    clearDom(container);
    var rst = is_function_default(html) ? html(container) : html;
    if (is_element_default(rst)) {
      container.appendChild(rst);
    } else if (is_string_default(rst) || is_number_default(rst)) {
      var dom = createDom("" + rst);
      if (dom) {
        container.appendChild(dom);
      }
    }
    this.resetPosition();
  };
  HtmlAnnotation2.prototype.resetPosition = function() {
    var container = this.getContainer();
    var _a3 = this.getLocation(), x = _a3.x, y = _a3.y;
    var alignX = this.get("alignX");
    var alignY = this.get("alignY");
    var offsetX = this.get("offsetX");
    var offsetY = this.get("offsetY");
    var domWidth = getOuterWidth(container);
    var domHeight = getOuterHeight(container);
    var position = {
      x,
      y
    };
    if (alignX === "middle") {
      position.x -= Math.round(domWidth / 2);
    } else if (alignX === "right") {
      position.x -= Math.round(domWidth);
    }
    if (alignY === "middle") {
      position.y -= Math.round(domHeight / 2);
    } else if (alignY === "bottom") {
      position.y -= Math.round(domHeight);
    }
    if (offsetX) {
      position.x += offsetX;
    }
    if (offsetY) {
      position.y += offsetY;
    }
    modifyCSS(container, {
      position: "absolute",
      left: position.x + "px",
      top: position.y + "px",
      zIndex: this.get("zIndex")
    });
  };
  return HtmlAnnotation2;
}(html_component_default);
var html_default = HtmlAnnotation;

// node_modules/@antv/component/esm/axis/index.js
var axis_exports = {};
__export(axis_exports, {
  Base: () => base_default8,
  Circle: () => circle_default2,
  Line: () => line_default4
});

// node_modules/@antv/component/esm/util/state.js
function getStatesStyle(item, elementName, stateStyles) {
  var styleName = elementName + "Style";
  var styles = null;
  each_default(stateStyles, function(v, state) {
    if (item[state] && v[styleName]) {
      if (!styles) {
        styles = {};
      }
      mix(styles, v[styleName]);
    }
  });
  return styles;
}

// node_modules/@antv/component/esm/axis/base.js
var AxisBase = function(_super) {
  __extends(AxisBase2, _super);
  function AxisBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AxisBase2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign(__assign({}, cfg), {
      name: "axis",
      ticks: [],
      line: {},
      tickLine: {},
      subTickLine: null,
      title: null,
      label: {},
      verticalFactor: 1,
      verticalLimitLength: null,
      overlapOrder: ["autoRotate", "autoEllipsis", "autoHide"],
      tickStates: {},
      optimize: {},
      defaultCfg: {
        line: {
          style: {
            lineWidth: 1,
            stroke: theme_default.lineColor
          }
        },
        tickLine: {
          style: {
            lineWidth: 1,
            stroke: theme_default.lineColor
          },
          alignTick: true,
          length: 5,
          displayWithLabel: true
        },
        subTickLine: {
          style: {
            lineWidth: 1,
            stroke: theme_default.lineColor
          },
          count: 4,
          length: 2
        },
        label: {
          autoRotate: true,
          autoHide: false,
          autoEllipsis: false,
          style: {
            fontSize: 12,
            fill: theme_default.textColor,
            fontFamily: theme_default.fontFamily,
            fontWeight: "normal"
          },
          offset: 10,
          offsetX: 0,
          offsetY: 0
        },
        title: {
          autoRotate: true,
          spacing: 5,
          position: "center",
          style: {
            fontSize: 12,
            fill: theme_default.textColor,
            textBaseline: "middle",
            fontFamily: theme_default.fontFamily,
            textAlign: "center"
          },
          iconStyle: {
            fill: theme_default.descriptionIconFill,
            stroke: theme_default.descriptionIconStroke
          },
          description: ""
        },
        tickStates: {
          active: {
            labelStyle: {
              fontWeight: 500
            },
            tickLineStyle: {
              lineWidth: 2
            }
          },
          inactive: {
            labelStyle: {
              fill: theme_default.uncheckedColor
            }
          }
        },
        optimize: {
          enable: true,
          threshold: 400
        }
      },
      theme: {}
    });
  };
  AxisBase2.prototype.renderInner = function(group2) {
    if (this.get("line")) {
      this.drawLine(group2);
    }
    this.drawTicks(group2);
    if (this.get("title")) {
      this.drawTitle(group2);
    }
  };
  AxisBase2.prototype.isList = function() {
    return true;
  };
  AxisBase2.prototype.getItems = function() {
    return this.get("ticks");
  };
  AxisBase2.prototype.setItems = function(items) {
    this.update({
      ticks: items
    });
  };
  AxisBase2.prototype.updateItem = function(item, cfg) {
    mix(item, cfg);
    this.clear();
    this.render();
  };
  AxisBase2.prototype.clearItems = function() {
    var itemGroup = this.getElementByLocalId("label-group");
    itemGroup && itemGroup.clear();
  };
  AxisBase2.prototype.setItemState = function(item, state, value) {
    item[state] = value;
    this.updateTickStates(item);
  };
  AxisBase2.prototype.hasState = function(item, state) {
    return !!item[state];
  };
  AxisBase2.prototype.getItemStates = function(item) {
    var tickStates = this.get("tickStates");
    var rst = [];
    each_default(tickStates, function(v, k) {
      if (item[k]) {
        rst.push(k);
      }
    });
    return rst;
  };
  AxisBase2.prototype.clearItemsState = function(state) {
    var _this = this;
    var items = this.getItemsByState(state);
    each_default(items, function(item) {
      _this.setItemState(item, state, false);
    });
  };
  AxisBase2.prototype.getItemsByState = function(state) {
    var _this = this;
    var items = this.getItems();
    return filter_default(items, function(item) {
      return _this.hasState(item, state);
    });
  };
  AxisBase2.prototype.getSidePoint = function(point, offset) {
    var self2 = this;
    var vector = self2.getSideVector(offset, point);
    return {
      x: point.x + vector[0],
      y: point.y + vector[1]
    };
  };
  AxisBase2.prototype.getTextAnchor = function(vector) {
    var align;
    if (isNumberEqual(vector[0], 0)) {
      align = "center";
    } else if (vector[0] > 0) {
      align = "start";
    } else if (vector[0] < 0) {
      align = "end";
    }
    return align;
  };
  AxisBase2.prototype.getTextBaseline = function(vector) {
    var base;
    if (isNumberEqual(vector[1], 0)) {
      base = "middle";
    } else if (vector[1] > 0) {
      base = "top";
    } else if (vector[1] < 0) {
      base = "bottom";
    }
    return base;
  };
  AxisBase2.prototype.processOverlap = function(labelGroup) {
  };
  AxisBase2.prototype.drawLine = function(group2) {
    var path = this.getLinePath();
    var line = this.get("line");
    this.addShape(group2, {
      type: "path",
      id: this.getElementId("line"),
      name: "axis-line",
      attrs: mix({
        path
      }, line.style)
    });
  };
  AxisBase2.prototype.getTickLineItems = function(ticks) {
    var _this = this;
    var tickLineItems = [];
    var tickLine = this.get("tickLine");
    var alignTick = tickLine.alignTick;
    var tickLineLength = tickLine.length;
    var tickSegment = 1;
    var tickCount = ticks.length;
    if (tickCount >= 2) {
      tickSegment = ticks[1].value - ticks[0].value;
    }
    each_default(ticks, function(tick) {
      var point = tick.point;
      if (!alignTick) {
        point = _this.getTickPoint(tick.value - tickSegment / 2);
      }
      var endPoint = _this.getSidePoint(point, tickLineLength);
      tickLineItems.push({
        startPoint: point,
        tickValue: tick.value,
        endPoint,
        tickId: tick.id,
        id: "tickline-" + tick.id
      });
    });
    return tickLineItems;
  };
  AxisBase2.prototype.getSubTickLineItems = function(tickLineItems) {
    var subTickLineItems = [];
    var subTickLine = this.get("subTickLine");
    var subCount = subTickLine.count;
    var tickLineCount = tickLineItems.length;
    if (tickLineCount >= 2) {
      for (var i = 0; i < tickLineCount - 1; i++) {
        var pre = tickLineItems[i];
        var next = tickLineItems[i + 1];
        for (var j = 0; j < subCount; j++) {
          var percent = (j + 1) / (subCount + 1);
          var tickValue = (1 - percent) * pre.tickValue + percent * next.tickValue;
          var point = this.getTickPoint(tickValue);
          var endPoint = this.getSidePoint(point, subTickLine.length);
          subTickLineItems.push({
            startPoint: point,
            endPoint,
            tickValue,
            id: "sub-" + pre.id + "-" + j
          });
        }
      }
    }
    return subTickLineItems;
  };
  AxisBase2.prototype.getTickLineAttrs = function(tickItem, type, index, tickItems) {
    var style = this.get(type).style;
    var item = {
      points: [tickItem.startPoint, tickItem.endPoint]
    };
    var defaultTickLineStyle = get_default(this.get("theme"), ["tickLine", "style"], {});
    style = is_function_default(style) ? mix({}, defaultTickLineStyle, style(item, index, tickItems)) : style;
    var startPoint = tickItem.startPoint, endPoint = tickItem.endPoint;
    return __assign({ x1: startPoint.x, y1: startPoint.y, x2: endPoint.x, y2: endPoint.y }, style);
  };
  AxisBase2.prototype.drawTick = function(tickItem, tickLineGroup, type, index, tickItems) {
    this.addShape(tickLineGroup, {
      type: "line",
      id: this.getElementId(tickItem.id),
      name: "axis-" + type,
      attrs: this.getTickLineAttrs(tickItem, type, index, tickItems)
    });
  };
  AxisBase2.prototype.drawTickLines = function(group2) {
    var _this = this;
    var ticks = this.get("ticks");
    var subTickLine = this.get("subTickLine");
    var tickLineItems = this.getTickLineItems(ticks);
    var tickLineGroup = this.addGroup(group2, {
      name: "axis-tickline-group",
      id: this.getElementId("tickline-group")
    });
    var tickCfg = this.get("tickLine");
    each_default(tickLineItems, function(item, index) {
      if (tickCfg.displayWithLabel) {
        var labelId = _this.getElementId("label-" + item.tickId);
        if (group2.findById(labelId)) {
          _this.drawTick(item, tickLineGroup, "tickLine", index, tickLineItems);
        }
      } else {
        _this.drawTick(item, tickLineGroup, "tickLine", index, tickLineItems);
      }
    });
    if (subTickLine) {
      var subTickLineItems_1 = this.getSubTickLineItems(tickLineItems);
      each_default(subTickLineItems_1, function(item, index) {
        _this.drawTick(item, tickLineGroup, "subTickLine", index, subTickLineItems_1);
      });
    }
  };
  AxisBase2.prototype.processTicks = function() {
    var _this = this;
    var ticks = this.get("ticks");
    each_default(ticks, function(tick) {
      tick.point = _this.getTickPoint(tick.value);
      if (is_nil_default(tick.id)) {
        tick.id = tick.name;
      }
    });
  };
  AxisBase2.prototype.drawTicks = function(group2) {
    var _this = this;
    this.optimizeTicks();
    this.processTicks();
    if (this.get("label")) {
      this.drawLabels(group2);
    }
    if (this.get("tickLine")) {
      this.drawTickLines(group2);
    }
    var ticks = this.get("ticks");
    each_default(ticks, function(tick) {
      _this.applyTickStates(tick, group2);
    });
  };
  AxisBase2.prototype.optimizeTicks = function() {
    var optimize = this.get("optimize");
    var ticks = this.get("ticks");
    if (optimize && optimize.enable && optimize.threshold > 0) {
      var len3 = size(ticks);
      if (len3 > optimize.threshold) {
        var page_1 = Math.ceil(len3 / optimize.threshold);
        var optimizedTicks = ticks.filter(function(tick, idx) {
          return idx % page_1 === 0;
        });
        this.set("ticks", optimizedTicks);
        this.set("originalTicks", ticks);
      }
    }
  };
  AxisBase2.prototype.getLabelAttrs = function(tick, index, ticks) {
    var labelCfg = this.get("label");
    var offset = labelCfg.offset, offsetX = labelCfg.offsetX, offsetY = labelCfg.offsetY, rotate5 = labelCfg.rotate, formatter = labelCfg.formatter;
    var point = this.getSidePoint(tick.point, offset);
    var vector = this.getSideVector(offset, point);
    var text = formatter ? formatter(tick.name, tick, index) : tick.name;
    var style = labelCfg.style;
    style = is_function_default(style) ? get_default(this.get("theme"), ["label", "style"], {}) : style;
    var attrs = mix({
      x: point.x + offsetX,
      y: point.y + offsetY,
      text,
      textAlign: this.getTextAnchor(vector),
      textBaseline: this.getTextBaseline(vector)
    }, style);
    if (rotate5) {
      attrs.matrix = getMatrixByAngle(point, rotate5);
    }
    return attrs;
  };
  AxisBase2.prototype.drawLabels = function(group2) {
    var _this = this;
    var ticks = this.get("ticks");
    var labelGroup = this.addGroup(group2, {
      name: "axis-label-group",
      id: this.getElementId("label-group")
    });
    each_default(ticks, function(tick, index) {
      _this.addShape(labelGroup, {
        type: "text",
        name: "axis-label",
        id: _this.getElementId("label-" + tick.id),
        attrs: _this.getLabelAttrs(tick, index, ticks),
        delegateObject: {
          tick,
          item: tick,
          index
        }
      });
    });
    this.processOverlap(labelGroup);
    var labels = labelGroup.getChildren();
    var defaultLabelStyle = get_default(this.get("theme"), ["label", "style"], {});
    var _a3 = this.get("label"), style = _a3.style, formatter = _a3.formatter;
    if (is_function_default(style)) {
      var afterProcessTicks_1 = labels.map(function(label) {
        return get_default(label.get("delegateObject"), "tick");
      });
      each_default(labels, function(label, index) {
        var tick = label.get("delegateObject").tick;
        var text = formatter ? formatter(tick.name, tick, index) : tick.name;
        var newStyle = mix({}, defaultLabelStyle, style(text, index, afterProcessTicks_1));
        label.attr(newStyle);
      });
    }
  };
  AxisBase2.prototype.getTitleAttrs = function() {
    var titleCfg = this.get("title");
    var style = titleCfg.style, position = titleCfg.position, offset = titleCfg.offset, _a3 = titleCfg.spacing, spacing = _a3 === void 0 ? 0 : _a3, autoRotate = titleCfg.autoRotate;
    var titleHeight = style.fontSize;
    var percent = 0.5;
    if (position === "start") {
      percent = 0;
    } else if (position === "end") {
      percent = 1;
    }
    var point = this.getTickPoint(percent);
    var titlePoint = this.getSidePoint(point, offset || spacing + titleHeight / 2);
    var attrs = mix({
      x: titlePoint.x,
      y: titlePoint.y,
      text: titleCfg.text
    }, style);
    var rotate5 = titleCfg.rotate;
    var angle3 = rotate5;
    if (is_nil_default(rotate5) && autoRotate) {
      var vector = this.getAxisVector(point);
      var v1 = [1, 0];
      angle3 = ext_exports.angleTo(vector, v1, true);
    }
    if (angle3) {
      var matrix = getMatrixByAngle(titlePoint, angle3);
      attrs.matrix = matrix;
    }
    return attrs;
  };
  AxisBase2.prototype.drawTitle = function(group2) {
    var _a3;
    var titleAttrs = this.getTitleAttrs();
    var titleShape = this.addShape(group2, {
      type: "text",
      id: this.getElementId("title"),
      name: "axis-title",
      attrs: titleAttrs
    });
    if ((_a3 = this.get("title")) === null || _a3 === void 0 ? void 0 : _a3.description) {
      this.drawDescriptionIcon(group2, titleShape, titleAttrs.matrix);
    }
  };
  AxisBase2.prototype.drawDescriptionIcon = function(group2, titleShape, matrix) {
    var descriptionShape = this.addGroup(group2, {
      name: "axis-description",
      id: this.getElementById("description")
    });
    var _a3 = titleShape.getBBox(), maxX = _a3.maxX, maxY = _a3.maxY, height = _a3.height;
    var iconStyle = this.get("title").iconStyle;
    var spacing = 4;
    var r = height / 2;
    var lineWidth = r / 6;
    var startX = maxX + spacing;
    var startY = maxY - height / 2;
    var _b = [startX + r, startY - r], x0 = _b[0], y0 = _b[1];
    var _c = [x0 + r, y0 + r], x1 = _c[0], y1 = _c[1];
    var _d = [x0, y1 + r], x2 = _d[0], y2 = _d[1];
    var _e = [startX, y0 + r], x3 = _e[0], y3 = _e[1];
    var _f = [startX + r, startY - height / 4], x4 = _f[0], y4 = _f[1];
    var _g = [x4, y4 + lineWidth], x5 = _g[0], y5 = _g[1];
    var _h = [x5, y5 + lineWidth], x6 = _h[0], y6 = _h[1];
    var _j = [x6, y6 + r * 3 / 4], x7 = _j[0], y7 = _j[1];
    this.addShape(descriptionShape, {
      type: "path",
      id: this.getElementId("title-description-icon"),
      name: "axis-title-description-icon",
      attrs: __assign({
        path: [
          ["M", x0, y0],
          ["A", r, r, 0, 0, 1, x1, y1],
          ["A", r, r, 0, 0, 1, x2, y2],
          ["A", r, r, 0, 0, 1, x3, y3],
          ["A", r, r, 0, 0, 1, x0, y0],
          ["M", x4, y4],
          ["L", x5, y5],
          ["M", x6, y6],
          ["L", x7, y7]
        ],
        lineWidth,
        matrix
      }, iconStyle)
    });
    this.addShape(descriptionShape, {
      type: "rect",
      id: this.getElementId("title-description-rect"),
      name: "axis-title-description-rect",
      attrs: {
        x: startX,
        y: startY - height / 2,
        width: height,
        height,
        stroke: "#000",
        fill: "#000",
        opacity: 0,
        matrix,
        cursor: "pointer"
      }
    });
  };
  AxisBase2.prototype.applyTickStates = function(tick, group2) {
    var states = this.getItemStates(tick);
    if (states.length) {
      var tickStates = this.get("tickStates");
      var labelId = this.getElementId("label-" + tick.id);
      var labelShape = group2.findById(labelId);
      if (labelShape) {
        var labelStateStyle = getStatesStyle(tick, "label", tickStates);
        labelStateStyle && labelShape.attr(labelStateStyle);
      }
      var tickLineId = this.getElementId("tickline-" + tick.id);
      var tickLineShape = group2.findById(tickLineId);
      if (tickLineShape) {
        var tickLineStateStyle = getStatesStyle(tick, "tickLine", tickStates);
        tickLineStateStyle && tickLineShape.attr(tickLineStateStyle);
      }
    }
  };
  AxisBase2.prototype.updateTickStates = function(tick) {
    var states = this.getItemStates(tick);
    var tickStates = this.get("tickStates");
    var labelCfg = this.get("label");
    var labelShape = this.getElementByLocalId("label-" + tick.id);
    var tickLineCfg = this.get("tickLine");
    var tickLineShape = this.getElementByLocalId("tickline-" + tick.id);
    if (states.length) {
      if (labelShape) {
        var labelStateStyle = getStatesStyle(tick, "label", tickStates);
        labelStateStyle && labelShape.attr(labelStateStyle);
      }
      if (tickLineShape) {
        var tickLineStateStyle = getStatesStyle(tick, "tickLine", tickStates);
        tickLineStateStyle && tickLineShape.attr(tickLineStateStyle);
      }
    } else {
      if (labelShape) {
        labelShape.attr(labelCfg.style);
      }
      if (tickLineShape) {
        tickLineShape.attr(tickLineCfg.style);
      }
    }
  };
  return AxisBase2;
}(group_component_default);
var base_default8 = AxisBase;

// node_modules/@antv/component/esm/axis/overlap/index.js
var overlap_exports = {};
__export(overlap_exports, {
  autoEllipsis: () => auto_ellipsis_exports,
  autoHide: () => auto_hide_exports,
  autoRotate: () => auto_rotate_exports
});

// node_modules/@antv/component/esm/axis/overlap/auto-ellipsis.js
var auto_ellipsis_exports = {};
__export(auto_ellipsis_exports, {
  ellipsisHead: () => ellipsisHead,
  ellipsisMiddle: () => ellipsisMiddle,
  ellipsisTail: () => ellipsisTail,
  getDefault: () => getDefault
});
function ellipseLabels(isVertical2, labelGroup, limitLength, position) {
  var children = labelGroup.getChildren();
  var ellipsisFlag = false;
  each_default(children, function(label) {
    var rst = ellipsisLabel(isVertical2, label, limitLength, position);
    ellipsisFlag = ellipsisFlag || rst;
  });
  return ellipsisFlag;
}
function getDefault() {
  return ellipsisTail;
}
function ellipsisHead(isVertical2, labelGroup, limitLength) {
  return ellipseLabels(isVertical2, labelGroup, limitLength, "head");
}
function ellipsisTail(isVertical2, labelGroup, limitLength) {
  return ellipseLabels(isVertical2, labelGroup, limitLength, "tail");
}
function ellipsisMiddle(isVertical2, labelGroup, limitLength) {
  return ellipseLabels(isVertical2, labelGroup, limitLength, "middle");
}

// node_modules/@antv/component/esm/axis/overlap/auto-hide.js
var auto_hide_exports = {};
__export(auto_hide_exports, {
  equidistance: () => equidistance,
  equidistanceWithReverseBoth: () => equidistanceWithReverseBoth,
  getDefault: () => getDefault2,
  reserveBoth: () => reserveBoth,
  reserveFirst: () => reserveFirst,
  reserveLast: () => reserveLast
});
function isRotate(label) {
  var matrix = label.attr("matrix");
  return matrix && matrix[0] !== 1;
}
function getRotateAngle(label) {
  var angle3 = isRotate(label) ? getAngleByMatrix(label.attr("matrix")) : 0;
  return angle3 % 360;
}
function isOverlap(isVertical2, first, second, minGap) {
  var overlap2 = false;
  var angle3 = getRotateAngle(first);
  var distance8 = isVertical2 ? Math.abs(second.attr("y") - first.attr("y")) : Math.abs(second.attr("x") - first.attr("x"));
  var prevBBox = (isVertical2 ? second.attr("y") > first.attr("y") : second.attr("x") > first.attr("x")) ? first.getBBox() : second.getBBox();
  if (isVertical2) {
    var ratio = Math.abs(Math.cos(angle3));
    if (near(ratio, 0, Math.PI / 180)) {
      overlap2 = prevBBox.width + minGap > distance8;
    } else {
      overlap2 = prevBBox.height / ratio + minGap > distance8;
    }
  } else {
    var ratio = Math.abs(Math.sin(angle3));
    if (near(ratio, 0, Math.PI / 180)) {
      overlap2 = prevBBox.width + minGap > distance8;
    } else {
      overlap2 = prevBBox.height / ratio + minGap > distance8;
    }
  }
  return overlap2;
}
function reserveOne(isVertical2, labelsGroup, reversed, autoHideCfg) {
  var minGap = (autoHideCfg === null || autoHideCfg === void 0 ? void 0 : autoHideCfg.minGap) || 0;
  var labels = labelsGroup.getChildren().slice().filter(function(item) {
    return item.get("visible");
  });
  if (!labels.length) {
    return false;
  }
  var hasHide = false;
  if (reversed) {
    labels.reverse();
  }
  var count = labels.length;
  var first = labels[0];
  var prev = first;
  for (var i = 1; i < count; i++) {
    var label = labels[i];
    var curBBox = label.getBBox();
    var isHide = isOverlap(isVertical2, prev, label, minGap);
    if (isHide) {
      label.hide();
      hasHide = true;
    } else {
      prev = label;
    }
  }
  return hasHide;
}
function parityHide(isVertical2, labelsGroup, autoHideCfg) {
  var minGap = (autoHideCfg === null || autoHideCfg === void 0 ? void 0 : autoHideCfg.minGap) || 0;
  var labels = labelsGroup.getChildren().slice();
  if (labels.length < 2) {
    return false;
  }
  var hasHide = false;
  var first = labels[0];
  var firstBBox = first.getBBox();
  var second = labels[1];
  var count = labels.length;
  var angle3 = getRotateAngle(first);
  var distance8 = isVertical2 ? Math.abs(second.attr("y") - first.attr("y")) : Math.abs(second.attr("x") - first.attr("x"));
  var interval2 = 0;
  if (isVertical2) {
    var ratio = Math.abs(Math.cos(angle3));
    if (near(ratio, 0, Math.PI / 180)) {
      var maxWidth = getMaxLabelWidth(labels);
      interval2 = (maxWidth + minGap) / distance8;
    } else {
      interval2 = (firstBBox.height / ratio + minGap) / distance8;
    }
  } else {
    var ratio = Math.abs(Math.sin(angle3));
    if (near(ratio, 0, Math.PI / 180)) {
      var maxWidth = getMaxLabelWidth(labels);
      interval2 = (maxWidth + minGap) / distance8;
    } else {
      interval2 = (firstBBox.height / ratio + minGap) / distance8;
    }
  }
  if (interval2 > 1) {
    interval2 = Math.ceil(interval2);
    for (var i = 0; i < count; i++) {
      if (i % interval2 !== 0) {
        labels[i].hide();
        hasHide = true;
      }
    }
  }
  return hasHide;
}
function getDefault2() {
  return equidistance;
}
function reserveFirst(isVertical2, labelsGroup, limitLength, autoHideCfg) {
  return reserveOne(isVertical2, labelsGroup, false, autoHideCfg);
}
function reserveLast(isVertical2, labelsGroup, limitLength, autoHideCfg) {
  return reserveOne(isVertical2, labelsGroup, true, autoHideCfg);
}
function reserveBoth(isVertical2, labelsGroup, limitLength, autoHideCfg) {
  var minGap = (autoHideCfg === null || autoHideCfg === void 0 ? void 0 : autoHideCfg.minGap) || 0;
  var labels = labelsGroup.getChildren().slice();
  if (labels.length <= 2) {
    return false;
  }
  var hasHide = false;
  var count = labels.length;
  var first = labels[0];
  var last2 = labels[count - 1];
  var preLabel = first;
  for (var i = 1; i < count - 1; i++) {
    var label = labels[i];
    var curBBox = label.getBBox();
    var isHide = isOverlap(isVertical2, preLabel, label, minGap);
    if (isHide) {
      label.hide();
      hasHide = true;
    } else {
      preLabel = label;
    }
  }
  var overlap2 = isOverlap(isVertical2, preLabel, last2, minGap);
  if (overlap2) {
    preLabel.hide();
    hasHide = true;
  }
  return hasHide;
}
function equidistance(isVertical2, labelsGroup, limitLength, autoHideCfg) {
  var hasHide = parityHide(isVertical2, labelsGroup, autoHideCfg);
  if (reserveOne(isVertical2, labelsGroup, false)) {
    hasHide = true;
  }
  return hasHide;
}
function equidistanceWithReverseBoth(isVertical2, labelsGroup, limitLength, autoHideCfg) {
  var labels = labelsGroup.getChildren().slice();
  var hasHide = parityHide(isVertical2, labelsGroup, autoHideCfg);
  if (labels.length > 2) {
    var first = labels[0];
    var last2 = labels[labels.length - 1];
    if (!first.get("visible")) {
      first.show();
      if (reserveOne(isVertical2, labelsGroup, false, autoHideCfg)) {
        hasHide = true;
      }
    }
    if (!last2.get("visible")) {
      last2.show();
      if (reserveOne(isVertical2, labelsGroup, true, autoHideCfg)) {
        hasHide = true;
      }
    }
  }
  return hasHide;
}

// node_modules/@antv/component/esm/axis/overlap/auto-rotate.js
var auto_rotate_exports = {};
__export(auto_rotate_exports, {
  fixedAngle: () => fixedAngle,
  getDefault: () => getDefault3,
  unfixedAngle: () => unfixedAngle
});
function setLabelsAngle(labels, angle3) {
  each_default(labels, function(label) {
    var x = label.attr("x");
    var y = label.attr("y");
    var matrix = getMatrixByAngle({ x, y }, angle3);
    label.attr("matrix", matrix);
  });
}
function labelRotate(isVertical2, labelsGroup, limitLength, getAngle4) {
  var labels = labelsGroup.getChildren();
  if (!labels.length) {
    return false;
  }
  if (!isVertical2 && labels.length < 2) {
    return false;
  }
  var maxWidth = getMaxLabelWidth(labels);
  var isOverlap2 = false;
  if (isVertical2) {
    isOverlap2 = !!limitLength && maxWidth > limitLength;
  } else {
    var tickWidth = Math.abs(labels[1].attr("x") - labels[0].attr("x"));
    isOverlap2 = maxWidth > tickWidth;
  }
  if (isOverlap2) {
    var angle3 = getAngle4(limitLength, maxWidth);
    setLabelsAngle(labels, angle3);
  }
  return isOverlap2;
}
function getDefault3() {
  return fixedAngle;
}
function fixedAngle(isVertical2, labelsGroup, limitLength, customRotate) {
  return labelRotate(isVertical2, labelsGroup, limitLength, function() {
    if (is_number_default(customRotate)) {
      return customRotate;
    }
    return isVertical2 ? theme_default.verticalAxisRotate : theme_default.horizontalAxisRotate;
  });
}
function unfixedAngle(isVertical2, labelsGroup, limitLength) {
  return labelRotate(isVertical2, labelsGroup, limitLength, function(length5, maxWidth) {
    if (!length5) {
      return isVertical2 ? theme_default.verticalAxisRotate : theme_default.horizontalAxisRotate;
    }
    if (isVertical2) {
      return -Math.acos(length5 / maxWidth);
    } else {
      var angle3 = 0;
      if (length5 > maxWidth) {
        angle3 = Math.PI / 4;
      } else {
        angle3 = Math.asin(length5 / maxWidth);
        if (angle3 > Math.PI / 4) {
          angle3 = Math.PI / 4;
        }
      }
      return angle3;
    }
  });
}

// node_modules/@antv/component/esm/axis/line.js
var Line = function(_super) {
  __extends(Line6, _super);
  function Line6() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Line6.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign(__assign({}, cfg), {
      type: "line",
      locationType: "region",
      start: null,
      end: null
    });
  };
  Line6.prototype.getLinePath = function() {
    var start = this.get("start");
    var end = this.get("end");
    var path = [];
    path.push(["M", start.x, start.y]);
    path.push(["L", end.x, end.y]);
    return path;
  };
  Line6.prototype.getInnerLayoutBBox = function() {
    var start = this.get("start");
    var end = this.get("end");
    var bbox = _super.prototype.getInnerLayoutBBox.call(this);
    var minX = Math.min(start.x, end.x, bbox.x);
    var minY = Math.min(start.y, end.y, bbox.y);
    var maxX = Math.max(start.x, end.x, bbox.maxX);
    var maxY = Math.max(start.y, end.y, bbox.maxY);
    return {
      x: minX,
      y: minY,
      minX,
      minY,
      maxX,
      maxY,
      width: maxX - minX,
      height: maxY - minY
    };
  };
  Line6.prototype.isVertical = function() {
    var start = this.get("start");
    var end = this.get("end");
    return isNumberEqual(start.x, end.x);
  };
  Line6.prototype.isHorizontal = function() {
    var start = this.get("start");
    var end = this.get("end");
    return isNumberEqual(start.y, end.y);
  };
  Line6.prototype.getTickPoint = function(tickValue) {
    var self2 = this;
    var start = self2.get("start");
    var end = self2.get("end");
    var regionX = end.x - start.x;
    var regionY = end.y - start.y;
    return {
      x: start.x + regionX * tickValue,
      y: start.y + regionY * tickValue
    };
  };
  Line6.prototype.getSideVector = function(offset) {
    var axisVector = this.getAxisVector();
    var normal = vec2_exports.normalize([0, 0], axisVector);
    var factor = this.get("verticalFactor");
    var verticalVector = [normal[1], normal[0] * -1];
    return vec2_exports.scale([0, 0], verticalVector, offset * factor);
  };
  Line6.prototype.getAxisVector = function() {
    var start = this.get("start");
    var end = this.get("end");
    return [end.x - start.x, end.y - start.y];
  };
  Line6.prototype.processOverlap = function(labelGroup) {
    var _this = this;
    var isVertical2 = this.isVertical();
    var isHorizontal = this.isHorizontal();
    if (!isVertical2 && !isHorizontal) {
      return;
    }
    var labelCfg = this.get("label");
    var titleCfg = this.get("title");
    var verticalLimitLength = this.get("verticalLimitLength");
    var labelOffset = labelCfg.offset;
    var limitLength = verticalLimitLength;
    var titleHeight = 0;
    var titleSpacing = 0;
    if (titleCfg) {
      titleHeight = titleCfg.style.fontSize;
      titleSpacing = titleCfg.spacing;
    }
    if (limitLength) {
      limitLength = limitLength - labelOffset - titleSpacing - titleHeight;
    }
    var overlapOrder = this.get("overlapOrder");
    each_default(overlapOrder, function(name) {
      if (labelCfg[name] && _this.canProcessOverlap(name)) {
        _this.autoProcessOverlap(name, labelCfg[name], labelGroup, limitLength);
      }
    });
    if (titleCfg) {
      if (is_nil_default(titleCfg.offset)) {
        var bbox = labelGroup.getCanvasBBox();
        var length_1 = isVertical2 ? bbox.width : bbox.height;
        titleCfg.offset = labelOffset + length_1 + titleSpacing + titleHeight / 2;
      }
    }
  };
  Line6.prototype.canProcessOverlap = function(name) {
    var labelCfg = this.get("label");
    if (name === "autoRotate") {
      return is_nil_default(labelCfg.rotate);
    }
    return true;
  };
  Line6.prototype.autoProcessOverlap = function(name, value, labelGroup, limitLength) {
    var _this = this;
    var isVertical2 = this.isVertical();
    var hasAdjusted = false;
    var util = overlap_exports[name];
    if (value === true) {
      var labelCfg = this.get("label");
      hasAdjusted = util.getDefault()(isVertical2, labelGroup, limitLength);
    } else if (is_function_default(value)) {
      hasAdjusted = value(isVertical2, labelGroup, limitLength);
    } else if (is_object_default(value)) {
      var overlapCfg = value;
      if (util[overlapCfg.type]) {
        hasAdjusted = util[overlapCfg.type](isVertical2, labelGroup, limitLength, overlapCfg.cfg);
      }
    } else if (util[value]) {
      hasAdjusted = util[value](isVertical2, labelGroup, limitLength);
    }
    if (name === "autoRotate") {
      if (hasAdjusted) {
        var labels = labelGroup.getChildren();
        var verticalFactor_1 = this.get("verticalFactor");
        each_default(labels, function(label) {
          var textAlign = label.attr("textAlign");
          if (textAlign === "center") {
            var newAlign = verticalFactor_1 > 0 ? "end" : "start";
            label.attr("textAlign", newAlign);
          }
        });
      }
    } else if (name === "autoHide") {
      var children = labelGroup.getChildren().slice(0);
      each_default(children, function(label) {
        if (!label.get("visible")) {
          if (_this.get("isRegister")) {
            _this.unregisterElement(label);
          }
          label.remove();
        }
      });
    }
  };
  return Line6;
}(base_default8);
var line_default4 = Line;

// node_modules/@antv/component/esm/axis/circle.js
var Circle = function(_super) {
  __extends(Circle6, _super);
  function Circle6() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Circle6.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign(__assign({}, cfg), { type: "circle", locationType: "circle", center: null, radius: null, startAngle: -Math.PI / 2, endAngle: Math.PI * 3 / 2 });
  };
  Circle6.prototype.getLinePath = function() {
    var center = this.get("center");
    var x = center.x;
    var y = center.y;
    var rx = this.get("radius");
    var ry = rx;
    var startAngle = this.get("startAngle");
    var endAngle = this.get("endAngle");
    var path = [];
    if (Math.abs(endAngle - startAngle) === Math.PI * 2) {
      path = [["M", x, y - ry], ["A", rx, ry, 0, 1, 1, x, y + ry], ["A", rx, ry, 0, 1, 1, x, y - ry], ["Z"]];
    } else {
      var startPoint = this.getCirclePoint(startAngle);
      var endPoint = this.getCirclePoint(endAngle);
      var large = Math.abs(endAngle - startAngle) > Math.PI ? 1 : 0;
      var sweep = startAngle > endAngle ? 0 : 1;
      path = [
        ["M", x, y],
        ["L", startPoint.x, startPoint.y],
        ["A", rx, ry, 0, large, sweep, endPoint.x, endPoint.y],
        ["L", x, y]
      ];
    }
    return path;
  };
  Circle6.prototype.getTickPoint = function(tickValue) {
    var startAngle = this.get("startAngle");
    var endAngle = this.get("endAngle");
    var angle3 = startAngle + (endAngle - startAngle) * tickValue;
    return this.getCirclePoint(angle3);
  };
  Circle6.prototype.getSideVector = function(offset, point) {
    var center = this.get("center");
    var vector = [point.x - center.x, point.y - center.y];
    var factor = this.get("verticalFactor");
    var vecLen = vec2_exports.length(vector);
    vec2_exports.scale(vector, vector, factor * offset / vecLen);
    return vector;
  };
  Circle6.prototype.getAxisVector = function(point) {
    var center = this.get("center");
    var vector = [point.x - center.x, point.y - center.y];
    return [vector[1], -1 * vector[0]];
  };
  Circle6.prototype.getCirclePoint = function(angle3, radius) {
    var center = this.get("center");
    radius = radius || this.get("radius");
    return {
      x: center.x + Math.cos(angle3) * radius,
      y: center.y + Math.sin(angle3) * radius
    };
  };
  Circle6.prototype.canProcessOverlap = function(name) {
    var labelCfg = this.get("label");
    if (name === "autoRotate") {
      return is_nil_default(labelCfg.rotate);
    }
    return true;
  };
  Circle6.prototype.processOverlap = function(labelGroup) {
    var _this = this;
    var labelCfg = this.get("label");
    var titleCfg = this.get("title");
    var verticalLimitLength = this.get("verticalLimitLength");
    var labelOffset = labelCfg.offset;
    var limitLength = verticalLimitLength;
    var titleHeight = 0;
    var titleSpacing = 0;
    if (titleCfg) {
      titleHeight = titleCfg.style.fontSize;
      titleSpacing = titleCfg.spacing;
    }
    if (limitLength) {
      limitLength = limitLength - labelOffset - titleSpacing - titleHeight;
    }
    var overlapOrder = this.get("overlapOrder");
    each_default(overlapOrder, function(name) {
      if (labelCfg[name] && _this.canProcessOverlap(name)) {
        _this.autoProcessOverlap(name, labelCfg[name], labelGroup, limitLength);
      }
    });
    if (titleCfg) {
      if (is_nil_default(titleCfg.offset)) {
        var length_1 = labelGroup.getCanvasBBox().height;
        titleCfg.offset = labelOffset + length_1 + titleSpacing + titleHeight / 2;
      }
    }
  };
  Circle6.prototype.autoProcessOverlap = function(name, value, labelGroup, limitLength) {
    var _this = this;
    var hasAdjusted = false;
    var util = overlap_exports[name];
    if (limitLength > 0) {
      if (value === true) {
        hasAdjusted = util.getDefault()(false, labelGroup, limitLength);
      } else if (is_function_default(value)) {
        hasAdjusted = value(false, labelGroup, limitLength);
      } else if (is_object_default(value)) {
        var overlapCfg = value;
        if (util[overlapCfg.type]) {
          hasAdjusted = util[overlapCfg.type](false, labelGroup, limitLength, overlapCfg.cfg);
        }
      } else if (util[value]) {
        hasAdjusted = util[value](false, labelGroup, limitLength);
      }
    }
    if (name === "autoRotate") {
      if (hasAdjusted) {
        var labels = labelGroup.getChildren();
        var verticalFactor_1 = this.get("verticalFactor");
        each_default(labels, function(label) {
          var textAlign = label.attr("textAlign");
          if (textAlign === "center") {
            var newAlign = verticalFactor_1 > 0 ? "end" : "start";
            label.attr("textAlign", newAlign);
          }
        });
      }
    } else if (name === "autoHide") {
      var children = labelGroup.getChildren().slice(0);
      each_default(children, function(label) {
        if (!label.get("visible")) {
          if (_this.get("isRegister")) {
            _this.unregisterElement(label);
          }
          label.remove();
        }
      });
    }
  };
  return Circle6;
}(base_default8);
var circle_default2 = Circle;

// node_modules/@antv/component/esm/crosshair/index.js
var crosshair_exports = {};
__export(crosshair_exports, {
  Base: () => base_default9,
  Circle: () => circle_default3,
  Html: () => html_default2,
  Line: () => line_default5
});

// node_modules/@antv/component/esm/crosshair/base.js
var CrosshairBase = function(_super) {
  __extends(CrosshairBase2, _super);
  function CrosshairBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  CrosshairBase2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign(__assign({}, cfg), { name: "crosshair", type: "base", line: {}, text: null, textBackground: {}, capture: false, defaultCfg: {
      line: {
        style: {
          lineWidth: 1,
          stroke: theme_default.lineColor
        }
      },
      text: {
        position: "start",
        offset: 10,
        autoRotate: false,
        content: null,
        style: {
          fill: theme_default.textColor,
          textAlign: "center",
          textBaseline: "middle",
          fontFamily: theme_default.fontFamily
        }
      },
      textBackground: {
        padding: 5,
        style: {
          stroke: theme_default.lineColor
        }
      }
    } });
  };
  CrosshairBase2.prototype.renderInner = function(group2) {
    if (this.get("line")) {
      this.renderLine(group2);
    }
    if (this.get("text")) {
      this.renderText(group2);
      this.renderBackground(group2);
    }
  };
  CrosshairBase2.prototype.renderText = function(group2) {
    var text = this.get("text");
    var style = text.style, autoRotate = text.autoRotate, content = text.content;
    if (!is_nil_default(content)) {
      var textPoint = this.getTextPoint();
      var matrix = null;
      if (autoRotate) {
        var angle3 = this.getRotateAngle();
        matrix = getMatrixByAngle(textPoint, angle3);
      }
      this.addShape(group2, {
        type: "text",
        name: "crosshair-text",
        id: this.getElementId("text"),
        attrs: __assign(__assign(__assign({}, textPoint), { text: content, matrix }), style)
      });
    }
  };
  CrosshairBase2.prototype.renderLine = function(group2) {
    var path = this.getLinePath();
    var line = this.get("line");
    var style = line.style;
    this.addShape(group2, {
      type: "path",
      name: "crosshair-line",
      id: this.getElementId("line"),
      attrs: __assign({ path }, style)
    });
  };
  CrosshairBase2.prototype.renderBackground = function(group2) {
    var textId = this.getElementId("text");
    var textShape = group2.findById(textId);
    var textBackground = this.get("textBackground");
    if (textBackground && textShape) {
      var textBBox = textShape.getBBox();
      var padding = formatPadding(textBackground.padding);
      var style = textBackground.style;
      var backgroundShape = this.addShape(group2, {
        type: "rect",
        name: "crosshair-text-background",
        id: this.getElementId("text-background"),
        attrs: __assign({ x: textBBox.x - padding[3], y: textBBox.y - padding[0], width: textBBox.width + padding[1] + padding[3], height: textBBox.height + padding[0] + padding[2], matrix: textShape.attr("matrix") }, style)
      });
      backgroundShape.toBack();
    }
  };
  return CrosshairBase2;
}(group_component_default);
var base_default9 = CrosshairBase;

// node_modules/@antv/component/esm/crosshair/line.js
var LineCrosshair = function(_super) {
  __extends(LineCrosshair3, _super);
  function LineCrosshair3() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  LineCrosshair3.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign(__assign({}, cfg), { type: "line", locationType: "region", start: null, end: null });
  };
  LineCrosshair3.prototype.getRotateAngle = function() {
    var _a3 = this.getLocation(), start = _a3.start, end = _a3.end;
    var position = this.get("text").position;
    var angle3 = Math.atan2(end.y - start.y, end.x - start.x);
    var tangentAngle = position === "start" ? angle3 - Math.PI / 2 : angle3 + Math.PI / 2;
    return tangentAngle;
  };
  LineCrosshair3.prototype.getTextPoint = function() {
    var _a3 = this.getLocation(), start = _a3.start, end = _a3.end;
    var _b = this.get("text"), position = _b.position, offset = _b.offset;
    return getTextPoint(start, end, position, offset);
  };
  LineCrosshair3.prototype.getLinePath = function() {
    var _a3 = this.getLocation(), start = _a3.start, end = _a3.end;
    return [
      ["M", start.x, start.y],
      ["L", end.x, end.y]
    ];
  };
  return LineCrosshair3;
}(base_default9);
var line_default5 = LineCrosshair;

// node_modules/@antv/component/esm/crosshair/circle.js
var LineCrosshair2 = function(_super) {
  __extends(LineCrosshair3, _super);
  function LineCrosshair3() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  LineCrosshair3.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign(__assign({}, cfg), { type: "circle", locationType: "circle", center: null, radius: 100, startAngle: -Math.PI / 2, endAngle: Math.PI * 3 / 2 });
  };
  LineCrosshair3.prototype.getRotateAngle = function() {
    var _a3 = this.getLocation(), startAngle = _a3.startAngle, endAngle = _a3.endAngle;
    var position = this.get("text").position;
    var tangentAngle = position === "start" ? startAngle + Math.PI / 2 : endAngle - Math.PI / 2;
    return tangentAngle;
  };
  LineCrosshair3.prototype.getTextPoint = function() {
    var text = this.get("text");
    var position = text.position, offset = text.offset;
    var _a3 = this.getLocation(), center = _a3.center, radius = _a3.radius, startAngle = _a3.startAngle, endAngle = _a3.endAngle;
    var angle3 = position === "start" ? startAngle : endAngle;
    var tangentAngle = this.getRotateAngle() - Math.PI;
    var point = getCirclePoint(center, radius, angle3);
    var offsetX = Math.cos(tangentAngle) * offset;
    var offsetY = Math.sin(tangentAngle) * offset;
    return {
      x: point.x + offsetX,
      y: point.y + offsetY
    };
  };
  LineCrosshair3.prototype.getLinePath = function() {
    var _a3 = this.getLocation(), center = _a3.center, radius = _a3.radius, startAngle = _a3.startAngle, endAngle = _a3.endAngle;
    var path = null;
    if (endAngle - startAngle === Math.PI * 2) {
      var x = center.x, y = center.y;
      path = [
        ["M", x, y - radius],
        ["A", radius, radius, 0, 1, 1, x, y + radius],
        ["A", radius, radius, 0, 1, 1, x, y - radius],
        ["Z"]
      ];
    } else {
      var startPoint = getCirclePoint(center, radius, startAngle);
      var endPoint = getCirclePoint(center, radius, endAngle);
      var large = Math.abs(endAngle - startAngle) > Math.PI ? 1 : 0;
      var sweep = startAngle > endAngle ? 0 : 1;
      path = [
        ["M", startPoint.x, startPoint.y],
        ["A", radius, radius, 0, large, sweep, endPoint.x, endPoint.y]
      ];
    }
    return path;
  };
  return LineCrosshair3;
}(base_default9);
var circle_default3 = LineCrosshair2;

// node_modules/@antv/component/esm/crosshair/css-const.js
var CONTAINER_CLASS = "g2-crosshair";
var CROSSHAIR_LINE = CONTAINER_CLASS + "-line";
var CROSSHAIR_TEXT = CONTAINER_CLASS + "-text";

// node_modules/@antv/component/esm/crosshair/html-theme.js
var _a;
var html_theme_default = (_a = {}, _a["" + CONTAINER_CLASS] = {
  position: "relative"
}, _a["" + CROSSHAIR_LINE] = {
  position: "absolute",
  backgroundColor: "rgba(0, 0, 0, 0.25)"
}, _a["" + CROSSHAIR_TEXT] = {
  position: "absolute",
  color: theme_default.textColor,
  fontFamily: theme_default.fontFamily
}, _a);

// node_modules/@antv/component/esm/crosshair/html.js
var HtmlCrosshair = function(_super) {
  __extends(HtmlCrosshair2, _super);
  function HtmlCrosshair2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  HtmlCrosshair2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign(__assign({}, cfg), { name: "crosshair", type: "html", locationType: "region", start: { x: 0, y: 0 }, end: { x: 0, y: 0 }, capture: false, text: null, containerTpl: '<div class="' + CONTAINER_CLASS + '"></div>', crosshairTpl: '<div class="' + CROSSHAIR_LINE + '"></div>', textTpl: '<span class="' + CROSSHAIR_TEXT + '">{content}</span>', domStyles: null, containerClassName: CONTAINER_CLASS, defaultStyles: html_theme_default, defaultCfg: {
      text: {
        position: "start",
        content: null,
        align: "center",
        offset: 10
      }
    } });
  };
  HtmlCrosshair2.prototype.render = function() {
    this.resetText();
    this.resetPosition();
  };
  HtmlCrosshair2.prototype.initCrossHair = function() {
    var container = this.getContainer();
    var crosshairTpl = this.get("crosshairTpl");
    var crosshairEl = createDom(crosshairTpl);
    container.appendChild(crosshairEl);
    this.applyStyle(CROSSHAIR_LINE, crosshairEl);
    this.set("crosshairEl", crosshairEl);
  };
  HtmlCrosshair2.prototype.getTextPoint = function() {
    var _a3 = this.getLocation(), start = _a3.start, end = _a3.end;
    var _b = this.get("text"), position = _b.position, offset = _b.offset;
    return getTextPoint(start, end, position, offset);
  };
  HtmlCrosshair2.prototype.resetText = function() {
    var text = this.get("text");
    var textEl = this.get("textEl");
    if (text) {
      var content = text.content;
      if (!textEl) {
        var container = this.getContainer();
        var textTpl = substitute_default(this.get("textTpl"), text);
        textEl = createDom(textTpl);
        container.appendChild(textEl);
        this.applyStyle(CROSSHAIR_TEXT, textEl);
        this.set("textEl", textEl);
      }
      textEl.innerHTML = content;
    } else if (textEl) {
      textEl.remove();
    }
  };
  HtmlCrosshair2.prototype.isVertical = function(start, end) {
    return start.x === end.x;
  };
  HtmlCrosshair2.prototype.resetPosition = function() {
    var crosshairEl = this.get("crosshairEl");
    if (!crosshairEl) {
      this.initCrossHair();
      crosshairEl = this.get("crosshairEl");
    }
    var start = this.get("start");
    var end = this.get("end");
    var minX = Math.min(start.x, end.x);
    var minY = Math.min(start.y, end.y);
    if (this.isVertical(start, end)) {
      modifyCSS(crosshairEl, {
        width: "1px",
        height: toPx(Math.abs(end.y - start.y))
      });
    } else {
      modifyCSS(crosshairEl, {
        height: "1px",
        width: toPx(Math.abs(end.x - start.x))
      });
    }
    modifyCSS(crosshairEl, {
      top: toPx(minY),
      left: toPx(minX)
    });
    this.alignText();
  };
  HtmlCrosshair2.prototype.alignText = function() {
    var textEl = this.get("textEl");
    if (textEl) {
      var align = this.get("text").align;
      var clientWidth = textEl.clientWidth;
      var point = this.getTextPoint();
      switch (align) {
        case "center":
          point.x = point.x - clientWidth / 2;
          break;
        case "right":
          point.x = point.x - clientWidth;
        case "left":
          break;
      }
      modifyCSS(textEl, {
        top: toPx(point.y),
        left: toPx(point.x)
      });
    }
  };
  HtmlCrosshair2.prototype.updateInner = function(cfg) {
    if (has_key_default(cfg, "text")) {
      this.resetText();
    }
    _super.prototype.updateInner.call(this, cfg);
  };
  return HtmlCrosshair2;
}(html_component_default);
var html_default2 = HtmlCrosshair;

// node_modules/@antv/component/esm/grid/index.js
var grid_exports = {};
__export(grid_exports, {
  Base: () => base_default10,
  Circle: () => circle_default4,
  Line: () => line_default6
});

// node_modules/@antv/component/esm/grid/base.js
var GridBase = function(_super) {
  __extends(GridBase2, _super);
  function GridBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  GridBase2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign(__assign({}, cfg), { name: "grid", line: {}, alternateColor: null, capture: false, items: [], closed: false, defaultCfg: {
      line: {
        type: "line",
        style: {
          lineWidth: 1,
          stroke: theme_default.lineColor
        }
      }
    } });
  };
  GridBase2.prototype.getLineType = function() {
    var line = this.get("line") || this.get("defaultCfg").line;
    return line.type;
  };
  GridBase2.prototype.renderInner = function(group2) {
    this.drawGrid(group2);
  };
  GridBase2.prototype.getAlternatePath = function(prePoints, points) {
    var regionPath = this.getGridPath(prePoints);
    var reversePoints = points.slice(0).reverse();
    var nextPath = this.getGridPath(reversePoints, true);
    var closed = this.get("closed");
    if (closed) {
      regionPath = regionPath.concat(nextPath);
    } else {
      nextPath[0][0] = "L";
      regionPath = regionPath.concat(nextPath);
      regionPath.push(["Z"]);
    }
    return regionPath;
  };
  GridBase2.prototype.getPathStyle = function() {
    return this.get("line").style;
  };
  GridBase2.prototype.drawGrid = function(group2) {
    var _this = this;
    var line = this.get("line");
    var items = this.get("items");
    var alternateColor = this.get("alternateColor");
    var preItem = null;
    each_default(items, function(item, index) {
      var id = item.id || index;
      if (line) {
        var style = _this.getPathStyle();
        style = is_function_default(style) ? style(item, index, items) : style;
        var lineId = _this.getElementId("line-" + id);
        var gridPath = _this.getGridPath(item.points);
        _this.addShape(group2, {
          type: "path",
          name: "grid-line",
          id: lineId,
          attrs: mix({
            path: gridPath
          }, style)
        });
      }
      if (alternateColor && index > 0) {
        var regionId = _this.getElementId("region-" + id);
        var isEven = index % 2 === 0;
        if (is_string_default(alternateColor)) {
          if (isEven) {
            _this.drawAlternateRegion(regionId, group2, preItem.points, item.points, alternateColor);
          }
        } else {
          var color2 = isEven ? alternateColor[1] : alternateColor[0];
          _this.drawAlternateRegion(regionId, group2, preItem.points, item.points, color2);
        }
      }
      preItem = item;
    });
  };
  GridBase2.prototype.drawAlternateRegion = function(id, group2, prePoints, points, color2) {
    var regionPath = this.getAlternatePath(prePoints, points);
    this.addShape(group2, {
      type: "path",
      id,
      name: "grid-region",
      attrs: {
        path: regionPath,
        fill: color2
      }
    });
  };
  return GridBase2;
}(group_component_default);
var base_default10 = GridBase;

// node_modules/@antv/component/esm/grid/circle.js
function distance5(x1, y1, x2, y2) {
  var dx = x2 - x1;
  var dy = y2 - y1;
  return Math.sqrt(dx * dx + dy * dy);
}
var Circle2 = function(_super) {
  __extends(Circle6, _super);
  function Circle6() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Circle6.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign(__assign({}, cfg), {
      type: "circle",
      center: null,
      closed: true
    });
  };
  Circle6.prototype.getGridPath = function(points, reversed) {
    var lineType = this.getLineType();
    var closed = this.get("closed");
    var path = [];
    if (points.length) {
      if (lineType === "circle") {
        var center = this.get("center");
        var firstPoint = points[0];
        var radius_1 = distance5(center.x, center.y, firstPoint.x, firstPoint.y);
        var sweepFlag_1 = reversed ? 0 : 1;
        if (closed) {
          path.push(["M", center.x, center.y - radius_1]);
          path.push(["A", radius_1, radius_1, 0, 0, sweepFlag_1, center.x, center.y + radius_1]);
          path.push(["A", radius_1, radius_1, 0, 0, sweepFlag_1, center.x, center.y - radius_1]);
          path.push(["Z"]);
        } else {
          each_default(points, function(point, index) {
            if (index === 0) {
              path.push(["M", point.x, point.y]);
            } else {
              path.push(["A", radius_1, radius_1, 0, 0, sweepFlag_1, point.x, point.y]);
            }
          });
        }
      } else {
        each_default(points, function(point, index) {
          if (index === 0) {
            path.push(["M", point.x, point.y]);
          } else {
            path.push(["L", point.x, point.y]);
          }
        });
        if (closed) {
          path.push(["Z"]);
        }
      }
    }
    return path;
  };
  return Circle6;
}(base_default10);
var circle_default4 = Circle2;

// node_modules/@antv/component/esm/grid/line.js
var Line2 = function(_super) {
  __extends(Line6, _super);
  function Line6() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Line6.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign(__assign({}, cfg), { type: "line" });
  };
  Line6.prototype.getGridPath = function(points) {
    var path = [];
    each_default(points, function(point, index) {
      if (index === 0) {
        path.push(["M", point.x, point.y]);
      } else {
        path.push(["L", point.x, point.y]);
      }
    });
    return path;
  };
  return Line6;
}(base_default10);
var line_default6 = Line2;

// node_modules/@antv/component/esm/legend/index.js
var legend_exports = {};
__export(legend_exports, {
  Base: () => base_default11,
  Category: () => category_default,
  Continuous: () => continuous_default
});

// node_modules/@antv/component/esm/legend/base.js
var LegendBase = function(_super) {
  __extends(LegendBase2, _super);
  function LegendBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  LegendBase2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign(__assign({}, cfg), {
      name: "legend",
      layout: "horizontal",
      locationType: "point",
      x: 0,
      y: 0,
      offsetX: 0,
      offsetY: 0,
      title: null,
      background: null
    });
  };
  LegendBase2.prototype.getLayoutBBox = function() {
    var bbox = _super.prototype.getLayoutBBox.call(this);
    var maxWidth = this.get("maxWidth");
    var maxHeight = this.get("maxHeight");
    var width = bbox.width, height = bbox.height;
    if (maxWidth) {
      width = Math.min(width, maxWidth);
    }
    if (maxHeight) {
      height = Math.min(height, maxHeight);
    }
    return createBBox(bbox.minX, bbox.minY, width, height);
  };
  LegendBase2.prototype.setLocation = function(cfg) {
    this.set("x", cfg.x);
    this.set("y", cfg.y);
    this.resetLocation();
  };
  LegendBase2.prototype.resetLocation = function() {
    var x = this.get("x");
    var y = this.get("y");
    var offsetX = this.get("offsetX");
    var offsetY = this.get("offsetY");
    this.moveElementTo(this.get("group"), {
      x: x + offsetX,
      y: y + offsetY
    });
  };
  LegendBase2.prototype.applyOffset = function() {
    this.resetLocation();
  };
  LegendBase2.prototype.getDrawPoint = function() {
    return this.get("currentPoint");
  };
  LegendBase2.prototype.setDrawPoint = function(point) {
    return this.set("currentPoint", point);
  };
  LegendBase2.prototype.renderInner = function(group2) {
    this.resetDraw();
    if (this.get("title")) {
      this.drawTitle(group2);
    }
    this.drawLegendContent(group2);
    if (this.get("background")) {
      this.drawBackground(group2);
    }
  };
  LegendBase2.prototype.drawBackground = function(group2) {
    var background = this.get("background");
    var bbox = group2.getBBox();
    var padding = formatPadding(background.padding);
    var attrs = __assign({
      x: 0,
      y: 0,
      width: bbox.width + padding[1] + padding[3],
      height: bbox.height + padding[0] + padding[2]
    }, background.style);
    var backgroundShape = this.addShape(group2, {
      type: "rect",
      id: this.getElementId("background"),
      name: "legend-background",
      attrs
    });
    backgroundShape.toBack();
  };
  LegendBase2.prototype.drawTitle = function(group2) {
    var currentPoint = this.get("currentPoint");
    var titleCfg = this.get("title");
    var spacing = titleCfg.spacing, style = titleCfg.style, text = titleCfg.text;
    var shape = this.addShape(group2, {
      type: "text",
      id: this.getElementId("title"),
      name: "legend-title",
      attrs: __assign({ text, x: currentPoint.x, y: currentPoint.y }, style)
    });
    var bbox = shape.getBBox();
    this.set("currentPoint", { x: currentPoint.x, y: bbox.maxY + spacing });
  };
  LegendBase2.prototype.resetDraw = function() {
    var background = this.get("background");
    var currentPoint = { x: 0, y: 0 };
    if (background) {
      var padding = formatPadding(background.padding);
      currentPoint.x = padding[3];
      currentPoint.y = padding[0];
    }
    this.set("currentPoint", currentPoint);
  };
  return LegendBase2;
}(group_component_default);
var base_default11 = LegendBase;

// node_modules/@antv/component/esm/legend/category.js
var DEFAULT_PAGE_NAVIGATOR = {
  marker: {
    style: {
      inactiveFill: "#000",
      inactiveOpacity: 0.45,
      fill: "#000",
      opacity: 1,
      size: 12
    }
  },
  text: {
    style: {
      fill: "#ccc",
      fontSize: 12
    }
  }
};
var textStyle = {
  fill: theme_default.textColor,
  fontSize: 12,
  textAlign: "start",
  textBaseline: "middle",
  fontFamily: theme_default.fontFamily,
  fontWeight: "normal",
  lineHeight: 12
};
var RIGHT_ARROW_NAME = "navigation-arrow-right";
var LEFT_ARROW_NAME = "navigation-arrow-left";
var ROTATE_MAP = {
  right: 90 * Math.PI / 180,
  left: (360 - 90) * Math.PI / 180,
  up: 0,
  down: 180 * Math.PI / 180
};
var Category2 = function(_super) {
  __extends(Category3, _super);
  function Category3() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.currentPageIndex = 1;
    _this.totalPagesCnt = 1;
    _this.pageWidth = 0;
    _this.pageHeight = 0;
    _this.startX = 0;
    _this.startY = 0;
    _this.onNavigationBack = function() {
      var itemGroup = _this.getElementByLocalId("item-group");
      if (_this.currentPageIndex > 1) {
        _this.currentPageIndex -= 1;
        _this.updateNavigation();
        var matrix = _this.getCurrentNavigationMatrix();
        if (_this.get("animate")) {
          itemGroup.animate({
            matrix
          }, 100);
        } else {
          itemGroup.attr({ matrix });
        }
      }
    };
    _this.onNavigationAfter = function() {
      var itemGroup = _this.getElementByLocalId("item-group");
      if (_this.currentPageIndex < _this.totalPagesCnt) {
        _this.currentPageIndex += 1;
        _this.updateNavigation();
        var matrix = _this.getCurrentNavigationMatrix();
        if (_this.get("animate")) {
          itemGroup.animate({
            matrix
          }, 100);
        } else {
          itemGroup.attr({ matrix });
        }
      }
    };
    return _this;
  }
  Category3.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign(__assign({}, cfg), { name: "legend", type: "category", itemSpacing: 24, itemMarginBottom: 8, maxItemWidth: null, itemWidth: null, itemHeight: null, itemName: {}, itemValue: null, maxWidth: null, maxHeight: null, marker: {}, radio: null, items: [], itemStates: {}, itemBackground: {}, pageNavigator: {}, defaultCfg: {
      title: {
        spacing: 5,
        style: {
          fill: theme_default.textColor,
          fontSize: 12,
          textAlign: "start",
          textBaseline: "top"
        }
      },
      background: {
        padding: 5,
        style: {
          stroke: theme_default.lineColor
        }
      },
      itemBackground: {
        style: {
          opacity: 0,
          fill: "#fff"
        }
      },
      pageNavigator: DEFAULT_PAGE_NAVIGATOR,
      itemName: {
        spacing: 16,
        style: textStyle
      },
      marker: {
        spacing: 8,
        style: {
          r: 6,
          symbol: "circle"
        }
      },
      itemValue: {
        alignRight: false,
        formatter: null,
        style: textStyle,
        spacing: 6
      },
      itemStates: {
        active: {
          nameStyle: {
            opacity: 0.8
          }
        },
        unchecked: {
          nameStyle: {
            fill: theme_default.uncheckedColor
          },
          markerStyle: {
            fill: theme_default.uncheckedColor,
            stroke: theme_default.uncheckedColor
          }
        },
        inactive: {
          nameStyle: {
            fill: theme_default.uncheckedColor
          },
          markerStyle: {
            opacity: 0.2
          }
        }
      }
    } });
  };
  Category3.prototype.isList = function() {
    return true;
  };
  Category3.prototype.getItems = function() {
    return this.get("items");
  };
  Category3.prototype.setItems = function(items) {
    this.update({
      items
    });
  };
  Category3.prototype.updateItem = function(item, cfg) {
    mix(item, cfg);
    this.clear();
    this.render();
  };
  Category3.prototype.clearItems = function() {
    var itemGroup = this.getElementByLocalId("item-group");
    itemGroup && itemGroup.clear();
  };
  Category3.prototype.setItemState = function(item, state, value) {
    item[state] = value;
    var itemElement = this.getElementByLocalId("item-" + item.id);
    if (itemElement) {
      var items = this.getItems();
      var index = items.indexOf(item);
      var offsetGroup = this.createOffScreenGroup();
      var newElement = this.drawItem(item, index, this.getItemHeight(), offsetGroup);
      this.updateElements(newElement, itemElement);
      this.clearUpdateStatus(itemElement);
    }
  };
  Category3.prototype.hasState = function(item, state) {
    return !!item[state];
  };
  Category3.prototype.getItemStates = function(item) {
    var itemStates = this.get("itemStates");
    var rst = [];
    each_default(itemStates, function(v, k) {
      if (item[k]) {
        rst.push(k);
      }
    });
    return rst;
  };
  Category3.prototype.clearItemsState = function(state) {
    var _this = this;
    var items = this.getItemsByState(state);
    each_default(items, function(item) {
      _this.setItemState(item, state, false);
    });
  };
  Category3.prototype.getItemsByState = function(state) {
    var _this = this;
    var items = this.getItems();
    return filter_default(items, function(item) {
      return _this.hasState(item, state);
    });
  };
  Category3.prototype.drawLegendContent = function(group2) {
    this.processItems();
    this.drawItems(group2);
  };
  Category3.prototype.processItems = function() {
    var items = this.get("items");
    each_default(items, function(item) {
      if (!item.id) {
        item.id = item.name;
      }
    });
  };
  Category3.prototype.drawItems = function(group2) {
    var _this = this;
    var itemContainerGroup = this.addGroup(group2, {
      id: this.getElementId("item-container-group"),
      name: "legend-item-container-group"
    });
    var itemGroup = this.addGroup(itemContainerGroup, {
      id: this.getElementId("item-group"),
      name: "legend-item-group"
    });
    var itemHeight = this.getItemHeight();
    var itemWidth = this.get("itemWidth");
    var itemSpacing = this.get("itemSpacing");
    var itemMarginBottom = this.get("itemMarginBottom");
    var currentPoint = this.get("currentPoint");
    var startX = currentPoint.x;
    var startY = currentPoint.y;
    var layout2 = this.get("layout");
    var items = this.get("items");
    var wrapped = false;
    var pageWidth = 0;
    var maxWidth = this.get("maxWidth");
    var maxHeight = this.get("maxHeight");
    each_default(items, function(item, index) {
      var subGroup = _this.drawItem(item, index, itemHeight, itemGroup);
      var bbox = subGroup.getBBox();
      var width = itemWidth || bbox.width;
      if (width > pageWidth) {
        pageWidth = width;
      }
      if (layout2 === "horizontal") {
        if (maxWidth && maxWidth < currentPoint.x + width - startX) {
          wrapped = true;
          currentPoint.x = startX;
          currentPoint.y += itemHeight + itemMarginBottom;
        }
        _this.moveElementTo(subGroup, currentPoint);
        currentPoint.x += width + itemSpacing;
      } else {
        if (maxHeight && maxHeight < currentPoint.y + itemHeight + itemMarginBottom - startY) {
          wrapped = true;
          currentPoint.x += pageWidth + itemSpacing;
          currentPoint.y = startY;
          pageWidth = 0;
        }
        _this.moveElementTo(subGroup, currentPoint);
        currentPoint.y += itemHeight + itemMarginBottom;
      }
    });
    if (wrapped && this.get("flipPage")) {
      this.pageHeight = 0;
      this.pageWidth = 0;
      this.totalPagesCnt = 1;
      this.startX = startX;
      this.startY = startY;
      this.adjustNavigation(group2, itemGroup);
    }
  };
  Category3.prototype.getItemHeight = function() {
    var itemHeight = this.get("itemHeight");
    if (!itemHeight) {
      var style_1 = (this.get("itemName") || {}).style;
      if (is_function_default(style_1)) {
        var items_1 = this.getItems();
        items_1.forEach(function(item, index) {
          var fontSize = __assign(__assign({}, textStyle), style_1(item, index, items_1)).fontSize;
          if (itemHeight < fontSize) {
            itemHeight = fontSize;
          }
        });
      } else if (style_1) {
        itemHeight = style_1.fontSize;
      }
    }
    return itemHeight;
  };
  Category3.prototype.drawMarker = function(container, markerCfg, item, itemHeight) {
    var markerAttrs = __assign(__assign(__assign({ x: 0, y: itemHeight / 2 }, markerCfg.style), { symbol: get_default(item.marker, "symbol", "circle") }), get_default(item.marker, "style", {}));
    var shape = this.addShape(container, {
      type: "marker",
      id: this.getElementId("item-" + item.id + "-marker"),
      name: "legend-item-marker",
      attrs: markerAttrs
    });
    var bbox = shape.getBBox();
    shape.attr("x", bbox.width / 2);
    var _a3 = shape.attr(), stroke = _a3.stroke, fill = _a3.fill;
    if (stroke) {
      shape.set("isStroke", true);
    }
    if (fill) {
      shape.set("isFill", true);
    }
    return shape;
  };
  Category3.prototype.drawItemText = function(container, textName, cfg, item, itemHeight, xPosition, index) {
    var formatter = cfg.formatter;
    var style = cfg.style;
    var attrs = __assign(__assign({ x: xPosition, y: itemHeight / 2, text: formatter ? formatter(item[textName], item, index) : item[textName] }, textStyle), is_function_default(style) ? style(item, index, this.getItems()) : style);
    return this.addShape(container, {
      type: "text",
      id: this.getElementId("item-" + item.id + "-" + textName),
      name: "legend-item-" + textName,
      attrs
    });
  };
  Category3.prototype.drawRadio = function(container, radioCfg, item, itemHeight, x) {
    var _a3, _b;
    var style = radioCfg.style || {};
    var r = (_a3 = style.r) !== null && _a3 !== void 0 ? _a3 : itemHeight / 2;
    var lineWidth = r * 3.6 / 8;
    var _c = [x + r, itemHeight / 2 - r], x0 = _c[0], y0 = _c[1];
    var _d = [x0 + r, y0 + r], x1 = _d[0], y1 = _d[1];
    var _e = [x0, y1 + r], x2 = _e[0], y2 = _e[1];
    var _f = [x, y0 + r], x3 = _f[0], y3 = _f[1];
    var showRadio = item.showRadio;
    var attrs = __assign(__assign({ path: [
      ["M", x0, y0],
      ["A", r, r, 0, 0, 1, x1, y1],
      ["L", x1 - lineWidth, y1],
      ["L", x1, y1],
      ["A", r, r, 0, 0, 1, x2, y2],
      ["L", x2, y2 - lineWidth],
      ["L", x2, y2],
      ["A", r, r, 0, 0, 1, x3, y3],
      ["L", x3 + lineWidth, y3],
      ["L", x3, y3],
      ["A", r, r, 0, 0, 1, x0, y0],
      ["L", x0, y0 + lineWidth]
    ], stroke: "#000000", fill: "#ffffff" }, style), { opacity: showRadio ? (_b = style === null || style === void 0 ? void 0 : style.opacity) !== null && _b !== void 0 ? _b : 0.45 : 0 });
    var radioShape = this.addShape(container, {
      type: "path",
      id: this.getElementId("item-" + item.id + "-radio"),
      name: "legend-item-radio",
      attrs
    });
    radioShape.set("tip", radioCfg.tip);
    return radioShape;
  };
  Category3.prototype.drawItem = function(item, index, itemHeight, itemGroup) {
    var groupId = "item-" + item.id;
    var subContainer = this.addGroup(itemGroup, {
      name: "legend-item-container",
      id: this.getElementId("item-container-" + groupId),
      delegateObject: {
        item,
        index
      }
    });
    var subGroup = this.addGroup(subContainer, {
      name: "legend-item",
      id: this.getElementId(groupId),
      delegateObject: {
        item,
        index
      }
    });
    var marker = this.get("marker");
    var itemName = this.get("itemName");
    var itemValue = this.get("itemValue");
    var itemBackground = this.get("itemBackground");
    var radio = this.get("radio");
    var itemWidth = this.getLimitItemWidth();
    var curX = 0;
    if (marker) {
      var markerShape = this.drawMarker(subGroup, marker, item, itemHeight);
      var spacing = marker.spacing;
      var itemMarkerSpacing = get_default(item, ["marker", "spacing"]);
      if (is_number_default(itemMarkerSpacing)) {
        spacing = itemMarkerSpacing;
      }
      curX = markerShape.getBBox().maxX + spacing;
    }
    if (itemName) {
      var nameShape = this.drawItemText(subGroup, "name", itemName, item, itemHeight, curX, index);
      if (itemWidth) {
        ellipsisLabel(true, nameShape, clamp_default(itemWidth - curX, 0, itemWidth));
      }
      curX = nameShape.getBBox().maxX + itemName.spacing;
    }
    if (itemValue) {
      var valueShape = this.drawItemText(subGroup, "value", itemValue, item, itemHeight, curX, index);
      if (itemWidth) {
        if (itemValue.alignRight) {
          valueShape.attr({
            textAlign: "right",
            x: itemWidth
          });
          ellipsisLabel(true, valueShape, clamp_default(itemWidth - curX, 0, itemWidth), "head");
        } else {
          ellipsisLabel(true, valueShape, clamp_default(itemWidth - curX, 0, itemWidth));
        }
      }
      curX = valueShape.getBBox().maxX + itemValue.spacing;
    }
    if (radio) {
      this.drawRadio(subGroup, radio, item, itemHeight, curX);
    }
    if (itemBackground) {
      var bbox = subGroup.getBBox();
      var backShape = this.addShape(subGroup, {
        type: "rect",
        name: "legend-item-background",
        id: this.getElementId(groupId + "-background"),
        attrs: __assign({ x: 0, y: 0, width: bbox.width, height: itemHeight }, itemBackground.style)
      });
      backShape.toBack();
    }
    this.applyItemStates(item, subGroup);
    return subGroup;
  };
  Category3.prototype.adjustNavigation = function(container, itemGroup) {
    var _this = this;
    var startX = this.startX;
    var startY = this.startY;
    var layout2 = this.get("layout");
    var subGroups = itemGroup.findAll(function(item) {
      return item.get("name") === "legend-item";
    });
    var maxWidth = this.get("maxWidth");
    var maxHeight = this.get("maxHeight");
    var itemWidth = this.get("itemWidth");
    var itemSpacing = this.get("itemSpacing");
    var itemHeight = this.getItemHeight();
    var pageNavigator = deep_mix_default({}, DEFAULT_PAGE_NAVIGATOR, this.get("pageNavigator"));
    var navigation = this.drawNavigation(container, layout2, "00/00", pageNavigator);
    var navigationBBox = navigation.getBBox();
    var currentPoint = { x: startX, y: startY };
    var pages = 1;
    var widthLimit = 0;
    var pageWidth = 0;
    var maxItemWidth = 0;
    var itemMarginBottom = this.get("itemMarginBottom");
    if (layout2 === "horizontal") {
      var maxRow = this.get("maxRow") || 1;
      var maxRowHeight_1 = itemHeight + (maxRow === 1 ? 0 : itemMarginBottom);
      this.pageHeight = maxRowHeight_1 * maxRow;
      each_default(subGroups, function(item) {
        var bbox = item.getBBox();
        var width = itemWidth || bbox.width;
        if (widthLimit && widthLimit < currentPoint.x + width + itemSpacing || maxWidth < currentPoint.x + width + itemSpacing + navigationBBox.width) {
          if (pages === 1) {
            widthLimit = currentPoint.x + itemSpacing;
            _this.pageWidth = widthLimit;
            _this.moveElementTo(navigation, {
              x: maxWidth - itemSpacing - navigationBBox.width - navigationBBox.minX,
              y: currentPoint.y + itemHeight / 2 - navigationBBox.height / 2 - navigationBBox.minY
            });
          }
          pages += 1;
          currentPoint.x = startX;
          currentPoint.y += maxRowHeight_1;
        }
        _this.moveElementTo(item, currentPoint);
        item.getParent().setClip({
          type: "rect",
          attrs: {
            x: currentPoint.x,
            y: currentPoint.y,
            width: width + itemSpacing,
            height: itemHeight
          }
        });
        currentPoint.x += width + itemSpacing;
      });
    } else {
      each_default(subGroups, function(item) {
        var bbox = item.getBBox();
        if (bbox.width > pageWidth) {
          pageWidth = bbox.width;
        }
      });
      maxItemWidth = pageWidth;
      pageWidth += itemSpacing;
      if (maxWidth) {
        pageWidth = Math.min(maxWidth, pageWidth);
        maxItemWidth = Math.min(maxWidth, maxItemWidth);
      }
      this.pageWidth = pageWidth;
      this.pageHeight = maxHeight - Math.max(navigationBBox.height, itemHeight + itemMarginBottom);
      var cntPerPage_1 = Math.floor(this.pageHeight / (itemHeight + itemMarginBottom));
      each_default(subGroups, function(item, index) {
        if (index !== 0 && index % cntPerPage_1 === 0) {
          pages += 1;
          currentPoint.x += pageWidth;
          currentPoint.y = startY;
        }
        _this.moveElementTo(item, currentPoint);
        item.getParent().setClip({
          type: "rect",
          attrs: {
            x: currentPoint.x,
            y: currentPoint.y,
            width: pageWidth,
            height: itemHeight
          }
        });
        currentPoint.y += itemHeight + itemMarginBottom;
      });
      this.totalPagesCnt = pages;
      this.moveElementTo(navigation, {
        x: startX + maxItemWidth / 2 - navigationBBox.width / 2 - navigationBBox.minX,
        y: maxHeight - navigationBBox.height - navigationBBox.minY
      });
    }
    if (this.pageHeight && this.pageWidth) {
      itemGroup.getParent().setClip({
        type: "rect",
        attrs: {
          x: this.startX,
          y: this.startY,
          width: this.pageWidth,
          height: this.pageHeight
        }
      });
    }
    if (layout2 === "horizontal" && this.get("maxRow")) {
      this.totalPagesCnt = Math.ceil(pages / this.get("maxRow"));
    } else {
      this.totalPagesCnt = pages;
    }
    if (this.currentPageIndex > this.totalPagesCnt) {
      this.currentPageIndex = 1;
    }
    this.updateNavigation(navigation);
    itemGroup.attr("matrix", this.getCurrentNavigationMatrix());
  };
  Category3.prototype.drawNavigation = function(group2, layout2, text, styleCfg) {
    var currentPoint = { x: 0, y: 0 };
    var subGroup = this.addGroup(group2, {
      id: this.getElementId("navigation-group"),
      name: "legend-navigation"
    });
    var _a3 = get_default(styleCfg.marker, "style", {}), _b = _a3.size, size2 = _b === void 0 ? 12 : _b, arrowStyle = __rest(_a3, ["size"]);
    var leftArrow = this.drawArrow(subGroup, currentPoint, LEFT_ARROW_NAME, layout2 === "horizontal" ? "up" : "left", size2, arrowStyle);
    leftArrow.on("click", this.onNavigationBack);
    var leftArrowBBox = leftArrow.getBBox();
    currentPoint.x += leftArrowBBox.width + 2;
    var textShape = this.addShape(subGroup, {
      type: "text",
      id: this.getElementId("navigation-text"),
      name: "navigation-text",
      attrs: __assign({ x: currentPoint.x, y: currentPoint.y + size2 / 2, text, textBaseline: "middle" }, get_default(styleCfg.text, "style"))
    });
    var textBBox = textShape.getBBox();
    currentPoint.x += textBBox.width + 2;
    var rightArrow = this.drawArrow(subGroup, currentPoint, RIGHT_ARROW_NAME, layout2 === "horizontal" ? "down" : "right", size2, arrowStyle);
    rightArrow.on("click", this.onNavigationAfter);
    return subGroup;
  };
  Category3.prototype.updateNavigation = function(navigation) {
    var pageNavigator = deep_mix_default({}, DEFAULT_PAGE_NAVIGATOR, this.get("pageNavigator"));
    var _a3 = pageNavigator.marker.style, fill = _a3.fill, opacity = _a3.opacity, inactiveFill = _a3.inactiveFill, inactiveOpacity = _a3.inactiveOpacity;
    var text = this.currentPageIndex + "/" + this.totalPagesCnt;
    var textShape = navigation ? navigation.getChildren()[1] : this.getElementByLocalId("navigation-text");
    var leftArrow = navigation ? navigation.findById(this.getElementId(LEFT_ARROW_NAME)) : this.getElementByLocalId(LEFT_ARROW_NAME);
    var rightArrow = navigation ? navigation.findById(this.getElementId(RIGHT_ARROW_NAME)) : this.getElementByLocalId(RIGHT_ARROW_NAME);
    textShape.attr("text", text);
    leftArrow.attr("opacity", this.currentPageIndex === 1 ? inactiveOpacity : opacity);
    leftArrow.attr("fill", this.currentPageIndex === 1 ? inactiveFill : fill);
    leftArrow.attr("cursor", this.currentPageIndex === 1 ? "not-allowed" : "pointer");
    rightArrow.attr("opacity", this.currentPageIndex === this.totalPagesCnt ? inactiveOpacity : opacity);
    rightArrow.attr("fill", this.currentPageIndex === this.totalPagesCnt ? inactiveFill : fill);
    rightArrow.attr("cursor", this.currentPageIndex === this.totalPagesCnt ? "not-allowed" : "pointer");
    var cursorX = leftArrow.getBBox().maxX + 2;
    textShape.attr("x", cursorX);
    cursorX += textShape.getBBox().width + 2;
    this.updateArrowPath(rightArrow, { x: cursorX, y: 0 });
  };
  Category3.prototype.drawArrow = function(group2, currentPoint, name, direction2, size2, style) {
    var x = currentPoint.x, y = currentPoint.y;
    var shape = this.addShape(group2, {
      type: "path",
      id: this.getElementId(name),
      name,
      attrs: __assign({
        size: size2,
        direction: direction2,
        path: [["M", x + size2 / 2, y], ["L", x, y + size2], ["L", x + size2, y + size2], ["Z"]],
        cursor: "pointer"
      }, style)
    });
    shape.attr("matrix", getMatrixByAngle({ x: x + size2 / 2, y: y + size2 / 2 }, ROTATE_MAP[direction2]));
    return shape;
  };
  Category3.prototype.updateArrowPath = function(arrow, point) {
    var x = point.x, y = point.y;
    var _a3 = arrow.attr(), size2 = _a3.size, direction2 = _a3.direction;
    var matrix = getMatrixByAngle({ x: x + size2 / 2, y: y + size2 / 2 }, ROTATE_MAP[direction2]);
    arrow.attr("path", [["M", x + size2 / 2, y], ["L", x, y + size2], ["L", x + size2, y + size2], ["Z"]]);
    arrow.attr("matrix", matrix);
  };
  Category3.prototype.getCurrentNavigationMatrix = function() {
    var _a3 = this, currentPageIndex = _a3.currentPageIndex, pageWidth = _a3.pageWidth, pageHeight = _a3.pageHeight;
    var layout2 = this.get("layout");
    var translate3 = layout2 === "horizontal" ? {
      x: 0,
      y: pageHeight * (1 - currentPageIndex)
    } : {
      x: pageWidth * (1 - currentPageIndex),
      y: 0
    };
    return getMatrixByTranslate(translate3);
  };
  Category3.prototype.applyItemStates = function(item, subGroup) {
    var states = this.getItemStates(item);
    var hasStates = states.length > 0;
    if (hasStates) {
      var children = subGroup.getChildren();
      var itemStates_1 = this.get("itemStates");
      each_default(children, function(element) {
        var name = element.get("name");
        var elName = name.split("-")[2];
        var statesStyle = getStatesStyle(item, elName, itemStates_1);
        if (statesStyle) {
          element.attr(statesStyle);
          if (elName === "marker" && !(element.get("isStroke") && element.get("isFill"))) {
            if (element.get("isStroke")) {
              element.attr("fill", null);
            }
            if (element.get("isFill")) {
              element.attr("stroke", null);
            }
          }
        }
      });
    }
  };
  Category3.prototype.getLimitItemWidth = function() {
    var itemWidth = this.get("itemWidth");
    var maxItemWidth = this.get("maxItemWidth");
    if (maxItemWidth) {
      if (itemWidth) {
        maxItemWidth = itemWidth <= maxItemWidth ? itemWidth : maxItemWidth;
      }
    } else if (itemWidth) {
      maxItemWidth = itemWidth;
    }
    return maxItemWidth;
  };
  return Category3;
}(base_default11);
var category_default = Category2;

// node_modules/@antv/component/esm/legend/continuous.js
var HANDLER_HEIGHT_RATIO = 1.4;
var HANDLER_TRIANGLE_RATIO = 0.4;
var ContinueLegend = function(_super) {
  __extends(ContinueLegend2, _super);
  function ContinueLegend2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ContinueLegend2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign(__assign({}, cfg), { type: "continue", min: 0, max: 100, value: null, colors: [], track: {}, rail: {}, label: {}, handler: {}, slidable: true, tip: null, step: null, maxWidth: null, maxHeight: null, defaultCfg: {
      label: {
        align: "rail",
        spacing: 5,
        formatter: null,
        style: {
          fontSize: 12,
          fill: theme_default.textColor,
          textBaseline: "middle",
          fontFamily: theme_default.fontFamily
        }
      },
      handler: {
        size: 10,
        style: {
          fill: "#fff",
          stroke: "#333"
        }
      },
      track: {},
      rail: {
        type: "color",
        size: 20,
        defaultLength: 100,
        style: {
          fill: "#DCDEE2"
        }
      },
      title: {
        spacing: 5,
        style: {
          fill: theme_default.textColor,
          fontSize: 12,
          textAlign: "start",
          textBaseline: "top"
        }
      }
    } });
  };
  ContinueLegend2.prototype.isSlider = function() {
    return true;
  };
  ContinueLegend2.prototype.getValue = function() {
    return this.getCurrentValue();
  };
  ContinueLegend2.prototype.getRange = function() {
    return {
      min: this.get("min"),
      max: this.get("max")
    };
  };
  ContinueLegend2.prototype.setRange = function(min3, max3) {
    this.update({
      min: min3,
      max: max3
    });
  };
  ContinueLegend2.prototype.setValue = function(value) {
    var originValue = this.getValue();
    this.set("value", value);
    var group2 = this.get("group");
    this.resetTrackClip();
    if (this.get("slidable")) {
      this.resetHandlers(group2);
    }
    this.delegateEmit("valuechanged", {
      originValue,
      value
    });
  };
  ContinueLegend2.prototype.initEvent = function() {
    var group2 = this.get("group");
    this.bindSliderEvent(group2);
    this.bindRailEvent(group2);
    this.bindTrackEvent(group2);
  };
  ContinueLegend2.prototype.drawLegendContent = function(group2) {
    this.drawRail(group2);
    this.drawLabels(group2);
    this.fixedElements(group2);
    this.resetTrack(group2);
    this.resetTrackClip(group2);
    if (this.get("slidable")) {
      this.resetHandlers(group2);
    }
  };
  ContinueLegend2.prototype.bindSliderEvent = function(group2) {
    this.bindHandlersEvent(group2);
  };
  ContinueLegend2.prototype.bindHandlersEvent = function(group2) {
    var _this = this;
    group2.on("legend-handler-min:drag", function(ev) {
      var minValue = _this.getValueByCanvasPoint(ev.x, ev.y);
      var currentValue = _this.getCurrentValue();
      var maxValue = currentValue[1];
      if (maxValue < minValue) {
        maxValue = minValue;
      }
      _this.setValue([minValue, maxValue]);
    });
    group2.on("legend-handler-max:drag", function(ev) {
      var maxValue = _this.getValueByCanvasPoint(ev.x, ev.y);
      var currentValue = _this.getCurrentValue();
      var minValue = currentValue[0];
      if (minValue > maxValue) {
        minValue = maxValue;
      }
      _this.setValue([minValue, maxValue]);
    });
  };
  ContinueLegend2.prototype.bindRailEvent = function(group2) {
  };
  ContinueLegend2.prototype.bindTrackEvent = function(group2) {
    var _this = this;
    var prePoint = null;
    group2.on("legend-track:dragstart", function(ev) {
      prePoint = {
        x: ev.x,
        y: ev.y
      };
    });
    group2.on("legend-track:drag", function(ev) {
      if (!prePoint) {
        return;
      }
      var preValue = _this.getValueByCanvasPoint(prePoint.x, prePoint.y);
      var curValue = _this.getValueByCanvasPoint(ev.x, ev.y);
      var currentValue = _this.getCurrentValue();
      var curDiff = currentValue[1] - currentValue[0];
      var range = _this.getRange();
      var dValue = curValue - preValue;
      if (dValue < 0) {
        if (currentValue[0] + dValue > range.min) {
          _this.setValue([currentValue[0] + dValue, currentValue[1] + dValue]);
        } else {
          _this.setValue([range.min, range.min + curDiff]);
        }
      } else if (dValue > 0) {
        if (dValue > 0 && currentValue[1] + dValue < range.max) {
          _this.setValue([currentValue[0] + dValue, currentValue[1] + dValue]);
        } else {
          _this.setValue([range.max - curDiff, range.max]);
        }
      }
      prePoint = {
        x: ev.x,
        y: ev.y
      };
    });
    group2.on("legend-track:dragend", function(ev) {
      prePoint = null;
    });
  };
  ContinueLegend2.prototype.drawLabels = function(group2) {
    this.drawLabel("min", group2);
    this.drawLabel("max", group2);
  };
  ContinueLegend2.prototype.drawLabel = function(name, group2) {
    var labelCfg = this.get("label");
    var style = labelCfg.style;
    var labelAlign = labelCfg.align;
    var labelFormatter = labelCfg.formatter;
    var value = this.get(name);
    var alignAttrs = this.getLabelAlignAttrs(name, labelAlign);
    var localId = "label-" + name;
    this.addShape(group2, {
      type: "text",
      id: this.getElementId(localId),
      name: "legend-label-" + name,
      attrs: __assign(__assign({ x: 0, y: 0, text: is_function_default(labelFormatter) ? labelFormatter(value) : value }, style), alignAttrs)
    });
  };
  ContinueLegend2.prototype.getLabelAlignAttrs = function(name, align) {
    var isVertical2 = this.isVertical();
    var textAlign = "center";
    var textBaseline = "middle";
    if (isVertical2) {
      textAlign = "start";
      if (align !== "rail") {
        if (name === "min") {
          textBaseline = "top";
        } else {
          textBaseline = "bottom";
        }
      } else {
        textBaseline = "top";
      }
    } else {
      if (align !== "rail") {
        textBaseline = "top";
        if (name === "min") {
          textAlign = "start";
        } else {
          textAlign = "end";
        }
      } else {
        textAlign = "start";
        textBaseline = "middle";
      }
    }
    return {
      textAlign,
      textBaseline
    };
  };
  ContinueLegend2.prototype.getRailPath = function(x, y, w, h) {
    var railCfg = this.get("rail");
    var size2 = railCfg.size, defaultLength = railCfg.defaultLength, type = railCfg.type;
    var isVertical2 = this.isVertical();
    var length5 = defaultLength;
    var width = w;
    var height = h;
    if (!width) {
      width = isVertical2 ? size2 : length5;
    }
    if (!height) {
      height = isVertical2 ? length5 : size2;
    }
    var path = [];
    if (type === "color") {
      path.push(["M", x, y]);
      path.push(["L", x + width, y]);
      path.push(["L", x + width, y + height]);
      path.push(["L", x, y + height]);
      path.push(["Z"]);
    } else {
      path.push(["M", x + width, y]);
      path.push(["L", x + width, y + height]);
      path.push(["L", x, y + height]);
      path.push(["Z"]);
    }
    return path;
  };
  ContinueLegend2.prototype.drawRail = function(group2) {
    var railCfg = this.get("rail");
    var style = railCfg.style;
    this.addShape(group2, {
      type: "path",
      id: this.getElementId("rail"),
      name: "legend-rail",
      attrs: __assign({ path: this.getRailPath(0, 0) }, style)
    });
  };
  ContinueLegend2.prototype.getTrackColor = function(colors) {
    var count = colors.length;
    if (!count) {
      return null;
    }
    if (count === 1) {
      return colors[0];
    }
    var color2;
    if (this.isVertical()) {
      color2 = "l(90)";
    } else {
      color2 = "l(0)";
    }
    for (var i = 0; i < count; i++) {
      var percent = i / (count - 1);
      color2 += " " + percent + ":" + colors[i];
    }
    return color2;
  };
  ContinueLegend2.prototype.getTrackPath = function(group2) {
    var railShape = this.getRailShape(group2);
    var path = railShape.attr("path");
    return clone_default(path);
  };
  ContinueLegend2.prototype.getClipTrackAttrs = function(group2) {
    var value = this.getCurrentValue();
    var min3 = value[0], max3 = value[1];
    var railBBox = this.getRailBBox(group2);
    var startPoint = this.getPointByValue(min3, group2);
    var endPoint = this.getPointByValue(max3, group2);
    var isVertical2 = this.isVertical();
    var x;
    var y;
    var width;
    var height;
    if (isVertical2) {
      x = railBBox.minX;
      y = startPoint.y;
      width = railBBox.width;
      height = endPoint.y - startPoint.y;
    } else {
      x = startPoint.x;
      y = railBBox.minY;
      width = endPoint.x - startPoint.x;
      height = railBBox.height;
    }
    return {
      x,
      y,
      width,
      height
    };
  };
  ContinueLegend2.prototype.getTrackAttrs = function(group2) {
    var trackCfg = this.get("track");
    var colors = this.get("colors");
    var path = this.getTrackPath(group2);
    return mix({
      path,
      fill: this.getTrackColor(colors)
    }, trackCfg.style);
  };
  ContinueLegend2.prototype.resetTrackClip = function(group2) {
    var container = group2 || this.get("group");
    var trackId = this.getElementId("track");
    var trackShape = container.findById(trackId);
    var clipShape = trackShape.getClip();
    var attrs = this.getClipTrackAttrs(group2);
    if (!clipShape) {
      trackShape.setClip({
        type: "rect",
        attrs
      });
    } else {
      clipShape.attr(attrs);
    }
  };
  ContinueLegend2.prototype.resetTrack = function(group2) {
    var trackId = this.getElementId("track");
    var trackShape = group2.findById(trackId);
    var trackAttrs = this.getTrackAttrs(group2);
    if (trackShape) {
      trackShape.attr(trackAttrs);
    } else {
      this.addShape(group2, {
        type: "path",
        id: trackId,
        draggable: this.get("slidable"),
        name: "legend-track",
        attrs: trackAttrs
      });
    }
  };
  ContinueLegend2.prototype.getPointByValue = function(value, group2) {
    var _a3 = this.getRange(), min3 = _a3.min, max3 = _a3.max;
    var percent = (value - min3) / (max3 - min3);
    var bbox = this.getRailBBox(group2);
    var isVertcal = this.isVertical();
    var point = { x: 0, y: 0 };
    if (isVertcal) {
      point.x = bbox.minX + bbox.width / 2;
      point.y = getValueByPercent(bbox.minY, bbox.maxY, percent);
    } else {
      point.x = getValueByPercent(bbox.minX, bbox.maxX, percent);
      point.y = bbox.minY + bbox.height / 2;
    }
    return point;
  };
  ContinueLegend2.prototype.getRailShape = function(group2) {
    var container = group2 || this.get("group");
    return container.findById(this.getElementId("rail"));
  };
  ContinueLegend2.prototype.getRailBBox = function(group2) {
    var railShape = this.getRailShape(group2);
    var bbox = railShape.getBBox();
    return bbox;
  };
  ContinueLegend2.prototype.getRailCanvasBBox = function() {
    var container = this.get("group");
    var railShape = container.findById(this.getElementId("rail"));
    var bbox = railShape.getCanvasBBox();
    return bbox;
  };
  ContinueLegend2.prototype.isVertical = function() {
    return this.get("layout") === "vertical";
  };
  ContinueLegend2.prototype.getValueByCanvasPoint = function(x, y) {
    var _a3 = this.getRange(), min3 = _a3.min, max3 = _a3.max;
    var bbox = this.getRailCanvasBBox();
    var isVertcal = this.isVertical();
    var step = this.get("step");
    var percent;
    if (isVertcal) {
      percent = (y - bbox.minY) / bbox.height;
    } else {
      percent = (x - bbox.minX) / bbox.width;
    }
    var value = getValueByPercent(min3, max3, percent);
    if (step) {
      var count = Math.round((value - min3) / step);
      value = min3 + count * step;
    }
    if (value > max3) {
      value = max3;
    }
    if (value < min3) {
      value = min3;
    }
    return value;
  };
  ContinueLegend2.prototype.getCurrentValue = function() {
    var value = this.get("value");
    if (!value) {
      var values2 = this.get("values");
      if (!values2) {
        return [this.get("min"), this.get("max")];
      }
      return [Math.max(Math.min.apply(Math, __spreadArrays(values2, [this.get("max")])), this.get("min")), Math.min(Math.max.apply(Math, __spreadArrays(values2, [this.get("min")])), this.get("max"))];
    }
    return value;
  };
  ContinueLegend2.prototype.resetHandlers = function(group2) {
    var currentValue = this.getCurrentValue();
    var min3 = currentValue[0], max3 = currentValue[1];
    this.resetHandler(group2, "min", min3);
    this.resetHandler(group2, "max", max3);
  };
  ContinueLegend2.prototype.getHandlerPath = function(handlerCfg, point) {
    var isVertical2 = this.isVertical();
    var path = [];
    var width = handlerCfg.size;
    var x = point.x, y = point.y;
    var height = width * HANDLER_HEIGHT_RATIO;
    var halfWidth = width / 2;
    var oneSixthWidth = width / 6;
    if (isVertical2) {
      var triangleX = x + height * HANDLER_TRIANGLE_RATIO;
      path.push(["M", x, y]);
      path.push(["L", triangleX, y + halfWidth]);
      path.push(["L", x + height, y + halfWidth]);
      path.push(["L", x + height, y - halfWidth]);
      path.push(["L", triangleX, y - halfWidth]);
      path.push(["Z"]);
      path.push(["M", triangleX, y + oneSixthWidth]);
      path.push(["L", x + height - 2, y + oneSixthWidth]);
      path.push(["M", triangleX, y - oneSixthWidth]);
      path.push(["L", x + height - 2, y - oneSixthWidth]);
    } else {
      var triangleY = y + height * HANDLER_TRIANGLE_RATIO;
      path.push(["M", x, y]);
      path.push(["L", x - halfWidth, triangleY]);
      path.push(["L", x - halfWidth, y + height]);
      path.push(["L", x + halfWidth, y + height]);
      path.push(["L", x + halfWidth, triangleY]);
      path.push(["Z"]);
      path.push(["M", x - oneSixthWidth, triangleY]);
      path.push(["L", x - oneSixthWidth, y + height - 2]);
      path.push(["M", x + oneSixthWidth, triangleY]);
      path.push(["L", x + oneSixthWidth, y + height - 2]);
    }
    return path;
  };
  ContinueLegend2.prototype.resetHandler = function(group2, name, value) {
    var point = this.getPointByValue(value, group2);
    var handlerCfg = this.get("handler");
    var path = this.getHandlerPath(handlerCfg, point);
    var id = this.getElementId("handler-" + name);
    var handlerShape = group2.findById(id);
    var isVertical2 = this.isVertical();
    if (handlerShape) {
      handlerShape.attr("path", path);
    } else {
      this.addShape(group2, {
        type: "path",
        name: "legend-handler-" + name,
        draggable: true,
        id,
        attrs: __assign(__assign({ path }, handlerCfg.style), { cursor: isVertical2 ? "ns-resize" : "ew-resize" })
      });
    }
  };
  ContinueLegend2.prototype.fixedElements = function(group2) {
    var railShape = group2.findById(this.getElementId("rail"));
    var minLabel = group2.findById(this.getElementId("label-min"));
    var maxLabel = group2.findById(this.getElementId("label-max"));
    var startPoint = this.getDrawPoint();
    if (this.isVertical()) {
      this.fixedVertail(minLabel, maxLabel, railShape, startPoint);
    } else {
      this.fixedHorizontal(minLabel, maxLabel, railShape, startPoint);
    }
  };
  ContinueLegend2.prototype.fitRailLength = function(minLabelBBox, maxLabelBBox, railBBox, railShape) {
    var isVertical2 = this.isVertical();
    var lengthField = isVertical2 ? "height" : "width";
    var labelCfg = this.get("label");
    var labelAlign = labelCfg.align;
    var spacing = labelCfg.spacing;
    var maxLength = this.get("max" + upper_first_default(lengthField));
    if (maxLength) {
      var elementsLength = labelAlign === "rail" ? railBBox[lengthField] + minLabelBBox[lengthField] + maxLabelBBox[lengthField] + spacing * 2 : railBBox[lengthField];
      var diff2 = elementsLength - maxLength;
      if (diff2 > 0) {
        this.changeRailLength(railShape, lengthField, railBBox[lengthField] - diff2);
      }
    }
  };
  ContinueLegend2.prototype.changeRailLength = function(railShape, lengthField, length5) {
    var bbox = railShape.getBBox();
    var path;
    if (lengthField === "height") {
      path = this.getRailPath(bbox.x, bbox.y, bbox.width, length5);
    } else {
      path = this.getRailPath(bbox.x, bbox.y, length5, bbox.height);
    }
    railShape.attr("path", path);
  };
  ContinueLegend2.prototype.changeRailPosition = function(railShape, x, y) {
    var bbox = railShape.getBBox();
    var path = this.getRailPath(x, y, bbox.width, bbox.height);
    railShape.attr("path", path);
  };
  ContinueLegend2.prototype.fixedHorizontal = function(minLabel, maxLabel, railShape, startPoint) {
    var labelCfg = this.get("label");
    var labelAlign = labelCfg.align;
    var spacing = labelCfg.spacing;
    var railBBox = railShape.getBBox();
    var minLabelBBox = minLabel.getBBox();
    var maxLabelBBox = maxLabel.getBBox();
    var railHeight = railBBox.height;
    this.fitRailLength(minLabelBBox, maxLabelBBox, railBBox, railShape);
    railBBox = railShape.getBBox();
    if (labelAlign === "rail") {
      minLabel.attr({
        x: startPoint.x,
        y: startPoint.y + railHeight / 2
      });
      this.changeRailPosition(railShape, startPoint.x + minLabelBBox.width + spacing, startPoint.y);
      maxLabel.attr({
        x: startPoint.x + minLabelBBox.width + railBBox.width + spacing * 2,
        y: startPoint.y + railHeight / 2
      });
    } else if (labelAlign === "top") {
      minLabel.attr({
        x: startPoint.x,
        y: startPoint.y
      });
      maxLabel.attr({
        x: startPoint.x + railBBox.width,
        y: startPoint.y
      });
      this.changeRailPosition(railShape, startPoint.x, startPoint.y + minLabelBBox.height + spacing);
    } else {
      this.changeRailPosition(railShape, startPoint.x, startPoint.y);
      minLabel.attr({
        x: startPoint.x,
        y: startPoint.y + railBBox.height + spacing
      });
      maxLabel.attr({
        x: startPoint.x + railBBox.width,
        y: startPoint.y + railBBox.height + spacing
      });
    }
  };
  ContinueLegend2.prototype.fixedVertail = function(minLabel, maxLabel, railShape, startPoint) {
    var labelCfg = this.get("label");
    var labelAlign = labelCfg.align;
    var spacing = labelCfg.spacing;
    var railBBox = railShape.getBBox();
    var minLabelBBox = minLabel.getBBox();
    var maxLabelBBox = maxLabel.getBBox();
    this.fitRailLength(minLabelBBox, maxLabelBBox, railBBox, railShape);
    railBBox = railShape.getBBox();
    if (labelAlign === "rail") {
      minLabel.attr({
        x: startPoint.x,
        y: startPoint.y
      });
      this.changeRailPosition(railShape, startPoint.x, startPoint.y + minLabelBBox.height + spacing);
      maxLabel.attr({
        x: startPoint.x,
        y: startPoint.y + minLabelBBox.height + railBBox.height + spacing * 2
      });
    } else if (labelAlign === "right") {
      minLabel.attr({
        x: startPoint.x + railBBox.width + spacing,
        y: startPoint.y
      });
      this.changeRailPosition(railShape, startPoint.x, startPoint.y);
      maxLabel.attr({
        x: startPoint.x + railBBox.width + spacing,
        y: startPoint.y + railBBox.height
      });
    } else {
      var maxLabelWidth = Math.max(minLabelBBox.width, maxLabelBBox.width);
      minLabel.attr({
        x: startPoint.x,
        y: startPoint.y
      });
      this.changeRailPosition(railShape, startPoint.x + maxLabelWidth + spacing, startPoint.y);
      maxLabel.attr({
        x: startPoint.x,
        y: startPoint.y + railBBox.height
      });
    }
  };
  return ContinueLegend2;
}(base_default11);
var continuous_default = ContinueLegend;

// node_modules/@antv/component/esm/tooltip/index.js
var tooltip_exports = {};
__export(tooltip_exports, {
  Html: () => html_default3
});

// node_modules/@antv/component/esm/tooltip/css-const.js
var css_const_exports2 = {};
__export(css_const_exports2, {
  CONTAINER_CLASS: () => CONTAINER_CLASS2,
  CROSSHAIR_X: () => CROSSHAIR_X,
  CROSSHAIR_Y: () => CROSSHAIR_Y,
  LIST_CLASS: () => LIST_CLASS,
  LIST_ITEM_CLASS: () => LIST_ITEM_CLASS,
  MARKER_CLASS: () => MARKER_CLASS,
  NAME_CLASS: () => NAME_CLASS,
  TITLE_CLASS: () => TITLE_CLASS,
  VALUE_CLASS: () => VALUE_CLASS
});
var CONTAINER_CLASS2 = "g2-tooltip";
var TITLE_CLASS = "g2-tooltip-title";
var LIST_CLASS = "g2-tooltip-list";
var LIST_ITEM_CLASS = "g2-tooltip-list-item";
var MARKER_CLASS = "g2-tooltip-marker";
var VALUE_CLASS = "g2-tooltip-value";
var NAME_CLASS = "g2-tooltip-name";
var CROSSHAIR_X = "g2-tooltip-crosshair-x";
var CROSSHAIR_Y = "g2-tooltip-crosshair-y";

// node_modules/@antv/component/esm/tooltip/html-theme.js
var _a2;
var html_theme_default2 = (_a2 = {}, _a2["" + CONTAINER_CLASS2] = {
  position: "absolute",
  visibility: "visible",
  zIndex: 8,
  transition: "visibility 0.2s cubic-bezier(0.23, 1, 0.32, 1), left 0.4s cubic-bezier(0.23, 1, 0.32, 1), top 0.4s cubic-bezier(0.23, 1, 0.32, 1)",
  backgroundColor: "rgba(255, 255, 255, 0.9)",
  boxShadow: "0px 0px 10px #aeaeae",
  borderRadius: "3px",
  color: "rgb(87, 87, 87)",
  fontSize: "12px",
  fontFamily: theme_default.fontFamily,
  lineHeight: "20px",
  padding: "10px 10px 6px 10px"
}, _a2["" + TITLE_CLASS] = {
  marginBottom: "4px"
}, _a2["" + LIST_CLASS] = {
  margin: "0px",
  listStyleType: "none",
  padding: "0px"
}, _a2["" + LIST_ITEM_CLASS] = {
  listStyleType: "none",
  marginBottom: "4px"
}, _a2["" + MARKER_CLASS] = {
  width: "8px",
  height: "8px",
  borderRadius: "50%",
  display: "inline-block",
  marginRight: "8px"
}, _a2["" + VALUE_CLASS] = {
  display: "inline-block",
  float: "right",
  marginLeft: "30px"
}, _a2["" + CROSSHAIR_X] = {
  position: "absolute",
  width: "1px",
  backgroundColor: "rgba(0, 0, 0, 0.25)"
}, _a2["" + CROSSHAIR_Y] = {
  position: "absolute",
  height: "1px",
  backgroundColor: "rgba(0, 0, 0, 0.25)"
}, _a2);

// node_modules/@antv/component/esm/util/align.js
function getOutSides(x, y, width, height, limitBox) {
  var hits = {
    left: x < limitBox.x,
    right: x + width > limitBox.x + limitBox.width,
    top: y < limitBox.y,
    bottom: y + height > limitBox.y + limitBox.height
  };
  return hits;
}
function getPointByPosition(x, y, offset, width, height, position) {
  var px = x;
  var py = y;
  switch (position) {
    case "left":
      px = x - width - offset;
      py = y - height / 2;
      break;
    case "right":
      px = x + offset;
      py = y - height / 2;
      break;
    case "top":
      px = x - width / 2;
      py = y - height - offset;
      break;
    case "bottom":
      px = x - width / 2;
      py = y + offset;
      break;
    default:
      px = x + offset;
      py = y - height - offset;
      break;
  }
  return {
    x: px,
    y: py
  };
}
function getAlignPoint(x, y, offset, width, height, position, limitBox) {
  var point = getPointByPosition(x, y, offset, width, height, position);
  if (limitBox) {
    var outSides = getOutSides(point.x, point.y, width, height, limitBox);
    if (position === "auto") {
      if (outSides.right) {
        point.x = Math.max(0, x - width - offset);
      }
      if (outSides.top) {
        point.y = Math.max(0, y - height - offset);
      }
    } else if (position === "top" || position === "bottom") {
      if (outSides.left) {
        point.x = limitBox.x;
      }
      if (outSides.right) {
        point.x = limitBox.x + limitBox.width - width;
      }
      if (position === "top" && outSides.top) {
        point.y = y + offset;
      }
      if (position === "bottom" && outSides.bottom) {
        point.y = y - height - offset;
      }
    } else {
      if (outSides.top) {
        point.y = limitBox.y;
      }
      if (outSides.bottom) {
        point.y = limitBox.y + limitBox.height - height;
      }
      if (position === "left" && outSides.left) {
        point.x = x + offset;
      }
      if (position === "right" && outSides.right) {
        point.x = x - width - offset;
      }
    }
  }
  return point;
}

// node_modules/@antv/component/esm/tooltip/html.js
function hasOneKey(obj, keys2) {
  var result = false;
  each_default(keys2, function(key) {
    if (has_key_default(obj, key)) {
      result = true;
      return false;
    }
  });
  return result;
}
var Tooltip = function(_super) {
  __extends(Tooltip3, _super);
  function Tooltip3() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Tooltip3.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign(__assign({}, cfg), {
      name: "tooltip",
      type: "html",
      x: 0,
      y: 0,
      items: [],
      customContent: null,
      containerTpl: '<div class="' + CONTAINER_CLASS2 + '"><div class="' + TITLE_CLASS + '"></div><ul class="' + LIST_CLASS + '"></ul></div>',
      itemTpl: '<li class="' + LIST_ITEM_CLASS + '" data-index={index}>\n          <span class="' + MARKER_CLASS + '" style="background:{color}"></span>\n          <span class="' + NAME_CLASS + '">{name}</span>:\n          <span class="' + VALUE_CLASS + '">{value}</span>\n        </li>',
      xCrosshairTpl: '<div class="' + CROSSHAIR_X + '"></div>',
      yCrosshairTpl: '<div class="' + CROSSHAIR_Y + '"></div>',
      title: null,
      showTitle: true,
      region: null,
      crosshairsRegion: null,
      containerClassName: CONTAINER_CLASS2,
      crosshairs: null,
      offset: 10,
      position: "right",
      domStyles: null,
      defaultStyles: html_theme_default2
    });
  };
  Tooltip3.prototype.render = function() {
    if (this.get("customContent")) {
      this.renderCustomContent();
    } else {
      this.resetTitle();
      this.renderItems();
    }
    this.resetPosition();
  };
  Tooltip3.prototype.clear = function() {
    this.clearCrosshairs();
    this.setTitle("");
    this.clearItemDoms();
  };
  Tooltip3.prototype.show = function() {
    var container = this.getContainer();
    if (!container || this.destroyed) {
      return;
    }
    this.set("visible", true);
    modifyCSS(container, {
      visibility: "visible"
    });
    this.setCrossHairsVisible(true);
  };
  Tooltip3.prototype.hide = function() {
    var container = this.getContainer();
    if (!container || this.destroyed) {
      return;
    }
    this.set("visible", false);
    modifyCSS(container, {
      visibility: "hidden"
    });
    this.setCrossHairsVisible(false);
  };
  Tooltip3.prototype.getLocation = function() {
    return { x: this.get("x"), y: this.get("y") };
  };
  Tooltip3.prototype.setLocation = function(point) {
    this.set("x", point.x);
    this.set("y", point.y);
    this.resetPosition();
  };
  Tooltip3.prototype.setCrossHairsVisible = function(visible) {
    var display = visible ? "" : "none";
    var xCrosshairDom = this.get("xCrosshairDom");
    var yCrosshairDom = this.get("yCrosshairDom");
    xCrosshairDom && modifyCSS(xCrosshairDom, {
      display
    });
    yCrosshairDom && modifyCSS(yCrosshairDom, {
      display
    });
  };
  Tooltip3.prototype.initContainer = function() {
    _super.prototype.initContainer.call(this);
    if (this.get("customContent")) {
      if (this.get("container")) {
        this.get("container").remove();
      }
      var newContainer = this.getHtmlContentNode();
      var customContainer = document.createElement("div");
      customContainer.className = CONTAINER_CLASS2;
      customContainer.appendChild(newContainer);
      this.get("parent").appendChild(customContainer);
      this.set("container", customContainer);
      this.resetStyles();
      this.applyStyles();
    }
  };
  Tooltip3.prototype.updateInner = function(cfg) {
    if (this.get("customContent")) {
      this.renderCustomContent();
    } else {
      if (hasOneKey(cfg, ["title", "showTitle"])) {
        this.resetTitle();
      }
      if (has_key_default(cfg, "items")) {
        this.renderItems();
      }
    }
    _super.prototype.updateInner.call(this, cfg);
  };
  Tooltip3.prototype.initDom = function() {
    this.cacheDoms();
  };
  Tooltip3.prototype.removeDom = function() {
    _super.prototype.removeDom.call(this);
    this.clearCrosshairs();
  };
  Tooltip3.prototype.resetPosition = function() {
    var x = this.get("x");
    var y = this.get("y");
    var offset = this.get("offset");
    var _a3 = this.getOffset(), offsetX = _a3.offsetX, offsetY = _a3.offsetY;
    var position = this.get("position");
    var region = this.get("region");
    var container = this.getContainer();
    var bbox = this.getBBox();
    var width = bbox.width, height = bbox.height;
    var limitBox;
    if (region) {
      limitBox = regionToBBox(region);
    }
    var point = getAlignPoint(x, y, offset, width, height, position, limitBox);
    modifyCSS(container, {
      left: toPx(point.x + offsetX),
      top: toPx(point.y + offsetY)
    });
    this.resetCrosshairs();
  };
  Tooltip3.prototype.renderCustomContent = function() {
    var newContainer = this.getHtmlContentNode();
    var oldContainer = this.get("container");
    oldContainer.innerHTML = "";
    oldContainer.appendChild(newContainer);
    this.resetStyles();
    this.applyStyles();
  };
  Tooltip3.prototype.getHtmlContentNode = function() {
    var node;
    var customContent = this.get("customContent");
    if (customContent) {
      var elem = customContent(this.get("title"), this.get("items"));
      if (is_element_default(elem)) {
        node = elem;
      } else {
        node = createDom(elem);
      }
    }
    return node;
  };
  Tooltip3.prototype.cacheDoms = function() {
    var container = this.getContainer();
    var titleDom = container.getElementsByClassName(TITLE_CLASS)[0];
    var listDom = container.getElementsByClassName(LIST_CLASS)[0];
    this.set("titleDom", titleDom);
    this.set("listDom", listDom);
  };
  Tooltip3.prototype.resetTitle = function() {
    var title = this.get("title");
    var showTitle = this.get("showTitle");
    if (showTitle && title) {
      this.setTitle(title);
    } else {
      this.setTitle("");
    }
  };
  Tooltip3.prototype.setTitle = function(text) {
    var titleDom = this.get("titleDom");
    if (titleDom) {
      titleDom.innerText = text;
    }
  };
  Tooltip3.prototype.resetCrosshairs = function() {
    var crosshairsRegion = this.get("crosshairsRegion");
    var crosshairs = this.get("crosshairs");
    if (!crosshairsRegion || !crosshairs) {
      this.clearCrosshairs();
    } else {
      var crosshairBox = regionToBBox(crosshairsRegion);
      var xCrosshairDom = this.get("xCrosshairDom");
      var yCrosshairDom = this.get("yCrosshairDom");
      if (crosshairs === "x") {
        this.resetCrosshair("x", crosshairBox);
        if (yCrosshairDom) {
          yCrosshairDom.remove();
          this.set("yCrosshairDom", null);
        }
      } else if (crosshairs === "y") {
        this.resetCrosshair("y", crosshairBox);
        if (xCrosshairDom) {
          xCrosshairDom.remove();
          this.set("xCrosshairDom", null);
        }
      } else {
        this.resetCrosshair("x", crosshairBox);
        this.resetCrosshair("y", crosshairBox);
      }
      this.setCrossHairsVisible(this.get("visible"));
    }
  };
  Tooltip3.prototype.resetCrosshair = function(name, bbox) {
    var croshairDom = this.checkCrosshair(name);
    var value = this.get(name);
    if (name === "x") {
      modifyCSS(croshairDom, {
        left: toPx(value),
        top: toPx(bbox.y),
        height: toPx(bbox.height)
      });
    } else {
      modifyCSS(croshairDom, {
        top: toPx(value),
        left: toPx(bbox.x),
        width: toPx(bbox.width)
      });
    }
  };
  Tooltip3.prototype.checkCrosshair = function(name) {
    var domName = name + "CrosshairDom";
    var tplName = name + "CrosshairTpl";
    var constName = "CROSSHAIR_" + name.toUpperCase();
    var styleName = css_const_exports2[constName];
    var croshairDom = this.get(domName);
    var parent = this.get("parent");
    if (!croshairDom) {
      croshairDom = createDom(this.get(tplName));
      this.applyStyle(styleName, croshairDom);
      parent.appendChild(croshairDom);
      this.set(domName, croshairDom);
    }
    return croshairDom;
  };
  Tooltip3.prototype.renderItems = function() {
    this.clearItemDoms();
    var items = this.get("items");
    var itemTpl = this.get("itemTpl");
    var listDom = this.get("listDom");
    if (listDom) {
      each_default(items, function(item) {
        var color2 = esm_default2.toCSSGradient(item.color);
        var substituteObj = __assign(__assign({}, item), { color: color2 });
        var domStr = substitute_default(itemTpl, substituteObj);
        var itemDom = createDom(domStr);
        listDom.appendChild(itemDom);
      });
      this.applyChildrenStyles(listDom, this.get("domStyles"));
    }
  };
  Tooltip3.prototype.clearItemDoms = function() {
    if (this.get("listDom")) {
      clearDom(this.get("listDom"));
    }
  };
  Tooltip3.prototype.clearCrosshairs = function() {
    var xCrosshairDom = this.get("xCrosshairDom");
    var yCrosshairDom = this.get("yCrosshairDom");
    xCrosshairDom && xCrosshairDom.remove();
    yCrosshairDom && yCrosshairDom.remove();
    this.set("xCrosshairDom", null);
    this.set("yCrosshairDom", null);
  };
  return Tooltip3;
}(html_component_default);
var html_default3 = Tooltip;

// node_modules/@antv/component/esm/trend/constant.js
var BACKGROUND_STYLE = {
  opacity: 0
};
var LINE_STYLE = {
  stroke: "#C5C5C5",
  strokeOpacity: 0.85
};
var AREA_STYLE = {
  fill: "#CACED4",
  opacity: 0.85
};

// node_modules/@antv/component/esm/trend/path.js
function pointsToPath(points) {
  return map_default(points, function(p, idx) {
    var command = idx === 0 ? "M" : "L";
    var x = p[0], y = p[1];
    return [command, x, y];
  });
}
function getLinePath(points) {
  return pointsToPath(points);
}
function getSmoothLinePath(points) {
  if (points.length <= 2) {
    return getLinePath(points);
  }
  var data = [];
  each_default(points, function(p) {
    if (!is_equal_default(p, data.slice(data.length - 2))) {
      data.push(p[0], p[1]);
    }
  });
  var path = catmull_rom_2_bezier_default(data, false);
  var _a3 = head(points), x = _a3[0], y = _a3[1];
  path.unshift(["M", x, y]);
  return path;
}
function dataToPath(data, width, height, smooth) {
  if (smooth === void 0) {
    smooth = true;
  }
  var y = new linear_default({
    values: data
  });
  var x = new base_default5({
    values: map_default(data, function(v, idx) {
      return idx;
    })
  });
  var points = map_default(data, function(v, idx) {
    return [x.scale(idx) * width, height - y.scale(v) * height];
  });
  return smooth ? getSmoothLinePath(points) : getLinePath(points);
}
function getAreaLineY(data, height) {
  var y = new linear_default({
    values: data
  });
  var lineY = y.max < 0 ? y.max : Math.max(0, y.min);
  return height - y.scale(lineY) * height;
}
function linePathToAreaPath(path, width, height, data) {
  var areaPath = __spreadArrays(path);
  var lineYPx = getAreaLineY(data, height);
  areaPath.push(["L", width, lineYPx]);
  areaPath.push(["L", 0, lineYPx]);
  areaPath.push(["Z"]);
  return areaPath;
}

// node_modules/@antv/component/esm/trend/trend.js
var Trend = function(_super) {
  __extends(Trend2, _super);
  function Trend2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Trend2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign(__assign({}, cfg), { name: "trend", x: 0, y: 0, width: 200, height: 16, smooth: true, isArea: false, data: [], backgroundStyle: BACKGROUND_STYLE, lineStyle: LINE_STYLE, areaStyle: AREA_STYLE });
  };
  Trend2.prototype.renderInner = function(group2) {
    var _a3 = this.cfg, width = _a3.width, height = _a3.height, data = _a3.data, smooth = _a3.smooth, isArea = _a3.isArea, backgroundStyle = _a3.backgroundStyle, lineStyle = _a3.lineStyle, areaStyle = _a3.areaStyle;
    this.addShape(group2, {
      id: this.getElementId("background"),
      type: "rect",
      attrs: __assign({
        x: 0,
        y: 0,
        width,
        height
      }, backgroundStyle)
    });
    var path = dataToPath(data, width, height, smooth);
    this.addShape(group2, {
      id: this.getElementId("line"),
      type: "path",
      attrs: __assign({ path }, lineStyle)
    });
    if (isArea) {
      var areaPath = linePathToAreaPath(path, width, height, data);
      this.addShape(group2, {
        id: this.getElementId("area"),
        type: "path",
        attrs: __assign({ path: areaPath }, areaStyle)
      });
    }
  };
  Trend2.prototype.applyOffset = function() {
    var _a3 = this.cfg, x = _a3.x, y = _a3.y;
    this.moveElementTo(this.get("group"), {
      x,
      y
    });
  };
  return Trend2;
}(group_component_default);

// node_modules/@antv/component/esm/slider/handler.js
var DEFAULT_HANDLER_STYLE = {
  fill: "#F7F7F7",
  stroke: "#BFBFBF",
  radius: 2,
  opacity: 1,
  cursor: "ew-resize",
  highLightFill: "#FFF"
};
var Handler = function(_super) {
  __extends(Handler2, _super);
  function Handler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Handler2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign(__assign({}, cfg), { name: "handler", x: 0, y: 0, width: 10, height: 24, style: DEFAULT_HANDLER_STYLE });
  };
  Handler2.prototype.renderInner = function(group2) {
    var _a3 = this.cfg, width = _a3.width, height = _a3.height, style = _a3.style;
    var fill = style.fill, stroke = style.stroke, radius = style.radius, opacity = style.opacity, cursor = style.cursor;
    this.addShape(group2, {
      type: "rect",
      id: this.getElementId("background"),
      attrs: {
        x: 0,
        y: 0,
        width,
        height,
        fill,
        stroke,
        radius,
        opacity,
        cursor
      }
    });
    var x1 = 1 / 3 * width;
    var x2 = 2 / 3 * width;
    var y1 = 1 / 4 * height;
    var y2 = 3 / 4 * height;
    this.addShape(group2, {
      id: this.getElementId("line-left"),
      type: "line",
      attrs: {
        x1,
        y1,
        x2: x1,
        y2,
        stroke,
        cursor
      }
    });
    this.addShape(group2, {
      id: this.getElementId("line-right"),
      type: "line",
      attrs: {
        x1: x2,
        y1,
        x2,
        y2,
        stroke,
        cursor
      }
    });
  };
  Handler2.prototype.applyOffset = function() {
    this.moveElementTo(this.get("group"), {
      x: this.get("x"),
      y: this.get("y")
    });
  };
  Handler2.prototype.initEvent = function() {
    this.bindEvents();
  };
  Handler2.prototype.bindEvents = function() {
    var _this = this;
    this.get("group").on("mouseenter", function() {
      var highLightFill = _this.get("style").highLightFill;
      _this.getElementByLocalId("background").attr("fill", highLightFill);
      _this.draw();
    });
    this.get("group").on("mouseleave", function() {
      var fill = _this.get("style").fill;
      _this.getElementByLocalId("background").attr("fill", fill);
      _this.draw();
    });
  };
  Handler2.prototype.draw = function() {
    var canvas = this.get("container").get("canvas");
    if (canvas) {
      canvas.draw();
    }
  };
  return Handler2;
}(group_component_default);

// node_modules/@antv/component/esm/slider/constant.js
var BACKGROUND_STYLE2 = {
  fill: "#416180",
  opacity: 0.05
};
var FOREGROUND_STYLE = {
  fill: "#5B8FF9",
  opacity: 0.15,
  cursor: "move"
};
var DEFAULT_HANDLER_WIDTH = 10;
var HANDLER_STYLE = {
  width: DEFAULT_HANDLER_WIDTH,
  height: 24
};
var TEXT_STYLE = {
  textBaseline: "middle",
  fill: "#000",
  opacity: 0.45
};
var SLIDER_CHANGE = "sliderchange";

// node_modules/@antv/component/esm/slider/slider.js
var Slider = function(_super) {
  __extends(Slider3, _super);
  function Slider3() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.onMouseDown = function(target) {
      return function(e) {
        _this.currentTarget = target;
        var event = e.originalEvent;
        event.stopPropagation();
        event.preventDefault();
        _this.prevX = get_default(event, "touches.0.pageX", event.pageX);
        _this.prevY = get_default(event, "touches.0.pageY", event.pageY);
        var containerDOM = _this.getContainerDOM();
        containerDOM.addEventListener("mousemove", _this.onMouseMove);
        containerDOM.addEventListener("mouseup", _this.onMouseUp);
        containerDOM.addEventListener("mouseleave", _this.onMouseUp);
        containerDOM.addEventListener("touchmove", _this.onMouseMove);
        containerDOM.addEventListener("touchend", _this.onMouseUp);
        containerDOM.addEventListener("touchcancel", _this.onMouseUp);
      };
    };
    _this.onMouseMove = function(event) {
      var width = _this.cfg.width;
      var originValue = [_this.get("start"), _this.get("end")];
      event.stopPropagation();
      event.preventDefault();
      var x = get_default(event, "touches.0.pageX", event.pageX);
      var y = get_default(event, "touches.0.pageY", event.pageY);
      var offsetX = x - _this.prevX;
      var offsetXRange = _this.adjustOffsetRange(offsetX / width);
      _this.updateStartEnd(offsetXRange);
      _this.updateUI(_this.getElementByLocalId("foreground"), _this.getElementByLocalId("minText"), _this.getElementByLocalId("maxText"));
      _this.prevX = x;
      _this.prevY = y;
      _this.draw();
      _this.emit(SLIDER_CHANGE, [_this.get("start"), _this.get("end")].sort());
      _this.delegateEmit("valuechanged", {
        originValue,
        value: [_this.get("start"), _this.get("end")]
      });
    };
    _this.onMouseUp = function() {
      if (_this.currentTarget) {
        _this.currentTarget = void 0;
      }
      var containerDOM = _this.getContainerDOM();
      if (containerDOM) {
        containerDOM.removeEventListener("mousemove", _this.onMouseMove);
        containerDOM.removeEventListener("mouseup", _this.onMouseUp);
        containerDOM.removeEventListener("mouseleave", _this.onMouseUp);
        containerDOM.removeEventListener("touchmove", _this.onMouseMove);
        containerDOM.removeEventListener("touchend", _this.onMouseUp);
        containerDOM.removeEventListener("touchcancel", _this.onMouseUp);
      }
    };
    return _this;
  }
  Slider3.prototype.setRange = function(min3, max3) {
    this.set("minLimit", min3);
    this.set("maxLimit", max3);
    var oldStart = this.get("start");
    var oldEnd = this.get("end");
    var newStart = clamp_default(oldStart, min3, max3);
    var newEnd = clamp_default(oldEnd, min3, max3);
    if (!this.get("isInit") && (oldStart !== newStart || oldEnd !== newEnd)) {
      this.setValue([newStart, newEnd]);
    }
  };
  Slider3.prototype.getRange = function() {
    return {
      min: this.get("minLimit") || 0,
      max: this.get("maxLimit") || 1
    };
  };
  Slider3.prototype.setValue = function(value) {
    var range = this.getRange();
    if (is_array_default(value) && value.length === 2) {
      var originValue = [this.get("start"), this.get("end")];
      this.update({
        start: clamp_default(value[0], range.min, range.max),
        end: clamp_default(value[1], range.min, range.max)
      });
      if (!this.get("updateAutoRender")) {
        this.render();
      }
      this.delegateEmit("valuechanged", {
        originValue,
        value
      });
    }
  };
  Slider3.prototype.getValue = function() {
    return [this.get("start"), this.get("end")];
  };
  Slider3.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign(__assign({}, cfg), { name: "slider", x: 0, y: 0, width: 100, height: 16, backgroundStyle: {}, foregroundStyle: {}, handlerStyle: {}, textStyle: {}, defaultCfg: {
      backgroundStyle: BACKGROUND_STYLE2,
      foregroundStyle: FOREGROUND_STYLE,
      handlerStyle: HANDLER_STYLE,
      textStyle: TEXT_STYLE
    } });
  };
  Slider3.prototype.update = function(cfg) {
    var start = cfg.start, end = cfg.end;
    var validCfg = __assign({}, cfg);
    if (!is_nil_default(start)) {
      validCfg.start = clamp_default(start, 0, 1);
    }
    if (!is_nil_default(end)) {
      validCfg.end = clamp_default(end, 0, 1);
    }
    _super.prototype.update.call(this, validCfg);
    this.minHandler = this.getChildComponentById(this.getElementId("minHandler"));
    this.maxHandler = this.getChildComponentById(this.getElementId("maxHandler"));
    this.trend = this.getChildComponentById(this.getElementId("trend"));
  };
  Slider3.prototype.init = function() {
    this.set("start", clamp_default(this.get("start"), 0, 1));
    this.set("end", clamp_default(this.get("end"), 0, 1));
    _super.prototype.init.call(this);
  };
  Slider3.prototype.render = function() {
    _super.prototype.render.call(this);
    this.updateUI(this.getElementByLocalId("foreground"), this.getElementByLocalId("minText"), this.getElementByLocalId("maxText"));
  };
  Slider3.prototype.renderInner = function(group2) {
    var _a3 = this.cfg, start = _a3.start, end = _a3.end, width = _a3.width, height = _a3.height, _b = _a3.trendCfg, trendCfg = _b === void 0 ? {} : _b, minText = _a3.minText, maxText = _a3.maxText, _c = _a3.backgroundStyle, backgroundStyle = _c === void 0 ? {} : _c, _d = _a3.foregroundStyle, foregroundStyle = _d === void 0 ? {} : _d, _e = _a3.textStyle, textStyle2 = _e === void 0 ? {} : _e;
    var handlerStyle = deep_mix_default({}, DEFAULT_HANDLER_STYLE, this.cfg.handlerStyle);
    var min3 = start * width;
    var max3 = end * width;
    if (size(get_default(trendCfg, "data"))) {
      this.trend = this.addComponent(group2, __assign({
        component: Trend,
        id: this.getElementId("trend"),
        x: 0,
        y: 0,
        width,
        height
      }, trendCfg));
    }
    this.addShape(group2, {
      id: this.getElementId("background"),
      type: "rect",
      attrs: __assign({
        x: 0,
        y: 0,
        width,
        height
      }, backgroundStyle)
    });
    var minTextShape = this.addShape(group2, {
      id: this.getElementId("minText"),
      type: "text",
      attrs: __assign({
        y: height / 2,
        textAlign: "right",
        text: minText,
        silent: false
      }, textStyle2)
    });
    var maxTextShape = this.addShape(group2, {
      id: this.getElementId("maxText"),
      type: "text",
      attrs: __assign({
        y: height / 2,
        textAlign: "left",
        text: maxText,
        silent: false
      }, textStyle2)
    });
    var foregroundShape = this.addShape(group2, {
      id: this.getElementId("foreground"),
      name: "foreground",
      type: "rect",
      attrs: __assign({
        y: 0,
        height
      }, foregroundStyle)
    });
    var handlerWidth = get_default(handlerStyle, "width", DEFAULT_HANDLER_WIDTH);
    var handlerHeight = get_default(handlerStyle, "height", 24);
    this.minHandler = this.addComponent(group2, {
      component: Handler,
      id: this.getElementId("minHandler"),
      name: "handler-min",
      x: 0,
      y: (height - handlerHeight) / 2,
      width: handlerWidth,
      height: handlerHeight,
      cursor: "ew-resize",
      style: handlerStyle
    });
    this.maxHandler = this.addComponent(group2, {
      component: Handler,
      id: this.getElementId("maxHandler"),
      name: "handler-max",
      x: 0,
      y: (height - handlerHeight) / 2,
      width: handlerWidth,
      height: handlerHeight,
      cursor: "ew-resize",
      style: handlerStyle
    });
  };
  Slider3.prototype.applyOffset = function() {
    this.moveElementTo(this.get("group"), {
      x: this.get("x"),
      y: this.get("y")
    });
  };
  Slider3.prototype.initEvent = function() {
    this.bindEvents();
  };
  Slider3.prototype.updateUI = function(foregroundShape, minTextShape, maxTextShape) {
    var _a3 = this.cfg, start = _a3.start, end = _a3.end, width = _a3.width, minText = _a3.minText, maxText = _a3.maxText, handlerStyle = _a3.handlerStyle, height = _a3.height;
    var min3 = start * width;
    var max3 = end * width;
    if (this.trend) {
      this.trend.update({
        width,
        height
      });
      if (!this.get("updateAutoRender")) {
        this.trend.render();
      }
    }
    foregroundShape.attr("x", min3);
    foregroundShape.attr("width", max3 - min3);
    var handlerWidth = get_default(handlerStyle, "width", DEFAULT_HANDLER_WIDTH);
    minTextShape.attr("text", minText);
    maxTextShape.attr("text", maxText);
    var _b = this._dodgeText([min3, max3], minTextShape, maxTextShape), minAttrs = _b[0], maxAttrs = _b[1];
    if (this.minHandler) {
      this.minHandler.update({
        x: min3 - handlerWidth / 2
      });
      if (!this.get("updateAutoRender")) {
        this.minHandler.render();
      }
    }
    each_default(minAttrs, function(v, k) {
      return minTextShape.attr(k, v);
    });
    if (this.maxHandler) {
      this.maxHandler.update({
        x: max3 - handlerWidth / 2
      });
      if (!this.get("updateAutoRender")) {
        this.maxHandler.render();
      }
    }
    each_default(maxAttrs, function(v, k) {
      return maxTextShape.attr(k, v);
    });
  };
  Slider3.prototype.bindEvents = function() {
    var group2 = this.get("group");
    group2.on("handler-min:mousedown", this.onMouseDown("minHandler"));
    group2.on("handler-min:touchstart", this.onMouseDown("minHandler"));
    group2.on("handler-max:mousedown", this.onMouseDown("maxHandler"));
    group2.on("handler-max:touchstart", this.onMouseDown("maxHandler"));
    var foreground = group2.findById(this.getElementId("foreground"));
    foreground.on("mousedown", this.onMouseDown("foreground"));
    foreground.on("touchstart", this.onMouseDown("foreground"));
  };
  Slider3.prototype.adjustOffsetRange = function(offsetRange) {
    var _a3 = this.cfg, start = _a3.start, end = _a3.end;
    switch (this.currentTarget) {
      case "minHandler": {
        var min3 = 0 - start;
        var max3 = 1 - start;
        return Math.min(max3, Math.max(min3, offsetRange));
      }
      case "maxHandler": {
        var min3 = 0 - end;
        var max3 = 1 - end;
        return Math.min(max3, Math.max(min3, offsetRange));
      }
      case "foreground": {
        var min3 = 0 - start;
        var max3 = 1 - end;
        return Math.min(max3, Math.max(min3, offsetRange));
      }
    }
  };
  Slider3.prototype.updateStartEnd = function(offsetRange) {
    var _a3 = this.cfg, start = _a3.start, end = _a3.end;
    switch (this.currentTarget) {
      case "minHandler":
        start += offsetRange;
        break;
      case "maxHandler":
        end += offsetRange;
        break;
      case "foreground":
        start += offsetRange;
        end += offsetRange;
        break;
    }
    this.set("start", start);
    this.set("end", end);
  };
  Slider3.prototype._dodgeText = function(range, minTextShape, maxTextShape) {
    var _a3, _b;
    var _c = this.cfg, handlerStyle = _c.handlerStyle, width = _c.width;
    var PADDING = 2;
    var handlerWidth = get_default(handlerStyle, "width", DEFAULT_HANDLER_WIDTH);
    var min3 = range[0], max3 = range[1];
    var sorted = false;
    if (min3 > max3) {
      _a3 = [max3, min3], min3 = _a3[0], max3 = _a3[1];
      _b = [maxTextShape, minTextShape], minTextShape = _b[0], maxTextShape = _b[1];
      sorted = true;
    }
    var minBBox = minTextShape.getBBox();
    var maxBBox = maxTextShape.getBBox();
    var minAttrs = minBBox.width > min3 - PADDING ? { x: min3 + handlerWidth / 2 + PADDING, textAlign: "left" } : { x: min3 - handlerWidth / 2 - PADDING, textAlign: "right" };
    var maxAttrs = maxBBox.width > width - max3 - PADDING ? { x: max3 - handlerWidth / 2 - PADDING, textAlign: "right" } : { x: max3 + handlerWidth / 2 + PADDING, textAlign: "left" };
    return !sorted ? [minAttrs, maxAttrs] : [maxAttrs, minAttrs];
  };
  Slider3.prototype.draw = function() {
    var container = this.get("container");
    var canvas = container && container.get("canvas");
    if (canvas) {
      canvas.draw();
    }
  };
  Slider3.prototype.getContainerDOM = function() {
    var container = this.get("container");
    var canvas = container && container.get("canvas");
    return canvas && canvas.get("container");
  };
  return Slider3;
}(group_component_default);

// node_modules/@antv/component/esm/scrollbar/scrollbar.js
var DEFAULT_STYLE = {
  trackColor: "rgba(0,0,0,0)",
  thumbColor: "rgba(0,0,0,0.15)",
  size: 8,
  lineCap: "round"
};
var DEFAULT_THEME = {
  default: DEFAULT_STYLE,
  hover: {
    thumbColor: "rgba(0,0,0,0.2)"
  }
};
var Scrollbar = function(_super) {
  __extends(Scrollbar3, _super);
  function Scrollbar3() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.clearEvents = noop_default;
    _this.onStartEvent = function(isMobile) {
      return function(e) {
        _this.isMobile = isMobile;
        e.originalEvent.preventDefault();
        var clientX = isMobile ? get_default(e.originalEvent, "touches.0.clientX") : e.clientX;
        var clientY = isMobile ? get_default(e.originalEvent, "touches.0.clientY") : e.clientY;
        _this.startPos = _this.cfg.isHorizontal ? clientX : clientY;
        _this.bindLaterEvent();
      };
    };
    _this.bindLaterEvent = function() {
      var containerDOM = _this.getContainerDOM();
      var events = [];
      if (_this.isMobile) {
        events = [
          addEventListener(containerDOM, "touchmove", _this.onMouseMove),
          addEventListener(containerDOM, "touchend", _this.onMouseUp),
          addEventListener(containerDOM, "touchcancel", _this.onMouseUp)
        ];
      } else {
        events = [
          addEventListener(containerDOM, "mousemove", _this.onMouseMove),
          addEventListener(containerDOM, "mouseup", _this.onMouseUp),
          addEventListener(containerDOM, "mouseleave", _this.onMouseUp)
        ];
      }
      _this.clearEvents = function() {
        events.forEach(function(e) {
          e.remove();
        });
      };
    };
    _this.onMouseMove = function(e) {
      var _a3 = _this.cfg, isHorizontal = _a3.isHorizontal, thumbOffset = _a3.thumbOffset;
      e.preventDefault();
      var clientX = _this.isMobile ? get_default(e, "touches.0.clientX") : e.clientX;
      var clientY = _this.isMobile ? get_default(e, "touches.0.clientY") : e.clientY;
      var endPos = isHorizontal ? clientX : clientY;
      var diff2 = endPos - _this.startPos;
      _this.startPos = endPos;
      _this.updateThumbOffset(thumbOffset + diff2);
    };
    _this.onMouseUp = function(e) {
      e.preventDefault();
      _this.clearEvents();
    };
    _this.onTrackClick = function(e) {
      var _a3 = _this.cfg, isHorizontal = _a3.isHorizontal, x = _a3.x, y = _a3.y, thumbLen = _a3.thumbLen;
      var containerDOM = _this.getContainerDOM();
      var rect = containerDOM.getBoundingClientRect();
      var clientX = e.clientX, clientY = e.clientY;
      var offset = isHorizontal ? clientX - rect.left - x - thumbLen / 2 : clientY - rect.top - y - thumbLen / 2;
      var newOffset = _this.validateRange(offset);
      _this.updateThumbOffset(newOffset);
    };
    _this.onThumbMouseOver = function() {
      var thumbColor = _this.cfg.theme.hover.thumbColor;
      _this.getElementByLocalId("thumb").attr("stroke", thumbColor);
      _this.draw();
    };
    _this.onThumbMouseOut = function() {
      var thumbColor = _this.cfg.theme.default.thumbColor;
      _this.getElementByLocalId("thumb").attr("stroke", thumbColor);
      _this.draw();
    };
    return _this;
  }
  Scrollbar3.prototype.setRange = function(min3, max3) {
    this.set("minLimit", min3);
    this.set("maxLimit", max3);
    var curValue = this.getValue();
    var newValue = clamp_default(curValue, min3, max3);
    if (curValue !== newValue && !this.get("isInit")) {
      this.setValue(newValue);
    }
  };
  Scrollbar3.prototype.getRange = function() {
    var min3 = this.get("minLimit") || 0;
    var max3 = this.get("maxLimit") || 1;
    return { min: min3, max: max3 };
  };
  Scrollbar3.prototype.setValue = function(value) {
    var range = this.getRange();
    var originalValue = this.getValue();
    this.update({
      thumbOffset: (this.get("trackLen") - this.get("thumbLen")) * clamp_default(value, range.min, range.max)
    });
    this.delegateEmit("valuechange", {
      originalValue,
      value: this.getValue()
    });
  };
  Scrollbar3.prototype.getValue = function() {
    return clamp_default(this.get("thumbOffset") / (this.get("trackLen") - this.get("thumbLen")), 0, 1);
  };
  Scrollbar3.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign(__assign({}, cfg), { name: "scrollbar", isHorizontal: true, minThumbLen: 20, thumbOffset: 0, theme: DEFAULT_THEME });
  };
  Scrollbar3.prototype.renderInner = function(group2) {
    this.renderTrackShape(group2);
    this.renderThumbShape(group2);
  };
  Scrollbar3.prototype.applyOffset = function() {
    this.moveElementTo(this.get("group"), {
      x: this.get("x"),
      y: this.get("y")
    });
  };
  Scrollbar3.prototype.initEvent = function() {
    this.bindEvents();
  };
  Scrollbar3.prototype.renderTrackShape = function(group2) {
    var _a3 = this.cfg, trackLen = _a3.trackLen, _b = _a3.theme, theme = _b === void 0 ? { default: {} } : _b;
    var _c = deep_mix_default({}, DEFAULT_THEME, theme).default, lineCap = _c.lineCap, trackColor = _c.trackColor, themeSize = _c.size;
    var size2 = get_default(this.cfg, "size", themeSize);
    var attrs = this.get("isHorizontal") ? {
      x1: 0 + size2 / 2,
      y1: size2 / 2,
      x2: trackLen - size2 / 2,
      y2: size2 / 2,
      lineWidth: size2,
      stroke: trackColor,
      lineCap
    } : {
      x1: size2 / 2,
      y1: 0 + size2 / 2,
      x2: size2 / 2,
      y2: trackLen - size2 / 2,
      lineWidth: size2,
      stroke: trackColor,
      lineCap
    };
    return this.addShape(group2, {
      id: this.getElementId("track"),
      name: "track",
      type: "line",
      attrs
    });
  };
  Scrollbar3.prototype.renderThumbShape = function(group2) {
    var _a3 = this.cfg, thumbOffset = _a3.thumbOffset, thumbLen = _a3.thumbLen, theme = _a3.theme;
    var _b = deep_mix_default({}, DEFAULT_THEME, theme).default, themeSize = _b.size, lineCap = _b.lineCap, thumbColor = _b.thumbColor;
    var size2 = get_default(this.cfg, "size", themeSize);
    var attrs = this.get("isHorizontal") ? {
      x1: thumbOffset + size2 / 2,
      y1: size2 / 2,
      x2: thumbOffset + thumbLen - size2 / 2,
      y2: size2 / 2,
      lineWidth: size2,
      stroke: thumbColor,
      lineCap,
      cursor: "default"
    } : {
      x1: size2 / 2,
      y1: thumbOffset + size2 / 2,
      x2: size2 / 2,
      y2: thumbOffset + thumbLen - size2 / 2,
      lineWidth: size2,
      stroke: thumbColor,
      lineCap,
      cursor: "default"
    };
    return this.addShape(group2, {
      id: this.getElementId("thumb"),
      name: "thumb",
      type: "line",
      attrs
    });
  };
  Scrollbar3.prototype.bindEvents = function() {
    var group2 = this.get("group");
    group2.on("mousedown", this.onStartEvent(false));
    group2.on("mouseup", this.onMouseUp);
    group2.on("touchstart", this.onStartEvent(true));
    group2.on("touchend", this.onMouseUp);
    var trackShape = group2.findById(this.getElementId("track"));
    trackShape.on("click", this.onTrackClick);
    var thumbShape = group2.findById(this.getElementId("thumb"));
    thumbShape.on("mouseover", this.onThumbMouseOver);
    thumbShape.on("mouseout", this.onThumbMouseOut);
  };
  Scrollbar3.prototype.getContainerDOM = function() {
    var container = this.get("container");
    var canvas = container && container.get("canvas");
    return canvas && canvas.get("container");
  };
  Scrollbar3.prototype.validateRange = function(offset) {
    var _a3 = this.cfg, thumbLen = _a3.thumbLen, trackLen = _a3.trackLen;
    var newOffset = offset;
    if (offset + thumbLen > trackLen) {
      newOffset = trackLen - thumbLen;
    } else if (offset + thumbLen < thumbLen) {
      newOffset = 0;
    }
    return newOffset;
  };
  Scrollbar3.prototype.draw = function() {
    var container = this.get("container");
    var canvas = container && container.get("canvas");
    if (canvas) {
      canvas.draw();
    }
  };
  Scrollbar3.prototype.updateThumbOffset = function(offset) {
    var _a3 = this.cfg, thumbOffset = _a3.thumbOffset, isHorizontal = _a3.isHorizontal, thumbLen = _a3.thumbLen, size2 = _a3.size;
    var newOffset = this.validateRange(offset);
    if (newOffset === thumbOffset) {
      return;
    }
    var thumbShape = this.getElementByLocalId("thumb");
    if (isHorizontal) {
      thumbShape.attr({
        x1: newOffset + size2 / 2,
        x2: newOffset + thumbLen - size2 / 2
      });
    } else {
      thumbShape.attr({
        y1: newOffset + size2 / 2,
        y2: newOffset + thumbLen - size2 / 2
      });
    }
    this.emitOffsetChange(newOffset);
  };
  Scrollbar3.prototype.emitOffsetChange = function(offset) {
    var _a3 = this.cfg, originalValue = _a3.thumbOffset, trackLen = _a3.trackLen, thumbLen = _a3.thumbLen;
    this.cfg.thumbOffset = offset;
    this.emit("scrollchange", {
      thumbOffset: offset,
      ratio: clamp_default(offset / (trackLen - thumbLen), 0, 1)
    });
    this.delegateEmit("valuechange", {
      originalValue,
      value: offset
    });
  };
  return Scrollbar3;
}(group_component_default);

// node_modules/@antv/g2/esm/dependents.js
var LineAxis = axis_exports.Line;
var CircleAxis = axis_exports.Circle;
var LineGrid = grid_exports.Line;
var CircleGrid = grid_exports.Circle;
var CategoryLegend = legend_exports.Category;
var ContinuousLegend = legend_exports.Continuous;
var HtmlTooltip = tooltip_exports.Html;

// node_modules/@antv/g2/esm/util/graphics.js
function getPointsBox(points) {
  if (is_empty_default(points)) {
    return null;
  }
  var minX = points[0].x;
  var maxX = points[0].x;
  var minY = points[0].y;
  var maxY = points[0].y;
  each_default(points, function(point) {
    minX = minX > point.x ? point.x : minX;
    maxX = maxX < point.x ? point.x : maxX;
    minY = minY > point.y ? point.y : minY;
    maxY = maxY < point.y ? point.y : maxY;
  });
  return {
    minX,
    maxX,
    minY,
    maxY,
    centerX: (minX + maxX) / 2,
    centerY: (minY + maxY) / 2
  };
}
function uniqueValues(array) {
  return Array.from(new Set(array)).length === 1;
}
function mid(array) {
  return (min_default(array) + max_default(array)) / 2;
}
function polarToCartesian(centerX, centerY, radius, angleInRadian) {
  return {
    x: centerX + radius * Math.cos(angleInRadian),
    y: centerY + radius * Math.sin(angleInRadian)
  };
}
function getSectorPath(centerX, centerY, radius, startAngleInRadian, endAngleInRadian, innerRadius) {
  if (innerRadius === void 0) {
    innerRadius = 0;
  }
  var start = polarToCartesian(centerX, centerY, radius, startAngleInRadian);
  var end = polarToCartesian(centerX, centerY, radius, endAngleInRadian);
  var innerStart = polarToCartesian(centerX, centerY, innerRadius, startAngleInRadian);
  var innerEnd = polarToCartesian(centerX, centerY, innerRadius, endAngleInRadian);
  if (endAngleInRadian - startAngleInRadian === Math.PI * 2) {
    var middlePoint = polarToCartesian(centerX, centerY, radius, startAngleInRadian + Math.PI);
    var innerMiddlePoint = polarToCartesian(centerX, centerY, innerRadius, startAngleInRadian + Math.PI);
    var circlePathCommands = [
      ["M", start.x, start.y],
      ["A", radius, radius, 0, 1, 1, middlePoint.x, middlePoint.y],
      ["A", radius, radius, 0, 1, 1, end.x, end.y],
      ["M", innerStart.x, innerStart.y]
    ];
    if (innerRadius) {
      circlePathCommands.push(["A", innerRadius, innerRadius, 0, 1, 0, innerMiddlePoint.x, innerMiddlePoint.y]);
      circlePathCommands.push(["A", innerRadius, innerRadius, 0, 1, 0, innerEnd.x, innerEnd.y]);
    }
    circlePathCommands.push(["M", start.x, start.y]);
    circlePathCommands.push(["Z"]);
    return circlePathCommands;
  }
  var arcSweep = endAngleInRadian - startAngleInRadian <= Math.PI ? 0 : 1;
  var sectorPathCommands = [
    ["M", start.x, start.y],
    ["A", radius, radius, 0, arcSweep, 1, end.x, end.y],
    ["L", innerEnd.x, innerEnd.y]
  ];
  if (innerRadius) {
    sectorPathCommands.push(["A", innerRadius, innerRadius, 0, arcSweep, 0, innerStart.x, innerStart.y]);
  }
  sectorPathCommands.push(["L", start.x, start.y]);
  sectorPathCommands.push(["Z"]);
  return sectorPathCommands;
}
function getArcPath(centerX, centerY, radius, startAngleInRadian, endAngleInRadian) {
  var start = polarToCartesian(centerX, centerY, radius, startAngleInRadian);
  var end = polarToCartesian(centerX, centerY, radius, endAngleInRadian);
  if (isNumberEqual(endAngleInRadian - startAngleInRadian, Math.PI * 2)) {
    var middlePoint = polarToCartesian(centerX, centerY, radius, startAngleInRadian + Math.PI);
    return [
      ["M", start.x, start.y],
      ["A", radius, radius, 0, 1, 1, middlePoint.x, middlePoint.y],
      ["A", radius, radius, 0, 1, 1, start.x, start.y],
      ["A", radius, radius, 0, 1, 0, middlePoint.x, middlePoint.y],
      ["A", radius, radius, 0, 1, 0, start.x, start.y],
      ["Z"]
    ];
  }
  var arcSweep = endAngleInRadian - startAngleInRadian <= Math.PI ? 0 : 1;
  return [
    ["M", start.x, start.y],
    ["A", radius, radius, 0, arcSweep, 1, end.x, end.y]
  ];
}
function getAngle2(shapeModel, coordinate) {
  var points = shapeModel.points;
  var box2 = getPointsBox(points);
  var endAngle;
  var startAngle;
  var coordStartAngle = coordinate.startAngle, coordEndAngle = coordinate.endAngle;
  var diffAngle = coordEndAngle - coordStartAngle;
  if (coordinate.isTransposed) {
    endAngle = box2.maxY * diffAngle;
    startAngle = box2.minY * diffAngle;
  } else {
    endAngle = box2.maxX * diffAngle;
    startAngle = box2.minX * diffAngle;
  }
  endAngle += coordStartAngle;
  startAngle += coordStartAngle;
  return {
    startAngle,
    endAngle
  };
}
function getPolygonCentroid(xs, ys) {
  if (is_number_default(xs) && is_number_default(ys)) {
    return [xs, ys];
  }
  xs = xs;
  ys = ys;
  if (uniqueValues(xs) || uniqueValues(ys))
    return [mid(xs), mid(ys)];
  var i = -1;
  var x = 0;
  var y = 0;
  var former;
  var current = xs.length - 1;
  var diff2;
  var k = 0;
  while (++i < xs.length) {
    former = current;
    current = i;
    k += diff2 = xs[former] * ys[current] - xs[current] * ys[former];
    x += (xs[former] + xs[current]) * diff2;
    y += (ys[former] + ys[current]) * diff2;
  }
  k *= 3;
  return [x / k, y / k];
}
function getReplaceAttrs(sourceShape, targetShape) {
  var originAttrs = sourceShape.attr();
  var newAttrs = targetShape.attr();
  each_default(originAttrs, function(v, k) {
    if (newAttrs[k] === void 0) {
      newAttrs[k] = void 0;
    }
  });
  return newAttrs;
}

// node_modules/@antv/g2/esm/util/helper.js
function isBetween2(value, start, end) {
  var min3 = Math.min(start, end);
  var max3 = Math.max(start, end);
  return value >= min3 && value <= max3;
}
function padEnd(source, targetLength, padValue) {
  if (is_string_default(source)) {
    return source.padEnd(targetLength, padValue);
  } else if (is_array_default(source)) {
    var sourceLength = source.length;
    if (sourceLength < targetLength) {
      var diff2 = targetLength - sourceLength;
      for (var i = 0; i < diff2; i++) {
        source.push(padValue);
      }
    }
  }
  return source;
}
function omit(obj, keys2) {
  if (typeof obj === "object") {
    keys2.forEach(function(key) {
      delete obj[key];
    });
  }
  return obj;
}
function uniq2(sourceArray, targetArray, map4) {
  var e_1, _a3;
  if (targetArray === void 0) {
    targetArray = [];
  }
  if (map4 === void 0) {
    map4 = /* @__PURE__ */ new Map();
  }
  try {
    for (var sourceArray_1 = __values(sourceArray), sourceArray_1_1 = sourceArray_1.next(); !sourceArray_1_1.done; sourceArray_1_1 = sourceArray_1.next()) {
      var source = sourceArray_1_1.value;
      if (!map4.has(source)) {
        targetArray.push(source);
        map4.set(source, true);
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (sourceArray_1_1 && !sourceArray_1_1.done && (_a3 = sourceArray_1.return))
        _a3.call(sourceArray_1);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  return targetArray;
}

// node_modules/@antv/g2/esm/util/bbox.js
var BBox = function() {
  function BBox2(x, y, width, height) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (width === void 0) {
      width = 0;
    }
    if (height === void 0) {
      height = 0;
    }
    this.x = x;
    this.y = y;
    this.height = height;
    this.width = width;
  }
  BBox2.fromRange = function(minX, minY, maxX, maxY) {
    return new BBox2(minX, minY, maxX - minX, maxY - minY);
  };
  BBox2.fromObject = function(bbox) {
    return new BBox2(bbox.minX, bbox.minY, bbox.width, bbox.height);
  };
  Object.defineProperty(BBox2.prototype, "minX", {
    get: function() {
      return this.x;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox2.prototype, "maxX", {
    get: function() {
      return this.x + this.width;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox2.prototype, "minY", {
    get: function() {
      return this.y;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox2.prototype, "maxY", {
    get: function() {
      return this.y + this.height;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox2.prototype, "tl", {
    get: function() {
      return { x: this.x, y: this.y };
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox2.prototype, "tr", {
    get: function() {
      return { x: this.maxX, y: this.y };
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox2.prototype, "bl", {
    get: function() {
      return { x: this.x, y: this.maxY };
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox2.prototype, "br", {
    get: function() {
      return { x: this.maxX, y: this.maxY };
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox2.prototype, "top", {
    get: function() {
      return {
        x: this.x + this.width / 2,
        y: this.minY
      };
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox2.prototype, "right", {
    get: function() {
      return {
        x: this.maxX,
        y: this.y + this.height / 2
      };
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox2.prototype, "bottom", {
    get: function() {
      return {
        x: this.x + this.width / 2,
        y: this.maxY
      };
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox2.prototype, "left", {
    get: function() {
      return {
        x: this.minX,
        y: this.y + this.height / 2
      };
    },
    enumerable: false,
    configurable: true
  });
  BBox2.prototype.isEqual = function(bbox) {
    return this.x === bbox.x && this.y === bbox.y && this.width === bbox.width && this.height === bbox.height;
  };
  BBox2.prototype.contains = function(child) {
    return child.minX >= this.minX && child.maxX <= this.maxX && child.minY >= this.minY && child.maxY <= this.maxY;
  };
  BBox2.prototype.clone = function() {
    return new BBox2(this.x, this.y, this.width, this.height);
  };
  BBox2.prototype.add = function() {
    var subBBox = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      subBBox[_i] = arguments[_i];
    }
    var bbox = this.clone();
    each_default(subBBox, function(b) {
      bbox.x = Math.min(b.x, bbox.x);
      bbox.y = Math.min(b.y, bbox.y);
      bbox.width = Math.max(b.maxX, bbox.maxX) - bbox.x;
      bbox.height = Math.max(b.maxY, bbox.maxY) - bbox.y;
    });
    return bbox;
  };
  BBox2.prototype.merge = function() {
    var subBBox = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      subBBox[_i] = arguments[_i];
    }
    var bbox = this.clone();
    each_default(subBBox, function(b) {
      bbox.x = Math.max(b.x, bbox.x);
      bbox.y = Math.max(b.y, bbox.y);
      bbox.width = Math.min(b.maxX, bbox.maxX) - bbox.x;
      bbox.height = Math.min(b.maxY, bbox.maxY) - bbox.y;
    });
    return bbox;
  };
  BBox2.prototype.cut = function(subBBox, direction2) {
    var width = subBBox.width;
    var height = subBBox.height;
    switch (direction2) {
      case DIRECTION.TOP:
      case DIRECTION.TOP_LEFT:
      case DIRECTION.TOP_RIGHT:
        return BBox2.fromRange(this.minX, this.minY + height, this.maxX, this.maxY);
      case DIRECTION.RIGHT:
      case DIRECTION.RIGHT_TOP:
      case DIRECTION.RIGHT_BOTTOM:
        return BBox2.fromRange(this.minX, this.minY, this.maxX - width, this.maxY);
      case DIRECTION.BOTTOM:
      case DIRECTION.BOTTOM_LEFT:
      case DIRECTION.BOTTOM_RIGHT:
        return BBox2.fromRange(this.minX, this.minY, this.maxX, this.maxY - height);
      case DIRECTION.LEFT:
      case DIRECTION.LEFT_TOP:
      case DIRECTION.LEFT_BOTTOM:
        return BBox2.fromRange(this.minX + width, this.minY, this.maxX, this.maxY);
      default:
        return this;
    }
  };
  BBox2.prototype.shrink = function(gap) {
    var _a3 = __read(gap, 4), top = _a3[0], right = _a3[1], bottom = _a3[2], left = _a3[3];
    return new BBox2(this.x + left, this.y + top, this.width - left - right, this.height - top - bottom);
  };
  BBox2.prototype.expand = function(gap) {
    var _a3 = __read(gap, 4), top = _a3[0], right = _a3[1], bottom = _a3[2], left = _a3[3];
    return new BBox2(this.x - left, this.y - top, this.width + left + right, this.height + top + bottom);
  };
  BBox2.prototype.exceed = function(bbox) {
    return [
      Math.max(-this.minY + bbox.minY, 0),
      Math.max(this.maxX - bbox.maxX, 0),
      Math.max(this.maxY - bbox.maxY, 0),
      Math.max(-this.minX + bbox.minX, 0)
    ];
  };
  BBox2.prototype.collide = function(bbox) {
    return this.minX < bbox.maxX && this.maxX > bbox.minX && this.minY < bbox.maxY && this.maxY > bbox.minY;
  };
  BBox2.prototype.size = function() {
    return this.width * this.height;
  };
  BBox2.prototype.isPointIn = function(p) {
    return p.x >= this.minX && p.x <= this.maxX && p.y >= this.minY && p.y <= this.maxY;
  };
  return BBox2;
}();
function toPoints(bbox) {
  return [
    [bbox.minX, bbox.minY],
    [bbox.maxX, bbox.minY],
    [bbox.maxX, bbox.maxY],
    [bbox.minX, bbox.maxY]
  ];
}

// node_modules/@antv/g2/esm/util/coordinate.js
function getXDimensionLength(coordinate) {
  if (coordinate.isPolar && !coordinate.isTransposed) {
    return (coordinate.endAngle - coordinate.startAngle) * coordinate.getRadius();
  }
  var start = coordinate.convert({ x: 0, y: 0 });
  var end = coordinate.convert({ x: 1, y: 0 });
  return Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));
}
function isFullCircle(coordinate) {
  if (coordinate.isPolar) {
    var startAngle = coordinate.startAngle, endAngle = coordinate.endAngle;
    return endAngle - startAngle === Math.PI * 2;
  }
  return false;
}
function getDistanceToCenter(coordinate, point) {
  var center = coordinate.getCenter();
  return Math.sqrt(Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2));
}
function isPointInCoordinate(coordinate, point) {
  var result = false;
  if (coordinate) {
    if (coordinate.type === "theta") {
      var start = coordinate.start, end = coordinate.end;
      result = isBetween2(point.x, start.x, end.x) && isBetween2(point.y, start.y, end.y);
    } else {
      var invertPoint = coordinate.invert(point);
      result = isBetween2(invertPoint.x, 0, 1) && isBetween2(invertPoint.y, 0, 1);
    }
  }
  return result;
}
function getAngleByPoint(coordinate, point) {
  var center = coordinate.getCenter();
  return Math.atan2(point.y - center.y, point.x - center.x);
}
function getCoordinateClipCfg(coordinate, margin) {
  if (margin === void 0) {
    margin = 0;
  }
  var start = coordinate.start, end = coordinate.end;
  var width = coordinate.getWidth();
  var height = coordinate.getHeight();
  if (coordinate.isPolar) {
    var startAngle_1 = coordinate.startAngle, endAngle_1 = coordinate.endAngle;
    var center_1 = coordinate.getCenter();
    var radius_1 = coordinate.getRadius();
    return {
      type: "path",
      startState: {
        path: getSectorPath(center_1.x, center_1.y, radius_1 + margin, startAngle_1, startAngle_1)
      },
      endState: function(ratio) {
        var diff2 = (endAngle_1 - startAngle_1) * ratio + startAngle_1;
        var path = getSectorPath(center_1.x, center_1.y, radius_1 + margin, startAngle_1, diff2);
        return {
          path
        };
      },
      attrs: {
        path: getSectorPath(center_1.x, center_1.y, radius_1 + margin, startAngle_1, endAngle_1)
      }
    };
  }
  var endState;
  if (coordinate.isTransposed) {
    endState = {
      height: height + margin * 2
    };
  } else {
    endState = {
      width: width + margin * 2
    };
  }
  return {
    type: "rect",
    startState: {
      x: start.x - margin,
      y: end.y - margin,
      width: coordinate.isTransposed ? width + margin * 2 : 0,
      height: coordinate.isTransposed ? 0 : height + margin * 2
    },
    endState,
    attrs: {
      x: start.x - margin,
      y: end.y - margin,
      width: width + margin * 2,
      height: height + margin * 2
    }
  };
}
function getCoordinateBBox(coordinate, margin) {
  if (margin === void 0) {
    margin = 0;
  }
  var start = coordinate.start, end = coordinate.end;
  var width = coordinate.getWidth();
  var height = coordinate.getHeight();
  var minX = Math.min(start.x, end.x);
  var minY = Math.min(start.y, end.y);
  return BBox.fromRange(minX - margin, minY - margin, minX + width + margin, minY + height + margin);
}

// node_modules/@antv/g2/esm/util/scale.js
var dateRegex = /^(?:(?!0000)[0-9]{4}([-/.]+)(?:(?:0?[1-9]|1[0-2])\1(?:0?[1-9]|1[0-9]|2[0-8])|(?:0?[13-9]|1[0-2])\1(?:29|30)|(?:0?[13578]|1[02])\1(?:31))|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)([-/.]+)0?2\2(?:29))(\s+([01]|([01][0-9]|2[0-3])):([0-9]|[0-5][0-9]):([0-9]|[0-5][0-9]))?$/;
function getDefaultType(value) {
  var type = "linear";
  if (dateRegex.test(value)) {
    type = "timeCat";
  } else if (is_string_default(value)) {
    type = "cat";
  }
  return type;
}
function inferScaleType(scale5, scaleDef, attrType, geometryType) {
  if (scaleDef === void 0) {
    scaleDef = {};
  }
  if (scaleDef.type)
    return scaleDef.type;
  if (scale5.type !== "identity" && GROUP_ATTRS.includes(attrType) && ["interval"].includes(geometryType)) {
    return "cat";
  }
  return scale5.isCategory ? "cat" : scale5.type;
}
function createScaleByField(field, data, scaleDef) {
  var validData = data || [];
  if (is_number_default(field) || is_nil_default(first_value_default(validData, field)) && is_empty_default(scaleDef)) {
    var Identity2 = getClass("identity");
    return new Identity2({
      field: field.toString(),
      values: [field]
    });
  }
  var values2 = values_of_key_default(validData, field);
  var type = get_default(scaleDef, "type", getDefaultType(values2[0]));
  var ScaleCtor = getClass(type);
  return new ScaleCtor(__assign({ field, values: values2 }, scaleDef));
}
function syncScale(scale5, newScale) {
  if (scale5.type !== "identity" && newScale.type !== "identity") {
    var obj = {};
    for (var k in newScale) {
      if (Object.prototype.hasOwnProperty.call(newScale, k)) {
        obj[k] = newScale[k];
      }
    }
    scale5.change(obj);
  }
}
function getName(scale5) {
  return scale5.alias || scale5.field;
}
function getDefaultCategoryScaleRange(scale5, coordinate, theme) {
  var values2 = scale5.values;
  var count = values2.length;
  var range;
  if (count === 1) {
    range = [0.5, 1];
  } else {
    var widthRatio = 1;
    var offset = 0;
    if (isFullCircle(coordinate)) {
      if (!coordinate.isTransposed) {
        range = [0, 1 - 1 / count];
      } else {
        widthRatio = get_default(theme, "widthRatio.multiplePie", 1 / 1.3);
        offset = 1 / count * widthRatio;
        range = [offset / 2, 1 - offset / 2];
      }
    } else {
      offset = 1 / count / 2;
      range = [offset, 1 - offset];
    }
  }
  return range;
}
function getMaxScale(scale5) {
  var values2 = scale5.values.filter(function(item) {
    return !is_nil_default(item) && !isNaN(item);
  });
  return Math.max.apply(Math, __spreadArray(__spreadArray([], __read(values2), false), [is_nil_default(scale5.max) ? -Infinity : scale5.max], false));
}

// node_modules/@antv/g2/esm/util/axis.js
function getLineAxisRelativeRegion(direction2) {
  var start;
  var end;
  switch (direction2) {
    case DIRECTION.TOP:
      start = { x: 0, y: 1 };
      end = { x: 1, y: 1 };
      break;
    case DIRECTION.RIGHT:
      start = { x: 1, y: 0 };
      end = { x: 1, y: 1 };
      break;
    case DIRECTION.BOTTOM:
      start = { x: 0, y: 0 };
      end = { x: 1, y: 0 };
      break;
    case DIRECTION.LEFT:
      start = { x: 0, y: 0 };
      end = { x: 0, y: 1 };
      break;
    default:
      start = end = { x: 0, y: 0 };
  }
  return { start, end };
}
function getCircleAxisRelativeRegion(coordinate) {
  var start;
  var end;
  if (coordinate.isTransposed) {
    start = {
      x: 0,
      y: 0
    };
    end = {
      x: 1,
      y: 0
    };
  } else {
    start = {
      x: 0,
      y: 0
    };
    end = {
      x: 0,
      y: 1
    };
  }
  return { start, end };
}
function getAxisRegion(coordinate, direction2) {
  var region = { start: { x: 0, y: 0 }, end: { x: 0, y: 0 } };
  if (coordinate.isRect) {
    region = getLineAxisRelativeRegion(direction2);
  } else if (coordinate.isPolar) {
    region = getCircleAxisRelativeRegion(coordinate);
  }
  var start = region.start, end = region.end;
  return {
    start: coordinate.convert(start),
    end: coordinate.convert(end)
  };
}
function isVertical(region) {
  var start = region.start, end = region.end;
  return start.x === end.x;
}
function getAxisFactorByRegion(region, center) {
  var start = region.start, end = region.end;
  var isAxisVertical = isVertical(region);
  if (isAxisVertical) {
    if ((start.y - end.y) * (center.x - start.x) > 0) {
      return 1;
    } else {
      return -1;
    }
  } else {
    if ((end.x - start.x) * (start.y - center.y) > 0) {
      return -1;
    } else {
      return 1;
    }
  }
}
function getAxisThemeCfg(theme, direction2) {
  var axisTheme = get_default(theme, ["components", "axis"], {});
  return deep_mix_default({}, get_default(axisTheme, ["common"], {}), deep_mix_default({}, get_default(axisTheme, [direction2], {})));
}
function getAxisTitleOptions(theme, direction2, axisOptions) {
  var axisTheme = get_default(theme, ["components", "axis"], {});
  return deep_mix_default({}, get_default(axisTheme, ["common", "title"], {}), deep_mix_default({}, get_default(axisTheme, [direction2, "title"], {})), axisOptions);
}
function getCircleAxisCenterRadius(coordinate) {
  var x = coordinate.x, y = coordinate.y, center = coordinate.circleCenter;
  var isReflectY = y.start > y.end;
  var start = coordinate.isTransposed ? coordinate.convert({
    x: isReflectY ? 0 : 1,
    y: 0
  }) : coordinate.convert({
    x: 0,
    y: isReflectY ? 0 : 1
  });
  var startVector = [start.x - center.x, start.y - center.y];
  var normalVector = [1, 0];
  var startAngle = start.y > center.y ? vec2_exports.angle(startVector, normalVector) : vec2_exports.angle(startVector, normalVector) * -1;
  var endAngle = startAngle + (x.end - x.start);
  var radius = Math.sqrt(Math.pow(start.x - center.x, 2) + Math.pow(start.y - center.y, 2));
  return {
    center,
    radius,
    startAngle,
    endAngle
  };
}
function getAxisOption(axes, field) {
  if (is_boolean_default(axes)) {
    return axes === false ? false : {};
  }
  return get_default(axes, [field]);
}
function getAxisDirection(axisOption, def) {
  return get_default(axisOption, "position", def);
}
function getAxisTitleText(scale5, axisOption) {
  return get_default(axisOption, ["title", "text"], getName(scale5));
}

// node_modules/@antv/g2/esm/facet/facet.js
var Facet = function() {
  function Facet2(view, cfg) {
    this.destroyed = false;
    this.facets = [];
    this.view = view;
    this.cfg = deep_mix_default({}, this.getDefaultCfg(), cfg);
  }
  Facet2.prototype.init = function() {
    if (!this.container) {
      this.container = this.createContainer();
    }
    var data = this.view.getData();
    this.facets = this.generateFacets(data);
  };
  Facet2.prototype.render = function() {
    this.renderViews();
  };
  Facet2.prototype.update = function() {
  };
  Facet2.prototype.clear = function() {
    this.clearFacetViews();
  };
  Facet2.prototype.destroy = function() {
    this.clear();
    if (this.container) {
      this.container.remove(true);
      this.container = void 0;
    }
    this.destroyed = true;
    this.view = void 0;
    this.facets = [];
  };
  Facet2.prototype.facetToView = function(facet) {
    var region = facet.region, data = facet.data, _a3 = facet.padding, padding = _a3 === void 0 ? this.cfg.padding : _a3;
    var view = this.view.createView({
      region,
      padding
    });
    view.data(data || []);
    facet.view = view;
    this.beforeEachView(view, facet);
    var eachView = this.cfg.eachView;
    if (eachView) {
      eachView(view, facet);
    }
    this.afterEachView(view, facet);
    return view;
  };
  Facet2.prototype.createContainer = function() {
    var foregroundGroup = this.view.getLayer(LAYER.FORE);
    return foregroundGroup.addGroup();
  };
  Facet2.prototype.renderViews = function() {
    this.createFacetViews();
  };
  Facet2.prototype.createFacetViews = function() {
    var _this = this;
    return this.facets.map(function(facet) {
      return _this.facetToView(facet);
    });
  };
  Facet2.prototype.clearFacetViews = function() {
    var _this = this;
    each_default(this.facets, function(facet) {
      if (facet.view) {
        _this.view.removeView(facet.view);
        facet.view = void 0;
      }
    });
  };
  Facet2.prototype.parseSpacing = function() {
    var _a3 = this.view.viewBBox, width = _a3.width, height = _a3.height;
    var spacing = this.cfg.spacing;
    return spacing.map(function(s, idx) {
      if (is_number_default(s))
        return s / (idx === 0 ? width : height);
      else
        return parseFloat(s) / 100;
    });
  };
  Facet2.prototype.getFieldValues = function(data, field) {
    var rst = [];
    var cache3 = {};
    each_default(data, function(d) {
      var value = d[field];
      if (!is_nil_default(value) && !cache3[value]) {
        rst.push(value);
        cache3[value] = true;
      }
    });
    return rst;
  };
  Facet2.prototype.getRegion = function(rows, cols, xIndex, yIndex) {
    var _a3 = __read(this.parseSpacing(), 2), xSpacing = _a3[0], ySpacing = _a3[1];
    var xRatio = (1 + xSpacing) / (cols === 0 ? 1 : cols) - xSpacing;
    var yRatio = (1 + ySpacing) / (rows === 0 ? 1 : rows) - ySpacing;
    var start = {
      x: (xRatio + xSpacing) * xIndex,
      y: (yRatio + ySpacing) * yIndex
    };
    var end = {
      x: start.x + xRatio,
      y: start.y + yRatio
    };
    return { start, end };
  };
  Facet2.prototype.getDefaultCfg = function() {
    return {
      eachView: void 0,
      showTitle: true,
      spacing: [0, 0],
      padding: 10,
      fields: []
    };
  };
  Facet2.prototype.getDefaultTitleCfg = function() {
    var fontFamily = this.view.getTheme().fontFamily;
    return {
      style: {
        fontSize: 14,
        fill: "#666",
        fontFamily
      }
    };
  };
  Facet2.prototype.processAxis = function(view, facet) {
    var options = view.getOptions();
    var coordinateOption = options.coordinate;
    var geometries = view.geometries;
    var coordinateType = get_default(coordinateOption, "type", "rect");
    if (coordinateType === "rect" && geometries.length) {
      if (is_nil_default(options.axes)) {
        options.axes = {};
      }
      var axes = options.axes;
      var _a3 = __read(geometries[0].getXYFields(), 2), x = _a3[0], y = _a3[1];
      var xOption = getAxisOption(axes, x);
      var yOption = getAxisOption(axes, y);
      if (xOption !== false) {
        options.axes[x] = this.getXAxisOption(x, axes, xOption, facet);
      }
      if (yOption !== false) {
        options.axes[y] = this.getYAxisOption(y, axes, yOption, facet);
      }
    }
  };
  Facet2.prototype.getFacetDataFilter = function(conditions) {
    return function(datum) {
      return every_default(conditions, function(condition) {
        var field = condition.field, value = condition.value;
        if (!is_nil_default(value) && field) {
          return datum[field] === value;
        }
        return true;
      });
    };
  };
  return Facet2;
}();

// node_modules/@antv/g2/esm/facet/index.js
var Facets = {};
var getFacet = function(type) {
  return Facets[lower_case_default(type)];
};
var registerFacet = function(type, ctor) {
  Facets[lower_case_default(type)] = ctor;
};

// node_modules/@antv/g2/esm/interaction/action/base.js
var Action = function() {
  function Action2(context, cfg) {
    this.context = context;
    this.cfg = cfg;
    context.addAction(this);
  }
  Action2.prototype.applyCfg = function(cfg) {
    mix(this, cfg);
  };
  Action2.prototype.init = function() {
    this.applyCfg(this.cfg);
  };
  Action2.prototype.destroy = function() {
    this.context.removeAction(this);
    this.context = null;
  };
  return Action2;
}();
var base_default12 = Action;

// node_modules/@antv/g2/esm/interaction/action/callback.js
var CallbackAction = function(_super) {
  __extends(CallbackAction2, _super);
  function CallbackAction2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  CallbackAction2.prototype.execute = function() {
    if (this.callback) {
      this.callback(this.context);
    }
  };
  CallbackAction2.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    this.callback = null;
  };
  return CallbackAction2;
}(base_default12);
var callback_default = CallbackAction;

// node_modules/@antv/g2/esm/interaction/action/register.js
var ActionCache = {};
function createAction(actionName, context) {
  var actionOption = ActionCache[actionName];
  var action = null;
  if (actionOption) {
    var ActionClass = actionOption.ActionClass, cfg = actionOption.cfg;
    action = new ActionClass(context, cfg);
    action.name = actionName;
    action.init();
  }
  return action;
}
function getActionClass(actionName) {
  var actionOption = ActionCache[actionName];
  return get_default(actionOption, "ActionClass");
}
function registerAction(actionName, ActionClass, cfg) {
  ActionCache[actionName] = {
    ActionClass,
    cfg
  };
}
function createCallbackAction(callback, context) {
  var action = new callback_default(context);
  action.callback = callback;
  action.name = "callback";
  return action;
}

// node_modules/@antv/g2/esm/geometry/shape/util/path.js
function _points2path(points, isInCircle) {
  var path = [];
  if (points.length) {
    path.push(["M", points[0].x, points[0].y]);
    for (var i = 1, length_1 = points.length; i < length_1; i += 1) {
      var item = points[i];
      path.push(["L", item.x, item.y]);
    }
    if (isInCircle) {
      path.push(["Z"]);
    }
  }
  return path;
}
function _convertArr(arr, coord) {
  var tmp = [arr[0]];
  for (var i = 1, len3 = arr.length; i < len3; i = i + 2) {
    var point = coord.convert({
      x: arr[i],
      y: arr[i + 1]
    });
    tmp.push(point.x, point.y);
  }
  return tmp;
}
function _convertArcPath(path, coord) {
  var isTransposed = coord.isTransposed;
  var r = path[1];
  var x = path[6];
  var y = path[7];
  var point = coord.convert({ x, y });
  var direction2 = isTransposed ? 0 : 1;
  return ["A", r, r, 0, 0, direction2, point.x, point.y];
}
function _convertPolarPath(pre, cur, coord) {
  var isTransposed = coord.isTransposed, startAngle = coord.startAngle, endAngle = coord.endAngle;
  var prePoint = pre[0].toLowerCase() === "a" ? {
    x: pre[6],
    y: pre[7]
  } : {
    x: pre[1],
    y: pre[2]
  };
  var curPoint = {
    x: cur[1],
    y: cur[2]
  };
  var rst = [];
  var xDim = isTransposed ? "y" : "x";
  var angleRange = Math.abs(curPoint[xDim] - prePoint[xDim]) * (endAngle - startAngle);
  var direction2 = curPoint[xDim] >= prePoint[xDim] ? 1 : 0;
  var flag = angleRange > Math.PI ? 1 : 0;
  var convertPoint = coord.convert(curPoint);
  var r = getDistanceToCenter(coord, convertPoint);
  if (r >= 0.5) {
    if (angleRange === Math.PI * 2) {
      var middlePoint = {
        x: (curPoint.x + prePoint.x) / 2,
        y: (curPoint.y + prePoint.y) / 2
      };
      var middleConvertPoint = coord.convert(middlePoint);
      rst.push(["A", r, r, 0, flag, direction2, middleConvertPoint.x, middleConvertPoint.y]);
      rst.push(["A", r, r, 0, flag, direction2, convertPoint.x, convertPoint.y]);
    } else {
      rst.push(["A", r, r, 0, flag, direction2, convertPoint.x, convertPoint.y]);
    }
  }
  return rst;
}
function _filterFullCirleLine(path) {
  each_default(path, function(subPath, index) {
    var cur = subPath;
    if (cur[0].toLowerCase() === "a") {
      var pre = path[index - 1];
      var next = path[index + 1];
      if (next && next[0].toLowerCase() === "a") {
        if (pre && pre[0].toLowerCase() === "l") {
          pre[0] = "M";
        }
      } else if (pre && pre[0].toLowerCase() === "a") {
        if (next && next[0].toLowerCase() === "l") {
          next[0] = "M";
        }
      }
    }
  });
}
var smoothBezier2 = function(points, smooth, isLoop, constraint) {
  var _a3;
  var cps = [];
  var hasConstraint = !!constraint;
  var prevPoint;
  var nextPoint;
  var min3;
  var max3;
  var nextCp0;
  var cp1;
  var cp0;
  if (hasConstraint) {
    _a3 = __read(constraint, 2), min3 = _a3[0], max3 = _a3[1];
    for (var i = 0, l = points.length; i < l; i++) {
      var point = points[i];
      min3 = vec2_exports.min([0, 0], min3, point);
      max3 = vec2_exports.max([0, 0], max3, point);
    }
  }
  for (var i = 0, len3 = points.length; i < len3; i++) {
    var point = points[i];
    if (i === 0 && !isLoop) {
      cp0 = point;
    } else if (i === len3 - 1 && !isLoop) {
      cp1 = point;
      cps.push(cp0);
      cps.push(cp1);
    } else {
      prevPoint = points[isLoop ? i ? i - 1 : len3 - 1 : i - 1];
      nextPoint = points[isLoop ? (i + 1) % len3 : i + 1];
      var v = [0, 0];
      v = vec2_exports.sub(v, nextPoint, prevPoint);
      v = vec2_exports.scale(v, v, smooth);
      var d0 = vec2_exports.distance(point, prevPoint);
      var d1 = vec2_exports.distance(point, nextPoint);
      var sum = d0 + d1;
      if (sum !== 0) {
        d0 /= sum;
        d1 /= sum;
      }
      var v1 = vec2_exports.scale([0, 0], v, -d0);
      var v2 = vec2_exports.scale([0, 0], v, d1);
      cp1 = vec2_exports.add([0, 0], point, v1);
      nextCp0 = vec2_exports.add([0, 0], point, v2);
      nextCp0 = vec2_exports.min([0, 0], nextCp0, vec2_exports.max([0, 0], nextPoint, point));
      nextCp0 = vec2_exports.max([0, 0], nextCp0, vec2_exports.min([0, 0], nextPoint, point));
      v1 = vec2_exports.sub([0, 0], nextCp0, point);
      v1 = vec2_exports.scale([0, 0], v1, -d0 / d1);
      cp1 = vec2_exports.add([0, 0], point, v1);
      cp1 = vec2_exports.min([0, 0], cp1, vec2_exports.max([0, 0], prevPoint, point));
      cp1 = vec2_exports.max([0, 0], cp1, vec2_exports.min([0, 0], prevPoint, point));
      v2 = vec2_exports.sub([0, 0], point, cp1);
      v2 = vec2_exports.scale([0, 0], v2, d1 / d0);
      nextCp0 = vec2_exports.add([0, 0], point, v2);
      if (hasConstraint) {
        cp1 = vec2_exports.max([0, 0], cp1, min3);
        cp1 = vec2_exports.min([0, 0], cp1, max3);
        nextCp0 = vec2_exports.max([0, 0], nextCp0, min3);
        nextCp0 = vec2_exports.min([0, 0], nextCp0, max3);
      }
      cps.push(cp0);
      cps.push(cp1);
      cp0 = nextCp0;
    }
  }
  if (isLoop) {
    cps.push(cps.shift());
  }
  return cps;
};
function catmullRom2bezier(crp, z, constraint) {
  var isLoop = !!z;
  var pointList = [];
  for (var i = 0, l = crp.length; i < l; i += 2) {
    pointList.push([crp[i], crp[i + 1]]);
  }
  var controlPointList = smoothBezier2(pointList, 0.4, isLoop, constraint);
  var len3 = pointList.length;
  var d1 = [];
  var cp1;
  var cp2;
  var p;
  for (var i = 0; i < len3 - 1; i++) {
    cp1 = controlPointList[i * 2];
    cp2 = controlPointList[i * 2 + 1];
    p = pointList[i + 1];
    d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);
  }
  if (isLoop) {
    cp1 = controlPointList[len3];
    cp2 = controlPointList[len3 + 1];
    p = pointList[0];
    d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);
  }
  return d1;
}
function getLinePath2(points, isInCircle) {
  return _points2path(points, isInCircle);
}
function getSplinePath(points, isInCircle, constaint) {
  var data = [];
  var first = points[0];
  var prePoint = null;
  if (points.length <= 2) {
    return getLinePath2(points, isInCircle);
  }
  for (var i = 0, len3 = points.length; i < len3; i++) {
    var point = points[i];
    if (!prePoint || !(prePoint.x === point.x && prePoint.y === point.y)) {
      data.push(point.x);
      data.push(point.y);
      prePoint = point;
    }
  }
  var constraint = constaint || [
    [0, 0],
    [1, 1]
  ];
  var splinePath = catmullRom2bezier(data, isInCircle, constraint);
  splinePath.unshift(["M", first.x, first.y]);
  return splinePath;
}
function convertNormalPath(coord, path) {
  var tmp = [];
  each_default(path, function(subPath) {
    var action = subPath[0];
    switch (action.toLowerCase()) {
      case "m":
      case "l":
      case "c":
        tmp.push(_convertArr(subPath, coord));
        break;
      case "a":
        tmp.push(_convertArcPath(subPath, coord));
        break;
      case "z":
      default:
        tmp.push(subPath);
        break;
    }
  });
  return tmp;
}
function convertPolarPath(coord, path) {
  var tmp = [];
  var pre;
  var cur;
  var transposed;
  var equals5;
  each_default(path, function(subPath, index) {
    var action = subPath[0];
    switch (action.toLowerCase()) {
      case "m":
      case "c":
      case "q":
        tmp.push(_convertArr(subPath, coord));
        break;
      case "l":
        pre = path[index - 1];
        cur = subPath;
        transposed = coord.isTransposed;
        equals5 = transposed ? pre[pre.length - 2] === cur[1] : pre[pre.length - 1] === cur[2];
        if (equals5) {
          tmp = tmp.concat(_convertPolarPath(pre, cur, coord));
        } else {
          tmp.push(_convertArr(subPath, coord));
        }
        break;
      case "a":
        tmp.push(_convertArcPath(subPath, coord));
        break;
      case "z":
      default:
        tmp.push(subPath);
        break;
    }
  });
  _filterFullCirleLine(tmp);
  return tmp;
}

// node_modules/@antv/g2/esm/interaction/action/util.js
function getMaskBBox(context, tolerance3) {
  var event = context.event;
  var maskShape = event.target;
  var maskBBox = maskShape.getCanvasBBox();
  if (!(maskBBox.width >= tolerance3 || maskBBox.height >= tolerance3)) {
    return null;
  }
  return maskBBox;
}
function getMaskPath(context, tolerance3) {
  var event = context.event;
  var maskShape = event.target;
  var maskBBox = maskShape.getCanvasBBox();
  if (!(maskBBox.width >= tolerance3 || maskBBox.height >= tolerance3)) {
    return null;
  }
  return maskShape.attr("path");
}
function getCurrentElement(context) {
  var event = context.event;
  var element;
  var target = event.target;
  if (target) {
    element = target.get("element");
  }
  return element;
}
function getDelegationObject(context) {
  var event = context.event;
  var target = event.target;
  var delegateObject;
  if (target) {
    delegateObject = target.get("delegateObject");
  }
  return delegateObject;
}
function isElementChange(context) {
  var event = context.event.gEvent;
  if (event && event.fromShape && event.toShape && event.fromShape.get("element") === event.toShape.get("element")) {
    return false;
  }
  return true;
}
function isList(delegateObject) {
  return delegateObject && delegateObject.component && delegateObject.component.isList();
}
function isSlider(delegateObject) {
  return delegateObject && delegateObject.component && delegateObject.component.isSlider();
}
function isMask(context) {
  var event = context.event;
  var target = event.target;
  return target && target.get("name") === "mask";
}
function getMaskedElements(context, tolerance3) {
  var target = context.event.target;
  if (target.get("type") === "path") {
    var maskPath = getMaskPath(context, tolerance3);
    if (!maskPath) {
      return;
    }
    return getElementsByPath(context.view, maskPath);
  }
  var maskBBox = getMaskBBox(context, tolerance3);
  if (!maskBBox) {
    return null;
  }
  return getIntersectElements(context.view, maskBBox);
}
function getSiblingMaskElements(context, sibling, tolerance3) {
  var maskBBox = getMaskBBox(context, tolerance3);
  if (!maskBBox) {
    return null;
  }
  var view = context.view;
  var start = getSiblingPoint(view, sibling, { x: maskBBox.x, y: maskBBox.y });
  var end = getSiblingPoint(view, sibling, { x: maskBBox.maxX, y: maskBBox.maxY });
  var box2 = {
    minX: start.x,
    minY: start.y,
    maxX: end.x,
    maxY: end.y
  };
  return getIntersectElements(sibling, box2);
}
function getElements(view) {
  var geometries = view.geometries;
  var rst = [];
  each_default(geometries, function(geom) {
    var elements = geom.elements;
    rst = rst.concat(elements);
  });
  if (view.views && view.views.length) {
    each_default(view.views, function(subView) {
      rst = rst.concat(getElements(subView));
    });
  }
  return rst;
}
function getElementsByField(view, field, value) {
  var elements = getElements(view);
  return elements.filter(function(el) {
    return getElementValue(el, field) === value;
  });
}
function getElementsByState(view, stateName) {
  var geometries = view.geometries;
  var rst = [];
  each_default(geometries, function(geom) {
    var elements = geom.getElementsBy(function(el) {
      return el.hasState(stateName);
    });
    rst = rst.concat(elements);
  });
  return rst;
}
function getElementValue(element, field) {
  var model = element.getModel();
  var record = model.data;
  var value;
  if (is_array_default(record)) {
    value = record[0][field];
  } else {
    value = record[field];
  }
  return value;
}
function intersectRect(box1, box2) {
  return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);
}
function getIntersectElements(view, box2) {
  var elements = getElements(view);
  var rst = [];
  each_default(elements, function(el) {
    var shape = el.shape;
    var shapeBBox = shape.getCanvasBBox();
    if (intersectRect(box2, shapeBBox)) {
      rst.push(el);
    }
  });
  return rst;
}
function pathToPoints(path) {
  var points = [];
  each_default(path, function(seg) {
    var command = seg[0];
    if (command !== "A") {
      for (var i = 1; i < seg.length; i = i + 2) {
        points.push([seg[i], seg[i + 1]]);
      }
    } else {
      var length_1 = seg.length;
      points.push([seg[length_1 - 2], seg[length_1 - 1]]);
    }
  });
  return points;
}
function getElementsByPath(view, path) {
  var elements = getElements(view);
  var points = pathToPoints(path);
  var rst = elements.filter(function(el) {
    var shape = el.shape;
    var shapePoints;
    if (shape.get("type") === "path") {
      shapePoints = pathToPoints(shape.attr("path"));
    } else {
      var shapeBBox = shape.getCanvasBBox();
      shapePoints = toPoints(shapeBBox);
    }
    return isPolygonsIntersect(points, shapePoints);
  });
  return rst;
}
function getComponents(view) {
  return view.getComponents().map(function(co) {
    return co.component;
  });
}
function distance6(p1, p2) {
  var dx = p2.x - p1.x;
  var dy = p2.y - p1.y;
  return Math.sqrt(dx * dx + dy * dy);
}
function getSpline(points, z) {
  if (points.length <= 2) {
    return getLinePath2(points, false);
  }
  var first = points[0];
  var arr = [];
  each_default(points, function(point) {
    arr.push(point.x);
    arr.push(point.y);
  });
  var path = catmullRom2bezier(arr, z, null);
  path.unshift(["M", first.x, first.y]);
  return path;
}
function isInBox(box2, point) {
  return box2.x <= point.x && box2.maxX >= point.x && box2.y <= point.y && box2.maxY > point.y;
}
function getSilbings(view) {
  var parent = view.parent;
  var siblings = null;
  if (parent) {
    siblings = parent.views.filter(function(sub4) {
      return sub4 !== view;
    });
  }
  return siblings;
}
function point2Normalize(view, point) {
  var coord = view.getCoordinate();
  return coord.invert(point);
}
function getSiblingPoint(view, sibling, point) {
  var normalPoint = point2Normalize(view, point);
  return sibling.getCoordinate().convert(normalPoint);
}
function isInRecords(records, record, xFiled, yField) {
  var isIn = false;
  each_default(records, function(r) {
    if (r[xFiled] === record[xFiled] && r[yField] === record[yField]) {
      isIn = true;
      return false;
    }
  });
  return isIn;
}
function getScaleByField(view, field) {
  var scale5 = view.getScaleByField(field);
  if (!scale5 && view.views) {
    each_default(view.views, function(subView) {
      scale5 = getScaleByField(subView, field);
      if (scale5) {
        return false;
      }
    });
  }
  return scale5;
}

// node_modules/@antv/g2/esm/interaction/context.js
var Context = function() {
  function Context2(view) {
    this.actions = [];
    this.event = null;
    this.cacheMap = {};
    this.view = view;
  }
  Context2.prototype.cache = function() {
    var params = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      params[_i] = arguments[_i];
    }
    if (params.length === 1) {
      return this.cacheMap[params[0]];
    } else if (params.length === 2) {
      this.cacheMap[params[0]] = params[1];
    }
  };
  Context2.prototype.getAction = function(name) {
    return this.actions.find(function(action) {
      return action.name === name;
    });
  };
  Context2.prototype.addAction = function(action) {
    this.actions.push(action);
  };
  Context2.prototype.removeAction = function(action) {
    var actions = this.actions;
    var index = this.actions.indexOf(action);
    if (index >= 0) {
      actions.splice(index, 1);
    }
  };
  Context2.prototype.getCurrentPoint = function() {
    var event = this.event;
    if (event) {
      if (event.target instanceof HTMLElement) {
        var canvas = this.view.getCanvas();
        var point = canvas.getPointByClient(event.clientX, event.clientY);
        return point;
      } else {
        return {
          x: event.x,
          y: event.y
        };
      }
    }
    return null;
  };
  Context2.prototype.getCurrentShape = function() {
    return get_default(this.event, ["gEvent", "shape"]);
  };
  Context2.prototype.isInPlot = function() {
    var point = this.getCurrentPoint();
    if (point) {
      return this.view.isPointInPlot(point);
    }
    return false;
  };
  Context2.prototype.isInShape = function(name) {
    var shape = this.getCurrentShape();
    if (shape) {
      return shape.get("name") === name;
    }
    return false;
  };
  Context2.prototype.isInComponent = function(name) {
    var components = getComponents(this.view);
    var point = this.getCurrentPoint();
    if (point) {
      return !!components.find(function(component) {
        var bbox = component.getBBox();
        if (name) {
          return component.get("name") === name && isInBox(bbox, point);
        } else {
          return isInBox(bbox, point);
        }
      });
    }
    return false;
  };
  Context2.prototype.destroy = function() {
    each_default(this.actions.slice(), function(action) {
      action.destroy();
    });
    this.view = null;
    this.event = null;
    this.actions = null;
    this.cacheMap = null;
  };
  return Context2;
}();
var context_default = Context;

// node_modules/@antv/g2/esm/interaction/interaction.js
var Interaction = function() {
  function Interaction2(view, cfg) {
    this.view = view;
    this.cfg = cfg;
  }
  Interaction2.prototype.init = function() {
    this.initEvents();
  };
  Interaction2.prototype.initEvents = function() {
  };
  Interaction2.prototype.clearEvents = function() {
  };
  Interaction2.prototype.destroy = function() {
    this.clearEvents();
  };
  return Interaction2;
}();
var interaction_default = Interaction;

// node_modules/@antv/g2/esm/interaction/grammar-interaction.js
function parseAction(actionStr, context, arg) {
  var arr = actionStr.split(":");
  var actionName = arr[0];
  var action = context.getAction(actionName) || createAction(actionName, context);
  if (!action) {
    throw new Error("There is no action named ".concat(actionName));
  }
  var methodName = arr[1];
  return {
    action,
    methodName,
    arg
  };
}
function executeAction(actionObject) {
  var action = actionObject.action, methodName = actionObject.methodName, arg = actionObject.arg;
  if (action[methodName]) {
    action[methodName](arg);
  } else {
    throw new Error("Action(".concat(action.name, ") doesn't have a method called ").concat(methodName));
  }
}
var STEP_NAMES = {
  START: "start",
  SHOW_ENABLE: "showEnable",
  END: "end",
  ROLLBACK: "rollback",
  PROCESSING: "processing"
};
var GrammarInteraction = function(_super) {
  __extends(GrammarInteraction2, _super);
  function GrammarInteraction2(view, steps) {
    var _this = _super.call(this, view, steps) || this;
    _this.callbackCaches = {};
    _this.emitCaches = {};
    _this.steps = steps;
    return _this;
  }
  GrammarInteraction2.prototype.init = function() {
    this.initContext();
    _super.prototype.init.call(this);
  };
  GrammarInteraction2.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    this.steps = null;
    if (this.context) {
      this.context.destroy();
      this.context = null;
    }
    this.callbackCaches = null;
    this.view = null;
  };
  GrammarInteraction2.prototype.initEvents = function() {
    var _this = this;
    each_default(this.steps, function(stepArr, stepName) {
      each_default(stepArr, function(step) {
        var callback = _this.getActionCallback(stepName, step);
        if (callback) {
          _this.bindEvent(step.trigger, callback);
        }
      });
    });
  };
  GrammarInteraction2.prototype.clearEvents = function() {
    var _this = this;
    each_default(this.steps, function(stepArr, stepName) {
      each_default(stepArr, function(step) {
        var callback = _this.getActionCallback(stepName, step);
        if (callback) {
          _this.offEvent(step.trigger, callback);
        }
      });
    });
  };
  GrammarInteraction2.prototype.initContext = function() {
    var view = this.view;
    var context = new context_default(view);
    this.context = context;
    var steps = this.steps;
    each_default(steps, function(subSteps) {
      each_default(subSteps, function(step) {
        if (is_function_default(step.action)) {
          step.actionObject = {
            action: createCallbackAction(step.action, context),
            methodName: "execute"
          };
        } else if (is_string_default(step.action)) {
          step.actionObject = parseAction(step.action, context, step.arg);
        } else if (is_array_default(step.action)) {
          var actionArr = step.action;
          var argArr_1 = is_array_default(step.arg) ? step.arg : [step.arg];
          step.actionObject = [];
          each_default(actionArr, function(actionStr, idx) {
            step.actionObject.push(parseAction(actionStr, context, argArr_1[idx]));
          });
        }
      });
    });
  };
  GrammarInteraction2.prototype.isAllowStep = function(stepName) {
    var currentStepName = this.currentStepName;
    var steps = this.steps;
    if (currentStepName === stepName) {
      return true;
    }
    if (stepName === STEP_NAMES.SHOW_ENABLE) {
      return true;
    }
    if (stepName === STEP_NAMES.PROCESSING) {
      return currentStepName === STEP_NAMES.START;
    }
    if (stepName === STEP_NAMES.START) {
      return currentStepName !== STEP_NAMES.PROCESSING;
    }
    if (stepName === STEP_NAMES.END) {
      return currentStepName === STEP_NAMES.PROCESSING || currentStepName === STEP_NAMES.START;
    }
    if (stepName === STEP_NAMES.ROLLBACK) {
      if (steps[STEP_NAMES.END]) {
        return currentStepName === STEP_NAMES.END;
      } else if (currentStepName === STEP_NAMES.START) {
        return true;
      }
    }
    return false;
  };
  GrammarInteraction2.prototype.isAllowExecute = function(stepName, step) {
    if (this.isAllowStep(stepName)) {
      var key = this.getKey(stepName, step);
      if (step.once && this.emitCaches[key]) {
        return false;
      }
      if (step.isEnable) {
        return step.isEnable(this.context);
      }
      return true;
    }
    return false;
  };
  GrammarInteraction2.prototype.enterStep = function(stepName) {
    this.currentStepName = stepName;
    this.emitCaches = {};
  };
  GrammarInteraction2.prototype.afterExecute = function(stepName, step) {
    if (stepName !== STEP_NAMES.SHOW_ENABLE && this.currentStepName !== stepName) {
      this.enterStep(stepName);
    }
    var key = this.getKey(stepName, step);
    this.emitCaches[key] = true;
  };
  GrammarInteraction2.prototype.getKey = function(stepName, step) {
    return stepName + step.trigger + step.action;
  };
  GrammarInteraction2.prototype.getActionCallback = function(stepName, step) {
    var _this = this;
    var context = this.context;
    var callbackCaches = this.callbackCaches;
    var actionObject = step.actionObject;
    if (step.action && actionObject) {
      var key = this.getKey(stepName, step);
      if (!callbackCaches[key]) {
        var actionCallback = function(event) {
          context.event = event;
          if (_this.isAllowExecute(stepName, step)) {
            if (is_array_default(actionObject)) {
              each_default(actionObject, function(obj) {
                context.event = event;
                executeAction(obj);
              });
            } else {
              context.event = event;
              executeAction(actionObject);
            }
            _this.afterExecute(stepName, step);
            if (step.callback) {
              context.event = event;
              step.callback(context);
            }
          } else {
            context.event = null;
          }
        };
        if (step.debounce) {
          callbackCaches[key] = debounce_default(actionCallback, step.debounce.wait, step.debounce.immediate);
        } else if (step.throttle) {
          callbackCaches[key] = throttle_default(actionCallback, step.throttle.wait, {
            leading: step.throttle.leading,
            trailing: step.throttle.trailing
          });
        } else {
          callbackCaches[key] = actionCallback;
        }
      }
      return callbackCaches[key];
    }
    return null;
  };
  GrammarInteraction2.prototype.bindEvent = function(eventName, callback) {
    var nameArr = eventName.split(":");
    if (nameArr[0] === "window") {
      window.addEventListener(nameArr[1], callback);
    } else if (nameArr[0] === "document") {
      document.addEventListener(nameArr[1], callback);
    } else {
      this.view.on(eventName, callback);
    }
  };
  GrammarInteraction2.prototype.offEvent = function(eventName, callback) {
    var nameArr = eventName.split(":");
    if (nameArr[0] === "window") {
      window.removeEventListener(nameArr[1], callback);
    } else if (nameArr[0] === "document") {
      document.removeEventListener(nameArr[1], callback);
    } else {
      this.view.off(eventName, callback);
    }
  };
  return GrammarInteraction2;
}(interaction_default);
var grammar_interaction_default = GrammarInteraction;

// node_modules/@antv/g2/esm/interaction/index.js
var Interactions = {};
function getInteraction(name) {
  return Interactions[lower_case_default(name)];
}
function registerInteraction(name, interaction) {
  Interactions[lower_case_default(name)] = interaction;
}
function createInteraction(name, view, cfg) {
  var interaciton = getInteraction(name);
  if (!interaciton) {
    return null;
  }
  if (is_plain_object_default(interaciton)) {
    var steps = mix(clone_default(interaciton), cfg);
    return new grammar_interaction_default(view, steps);
  } else {
    var cls = interaciton;
    return new cls(view, cfg);
  }
}

// node_modules/@antv/g2/esm/theme/util/create-by-style-sheet.js
function createAxisStyles(styleSheet) {
  return {
    title: {
      autoRotate: true,
      position: "center",
      spacing: styleSheet.axisTitleSpacing,
      style: {
        fill: styleSheet.axisTitleTextFillColor,
        fontSize: styleSheet.axisTitleTextFontSize,
        lineHeight: styleSheet.axisTitleTextLineHeight,
        textBaseline: "middle",
        fontFamily: styleSheet.fontFamily
      },
      iconStyle: {
        fill: styleSheet.axisDescriptionIconFillColor
      }
    },
    label: {
      autoRotate: false,
      autoEllipsis: false,
      autoHide: { type: "equidistance", cfg: { minGap: 6 } },
      offset: styleSheet.axisLabelOffset,
      style: {
        fill: styleSheet.axisLabelFillColor,
        fontSize: styleSheet.axisLabelFontSize,
        lineHeight: styleSheet.axisLabelLineHeight,
        fontFamily: styleSheet.fontFamily
      }
    },
    line: {
      style: {
        lineWidth: styleSheet.axisLineBorder,
        stroke: styleSheet.axisLineBorderColor
      }
    },
    grid: {
      line: {
        type: "line",
        style: {
          stroke: styleSheet.axisGridBorderColor,
          lineWidth: styleSheet.axisGridBorder,
          lineDash: styleSheet.axisGridLineDash
        }
      },
      alignTick: true,
      animate: true
    },
    tickLine: {
      style: {
        lineWidth: styleSheet.axisTickLineBorder,
        stroke: styleSheet.axisTickLineBorderColor
      },
      alignTick: true,
      length: styleSheet.axisTickLineLength
    },
    subTickLine: null,
    animate: true
  };
}
function createLegendStyles(styleSheet) {
  return {
    title: null,
    marker: {
      symbol: "circle",
      spacing: styleSheet.legendMarkerSpacing,
      style: {
        r: styleSheet.legendCircleMarkerSize,
        fill: styleSheet.legendMarkerColor
      }
    },
    itemName: {
      spacing: 5,
      style: {
        fill: styleSheet.legendItemNameFillColor,
        fontFamily: styleSheet.fontFamily,
        fontSize: styleSheet.legendItemNameFontSize,
        lineHeight: styleSheet.legendItemNameLineHeight,
        fontWeight: styleSheet.legendItemNameFontWeight,
        textAlign: "start",
        textBaseline: "middle"
      }
    },
    itemStates: {
      active: {
        nameStyle: {
          opacity: 0.8
        }
      },
      unchecked: {
        nameStyle: {
          fill: "#D8D8D8"
        },
        markerStyle: {
          fill: "#D8D8D8",
          stroke: "#D8D8D8"
        }
      },
      inactive: {
        nameStyle: {
          fill: "#D8D8D8"
        },
        markerStyle: {
          opacity: 0.2
        }
      }
    },
    flipPage: true,
    pageNavigator: {
      marker: {
        style: {
          size: styleSheet.legendPageNavigatorMarkerSize,
          inactiveFill: styleSheet.legendPageNavigatorMarkerInactiveFillColor,
          inactiveOpacity: styleSheet.legendPageNavigatorMarkerInactiveFillOpacity,
          fill: styleSheet.legendPageNavigatorMarkerFillColor,
          opacity: styleSheet.legendPageNavigatorMarkerFillOpacity
        }
      },
      text: {
        style: {
          fill: styleSheet.legendPageNavigatorTextFillColor,
          fontSize: styleSheet.legendPageNavigatorTextFontSize
        }
      }
    },
    animate: false,
    maxItemWidth: 200,
    itemSpacing: styleSheet.legendItemSpacing,
    itemMarginBottom: styleSheet.legendItemMarginBottom,
    padding: styleSheet.legendPadding
  };
}
function createThemeByStyleSheet(styleSheet) {
  var _a3;
  var shapeStyles = {
    point: {
      default: {
        fill: styleSheet.pointFillColor,
        r: styleSheet.pointSize,
        stroke: styleSheet.pointBorderColor,
        lineWidth: styleSheet.pointBorder,
        fillOpacity: styleSheet.pointFillOpacity
      },
      active: {
        stroke: styleSheet.pointActiveBorderColor,
        lineWidth: styleSheet.pointActiveBorder
      },
      selected: {
        stroke: styleSheet.pointSelectedBorderColor,
        lineWidth: styleSheet.pointSelectedBorder
      },
      inactive: {
        fillOpacity: styleSheet.pointInactiveFillOpacity,
        strokeOpacity: styleSheet.pointInactiveBorderOpacity
      }
    },
    hollowPoint: {
      default: {
        fill: styleSheet.hollowPointFillColor,
        lineWidth: styleSheet.hollowPointBorder,
        stroke: styleSheet.hollowPointBorderColor,
        strokeOpacity: styleSheet.hollowPointBorderOpacity,
        r: styleSheet.hollowPointSize
      },
      active: {
        stroke: styleSheet.hollowPointActiveBorderColor,
        strokeOpacity: styleSheet.hollowPointActiveBorderOpacity
      },
      selected: {
        lineWidth: styleSheet.hollowPointSelectedBorder,
        stroke: styleSheet.hollowPointSelectedBorderColor,
        strokeOpacity: styleSheet.hollowPointSelectedBorderOpacity
      },
      inactive: {
        strokeOpacity: styleSheet.hollowPointInactiveBorderOpacity
      }
    },
    area: {
      default: {
        fill: styleSheet.areaFillColor,
        fillOpacity: styleSheet.areaFillOpacity,
        stroke: null
      },
      active: {
        fillOpacity: styleSheet.areaActiveFillOpacity
      },
      selected: {
        fillOpacity: styleSheet.areaSelectedFillOpacity
      },
      inactive: {
        fillOpacity: styleSheet.areaInactiveFillOpacity
      }
    },
    hollowArea: {
      default: {
        fill: null,
        stroke: styleSheet.hollowAreaBorderColor,
        lineWidth: styleSheet.hollowAreaBorder,
        strokeOpacity: styleSheet.hollowAreaBorderOpacity
      },
      active: {
        fill: null,
        lineWidth: styleSheet.hollowAreaActiveBorder
      },
      selected: {
        fill: null,
        lineWidth: styleSheet.hollowAreaSelectedBorder
      },
      inactive: {
        strokeOpacity: styleSheet.hollowAreaInactiveBorderOpacity
      }
    },
    interval: {
      default: {
        fill: styleSheet.intervalFillColor,
        fillOpacity: styleSheet.intervalFillOpacity
      },
      active: {
        stroke: styleSheet.intervalActiveBorderColor,
        lineWidth: styleSheet.intervalActiveBorder
      },
      selected: {
        stroke: styleSheet.intervalSelectedBorderColor,
        lineWidth: styleSheet.intervalSelectedBorder
      },
      inactive: {
        fillOpacity: styleSheet.intervalInactiveFillOpacity,
        strokeOpacity: styleSheet.intervalInactiveBorderOpacity
      }
    },
    hollowInterval: {
      default: {
        fill: styleSheet.hollowIntervalFillColor,
        stroke: styleSheet.hollowIntervalBorderColor,
        lineWidth: styleSheet.hollowIntervalBorder,
        strokeOpacity: styleSheet.hollowIntervalBorderOpacity
      },
      active: {
        stroke: styleSheet.hollowIntervalActiveBorderColor,
        lineWidth: styleSheet.hollowIntervalActiveBorder,
        strokeOpacity: styleSheet.hollowIntervalActiveBorderOpacity
      },
      selected: {
        stroke: styleSheet.hollowIntervalSelectedBorderColor,
        lineWidth: styleSheet.hollowIntervalSelectedBorder,
        strokeOpacity: styleSheet.hollowIntervalSelectedBorderOpacity
      },
      inactive: {
        stroke: styleSheet.hollowIntervalInactiveBorderColor,
        lineWidth: styleSheet.hollowIntervalInactiveBorder,
        strokeOpacity: styleSheet.hollowIntervalInactiveBorderOpacity
      }
    },
    line: {
      default: {
        stroke: styleSheet.lineBorderColor,
        lineWidth: styleSheet.lineBorder,
        strokeOpacity: styleSheet.lineBorderOpacity,
        fill: null,
        lineAppendWidth: 10,
        lineCap: "round",
        lineJoin: "round"
      },
      active: {
        lineWidth: styleSheet.lineActiveBorder
      },
      selected: {
        lineWidth: styleSheet.lineSelectedBorder
      },
      inactive: {
        strokeOpacity: styleSheet.lineInactiveBorderOpacity
      }
    }
  };
  var axisStyles = createAxisStyles(styleSheet);
  var legendStyles = createLegendStyles(styleSheet);
  return {
    background: styleSheet.backgroundColor,
    defaultColor: styleSheet.brandColor,
    subColor: styleSheet.subColor,
    semanticRed: styleSheet.paletteSemanticRed,
    semanticGreen: styleSheet.paletteSemanticGreen,
    padding: "auto",
    fontFamily: styleSheet.fontFamily,
    columnWidthRatio: 1 / 2,
    maxColumnWidth: null,
    minColumnWidth: null,
    roseWidthRatio: 0.9999999,
    multiplePieWidthRatio: 1 / 1.3,
    colors10: styleSheet.paletteQualitative10,
    colors20: styleSheet.paletteQualitative20,
    sequenceColors: styleSheet.paletteSequence,
    shapes: {
      point: [
        "hollow-circle",
        "hollow-square",
        "hollow-bowtie",
        "hollow-diamond",
        "hollow-hexagon",
        "hollow-triangle",
        "hollow-triangle-down",
        "circle",
        "square",
        "bowtie",
        "diamond",
        "hexagon",
        "triangle",
        "triangle-down",
        "cross",
        "tick",
        "plus",
        "hyphen",
        "line"
      ],
      line: ["line", "dash", "dot", "smooth"],
      area: ["area", "smooth", "line", "smooth-line"],
      interval: ["rect", "hollow-rect", "line", "tick"]
    },
    sizes: [1, 10],
    geometries: {
      interval: {
        rect: {
          default: {
            style: shapeStyles.interval.default
          },
          active: {
            style: shapeStyles.interval.active
          },
          inactive: {
            style: shapeStyles.interval.inactive
          },
          selected: {
            style: function(element) {
              var coordinate = element.geometry.coordinate;
              if (coordinate.isPolar && coordinate.isTransposed) {
                var _a4 = getAngle2(element.getModel(), coordinate), startAngle = _a4.startAngle, endAngle = _a4.endAngle;
                var middleAngle = (startAngle + endAngle) / 2;
                var r = 7.5;
                var x = r * Math.cos(middleAngle);
                var y = r * Math.sin(middleAngle);
                return {
                  matrix: ext_exports.transform(null, [["t", x, y]])
                };
              }
              return shapeStyles.interval.selected;
            }
          }
        },
        "hollow-rect": {
          default: {
            style: shapeStyles.hollowInterval.default
          },
          active: {
            style: shapeStyles.hollowInterval.active
          },
          inactive: {
            style: shapeStyles.hollowInterval.inactive
          },
          selected: {
            style: shapeStyles.hollowInterval.selected
          }
        },
        line: {
          default: {
            style: shapeStyles.hollowInterval.default
          },
          active: {
            style: shapeStyles.hollowInterval.active
          },
          inactive: {
            style: shapeStyles.hollowInterval.inactive
          },
          selected: {
            style: shapeStyles.hollowInterval.selected
          }
        },
        tick: {
          default: {
            style: shapeStyles.hollowInterval.default
          },
          active: {
            style: shapeStyles.hollowInterval.active
          },
          inactive: {
            style: shapeStyles.hollowInterval.inactive
          },
          selected: {
            style: shapeStyles.hollowInterval.selected
          }
        },
        funnel: {
          default: {
            style: shapeStyles.interval.default
          },
          active: {
            style: shapeStyles.interval.active
          },
          inactive: {
            style: shapeStyles.interval.inactive
          },
          selected: {
            style: shapeStyles.interval.selected
          }
        },
        pyramid: {
          default: {
            style: shapeStyles.interval.default
          },
          active: {
            style: shapeStyles.interval.active
          },
          inactive: {
            style: shapeStyles.interval.inactive
          },
          selected: {
            style: shapeStyles.interval.selected
          }
        }
      },
      line: {
        line: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        dot: {
          default: {
            style: __assign(__assign({}, shapeStyles.line.default), { lineCap: null, lineDash: [1, 1] })
          },
          active: {
            style: __assign(__assign({}, shapeStyles.line.active), { lineCap: null, lineDash: [1, 1] })
          },
          inactive: {
            style: __assign(__assign({}, shapeStyles.line.inactive), { lineCap: null, lineDash: [1, 1] })
          },
          selected: {
            style: __assign(__assign({}, shapeStyles.line.selected), { lineCap: null, lineDash: [1, 1] })
          }
        },
        dash: {
          default: {
            style: __assign(__assign({}, shapeStyles.line.default), { lineCap: null, lineDash: [5.5, 1] })
          },
          active: {
            style: __assign(__assign({}, shapeStyles.line.active), { lineCap: null, lineDash: [5.5, 1] })
          },
          inactive: {
            style: __assign(__assign({}, shapeStyles.line.inactive), { lineCap: null, lineDash: [5.5, 1] })
          },
          selected: {
            style: __assign(__assign({}, shapeStyles.line.selected), { lineCap: null, lineDash: [5.5, 1] })
          }
        },
        smooth: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        hv: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        vh: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        hvh: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        vhv: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        }
      },
      polygon: {
        polygon: {
          default: {
            style: shapeStyles.interval.default
          },
          active: {
            style: shapeStyles.interval.active
          },
          inactive: {
            style: shapeStyles.interval.inactive
          },
          selected: {
            style: shapeStyles.interval.selected
          }
        }
      },
      point: {
        circle: {
          default: {
            style: shapeStyles.point.default
          },
          active: {
            style: shapeStyles.point.active
          },
          inactive: {
            style: shapeStyles.point.inactive
          },
          selected: {
            style: shapeStyles.point.selected
          }
        },
        square: {
          default: {
            style: shapeStyles.point.default
          },
          active: {
            style: shapeStyles.point.active
          },
          inactive: {
            style: shapeStyles.point.inactive
          },
          selected: {
            style: shapeStyles.point.selected
          }
        },
        bowtie: {
          default: {
            style: shapeStyles.point.default
          },
          active: {
            style: shapeStyles.point.active
          },
          inactive: {
            style: shapeStyles.point.inactive
          },
          selected: {
            style: shapeStyles.point.selected
          }
        },
        diamond: {
          default: {
            style: shapeStyles.point.default
          },
          active: {
            style: shapeStyles.point.active
          },
          inactive: {
            style: shapeStyles.point.inactive
          },
          selected: {
            style: shapeStyles.point.selected
          }
        },
        hexagon: {
          default: {
            style: shapeStyles.point.default
          },
          active: {
            style: shapeStyles.point.active
          },
          inactive: {
            style: shapeStyles.point.inactive
          },
          selected: {
            style: shapeStyles.point.selected
          }
        },
        triangle: {
          default: {
            style: shapeStyles.point.default
          },
          active: {
            style: shapeStyles.point.active
          },
          inactive: {
            style: shapeStyles.point.inactive
          },
          selected: {
            style: shapeStyles.point.selected
          }
        },
        "triangle-down": {
          default: {
            style: shapeStyles.point.default
          },
          active: {
            style: shapeStyles.point.active
          },
          inactive: {
            style: shapeStyles.point.inactive
          },
          selected: {
            style: shapeStyles.point.selected
          }
        },
        "hollow-circle": {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        "hollow-square": {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        "hollow-bowtie": {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        "hollow-diamond": {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        "hollow-hexagon": {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        "hollow-triangle": {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        "hollow-triangle-down": {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        cross: {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        tick: {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        plus: {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        hyphen: {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        line: {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        }
      },
      area: {
        area: {
          default: {
            style: shapeStyles.area.default
          },
          active: {
            style: shapeStyles.area.active
          },
          inactive: {
            style: shapeStyles.area.inactive
          },
          selected: {
            style: shapeStyles.area.selected
          }
        },
        smooth: {
          default: {
            style: shapeStyles.area.default
          },
          active: {
            style: shapeStyles.area.active
          },
          inactive: {
            style: shapeStyles.area.inactive
          },
          selected: {
            style: shapeStyles.area.selected
          }
        },
        line: {
          default: {
            style: shapeStyles.hollowArea.default
          },
          active: {
            style: shapeStyles.hollowArea.active
          },
          inactive: {
            style: shapeStyles.hollowArea.inactive
          },
          selected: {
            style: shapeStyles.hollowArea.selected
          }
        },
        "smooth-line": {
          default: {
            style: shapeStyles.hollowArea.default
          },
          active: {
            style: shapeStyles.hollowArea.active
          },
          inactive: {
            style: shapeStyles.hollowArea.inactive
          },
          selected: {
            style: shapeStyles.hollowArea.selected
          }
        }
      },
      schema: {
        candle: {
          default: {
            style: shapeStyles.hollowInterval.default
          },
          active: {
            style: shapeStyles.hollowInterval.active
          },
          inactive: {
            style: shapeStyles.hollowInterval.inactive
          },
          selected: {
            style: shapeStyles.hollowInterval.selected
          }
        },
        box: {
          default: {
            style: shapeStyles.hollowInterval.default
          },
          active: {
            style: shapeStyles.hollowInterval.active
          },
          inactive: {
            style: shapeStyles.hollowInterval.inactive
          },
          selected: {
            style: shapeStyles.hollowInterval.selected
          }
        }
      },
      edge: {
        line: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        vhv: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        smooth: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        arc: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        }
      },
      violin: {
        violin: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        smooth: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        hollow: {
          default: {
            style: shapeStyles.hollowArea.default
          },
          active: {
            style: shapeStyles.hollowArea.active
          },
          inactive: {
            style: shapeStyles.hollowArea.inactive
          },
          selected: {
            style: shapeStyles.hollowArea.selected
          }
        },
        "hollow-smooth": {
          default: {
            style: shapeStyles.hollowArea.default
          },
          active: {
            style: shapeStyles.hollowArea.active
          },
          inactive: {
            style: shapeStyles.hollowArea.inactive
          },
          selected: {
            style: shapeStyles.hollowArea.selected
          }
        }
      }
    },
    components: {
      axis: {
        common: axisStyles,
        top: {
          position: "top",
          grid: null,
          title: null,
          verticalLimitLength: 1 / 2
        },
        bottom: {
          position: "bottom",
          grid: null,
          title: null,
          verticalLimitLength: 1 / 2
        },
        left: {
          position: "left",
          title: null,
          line: null,
          tickLine: null,
          verticalLimitLength: 1 / 3
        },
        right: {
          position: "right",
          title: null,
          line: null,
          tickLine: null,
          verticalLimitLength: 1 / 3
        },
        circle: {
          title: null,
          grid: deep_mix_default({}, axisStyles.grid, { line: { type: "line" } })
        },
        radius: {
          title: null,
          grid: deep_mix_default({}, axisStyles.grid, { line: { type: "circle" } })
        }
      },
      legend: {
        common: legendStyles,
        right: {
          layout: "vertical",
          padding: styleSheet.legendVerticalPadding
        },
        left: {
          layout: "vertical",
          padding: styleSheet.legendVerticalPadding
        },
        top: {
          layout: "horizontal",
          padding: styleSheet.legendHorizontalPadding
        },
        bottom: {
          layout: "horizontal",
          padding: styleSheet.legendHorizontalPadding
        },
        continuous: {
          title: null,
          background: null,
          track: {},
          rail: {
            type: "color",
            size: styleSheet.sliderRailHeight,
            defaultLength: styleSheet.sliderRailWidth,
            style: {
              fill: styleSheet.sliderRailFillColor,
              stroke: styleSheet.sliderRailBorderColor,
              lineWidth: styleSheet.sliderRailBorder
            }
          },
          label: {
            align: "rail",
            spacing: 4,
            formatter: null,
            style: {
              fill: styleSheet.sliderLabelTextFillColor,
              fontSize: styleSheet.sliderLabelTextFontSize,
              lineHeight: styleSheet.sliderLabelTextLineHeight,
              textBaseline: "middle",
              fontFamily: styleSheet.fontFamily
            }
          },
          handler: {
            size: styleSheet.sliderHandlerWidth,
            style: {
              fill: styleSheet.sliderHandlerFillColor,
              stroke: styleSheet.sliderHandlerBorderColor
            }
          },
          slidable: true,
          padding: legendStyles.padding
        }
      },
      tooltip: {
        showContent: true,
        follow: true,
        showCrosshairs: false,
        showMarkers: true,
        shared: false,
        enterable: false,
        position: "auto",
        marker: {
          symbol: "circle",
          stroke: "#fff",
          shadowBlur: 10,
          shadowOffsetX: 0,
          shadowOffsetY: 0,
          shadowColor: "rgba(0,0,0,0.09)",
          lineWidth: 2,
          r: 4
        },
        crosshairs: {
          line: {
            style: {
              stroke: styleSheet.tooltipCrosshairsBorderColor,
              lineWidth: styleSheet.tooltipCrosshairsBorder
            }
          },
          text: null,
          textBackground: {
            padding: 2,
            style: {
              fill: "rgba(0, 0, 0, 0.25)",
              lineWidth: 0,
              stroke: null
            }
          },
          follow: false
        },
        domStyles: (_a3 = {}, _a3["".concat(css_const_exports2.CONTAINER_CLASS)] = {
          position: "absolute",
          visibility: "hidden",
          zIndex: 8,
          transition: "left 0.4s cubic-bezier(0.23, 1, 0.32, 1) 0s, top 0.4s cubic-bezier(0.23, 1, 0.32, 1) 0s",
          backgroundColor: styleSheet.tooltipContainerFillColor,
          opacity: styleSheet.tooltipContainerFillOpacity,
          boxShadow: styleSheet.tooltipContainerShadow,
          borderRadius: "".concat(styleSheet.tooltipContainerBorderRadius, "px"),
          color: styleSheet.tooltipTextFillColor,
          fontSize: "".concat(styleSheet.tooltipTextFontSize, "px"),
          fontFamily: styleSheet.fontFamily,
          lineHeight: "".concat(styleSheet.tooltipTextLineHeight, "px"),
          padding: "0 12px 0 12px"
        }, _a3["".concat(css_const_exports2.TITLE_CLASS)] = {
          marginBottom: "12px",
          marginTop: "12px"
        }, _a3["".concat(css_const_exports2.LIST_CLASS)] = {
          margin: 0,
          listStyleType: "none",
          padding: 0
        }, _a3["".concat(css_const_exports2.LIST_ITEM_CLASS)] = {
          listStyleType: "none",
          padding: 0,
          marginBottom: "12px",
          marginTop: "12px",
          marginLeft: 0,
          marginRight: 0
        }, _a3["".concat(css_const_exports2.MARKER_CLASS)] = {
          width: "8px",
          height: "8px",
          borderRadius: "50%",
          display: "inline-block",
          marginRight: "8px"
        }, _a3["".concat(css_const_exports2.VALUE_CLASS)] = {
          display: "inline-block",
          float: "right",
          marginLeft: "30px"
        }, _a3)
      },
      annotation: {
        arc: {
          style: {
            stroke: styleSheet.annotationArcBorderColor,
            lineWidth: styleSheet.annotationArcBorder
          },
          animate: true
        },
        line: {
          style: {
            stroke: styleSheet.annotationLineBorderColor,
            lineDash: styleSheet.annotationLineDash,
            lineWidth: styleSheet.annotationLineBorder
          },
          text: {
            position: "start",
            autoRotate: true,
            style: {
              fill: styleSheet.annotationTextFillColor,
              stroke: styleSheet.annotationTextBorderColor,
              lineWidth: styleSheet.annotationTextBorder,
              fontSize: styleSheet.annotationTextFontSize,
              textAlign: "start",
              fontFamily: styleSheet.fontFamily,
              textBaseline: "bottom"
            }
          },
          animate: true
        },
        text: {
          style: {
            fill: styleSheet.annotationTextFillColor,
            stroke: styleSheet.annotationTextBorderColor,
            lineWidth: styleSheet.annotationTextBorder,
            fontSize: styleSheet.annotationTextFontSize,
            textBaseline: "middle",
            textAlign: "start",
            fontFamily: styleSheet.fontFamily
          },
          animate: true
        },
        region: {
          top: false,
          style: {
            lineWidth: styleSheet.annotationRegionBorder,
            stroke: styleSheet.annotationRegionBorderColor,
            fill: styleSheet.annotationRegionFillColor,
            fillOpacity: styleSheet.annotationRegionFillOpacity
          },
          animate: true
        },
        image: {
          top: false,
          animate: true
        },
        dataMarker: {
          top: true,
          point: {
            style: {
              r: 3,
              stroke: styleSheet.brandColor,
              lineWidth: 2
            }
          },
          line: {
            style: {
              stroke: styleSheet.annotationLineBorderColor,
              lineWidth: styleSheet.annotationLineBorder
            },
            length: styleSheet.annotationDataMarkerLineLength
          },
          text: {
            style: {
              textAlign: "start",
              fill: styleSheet.annotationTextFillColor,
              stroke: styleSheet.annotationTextBorderColor,
              lineWidth: styleSheet.annotationTextBorder,
              fontSize: styleSheet.annotationTextFontSize,
              fontFamily: styleSheet.fontFamily
            }
          },
          direction: "upward",
          autoAdjust: true,
          animate: true
        },
        dataRegion: {
          style: {
            region: {
              fill: styleSheet.annotationRegionFillColor,
              fillOpacity: styleSheet.annotationRegionFillOpacity
            },
            text: {
              textAlign: "center",
              textBaseline: "bottom",
              fill: styleSheet.annotationTextFillColor,
              stroke: styleSheet.annotationTextBorderColor,
              lineWidth: styleSheet.annotationTextBorder,
              fontSize: styleSheet.annotationTextFontSize,
              fontFamily: styleSheet.fontFamily
            }
          },
          animate: true
        }
      },
      slider: {
        common: {
          padding: [8, 8, 8, 8],
          backgroundStyle: {
            fill: styleSheet.cSliderBackgroundFillColor,
            opacity: styleSheet.cSliderBackgroundFillOpacity
          },
          foregroundStyle: {
            fill: styleSheet.cSliderForegroundFillColor,
            opacity: styleSheet.cSliderForegroundFillOpacity
          },
          handlerStyle: {
            width: styleSheet.cSliderHandlerWidth,
            height: styleSheet.cSliderHandlerHeight,
            fill: styleSheet.cSliderHandlerFillColor,
            opacity: styleSheet.cSliderHandlerFillOpacity,
            stroke: styleSheet.cSliderHandlerBorderColor,
            lineWidth: styleSheet.cSliderHandlerBorder,
            radius: styleSheet.cSliderHandlerBorderRadius,
            highLightFill: styleSheet.cSliderHandlerHighlightFillColor
          },
          textStyle: {
            fill: styleSheet.cSliderTextFillColor,
            opacity: styleSheet.cSliderTextFillOpacity,
            fontSize: styleSheet.cSliderTextFontSize,
            lineHeight: styleSheet.cSliderTextLineHeight,
            fontWeight: styleSheet.cSliderTextFontWeight,
            stroke: styleSheet.cSliderTextBorderColor,
            lineWidth: styleSheet.cSliderTextBorder
          }
        }
      },
      scrollbar: {
        common: {
          padding: [8, 8, 8, 8]
        },
        default: {
          style: {
            trackColor: styleSheet.scrollbarTrackFillColor,
            thumbColor: styleSheet.scrollbarThumbFillColor
          }
        },
        hover: {
          style: {
            thumbColor: styleSheet.scrollbarThumbHighlightFillColor
          }
        }
      }
    },
    labels: {
      offset: 12,
      style: {
        fill: styleSheet.labelFillColor,
        fontSize: styleSheet.labelFontSize,
        fontFamily: styleSheet.fontFamily,
        stroke: styleSheet.labelBorderColor,
        lineWidth: styleSheet.labelBorder
      },
      fillColorDark: styleSheet.labelFillColorDark,
      fillColorLight: styleSheet.labelFillColorLight,
      autoRotate: true
    },
    innerLabels: {
      style: {
        fill: styleSheet.innerLabelFillColor,
        fontSize: styleSheet.innerLabelFontSize,
        fontFamily: styleSheet.fontFamily,
        stroke: styleSheet.innerLabelBorderColor,
        lineWidth: styleSheet.innerLabelBorder
      },
      autoRotate: true
    },
    overflowLabels: {
      style: {
        fill: styleSheet.overflowLabelFillColor,
        fontSize: styleSheet.overflowLabelFontSize,
        fontFamily: styleSheet.fontFamily,
        stroke: styleSheet.overflowLabelBorderColor,
        lineWidth: styleSheet.overflowLabelBorder
      }
    },
    pieLabels: {
      labelHeight: 14,
      offset: 10,
      labelLine: {
        style: {
          lineWidth: styleSheet.labelLineBorder
        }
      },
      autoRotate: true
    }
  };
}

// node_modules/@antv/g2/esm/theme/style-sheet/light.js
var BLACK_COLORS = {
  100: "#000",
  95: "#0D0D0D",
  85: "#262626",
  65: "#595959",
  45: "#8C8C8C",
  25: "#BFBFBF",
  15: "#D9D9D9",
  6: "#F0F0F0"
};
var WHITE_COLORS = {
  100: "#FFFFFF",
  95: "#F2F2F2",
  85: "#D9D9D9",
  65: "#A6A6A6",
  45: "#737373",
  25: "#404040",
  15: "#262626",
  6: "#0F0F0F"
};
var QUALITATIVE_10 = [
  "#5B8FF9",
  "#5AD8A6",
  "#5D7092",
  "#F6BD16",
  "#6F5EF9",
  "#6DC8EC",
  "#945FB9",
  "#FF9845",
  "#1E9493",
  "#FF99C3"
];
var QUALITATIVE_20 = [
  "#5B8FF9",
  "#CDDDFD",
  "#5AD8A6",
  "#CDF3E4",
  "#5D7092",
  "#CED4DE",
  "#F6BD16",
  "#FCEBB9",
  "#6F5EF9",
  "#D3CEFD",
  "#6DC8EC",
  "#D3EEF9",
  "#945FB9",
  "#DECFEA",
  "#FF9845",
  "#FFE0C7",
  "#1E9493",
  "#BBDEDE",
  "#FF99C3",
  "#FFE0ED"
];
var SINGLE_SEQUENCE = [
  "#B8E1FF",
  "#9AC5FF",
  "#7DAAFF",
  "#5B8FF9",
  "#3D76DD",
  "#085EC0",
  "#0047A5",
  "#00318A",
  "#001D70"
];
var createLightStyleSheet = function(cfg) {
  if (cfg === void 0) {
    cfg = {};
  }
  var _a3 = cfg.paletteQualitative10, paletteQualitative10 = _a3 === void 0 ? QUALITATIVE_10 : _a3, _b = cfg.paletteQualitative20, paletteQualitative20 = _b === void 0 ? QUALITATIVE_20 : _b;
  var _c = cfg.brandColor, brandColor = _c === void 0 ? paletteQualitative10[0] : _c;
  var token2 = {
    backgroundColor: "transparent",
    brandColor,
    subColor: "rgba(0,0,0,0.05)",
    paletteQualitative10,
    paletteQualitative20,
    paletteSemanticRed: "#F4664A",
    paletteSemanticGreen: "#30BF78",
    paletteSemanticYellow: "#FAAD14",
    paletteSequence: SINGLE_SEQUENCE,
    fontFamily: '"Segoe UI", Roboto, "Helvetica Neue", Arial,\n    "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol",\n    "Noto Color Emoji"',
    axisLineBorderColor: BLACK_COLORS[25],
    axisLineBorder: 1,
    axisLineDash: null,
    axisTitleTextFillColor: BLACK_COLORS[65],
    axisTitleTextFontSize: 12,
    axisTitleTextLineHeight: 12,
    axisTitleTextFontWeight: "normal",
    axisTitleSpacing: 12,
    axisDescriptionIconFillColor: WHITE_COLORS[85],
    axisTickLineBorderColor: BLACK_COLORS[25],
    axisTickLineLength: 4,
    axisTickLineBorder: 1,
    axisSubTickLineBorderColor: BLACK_COLORS[15],
    axisSubTickLineLength: 2,
    axisSubTickLineBorder: 1,
    axisLabelFillColor: BLACK_COLORS[45],
    axisLabelFontSize: 12,
    axisLabelLineHeight: 12,
    axisLabelFontWeight: "normal",
    axisLabelOffset: 8,
    axisGridBorderColor: BLACK_COLORS[15],
    axisGridBorder: 1,
    axisGridLineDash: null,
    legendTitleTextFillColor: BLACK_COLORS[45],
    legendTitleTextFontSize: 12,
    legendTitleTextLineHeight: 21,
    legendTitleTextFontWeight: "normal",
    legendMarkerColor: brandColor,
    legendMarkerSpacing: 8,
    legendMarkerSize: 4,
    legendCircleMarkerSize: 4,
    legendSquareMarkerSize: 4,
    legendLineMarkerSize: 5,
    legendItemNameFillColor: BLACK_COLORS[65],
    legendItemNameFontSize: 12,
    legendItemNameLineHeight: 12,
    legendItemNameFontWeight: "normal",
    legendItemSpacing: 24,
    legendItemMarginBottom: 12,
    legendPadding: [8, 8, 8, 8],
    legendHorizontalPadding: [8, 0, 8, 0],
    legendVerticalPadding: [0, 8, 0, 8],
    legendPageNavigatorMarkerSize: 12,
    legendPageNavigatorMarkerInactiveFillColor: BLACK_COLORS[100],
    legendPageNavigatorMarkerInactiveFillOpacity: 0.45,
    legendPageNavigatorMarkerFillColor: BLACK_COLORS[100],
    legendPageNavigatorMarkerFillOpacity: 1,
    legendPageNavigatorTextFillColor: BLACK_COLORS[45],
    legendPageNavigatorTextFontSize: 12,
    sliderRailFillColor: BLACK_COLORS[15],
    sliderRailBorder: 0,
    sliderRailBorderColor: null,
    sliderRailWidth: 100,
    sliderRailHeight: 12,
    sliderLabelTextFillColor: BLACK_COLORS[45],
    sliderLabelTextFontSize: 12,
    sliderLabelTextLineHeight: 12,
    sliderLabelTextFontWeight: "normal",
    sliderHandlerFillColor: BLACK_COLORS[6],
    sliderHandlerWidth: 10,
    sliderHandlerHeight: 14,
    sliderHandlerBorder: 1,
    sliderHandlerBorderColor: BLACK_COLORS[25],
    annotationArcBorderColor: BLACK_COLORS[15],
    annotationArcBorder: 1,
    annotationLineBorderColor: BLACK_COLORS[25],
    annotationLineBorder: 1,
    annotationLineDash: null,
    annotationTextFillColor: BLACK_COLORS[65],
    annotationTextFontSize: 12,
    annotationTextLineHeight: 12,
    annotationTextFontWeight: "normal",
    annotationTextBorderColor: null,
    annotationTextBorder: 0,
    annotationRegionFillColor: BLACK_COLORS[100],
    annotationRegionFillOpacity: 0.06,
    annotationRegionBorder: 0,
    annotationRegionBorderColor: null,
    annotationDataMarkerLineLength: 16,
    tooltipCrosshairsBorderColor: BLACK_COLORS[25],
    tooltipCrosshairsBorder: 1,
    tooltipCrosshairsLineDash: null,
    tooltipContainerFillColor: "rgb(255, 255, 255)",
    tooltipContainerFillOpacity: 0.95,
    tooltipContainerShadow: "0px 0px 10px #aeaeae",
    tooltipContainerBorderRadius: 3,
    tooltipTextFillColor: BLACK_COLORS[65],
    tooltipTextFontSize: 12,
    tooltipTextLineHeight: 12,
    tooltipTextFontWeight: "bold",
    labelFillColor: BLACK_COLORS[65],
    labelFillColorDark: "#2c3542",
    labelFillColorLight: "#ffffff",
    labelFontSize: 12,
    labelLineHeight: 12,
    labelFontWeight: "normal",
    labelBorderColor: null,
    labelBorder: 0,
    innerLabelFillColor: WHITE_COLORS[100],
    innerLabelFontSize: 12,
    innerLabelLineHeight: 12,
    innerLabelFontWeight: "normal",
    innerLabelBorderColor: null,
    innerLabelBorder: 0,
    overflowLabelFillColor: BLACK_COLORS[65],
    overflowLabelFontSize: 12,
    overflowLabelLineHeight: 12,
    overflowLabelFontWeight: "normal",
    overflowLabelBorderColor: WHITE_COLORS[100],
    overflowLabelBorder: 1,
    labelLineBorder: 1,
    labelLineBorderColor: BLACK_COLORS[25],
    cSliderRailHieght: 16,
    cSliderBackgroundFillColor: "#416180",
    cSliderBackgroundFillOpacity: 0.05,
    cSliderForegroundFillColor: "#5B8FF9",
    cSliderForegroundFillOpacity: 0.15,
    cSliderHandlerHeight: 24,
    cSliderHandlerWidth: 10,
    cSliderHandlerFillColor: "#F7F7F7",
    cSliderHandlerFillOpacity: 1,
    cSliderHandlerHighlightFillColor: "#FFF",
    cSliderHandlerBorderColor: "#BFBFBF",
    cSliderHandlerBorder: 1,
    cSliderHandlerBorderRadius: 2,
    cSliderTextFillColor: "#000",
    cSliderTextFillOpacity: 0.45,
    cSliderTextFontSize: 12,
    cSliderTextLineHeight: 12,
    cSliderTextFontWeight: "normal",
    cSliderTextBorderColor: null,
    cSliderTextBorder: 0,
    scrollbarTrackFillColor: "rgba(0,0,0,0)",
    scrollbarThumbFillColor: "rgba(0,0,0,0.15)",
    scrollbarThumbHighlightFillColor: "rgba(0,0,0,0.2)",
    pointFillColor: brandColor,
    pointFillOpacity: 0.95,
    pointSize: 4,
    pointBorder: 1,
    pointBorderColor: WHITE_COLORS[100],
    pointBorderOpacity: 1,
    pointActiveBorderColor: BLACK_COLORS[100],
    pointSelectedBorder: 2,
    pointSelectedBorderColor: BLACK_COLORS[100],
    pointInactiveFillOpacity: 0.3,
    pointInactiveBorderOpacity: 0.3,
    hollowPointSize: 4,
    hollowPointBorder: 1,
    hollowPointBorderColor: brandColor,
    hollowPointBorderOpacity: 0.95,
    hollowPointFillColor: WHITE_COLORS[100],
    hollowPointActiveBorder: 1,
    hollowPointActiveBorderColor: BLACK_COLORS[100],
    hollowPointActiveBorderOpacity: 1,
    hollowPointSelectedBorder: 2,
    hollowPointSelectedBorderColor: BLACK_COLORS[100],
    hollowPointSelectedBorderOpacity: 1,
    hollowPointInactiveBorderOpacity: 0.3,
    lineBorder: 2,
    lineBorderColor: brandColor,
    lineBorderOpacity: 1,
    lineActiveBorder: 3,
    lineSelectedBorder: 3,
    lineInactiveBorderOpacity: 0.3,
    areaFillColor: brandColor,
    areaFillOpacity: 0.25,
    areaActiveFillColor: brandColor,
    areaActiveFillOpacity: 0.5,
    areaSelectedFillColor: brandColor,
    areaSelectedFillOpacity: 0.5,
    areaInactiveFillOpacity: 0.3,
    hollowAreaBorderColor: brandColor,
    hollowAreaBorder: 2,
    hollowAreaBorderOpacity: 1,
    hollowAreaActiveBorder: 3,
    hollowAreaActiveBorderColor: BLACK_COLORS[100],
    hollowAreaSelectedBorder: 3,
    hollowAreaSelectedBorderColor: BLACK_COLORS[100],
    hollowAreaInactiveBorderOpacity: 0.3,
    intervalFillColor: brandColor,
    intervalFillOpacity: 0.95,
    intervalActiveBorder: 1,
    intervalActiveBorderColor: BLACK_COLORS[100],
    intervalActiveBorderOpacity: 1,
    intervalSelectedBorder: 2,
    intervalSelectedBorderColor: BLACK_COLORS[100],
    intervalSelectedBorderOpacity: 1,
    intervalInactiveBorderOpacity: 0.3,
    intervalInactiveFillOpacity: 0.3,
    hollowIntervalBorder: 2,
    hollowIntervalBorderColor: brandColor,
    hollowIntervalBorderOpacity: 1,
    hollowIntervalFillColor: WHITE_COLORS[100],
    hollowIntervalActiveBorder: 2,
    hollowIntervalActiveBorderColor: BLACK_COLORS[100],
    hollowIntervalSelectedBorder: 3,
    hollowIntervalSelectedBorderColor: BLACK_COLORS[100],
    hollowIntervalSelectedBorderOpacity: 1,
    hollowIntervalInactiveBorderOpacity: 0.3
  };
  return __assign(__assign({}, token2), cfg);
};
var antvLight = createLightStyleSheet();

// node_modules/@antv/g2/esm/theme/util/create-theme.js
function createTheme(themeCfg) {
  var _a3 = themeCfg.styleSheet, styleSheetCfg = _a3 === void 0 ? {} : _a3, themeObject = __rest(themeCfg, ["styleSheet"]);
  var styleSheet = createLightStyleSheet(styleSheetCfg);
  return deep_mix_default({}, createThemeByStyleSheet(styleSheet), themeObject);
}

// node_modules/@antv/g2/esm/theme/index.js
var defaultTheme = createTheme({});
var Themes = {
  default: defaultTheme
};
function getTheme(theme) {
  return get_default(Themes, lower_case_default(theme), Themes.default);
}
function registerTheme(theme, value) {
  Themes[lower_case_default(theme)] = createTheme(value);
}

// node_modules/@antv/g2/esm/util/tooltip.js
function snapEqual(v1, v2, scale5) {
  var value1 = scale5.translate(v1);
  var value2 = scale5.translate(v2);
  return isNumberEqual(value1, value2);
}
function getXValueByPoint(point, geometry) {
  var coordinate = geometry.coordinate;
  var xScale = geometry.getXScale();
  var range = xScale.range;
  var rangeMax = range[range.length - 1];
  var rangeMin = range[0];
  var invertPoint = coordinate.invert(point);
  var xValue = invertPoint.x;
  if (coordinate.isPolar && xValue > (1 + rangeMax) / 2) {
    xValue = rangeMin;
  }
  return xScale.translate(xScale.invert(xValue));
}
function filterYValue(data, point, geometry) {
  var coordinate = geometry.coordinate;
  var yScale = geometry.getYScale();
  var yField = yScale.field;
  var invertPoint = coordinate.invert(point);
  var yValue = yScale.invert(invertPoint.y);
  var result = find_default(data, function(obj) {
    var originData = obj[FIELD_ORIGIN];
    return originData[yField][0] <= yValue && originData[yField][1] >= yValue;
  });
  return result || data[data.length - 1];
}
var getXDistance = memoize_default(function(scale5) {
  if (scale5.isCategory) {
    return 1;
  }
  var scaleValues = scale5.values;
  var length5 = scaleValues.length;
  var min3 = scale5.translate(scaleValues[0]);
  var max3 = min3;
  for (var index = 0; index < length5; index++) {
    var value = scaleValues[index];
    var numericValue = scale5.translate(value);
    if (numericValue < min3) {
      min3 = numericValue;
    }
    if (numericValue > max3) {
      max3 = numericValue;
    }
  }
  return (max3 - min3) / (length5 - 1);
});
function getTooltipTitle(originData, geometry, title) {
  var positionAttr = geometry.getAttribute("position");
  var fields = positionAttr.getFields();
  var scales = geometry.scales;
  var titleField = is_function_default(title) || !title ? fields[0] : title;
  var titleScale = scales[titleField];
  var tooltipTitle = titleScale ? titleScale.getText(originData[titleField]) : originData[titleField] || titleField;
  return is_function_default(title) ? title(tooltipTitle, originData) : tooltipTitle;
}
function getAttributesForLegend(geometry) {
  var attributes = values_default(geometry.attributes);
  return filter_default(attributes, function(attribute) {
    return contains_default(GROUP_ATTRS, attribute.type);
  });
}
function getTooltipValueScale(geometry) {
  var e_1, _a3;
  var attributes = getAttributesForLegend(geometry);
  var scale5;
  try {
    for (var attributes_1 = __values(attributes), attributes_1_1 = attributes_1.next(); !attributes_1_1.done; attributes_1_1 = attributes_1.next()) {
      var attribute = attributes_1_1.value;
      var tmpScale = attribute.getScale(attribute.type);
      if (tmpScale && tmpScale.isLinear) {
        var tmpScaleDef = get_default(geometry.scaleDefs, tmpScale.field);
        var inferedScaleType = inferScaleType(tmpScale, tmpScaleDef, attribute.type, geometry.type);
        if (inferedScaleType !== "cat") {
          scale5 = tmpScale;
          break;
        }
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (attributes_1_1 && !attributes_1_1.done && (_a3 = attributes_1.return))
        _a3.call(attributes_1);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  var xScale = geometry.getXScale();
  var yScale = geometry.getYScale();
  return scale5 || yScale || xScale;
}
function getTooltipValue(originData, valueScale) {
  var field = valueScale.field;
  var value = originData[field];
  if (is_array_default(value)) {
    var texts = value.map(function(eachValue) {
      return valueScale.getText(eachValue);
    });
    return texts.join("-");
  }
  return valueScale.getText(value);
}
function getTooltipName(originData, geometry) {
  var nameScale;
  var groupScales = geometry.getGroupScales();
  if (groupScales.length) {
    nameScale = groupScales[0];
  }
  if (nameScale) {
    var field = nameScale.field;
    return nameScale.getText(originData[field]);
  }
  var valueScale = getTooltipValueScale(geometry);
  return getName(valueScale);
}
function findDataByPoint(point, data, geometry) {
  if (data.length === 0) {
    return null;
  }
  var geometryType = geometry.type;
  var xScale = geometry.getXScale();
  var yScale = geometry.getYScale();
  var xField = xScale.field;
  var yField = yScale.field;
  var rst = null;
  if (geometryType === "heatmap" || geometryType === "point") {
    var coordinate = geometry.coordinate;
    var invertPoint = coordinate.invert(point);
    var x = xScale.invert(invertPoint.x);
    var y = yScale.invert(invertPoint.y);
    var min3 = Infinity;
    for (var index = 0; index < data.length; index++) {
      var obj = data[index];
      var originData = obj[FIELD_ORIGIN];
      var range = Math.pow(originData[xField] - x, 2) + Math.pow(originData[yField] - y, 2);
      if (range < min3) {
        min3 = range;
        rst = obj;
      }
    }
    return rst;
  }
  var first = data[0];
  var last2 = data[data.length - 1];
  var xValue = getXValueByPoint(point, geometry);
  var firstXValue = first[FIELD_ORIGIN][xField];
  var firstYValue = first[FIELD_ORIGIN][yField];
  var lastXValue = last2[FIELD_ORIGIN][xField];
  var isYArray = yScale.isLinear && is_array_default(firstYValue);
  if (is_array_default(firstXValue)) {
    for (var index = 0; index < data.length; index++) {
      var record = data[index];
      var originData = record[FIELD_ORIGIN];
      if (xScale.translate(originData[xField][0]) <= xValue && xScale.translate(originData[xField][1]) >= xValue) {
        if (isYArray) {
          if (!is_array_default(rst)) {
            rst = [];
          }
          rst.push(record);
        } else {
          rst = record;
          break;
        }
      }
    }
    if (is_array_default(rst)) {
      rst = filterYValue(rst, point, geometry);
    }
  } else {
    var next = void 0;
    if (!xScale.isLinear && xScale.type !== "timeCat") {
      for (var index = 0; index < data.length; index++) {
        var record = data[index];
        var originData = record[FIELD_ORIGIN];
        if (snapEqual(originData[xField], xValue, xScale)) {
          if (isYArray) {
            if (!is_array_default(rst)) {
              rst = [];
            }
            rst.push(record);
          } else {
            rst = record;
            break;
          }
        } else if (xScale.translate(originData[xField]) <= xValue) {
          last2 = record;
          next = data[index + 1];
        }
      }
      if (is_array_default(rst)) {
        rst = filterYValue(rst, point, geometry);
      }
    } else {
      if ((xValue > xScale.translate(lastXValue) || xValue < xScale.translate(firstXValue)) && (xValue > xScale.max || xValue < xScale.min)) {
        return null;
      }
      var firstIdx = 0;
      var lastIdx = data.length - 1;
      var middleIdx = void 0;
      while (firstIdx <= lastIdx) {
        middleIdx = Math.floor((firstIdx + lastIdx) / 2);
        var item = data[middleIdx][FIELD_ORIGIN][xField];
        if (snapEqual(item, xValue, xScale)) {
          return data[middleIdx];
        }
        if (xScale.translate(item) <= xScale.translate(xValue)) {
          firstIdx = middleIdx + 1;
          last2 = data[middleIdx];
          next = data[middleIdx + 1];
        } else {
          if (lastIdx === 0) {
            last2 = data[0];
          }
          lastIdx = middleIdx - 1;
        }
      }
    }
    if (last2 && next) {
      if (Math.abs(xScale.translate(last2[FIELD_ORIGIN][xField]) - xValue) > Math.abs(xScale.translate(next[FIELD_ORIGIN][xField]) - xValue)) {
        last2 = next;
      }
    }
  }
  var distance8 = getXDistance(geometry.getXScale());
  if (!rst && Math.abs(xScale.translate(last2[FIELD_ORIGIN][xField]) - xValue) <= distance8 / 2) {
    rst = last2;
  }
  return rst;
}
function getTooltipItems(data, geometry, title, showNil) {
  var e_2, _a3;
  if (title === void 0) {
    title = "";
  }
  if (showNil === void 0) {
    showNil = false;
  }
  var originData = data[FIELD_ORIGIN];
  var tooltipTitle = getTooltipTitle(originData, geometry, title);
  var tooltipOption = geometry.tooltipOption;
  var defaultColor = geometry.theme.defaultColor;
  var items = [];
  var name;
  var value;
  function addItem(itemName, itemValue) {
    if (showNil || !is_nil_default(itemValue) && itemValue !== "") {
      var item = {
        title: tooltipTitle,
        data: originData,
        mappingData: data,
        name: itemName,
        value: itemValue,
        color: data.color || defaultColor,
        marker: true
      };
      items.push(item);
    }
  }
  if (is_object_default(tooltipOption)) {
    var fields = tooltipOption.fields, callback = tooltipOption.callback;
    if (callback) {
      var callbackParams = fields.map(function(field2) {
        return data[FIELD_ORIGIN][field2];
      });
      var cfg = callback.apply(void 0, __spreadArray([], __read(callbackParams), false));
      var itemCfg = __assign({ data: data[FIELD_ORIGIN], mappingData: data, title: tooltipTitle, color: data.color || defaultColor, marker: true }, cfg);
      items.push(itemCfg);
    } else {
      var scales = geometry.scales;
      try {
        for (var fields_1 = __values(fields), fields_1_1 = fields_1.next(); !fields_1_1.done; fields_1_1 = fields_1.next()) {
          var field = fields_1_1.value;
          if (!is_nil_default(originData[field])) {
            var scale5 = scales[field];
            name = getName(scale5);
            value = scale5.getText(originData[field]);
            addItem(name, value);
          }
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (fields_1_1 && !fields_1_1.done && (_a3 = fields_1.return))
            _a3.call(fields_1);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
    }
  } else {
    var valueScale = getTooltipValueScale(geometry);
    value = getTooltipValue(originData, valueScale);
    name = getTooltipName(originData, geometry);
    addItem(name, value);
  }
  return items;
}
function getTooltipItemsByFindData(geometry, point, title, tooltipCfg) {
  var e_3, _a3;
  var showNil = tooltipCfg.showNil;
  var result = [];
  var dataArray = geometry.dataArray;
  if (!is_empty_default(dataArray)) {
    geometry.sort(dataArray);
    try {
      for (var dataArray_1 = __values(dataArray), dataArray_1_1 = dataArray_1.next(); !dataArray_1_1.done; dataArray_1_1 = dataArray_1.next()) {
        var data = dataArray_1_1.value;
        var record = findDataByPoint(point, data, geometry);
        if (record) {
          var elementId = geometry.getElementId(record);
          var element = geometry.elementsMap[elementId];
          if (geometry.type === "heatmap" || element.visible) {
            var items = getTooltipItems(record, geometry, title, showNil);
            if (items.length) {
              result.push(items);
            }
          }
        }
      }
    } catch (e_3_1) {
      e_3 = { error: e_3_1 };
    } finally {
      try {
        if (dataArray_1_1 && !dataArray_1_1.done && (_a3 = dataArray_1.return))
          _a3.call(dataArray_1);
      } finally {
        if (e_3)
          throw e_3.error;
      }
    }
  }
  return result;
}
function getTooltipItemsByHitShape(geometry, point, title, tooltipCfg) {
  var showNil = tooltipCfg.showNil;
  var result = [];
  var container = geometry.container;
  var shape = container.getShape(point.x, point.y);
  if (shape && shape.get("visible") && shape.get("origin")) {
    var mappingData = shape.get("origin").mappingData;
    var items = getTooltipItems(mappingData, geometry, title, showNil);
    if (items.length) {
      result.push(items);
    }
  }
  return result;
}
function findItemsFromView(view, point, tooltipCfg) {
  var e_4, _a3;
  var result = [];
  var geometries = view.geometries;
  var shared = tooltipCfg.shared, title = tooltipCfg.title, reversed = tooltipCfg.reversed;
  try {
    for (var geometries_1 = __values(geometries), geometries_1_1 = geometries_1.next(); !geometries_1_1.done; geometries_1_1 = geometries_1.next()) {
      var geometry = geometries_1_1.value;
      if (geometry.visible && geometry.tooltipOption !== false) {
        var geometryType = geometry.type;
        var tooltipItems = void 0;
        if (["point", "edge", "polygon"].includes(geometryType)) {
          tooltipItems = getTooltipItemsByHitShape(geometry, point, title, tooltipCfg);
        } else if (["area", "line", "path", "heatmap"].includes(geometryType)) {
          tooltipItems = getTooltipItemsByFindData(geometry, point, title, tooltipCfg);
        } else {
          if (shared !== false) {
            tooltipItems = getTooltipItemsByFindData(geometry, point, title, tooltipCfg);
          } else {
            tooltipItems = getTooltipItemsByHitShape(geometry, point, title, tooltipCfg);
          }
        }
        if (tooltipItems.length) {
          if (reversed) {
            tooltipItems.reverse();
          }
          result.push(tooltipItems);
        }
      }
    }
  } catch (e_4_1) {
    e_4 = { error: e_4_1 };
  } finally {
    try {
      if (geometries_1_1 && !geometries_1_1.done && (_a3 = geometries_1.return))
        _a3.call(geometries_1);
    } finally {
      if (e_4)
        throw e_4.error;
    }
  }
  return result;
}
function findItemsFromViewRecurisive(view, point, tooltipCfg) {
  var e_5, _a3;
  var result = findItemsFromView(view, point, tooltipCfg);
  try {
    for (var _b = __values(view.views), _c = _b.next(); !_c.done; _c = _b.next()) {
      var childView = _c.value;
      result = result.concat(findItemsFromView(childView, point, tooltipCfg));
    }
  } catch (e_5_1) {
    e_5 = { error: e_5_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a3 = _b.return))
        _a3.call(_b);
    } finally {
      if (e_5)
        throw e_5.error;
    }
  }
  return result;
}

// node_modules/@antv/g2/esm/util/padding.js
function isAutoPadding(padding) {
  return !is_number_default(padding) && !is_array_default(padding);
}
function parsePadding(padding) {
  if (padding === void 0) {
    padding = 0;
  }
  var paddingArray = is_array_default(padding) ? padding : [padding];
  switch (paddingArray.length) {
    case 0:
      paddingArray = [0, 0, 0, 0];
      break;
    case 1:
      paddingArray = new Array(4).fill(paddingArray[0]);
      break;
    case 2:
      paddingArray = __spreadArray(__spreadArray([], __read(paddingArray), false), __read(paddingArray), false);
      break;
    case 3:
      paddingArray = __spreadArray(__spreadArray([], __read(paddingArray), false), [paddingArray[1]], false);
      break;
    default:
      paddingArray = paddingArray.slice(0, 4);
      break;
  }
  return paddingArray;
}

// node_modules/@antv/g2/esm/chart/controller/index.js
var LOAD_COMPONENT_CONTROLLERS = {};
function registerComponentController(name, plugin) {
  LOAD_COMPONENT_CONTROLLERS[name] = plugin;
}
function getComponentControllerNames() {
  return Object.keys(LOAD_COMPONENT_CONTROLLERS);
}
function getComponentController(name) {
  return LOAD_COMPONENT_CONTROLLERS[name];
}

// node_modules/@antv/g2/esm/chart/controller/coordinate.js
var CoordinateController = function() {
  function CoordinateController2(option) {
    this.option = this.wrapperOption(option);
  }
  CoordinateController2.prototype.update = function(option) {
    this.option = this.wrapperOption(option);
    return this;
  };
  CoordinateController2.prototype.hasAction = function(actionName) {
    var actions = this.option.actions;
    return some_default(actions, function(action) {
      return action[0] === actionName;
    });
  };
  CoordinateController2.prototype.create = function(start, end) {
    var _a3 = this.option, type = _a3.type, cfg = _a3.cfg;
    var isTheta = type === "theta";
    var props = __assign({ start, end }, cfg);
    var C2 = getCoordinate(isTheta ? "polar" : type);
    this.coordinate = new C2(props);
    this.coordinate.type = type;
    if (isTheta) {
      if (!this.hasAction("transpose")) {
        this.transpose();
      }
    }
    this.execActions();
    return this.coordinate;
  };
  CoordinateController2.prototype.adjust = function(start, end) {
    this.coordinate.update({
      start,
      end
    });
    this.coordinate.resetMatrix();
    this.execActions(["scale", "rotate", "translate"]);
    return this.coordinate;
  };
  CoordinateController2.prototype.rotate = function(angle3) {
    this.option.actions.push(["rotate", angle3]);
    return this;
  };
  CoordinateController2.prototype.reflect = function(dim) {
    this.option.actions.push(["reflect", dim]);
    return this;
  };
  CoordinateController2.prototype.scale = function(sx, sy) {
    this.option.actions.push(["scale", sx, sy]);
    return this;
  };
  CoordinateController2.prototype.transpose = function() {
    this.option.actions.push(["transpose"]);
    return this;
  };
  CoordinateController2.prototype.getOption = function() {
    return this.option;
  };
  CoordinateController2.prototype.getCoordinate = function() {
    return this.coordinate;
  };
  CoordinateController2.prototype.wrapperOption = function(option) {
    return __assign({ type: "rect", actions: [], cfg: {} }, option);
  };
  CoordinateController2.prototype.execActions = function(includeActions) {
    var _this = this;
    var actions = this.option.actions;
    each_default(actions, function(action) {
      var _a3;
      var _b = __read(action), actionName = _b[0], args = _b.slice(1);
      var shouldExec = is_nil_default(includeActions) ? true : includeActions.includes(actionName);
      if (shouldExec) {
        (_a3 = _this.coordinate)[actionName].apply(_a3, __spreadArray([], __read(args), false));
      }
    });
  };
  return CoordinateController2;
}();
var coordinate_default = CoordinateController;

// node_modules/@antv/g2/esm/chart/event.js
var Event = function() {
  function Event2(view, gEvent, data) {
    this.view = view;
    this.gEvent = gEvent;
    this.data = data;
    this.type = gEvent.type;
  }
  Event2.fromData = function(view, type, data) {
    return new Event2(view, new graph_event_default(type, {}), data);
  };
  Object.defineProperty(Event2.prototype, "target", {
    get: function() {
      return this.gEvent.target;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Event2.prototype, "event", {
    get: function() {
      return this.gEvent.originalEvent;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Event2.prototype, "x", {
    get: function() {
      return this.gEvent.x;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Event2.prototype, "y", {
    get: function() {
      return this.gEvent.y;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Event2.prototype, "clientX", {
    get: function() {
      return this.gEvent.clientX;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Event2.prototype, "clientY", {
    get: function() {
      return this.gEvent.clientY;
    },
    enumerable: false,
    configurable: true
  });
  Event2.prototype.toString = function() {
    return "[Event (type=".concat(this.type, ")]");
  };
  Event2.prototype.clone = function() {
    return new Event2(this.view, this.gEvent, this.data);
  };
  return Event2;
}();
var event_default = Event;

// node_modules/@antv/g2/esm/chart/layout/index.js
function defaultLayout(view) {
  var axis = view.getController("axis");
  var legend = view.getController("legend");
  var annotation = view.getController("annotation");
  var slider = view.getController("slider");
  var scrollbar = view.getController("scrollbar");
  [axis, slider, scrollbar, legend, annotation].forEach(function(controller) {
    if (controller) {
      controller.layout();
    }
  });
}

// node_modules/@antv/g2/esm/chart/util/scale-pool.js
var ScalePool = function() {
  function ScalePool2() {
    this.scales = /* @__PURE__ */ new Map();
    this.syncScales = /* @__PURE__ */ new Map();
  }
  ScalePool2.prototype.createScale = function(field, data, scaleDef, key) {
    var finalScaleDef = scaleDef;
    var cacheScaleMeta = this.getScaleMeta(key);
    if (data.length === 0 && cacheScaleMeta) {
      var cacheScale = cacheScaleMeta.scale;
      var cacheScaleDef = {
        type: cacheScale.type
      };
      if (cacheScale.isCategory) {
        cacheScaleDef.values = cacheScale.values;
      }
      finalScaleDef = deep_mix_default(cacheScaleDef, cacheScaleMeta.scaleDef, scaleDef);
    }
    var scale5 = createScaleByField(field, data, finalScaleDef);
    this.cacheScale(scale5, scaleDef, key);
    return scale5;
  };
  ScalePool2.prototype.sync = function(coordinate, theme) {
    var _this = this;
    this.syncScales.forEach(function(scaleKeys, syncKey) {
      var min3 = Number.MAX_SAFE_INTEGER;
      var max3 = Number.MIN_SAFE_INTEGER;
      var values2 = [];
      each_default(scaleKeys, function(key) {
        var scale5 = _this.getScale(key);
        max3 = is_number_default(scale5.max) ? Math.max(max3, scale5.max) : max3;
        min3 = is_number_default(scale5.min) ? Math.min(min3, scale5.min) : min3;
        each_default(scale5.values, function(v) {
          if (!values2.includes(v)) {
            values2.push(v);
          }
        });
      });
      each_default(scaleKeys, function(key) {
        var scale5 = _this.getScale(key);
        if (scale5.isContinuous) {
          scale5.change({
            min: min3,
            max: max3,
            values: values2
          });
        } else if (scale5.isCategory) {
          var range = scale5.range;
          var cacheScaleMeta = _this.getScaleMeta(key);
          if (values2 && !get_default(cacheScaleMeta, ["scaleDef", "range"])) {
            range = getDefaultCategoryScaleRange(deep_mix_default({}, scale5, {
              values: values2
            }), coordinate, theme);
          }
          scale5.change({
            values: values2,
            range
          });
        }
      });
    });
  };
  ScalePool2.prototype.cacheScale = function(scale5, scaleDef, key) {
    var sm = this.getScaleMeta(key);
    if (sm && sm.scale.type === scale5.type) {
      syncScale(sm.scale, scale5);
      sm.scaleDef = scaleDef;
    } else {
      sm = {
        key,
        scale: scale5,
        scaleDef
      };
      this.scales.set(key, sm);
    }
    var syncKey = this.getSyncKey(sm);
    sm.syncKey = syncKey;
    this.removeFromSyncScales(key);
    if (syncKey) {
      var scaleKeys = this.syncScales.get(syncKey);
      if (!scaleKeys) {
        scaleKeys = [];
        this.syncScales.set(syncKey, scaleKeys);
      }
      scaleKeys.push(key);
    }
  };
  ScalePool2.prototype.getScale = function(key) {
    var scaleMeta = this.getScaleMeta(key);
    if (!scaleMeta) {
      var field = last(key.split("-"));
      var scaleKeys = this.syncScales.get(field);
      if (scaleKeys && scaleKeys.length) {
        scaleMeta = this.getScaleMeta(scaleKeys[0]);
      }
    }
    return scaleMeta && scaleMeta.scale;
  };
  ScalePool2.prototype.deleteScale = function(key) {
    var scaleMeta = this.getScaleMeta(key);
    if (scaleMeta) {
      var syncKey = scaleMeta.syncKey;
      var scaleKeys = this.syncScales.get(syncKey);
      if (scaleKeys && scaleKeys.length) {
        var idx = scaleKeys.indexOf(key);
        if (idx !== -1) {
          scaleKeys.splice(idx, 1);
        }
      }
    }
    this.scales.delete(key);
  };
  ScalePool2.prototype.clear = function() {
    this.scales.clear();
    this.syncScales.clear();
  };
  ScalePool2.prototype.removeFromSyncScales = function(key) {
    var _this = this;
    this.syncScales.forEach(function(scaleKeys, syncKey) {
      var idx = scaleKeys.indexOf(key);
      if (idx !== -1) {
        scaleKeys.splice(idx, 1);
        if (scaleKeys.length === 0) {
          _this.syncScales.delete(syncKey);
        }
        return false;
      }
    });
  };
  ScalePool2.prototype.getSyncKey = function(sm) {
    var scale5 = sm.scale, scaleDef = sm.scaleDef;
    var field = scale5.field;
    var sync = get_default(scaleDef, ["sync"]);
    return sync === true ? field : sync === false ? void 0 : sync;
  };
  ScalePool2.prototype.getScaleMeta = function(key) {
    return this.scales.get(key);
  };
  return ScalePool2;
}();

// node_modules/@antv/g2/esm/chart/layout/padding-cal.js
var PaddingCal = function() {
  function PaddingCal2(top, right, bottom, left) {
    if (top === void 0) {
      top = 0;
    }
    if (right === void 0) {
      right = 0;
    }
    if (bottom === void 0) {
      bottom = 0;
    }
    if (left === void 0) {
      left = 0;
    }
    this.top = top;
    this.right = right;
    this.bottom = bottom;
    this.left = left;
  }
  PaddingCal2.instance = function(top, right, bottom, left) {
    if (top === void 0) {
      top = 0;
    }
    if (right === void 0) {
      right = 0;
    }
    if (bottom === void 0) {
      bottom = 0;
    }
    if (left === void 0) {
      left = 0;
    }
    return new PaddingCal2(top, right, bottom, left);
  };
  PaddingCal2.prototype.max = function(padding) {
    var _a3 = __read(padding, 4), top = _a3[0], right = _a3[1], bottom = _a3[2], left = _a3[3];
    this.top = Math.max(this.top, top);
    this.right = Math.max(this.right, right);
    this.bottom = Math.max(this.bottom, bottom);
    this.left = Math.max(this.left, left);
    return this;
  };
  PaddingCal2.prototype.shrink = function(padding) {
    var _a3 = __read(padding, 4), top = _a3[0], right = _a3[1], bottom = _a3[2], left = _a3[3];
    this.top += top;
    this.right += right;
    this.bottom += bottom;
    this.left += left;
    return this;
  };
  PaddingCal2.prototype.inc = function(bbox, direction2) {
    var width = bbox.width, height = bbox.height;
    switch (direction2) {
      case DIRECTION.TOP:
      case DIRECTION.TOP_LEFT:
      case DIRECTION.TOP_RIGHT:
        this.top += height;
        break;
      case DIRECTION.RIGHT:
      case DIRECTION.RIGHT_TOP:
      case DIRECTION.RIGHT_BOTTOM:
        this.right += width;
        break;
      case DIRECTION.BOTTOM:
      case DIRECTION.BOTTOM_LEFT:
      case DIRECTION.BOTTOM_RIGHT:
        this.bottom += height;
        break;
      case DIRECTION.LEFT:
      case DIRECTION.LEFT_TOP:
      case DIRECTION.LEFT_BOTTOM:
        this.left += width;
        break;
      default:
        break;
    }
    return this;
  };
  PaddingCal2.prototype.getPadding = function() {
    return [this.top, this.right, this.bottom, this.left];
  };
  PaddingCal2.prototype.clone = function() {
    return new (PaddingCal2.bind.apply(PaddingCal2, __spreadArray([void 0], __read(this.getPadding()), false)))();
  };
  return PaddingCal2;
}();

// node_modules/@antv/g2/esm/chart/layout/auto.js
function calculatePadding(view) {
  var padding = view.padding;
  if (!isAutoPadding(padding)) {
    return new (PaddingCal.bind.apply(PaddingCal, __spreadArray([void 0], __read(parsePadding(padding)), false)))();
  }
  var viewBBox = view.viewBBox;
  var paddingCal = new PaddingCal();
  var axisComponents = [];
  var paddingComponents = [];
  var otherComponents = [];
  each_default(view.getComponents(), function(co) {
    var type = co.type;
    if (type === COMPONENT_TYPE.AXIS) {
      axisComponents.push(co);
    } else if ([COMPONENT_TYPE.LEGEND, COMPONENT_TYPE.SLIDER, COMPONENT_TYPE.SCROLLBAR].includes(type)) {
      paddingComponents.push(co);
    } else if (type !== COMPONENT_TYPE.GRID && type !== COMPONENT_TYPE.TOOLTIP) {
      otherComponents.push(co);
    }
  });
  each_default(axisComponents, function(co) {
    var component = co.component;
    var bboxObject = component.getLayoutBBox();
    var componentBBox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height);
    var exceed = componentBBox.exceed(viewBBox);
    paddingCal.max(exceed);
  });
  each_default(paddingComponents, function(co) {
    var component = co.component, direction2 = co.direction;
    var bboxObject = component.getLayoutBBox();
    var componentPadding = component.get("padding");
    var componentBBox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height).expand(componentPadding);
    paddingCal.inc(componentBBox, direction2);
  });
  each_default(otherComponents, function(co) {
    var component = co.component, direction2 = co.direction;
    var bboxObject = component.getLayoutBBox();
    var componentBBox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height);
    paddingCal.inc(componentBBox, direction2);
  });
  return paddingCal;
}

// node_modules/@antv/g2/esm/chart/util/sync-view-padding.js
function defaultSyncViewPadding(chart, views, PC) {
  var syncPadding = PC.instance();
  views.forEach(function(v) {
    v.autoPadding = syncPadding.max(v.autoPadding.getPadding());
  });
}

// node_modules/@antv/g2/esm/chart/view.js
var View = function(_super) {
  __extends(View2, _super);
  function View2(props) {
    var _this = _super.call(this, { visible: props.visible }) || this;
    _this.views = [];
    _this.geometries = [];
    _this.controllers = [];
    _this.interactions = {};
    _this.limitInPlot = false;
    _this.options = {
      data: [],
      animate: true
    };
    _this.usedControllers = getComponentControllerNames();
    _this.scalePool = new ScalePool();
    _this.layoutFunc = defaultLayout;
    _this.isPreMouseInPlot = false;
    _this.isDataChanged = false;
    _this.isCoordinateChanged = false;
    _this.createdScaleKeys = /* @__PURE__ */ new Map();
    _this.onCanvasEvent = function(evt) {
      var name = evt.name;
      if (!name.includes(":")) {
        var e = _this.createViewEvent(evt);
        _this.doPlotEvent(e);
        _this.emit(name, e);
      }
    };
    _this.onDelegateEvents = function(evt) {
      var name = evt.name;
      if (!name.includes(":")) {
        return;
      }
      var e = _this.createViewEvent(evt);
      _this.emit(name, e);
    };
    var _a3 = props.id, id = _a3 === void 0 ? unique_id_default("view") : _a3, parent = props.parent, canvas = props.canvas, backgroundGroup = props.backgroundGroup, middleGroup = props.middleGroup, foregroundGroup = props.foregroundGroup, _b = props.region, region = _b === void 0 ? { start: { x: 0, y: 0 }, end: { x: 1, y: 1 } } : _b, padding = props.padding, appendPadding = props.appendPadding, theme = props.theme, options = props.options, limitInPlot2 = props.limitInPlot, syncViewPadding = props.syncViewPadding;
    _this.parent = parent;
    _this.canvas = canvas;
    _this.backgroundGroup = backgroundGroup;
    _this.middleGroup = middleGroup;
    _this.foregroundGroup = foregroundGroup;
    _this.region = region;
    _this.padding = padding;
    _this.appendPadding = appendPadding;
    _this.options = __assign(__assign({}, _this.options), options);
    _this.limitInPlot = limitInPlot2;
    _this.id = id;
    _this.syncViewPadding = syncViewPadding;
    _this.themeObject = is_object_default(theme) ? deep_mix_default({}, getTheme("default"), createTheme(theme)) : getTheme(theme);
    _this.init();
    return _this;
  }
  View2.prototype.setLayout = function(layout2) {
    this.layoutFunc = layout2;
  };
  View2.prototype.init = function() {
    this.calculateViewBBox();
    this.initEvents();
    this.initComponentController();
    this.initOptions();
  };
  View2.prototype.render = function(isUpdate, payload) {
    if (isUpdate === void 0) {
      isUpdate = false;
    }
    this.emit(VIEW_LIFE_CIRCLE.BEFORE_RENDER, event_default.fromData(this, VIEW_LIFE_CIRCLE.BEFORE_RENDER, payload));
    this.paint(isUpdate);
    this.emit(VIEW_LIFE_CIRCLE.AFTER_RENDER, event_default.fromData(this, VIEW_LIFE_CIRCLE.AFTER_RENDER, payload));
    if (this.visible === false) {
      this.changeVisible(false);
    }
  };
  View2.prototype.clear = function() {
    var _this = this;
    this.emit(VIEW_LIFE_CIRCLE.BEFORE_CLEAR);
    this.filteredData = [];
    this.coordinateInstance = void 0;
    this.isDataChanged = false;
    this.isCoordinateChanged = false;
    var geometries = this.geometries;
    for (var i = 0; i < geometries.length; i++) {
      geometries[i].clear();
      geometries[i].container.remove(true);
      geometries[i].labelsContainer.remove(true);
    }
    this.geometries = [];
    var controllers = this.controllers;
    for (var i = 0; i < controllers.length; i++) {
      if (controllers[i].name === "annotation") {
        controllers[i].clear(true);
      } else {
        controllers[i].clear();
      }
    }
    this.createdScaleKeys.forEach(function(v, k) {
      _this.getRootView().scalePool.deleteScale(k);
    });
    this.createdScaleKeys.clear();
    var views = this.views;
    for (var i = 0; i < views.length; i++) {
      views[i].clear();
    }
    this.emit(VIEW_LIFE_CIRCLE.AFTER_CLEAR);
  };
  View2.prototype.destroy = function() {
    this.emit(VIEW_LIFE_CIRCLE.BEFORE_DESTROY);
    var interactions = this.interactions;
    each_default(interactions, function(interaction) {
      if (interaction) {
        interaction.destroy();
      }
    });
    this.clear();
    var controllers = this.controllers;
    for (var i = 0, len3 = controllers.length; i < len3; i++) {
      var controller = controllers[i];
      controller.destroy();
    }
    this.backgroundGroup.remove(true);
    this.middleGroup.remove(true);
    this.foregroundGroup.remove(true);
    _super.prototype.destroy.call(this);
  };
  View2.prototype.changeVisible = function(visible) {
    _super.prototype.changeVisible.call(this, visible);
    var geometries = this.geometries;
    for (var i = 0, len3 = geometries.length; i < len3; i++) {
      var geometry = geometries[i];
      geometry.changeVisible(visible);
    }
    var controllers = this.controllers;
    for (var i = 0, len3 = controllers.length; i < len3; i++) {
      var controller = controllers[i];
      controller.changeVisible(visible);
    }
    this.foregroundGroup.set("visible", visible);
    this.middleGroup.set("visible", visible);
    this.backgroundGroup.set("visible", visible);
    this.getCanvas().draw();
    return this;
  };
  View2.prototype.data = function(data) {
    set_default(this.options, "data", data);
    this.isDataChanged = true;
    return this;
  };
  View2.prototype.source = function(data) {
    console.warn("This method will be removed at G2 V4.1. Please use chart.data() instead.");
    return this.data(data);
  };
  View2.prototype.filter = function(field, condition) {
    if (is_function_default(condition)) {
      set_default(this.options, ["filters", field], condition);
      return this;
    }
    if (!condition && get_default(this.options, ["filters", field])) {
      delete this.options.filters[field];
    }
    return this;
  };
  View2.prototype.axis = function(field, axisOption) {
    if (is_boolean_default(field)) {
      set_default(this.options, ["axes"], field);
    } else {
      set_default(this.options, ["axes", field], axisOption);
    }
    return this;
  };
  View2.prototype.legend = function(field, legendOption) {
    if (is_boolean_default(field)) {
      set_default(this.options, ["legends"], field);
    } else if (is_string_default(field)) {
      set_default(this.options, ["legends", field], legendOption);
      if (is_plain_object_default(legendOption) && (legendOption === null || legendOption === void 0 ? void 0 : legendOption.selected)) {
        set_default(this.options, ["filters", field], function(name) {
          var _a3;
          return (_a3 = legendOption === null || legendOption === void 0 ? void 0 : legendOption.selected[name]) !== null && _a3 !== void 0 ? _a3 : true;
        });
      }
    } else {
      set_default(this.options, ["legends"], field);
    }
    return this;
  };
  View2.prototype.scale = function(field, scaleOption) {
    var _this = this;
    if (is_string_default(field)) {
      set_default(this.options, ["scales", field], scaleOption);
    } else if (is_object_default(field)) {
      each_default(field, function(v, k) {
        set_default(_this.options, ["scales", k], v);
      });
    }
    return this;
  };
  View2.prototype.tooltip = function(cfg) {
    set_default(this.options, "tooltip", cfg);
    return this;
  };
  View2.prototype.annotation = function() {
    return this.getController("annotation");
  };
  View2.prototype.guide = function() {
    console.warn("This method will be removed at G2 V4.1. Please use chart.annotation() instead.");
    return this.annotation();
  };
  View2.prototype.coordinate = function(type, coordinateCfg) {
    if (is_string_default(type)) {
      set_default(this.options, "coordinate", { type, cfg: coordinateCfg });
    } else {
      set_default(this.options, "coordinate", type);
    }
    this.coordinateController.update(this.options.coordinate);
    return this.coordinateController;
  };
  View2.prototype.coord = function(type, coordinateCfg) {
    console.warn("This method will be removed at G2 V4.1. Please use chart.coordinate() instead.");
    return this.coordinate(type, coordinateCfg);
  };
  View2.prototype.facet = function(type, cfg) {
    if (this.facetInstance) {
      this.facetInstance.destroy();
    }
    var Ctor = getFacet(type);
    if (!Ctor) {
      throw new Error("facet '".concat(type, "' is not exist!"));
    }
    this.facetInstance = new Ctor(this, __assign(__assign({}, cfg), { type }));
    return this;
  };
  View2.prototype.animate = function(status) {
    set_default(this.options, "animate", status);
    return this;
  };
  View2.prototype.updateOptions = function(options) {
    this.clear();
    mix(this.options, options);
    this.views.forEach(function(view) {
      return view.destroy();
    });
    this.views = [];
    this.initOptions();
    this.coordinateBBox = this.viewBBox;
    return this;
  };
  View2.prototype.option = function(name, opt) {
    if (View2.prototype[name]) {
      throw new Error(`Can't use built in variable name "`.concat(name, '", please change another one.'));
    }
    set_default(this.options, name, opt);
    return this;
  };
  View2.prototype.theme = function(theme) {
    this.themeObject = is_object_default(theme) ? deep_mix_default({}, this.themeObject, createTheme(theme)) : getTheme(theme);
    return this;
  };
  View2.prototype.interaction = function(name, cfg) {
    var existInteraction = this.interactions[name];
    if (existInteraction) {
      existInteraction.destroy();
    }
    var interaction = createInteraction(name, this, cfg);
    if (interaction) {
      interaction.init();
      this.interactions[name] = interaction;
    }
    return this;
  };
  View2.prototype.removeInteraction = function(name) {
    var existInteraction = this.interactions[name];
    if (existInteraction) {
      existInteraction.destroy();
      this.interactions[name] = void 0;
    }
  };
  View2.prototype.changeData = function(data) {
    this.isDataChanged = true;
    this.emit(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, event_default.fromData(this, VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, null));
    this.data(data);
    this.paint(true);
    var views = this.views;
    for (var i = 0, len3 = views.length; i < len3; i++) {
      var view = views[i];
      view.changeData(data);
    }
    this.emit(VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, event_default.fromData(this, VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, null));
  };
  View2.prototype.createView = function(cfg) {
    if (this.parent && this.parent.parent) {
      console.warn("The view nesting recursive feature will be removed at G2 V4.1. Please avoid to use it.");
    }
    var sharedOptions = {
      data: this.options.data,
      scales: clone_default(this.options.scales),
      axes: clone_default(this.options.axes),
      coordinate: clone_default(this.coordinateController.getOption()),
      tooltip: clone_default(this.options.tooltip),
      legends: clone_default(this.options.legends),
      animate: this.options.animate,
      visible: this.visible
    };
    var v = new View2(__assign(__assign({
      parent: this,
      canvas: this.canvas,
      backgroundGroup: this.backgroundGroup.addGroup({ zIndex: GROUP_Z_INDEX.BG }),
      middleGroup: this.middleGroup.addGroup({ zIndex: GROUP_Z_INDEX.MID }),
      foregroundGroup: this.foregroundGroup.addGroup({ zIndex: GROUP_Z_INDEX.FORE }),
      theme: this.themeObject,
      padding: this.padding
    }, cfg), { options: __assign(__assign({}, sharedOptions), get_default(cfg, "options", {})) }));
    this.views.push(v);
    return v;
  };
  View2.prototype.view = function(cfg) {
    console.warn("This method will be removed at G2 V4.1. Please use chart.createView() instead.");
    return this.createView(cfg);
  };
  View2.prototype.removeView = function(view) {
    var removedView = remove_default(this.views, function(v) {
      return v === view;
    })[0];
    if (removedView) {
      removedView.destroy();
    }
    return removedView;
  };
  View2.prototype.getCoordinate = function() {
    return this.coordinateInstance;
  };
  View2.prototype.getTheme = function() {
    return this.themeObject;
  };
  View2.prototype.getXScale = function() {
    var g = this.geometries[0];
    return g ? g.getXScale() : null;
  };
  View2.prototype.getYScales = function() {
    var tmpMap = {};
    var yScales = [];
    this.geometries.forEach(function(g) {
      var yScale = g.getYScale();
      var field = yScale.field;
      if (!tmpMap[field]) {
        tmpMap[field] = true;
        yScales.push(yScale);
      }
    });
    return yScales;
  };
  View2.prototype.getScalesByDim = function(dimType) {
    var geometries = this.geometries;
    var scales = {};
    for (var i = 0, len3 = geometries.length; i < len3; i++) {
      var geometry = geometries[i];
      var scale5 = dimType === "x" ? geometry.getXScale() : geometry.getYScale();
      if (scale5 && !scales[scale5.field]) {
        scales[scale5.field] = scale5;
      }
    }
    return scales;
  };
  View2.prototype.getScale = function(field, key) {
    var defaultKey = key ? key : this.getScaleKey(field);
    return this.getRootView().scalePool.getScale(defaultKey);
  };
  View2.prototype.getScaleByField = function(field, key) {
    return this.getScale(field, key);
  };
  View2.prototype.getOptions = function() {
    return this.options;
  };
  View2.prototype.getData = function() {
    return this.filteredData;
  };
  View2.prototype.getOriginalData = function() {
    return this.options.data;
  };
  View2.prototype.getPadding = function() {
    return this.autoPadding.getPadding();
  };
  View2.prototype.getGeometries = function() {
    return this.geometries;
  };
  View2.prototype.getElements = function() {
    return reduce_default(this.geometries, function(elements, geometry) {
      return elements.concat(geometry.getElements());
    }, []);
  };
  View2.prototype.getElementsBy = function(condition) {
    return this.getElements().filter(function(el) {
      return condition(el);
    });
  };
  View2.prototype.getLayer = function(layer) {
    return layer === LAYER.BG ? this.backgroundGroup : layer === LAYER.MID ? this.middleGroup : layer === LAYER.FORE ? this.foregroundGroup : this.foregroundGroup;
  };
  View2.prototype.isPointInPlot = function(point) {
    return isPointInCoordinate(this.getCoordinate(), point);
  };
  View2.prototype.getLegendAttributes = function() {
    return flatten_default(this.geometries.map(function(g) {
      return g.getGroupAttributes();
    }));
  };
  View2.prototype.getGroupScales = function() {
    var scales = this.geometries.map(function(g) {
      return g.getGroupScales();
    });
    return uniq2(flatten_default(scales));
  };
  View2.prototype.getCanvas = function() {
    return this.getRootView().canvas;
  };
  View2.prototype.getRootView = function() {
    var v = this;
    while (true) {
      if (v.parent) {
        v = v.parent;
        continue;
      }
      break;
    }
    return v;
  };
  View2.prototype.getXY = function(data) {
    var coordinate = this.getCoordinate();
    var xScales = this.getScalesByDim("x");
    var yScales = this.getScalesByDim("y");
    var x;
    var y;
    each_default(data, function(value, key) {
      if (xScales[key]) {
        x = xScales[key].scale(value);
      }
      if (yScales[key]) {
        y = yScales[key].scale(value);
      }
    });
    if (!is_nil_default(x) && !is_nil_default(y)) {
      return coordinate.convert({ x, y });
    }
  };
  View2.prototype.getController = function(name) {
    return find_default(this.controllers, function(c) {
      return c.name === name;
    });
  };
  View2.prototype.showTooltip = function(point) {
    var tooltip = this.getController("tooltip");
    if (tooltip) {
      tooltip.showTooltip(point);
    }
    return this;
  };
  View2.prototype.hideTooltip = function() {
    var tooltip = this.getController("tooltip");
    if (tooltip) {
      tooltip.hideTooltip();
    }
    return this;
  };
  View2.prototype.lockTooltip = function() {
    var tooltip = this.getController("tooltip");
    if (tooltip) {
      tooltip.lockTooltip();
    }
    return this;
  };
  View2.prototype.unlockTooltip = function() {
    var tooltip = this.getController("tooltip");
    if (tooltip) {
      tooltip.unlockTooltip();
    }
    return this;
  };
  View2.prototype.isTooltipLocked = function() {
    var tooltip = this.getController("tooltip");
    return tooltip && tooltip.isTooltipLocked();
  };
  View2.prototype.getTooltipItems = function(point) {
    var tooltip = this.getController("tooltip");
    return tooltip ? tooltip.getTooltipItems(point) : [];
  };
  View2.prototype.getSnapRecords = function(point) {
    var geometries = this.geometries;
    var rst = [];
    for (var i = 0, len3 = geometries.length; i < len3; i++) {
      var geom = geometries[i];
      var dataArray = geom.dataArray;
      geom.sort(dataArray);
      var record = void 0;
      for (var j = 0, dataLen = dataArray.length; j < dataLen; j++) {
        var data = dataArray[j];
        record = findDataByPoint(point, data, geom);
        if (record) {
          rst.push(record);
        }
      }
    }
    var views = this.views;
    for (var i = 0, len3 = views.length; i < len3; i++) {
      var view = views[i];
      var snapRecords = view.getSnapRecords(point);
      rst = rst.concat(snapRecords);
    }
    return rst;
  };
  View2.prototype.getComponents = function() {
    var components = [];
    var controllers = this.controllers;
    for (var i = 0, len3 = controllers.length; i < len3; i++) {
      var controller = controllers[i];
      components = components.concat(controller.getComponents());
    }
    return components;
  };
  View2.prototype.filterData = function(data) {
    var filters = this.options.filters;
    if (size(filters) === 0) {
      return data;
    }
    return filter_default(data, function(datum, idx) {
      var fields = Object.keys(filters);
      return fields.every(function(field) {
        var condition = filters[field];
        return condition(datum[field], datum, idx);
      });
    });
  };
  View2.prototype.filterFieldData = function(field, data) {
    var filters = this.options.filters;
    var condition = get_default(filters, field);
    if (is_undefined_default(condition)) {
      return data;
    }
    return data.filter(function(datum, idx) {
      return condition(datum[field], datum, idx);
    });
  };
  View2.prototype.adjustCoordinate = function() {
    var _a3 = this.getCoordinate(), curStart = _a3.start, curEnd = _a3.end;
    var start = this.coordinateBBox.bl;
    var end = this.coordinateBBox.tr;
    if (is_equal_default(curStart, start) && is_equal_default(curEnd, end)) {
      this.isCoordinateChanged = false;
      return;
    }
    this.isCoordinateChanged = true;
    this.coordinateInstance = this.coordinateController.adjust(start, end);
  };
  View2.prototype.paint = function(isUpdate) {
    this.renderDataRecursive(isUpdate);
    this.syncScale();
    this.emit(VIEW_LIFE_CIRCLE.BEFORE_PAINT);
    this.renderPaddingRecursive(isUpdate);
    this.renderLayoutRecursive(isUpdate);
    this.renderBackgroundStyleShape();
    this.renderPaintRecursive(isUpdate);
    this.emit(VIEW_LIFE_CIRCLE.AFTER_PAINT);
    this.isDataChanged = false;
  };
  View2.prototype.renderBackgroundStyleShape = function() {
    if (this.parent) {
      return;
    }
    var background = get_default(this.themeObject, "background");
    if (background) {
      if (!this.backgroundStyleRectShape) {
        this.backgroundStyleRectShape = this.backgroundGroup.addShape("rect", {
          attrs: {},
          zIndex: -1,
          capture: false
        });
        this.backgroundStyleRectShape.toBack();
      }
      var _a3 = this.viewBBox, x = _a3.x, y = _a3.y, width = _a3.width, height = _a3.height;
      this.backgroundStyleRectShape.attr({
        fill: background,
        x,
        y,
        width,
        height
      });
    } else {
      if (this.backgroundStyleRectShape) {
        this.backgroundStyleRectShape.remove(true);
        this.backgroundStyleRectShape = void 0;
      }
    }
  };
  View2.prototype.renderPaddingRecursive = function(isUpdate) {
    this.calculateViewBBox();
    this.adjustCoordinate();
    this.initComponents(isUpdate);
    this.autoPadding = calculatePadding(this).shrink(parsePadding(this.appendPadding));
    this.coordinateBBox = this.viewBBox.shrink(this.autoPadding.getPadding());
    this.adjustCoordinate();
    var tooltipController = this.controllers.find(function(c) {
      return c.name === "tooltip";
    });
    tooltipController.update();
    var views = this.views;
    for (var i = 0, len3 = views.length; i < len3; i++) {
      var view = views[i];
      view.renderPaddingRecursive(isUpdate);
    }
  };
  View2.prototype.renderLayoutRecursive = function(isUpdate) {
    var syncViewPaddingFn = this.syncViewPadding === true ? defaultSyncViewPadding : is_function_default(this.syncViewPadding) ? this.syncViewPadding : void 0;
    if (syncViewPaddingFn) {
      syncViewPaddingFn(this, this.views, PaddingCal);
      this.views.forEach(function(v) {
        v.coordinateBBox = v.viewBBox.shrink(v.autoPadding.getPadding());
        v.adjustCoordinate();
      });
    }
    this.doLayout();
    var views = this.views;
    for (var i = 0, len3 = views.length; i < len3; i++) {
      var view = views[i];
      view.renderLayoutRecursive(isUpdate);
    }
  };
  View2.prototype.renderPaintRecursive = function(isUpdate) {
    var middleGroup = this.middleGroup;
    if (this.limitInPlot) {
      var _a3 = getCoordinateClipCfg(this.coordinateInstance), type = _a3.type, attrs = _a3.attrs;
      middleGroup.setClip({
        type,
        attrs
      });
    } else {
      middleGroup.setClip(void 0);
    }
    this.paintGeometries(isUpdate);
    this.renderComponents(isUpdate);
    var views = this.views;
    for (var i = 0, len3 = views.length; i < len3; i++) {
      var view = views[i];
      view.renderPaintRecursive(isUpdate);
    }
  };
  View2.prototype.createScale = function(field, data, scaleDef, key) {
    var currentScaleDef = get_default(this.options.scales, [field]);
    var mergedScaleDef = __assign(__assign({}, currentScaleDef), scaleDef);
    if (this.parent) {
      return this.parent.createScale(field, data, mergedScaleDef, key);
    }
    return this.scalePool.createScale(field, data, mergedScaleDef, key);
  };
  View2.prototype.renderDataRecursive = function(isUpdate) {
    this.doFilterData();
    this.createCoordinate();
    this.initGeometries(isUpdate);
    this.renderFacet(isUpdate);
    var views = this.views;
    for (var i = 0, len3 = views.length; i < len3; i++) {
      var view = views[i];
      view.renderDataRecursive(isUpdate);
    }
  };
  View2.prototype.calculateViewBBox = function() {
    var x;
    var y;
    var width;
    var height;
    if (this.parent) {
      var bbox = this.parent.coordinateBBox;
      x = bbox.x;
      y = bbox.y;
      width = bbox.width;
      height = bbox.height;
    } else {
      x = 0;
      y = 0;
      width = this.canvas.get("width");
      height = this.canvas.get("height");
    }
    var _a3 = this.region, start = _a3.start, end = _a3.end;
    var viewBBox = new BBox(x + width * start.x, y + height * start.y, width * (end.x - start.x), height * (end.y - start.y));
    if (!this.viewBBox || !this.viewBBox.isEqual(viewBBox)) {
      this.viewBBox = new BBox(x + width * start.x, y + height * start.y, width * (end.x - start.x), height * (end.y - start.y));
    }
    this.coordinateBBox = this.viewBBox;
  };
  View2.prototype.initEvents = function() {
    this.foregroundGroup.on("*", this.onDelegateEvents);
    this.middleGroup.on("*", this.onDelegateEvents);
    this.backgroundGroup.on("*", this.onDelegateEvents);
    this.canvas.on("*", this.onCanvasEvent);
  };
  View2.prototype.initComponentController = function() {
    var usedControllers = this.usedControllers;
    for (var i = 0, len3 = usedControllers.length; i < len3; i++) {
      var controllerName = usedControllers[i];
      var Ctor = getComponentController(controllerName);
      if (Ctor) {
        this.controllers.push(new Ctor(this));
      }
    }
  };
  View2.prototype.createViewEvent = function(evt) {
    var shape = evt.shape, name = evt.name;
    var data = shape ? shape.get("origin") : null;
    var e = new event_default(this, evt, data);
    e.type = name;
    return e;
  };
  View2.prototype.doPlotEvent = function(e) {
    var type = e.type, x = e.x, y = e.y;
    var point = { x, y };
    var ALL_EVENTS = [
      "mousedown",
      "mouseup",
      "mousemove",
      "mouseleave",
      "mousewheel",
      "touchstart",
      "touchmove",
      "touchend",
      "touchcancel",
      "click",
      "dblclick",
      "contextmenu"
    ];
    if (ALL_EVENTS.includes(type)) {
      var currentInPlot = this.isPointInPlot(point);
      var newEvent = e.clone();
      if (currentInPlot) {
        var TYPE = "plot:".concat(type);
        newEvent.type = TYPE;
        this.emit(TYPE, newEvent);
        if (type === "mouseleave" || type === "touchend") {
          this.isPreMouseInPlot = false;
        }
      }
      if (type === "mousemove" || type === "touchmove") {
        if (this.isPreMouseInPlot && !currentInPlot) {
          if (type === "mousemove") {
            newEvent.type = PLOT_EVENTS.MOUSE_LEAVE;
            this.emit(PLOT_EVENTS.MOUSE_LEAVE, newEvent);
          }
          newEvent.type = PLOT_EVENTS.LEAVE;
          this.emit(PLOT_EVENTS.LEAVE, newEvent);
        } else if (!this.isPreMouseInPlot && currentInPlot) {
          if (type === "mousemove") {
            newEvent.type = PLOT_EVENTS.MOUSE_ENTER;
            this.emit(PLOT_EVENTS.MOUSE_ENTER, newEvent);
          }
          newEvent.type = PLOT_EVENTS.ENTER;
          this.emit(PLOT_EVENTS.ENTER, newEvent);
        }
        this.isPreMouseInPlot = currentInPlot;
      } else if (type === "mouseleave" || type === "touchend") {
        if (this.isPreMouseInPlot) {
          if (type === "mouseleave") {
            newEvent.type = PLOT_EVENTS.MOUSE_LEAVE;
            this.emit(PLOT_EVENTS.MOUSE_LEAVE, newEvent);
          }
          newEvent.type = PLOT_EVENTS.LEAVE;
          this.emit(PLOT_EVENTS.LEAVE, newEvent);
          this.isPreMouseInPlot = false;
        }
      }
    }
  };
  View2.prototype.doFilterData = function() {
    var data = this.options.data;
    this.filteredData = this.filterData(data);
  };
  View2.prototype.initGeometries = function(isUpdate) {
    this.createOrUpdateScales();
    var coordinate = this.getCoordinate();
    var scaleDefs = get_default(this.options, "scales", {});
    var geometries = this.geometries;
    for (var i = 0, len3 = geometries.length; i < len3; i++) {
      var geometry = geometries[i];
      geometry.scales = this.getGeometryScales();
      var cfg = {
        coordinate,
        scaleDefs,
        data: this.filteredData,
        theme: this.themeObject,
        isDataChanged: this.isDataChanged,
        isCoordinateChanged: this.isCoordinateChanged
      };
      if (isUpdate) {
        geometry.update(cfg);
      } else {
        geometry.init(cfg);
      }
    }
    this.adjustScales();
  };
  View2.prototype.createOrUpdateScales = function() {
    var fields = this.getScaleFields();
    var groupedFields = this.getGroupedFields();
    var _a3 = this.getOptions(), data = _a3.data, _b = _a3.scales, scales = _b === void 0 ? {} : _b;
    var filteredData = this.filteredData;
    for (var i = 0, len3 = fields.length; i < len3; i++) {
      var field = fields[i];
      var scaleDef = scales[field];
      var key = this.getScaleKey(field);
      this.createScale(
        field,
        groupedFields.includes(field) ? data : filteredData,
        scaleDef,
        key
      );
      this.createdScaleKeys.set(key, true);
    }
  };
  View2.prototype.syncScale = function() {
    this.getRootView().scalePool.sync(this.getCoordinate(), this.theme);
  };
  View2.prototype.getGeometryScales = function() {
    var fields = this.getScaleFields();
    var scales = {};
    for (var i = 0; i < fields.length; i++) {
      var field = fields[i];
      scales[field] = this.getScaleByField(field);
    }
    return scales;
  };
  View2.prototype.getScaleFields = function() {
    var fields = [];
    var tmpMap = /* @__PURE__ */ new Map();
    var geometries = this.geometries;
    for (var i = 0; i < geometries.length; i++) {
      var geometry = geometries[i];
      var geometryScales = geometry.getScaleFields();
      uniq2(geometryScales, fields, tmpMap);
    }
    return fields;
  };
  View2.prototype.getGroupedFields = function() {
    var fields = [];
    var tmpMap = /* @__PURE__ */ new Map();
    var geometries = this.geometries;
    for (var i = 0; i < geometries.length; i++) {
      var geometry = geometries[i];
      var groupFields = geometry.getGroupFields();
      uniq2(groupFields, fields, tmpMap);
    }
    return fields;
  };
  View2.prototype.adjustScales = function() {
    this.adjustCategoryScaleRange();
  };
  View2.prototype.adjustCategoryScaleRange = function() {
    var _this = this;
    var xyScales = __spreadArray([this.getXScale()], __read(this.getYScales()), false).filter(function(e) {
      return !!e;
    });
    var coordinate = this.getCoordinate();
    var scaleOptions = this.options.scales;
    each_default(xyScales, function(scale5) {
      var field = scale5.field, values2 = scale5.values, isCategory = scale5.isCategory, isIdentity = scale5.isIdentity;
      if (isCategory || isIdentity) {
        if (values2 && !get_default(scaleOptions, [field, "range"])) {
          scale5.range = getDefaultCategoryScaleRange(scale5, coordinate, _this.theme);
        }
      }
    });
  };
  View2.prototype.initComponents = function(isUpdate) {
    var controllers = this.controllers;
    for (var i = 0; i < controllers.length; i++) {
      var controller = controllers[i];
      if (isUpdate) {
        controller.update();
      } else {
        controller.clear();
        controller.render();
      }
    }
  };
  View2.prototype.doLayout = function() {
    this.layoutFunc(this);
  };
  View2.prototype.createCoordinate = function() {
    var start = this.coordinateBBox.bl;
    var end = this.coordinateBBox.tr;
    this.coordinateInstance = this.coordinateController.create(start, end);
  };
  View2.prototype.paintGeometries = function(isUpdate) {
    var doAnimation = this.options.animate;
    var coordinate = this.getCoordinate();
    var canvasRegion = {
      x: this.viewBBox.x,
      y: this.viewBBox.y,
      minX: this.viewBBox.minX,
      minY: this.viewBBox.minY,
      maxX: this.viewBBox.maxX,
      maxY: this.viewBBox.maxY,
      width: this.viewBBox.width,
      height: this.viewBBox.height
    };
    var geometries = this.geometries;
    for (var i = 0; i < geometries.length; i++) {
      var geometry = geometries[i];
      geometry.coordinate = coordinate;
      geometry.canvasRegion = canvasRegion;
      if (!doAnimation) {
        geometry.animate(false);
      }
      geometry.paint(isUpdate);
    }
  };
  View2.prototype.renderComponents = function(isUpdate) {
    for (var i = 0; i < this.getComponents().length; i++) {
      var co = this.getComponents()[i];
      co.component.render();
    }
  };
  View2.prototype.renderFacet = function(isUpdate) {
    if (this.facetInstance) {
      if (isUpdate) {
        this.facetInstance.update();
      } else {
        this.facetInstance.clear();
        this.facetInstance.init();
        this.facetInstance.render();
      }
    }
  };
  View2.prototype.initOptions = function() {
    var _this = this;
    var _a3 = this.options, _b = _a3.geometries, geometries = _b === void 0 ? [] : _b, _c = _a3.interactions, interactions = _c === void 0 ? [] : _c, _d = _a3.views, views = _d === void 0 ? [] : _d, _e = _a3.annotations, annotations = _e === void 0 ? [] : _e, coordinate = _a3.coordinate, events = _a3.events, facets = _a3.facets;
    if (this.coordinateController) {
      coordinate && this.coordinateController.update(coordinate);
    } else {
      this.coordinateController = new coordinate_default(coordinate);
    }
    for (var i = 0; i < geometries.length; i++) {
      var geometryOption = geometries[i];
      this.createGeometry(geometryOption);
    }
    for (var j = 0; j < interactions.length; j++) {
      var interactionOption = interactions[j];
      var type = interactionOption.type, cfg = interactionOption.cfg;
      this.interaction(type, cfg);
    }
    for (var k = 0; k < views.length; k++) {
      var viewOption = views[k];
      this.createView(viewOption);
    }
    var annotationComponent = this.getController("annotation");
    for (var l = 0; l < annotations.length; l++) {
      var annotationOption = annotations[l];
      annotationComponent.annotation(annotationOption);
    }
    if (events) {
      each_default(events, function(eventCallback, eventName) {
        _this.on(eventName, eventCallback);
      });
    }
    if (facets) {
      each_default(facets, function(facet) {
        var type2 = facet.type, rest = __rest(facet, ["type"]);
        _this.facet(type2, rest);
      });
    }
  };
  View2.prototype.createGeometry = function(geometryOption) {
    var type = geometryOption.type, _a3 = geometryOption.cfg, cfg = _a3 === void 0 ? {} : _a3;
    if (this[type]) {
      var geometry_1 = this[type](cfg);
      each_default(geometryOption, function(v, k) {
        if (is_function_default(geometry_1[k])) {
          geometry_1[k](v);
        }
      });
    }
  };
  View2.prototype.getScaleKey = function(field) {
    return "".concat(this.id, "-").concat(field);
  };
  return View2;
}(base_default);
function registerGeometry(name, Ctor) {
  View.prototype[name.toLowerCase()] = function(cfg) {
    if (cfg === void 0) {
      cfg = {};
    }
    var props = __assign({
      container: this.middleGroup.addGroup(),
      labelsContainer: this.foregroundGroup.addGroup()
    }, cfg);
    var geometry = new Ctor(props);
    this.geometries.push(geometry);
    return geometry;
  };
}
var view_default = View;

// node_modules/@antv/g2/esm/chart/chart.js
var Chart = function(_super) {
  __extends(Chart2, _super);
  function Chart2(props) {
    var _this = this;
    var container = props.container, width = props.width, height = props.height, _a3 = props.autoFit, autoFit = _a3 === void 0 ? false : _a3, padding = props.padding, appendPadding = props.appendPadding, _b = props.renderer, renderer = _b === void 0 ? "canvas" : _b, pixelRatio = props.pixelRatio, _c = props.localRefresh, localRefresh = _c === void 0 ? true : _c, _d = props.visible, visible = _d === void 0 ? true : _d, _e = props.supportCSSTransform, supportCSSTransform = _e === void 0 ? false : _e, _f = props.defaultInteractions, defaultInteractions = _f === void 0 ? ["tooltip", "legend-filter", "legend-active", "continuous-filter", "ellipsis-text", "axis-description"] : _f, options = props.options, limitInPlot2 = props.limitInPlot, theme = props.theme, syncViewPadding = props.syncViewPadding;
    var ele = is_string_default(container) ? document.getElementById(container) : container;
    var wrapperElement = createDom('<div style="position:relative;"></div>');
    ele.appendChild(wrapperElement);
    var size2 = getChartSize(ele, autoFit, width, height);
    var G = getEngine(renderer);
    var canvas = new G.Canvas(__assign({ container: wrapperElement, pixelRatio, localRefresh, supportCSSTransform }, size2));
    _this = _super.call(this, {
      parent: null,
      canvas,
      backgroundGroup: canvas.addGroup({ zIndex: GROUP_Z_INDEX.BG }),
      middleGroup: canvas.addGroup({ zIndex: GROUP_Z_INDEX.MID }),
      foregroundGroup: canvas.addGroup({ zIndex: GROUP_Z_INDEX.FORE }),
      padding,
      appendPadding,
      visible,
      options,
      limitInPlot: limitInPlot2,
      theme,
      syncViewPadding
    }) || this;
    _this.onResize = debounce_default(function() {
      _this.forceFit();
    }, 300);
    _this.ele = ele;
    _this.canvas = canvas;
    _this.width = size2.width;
    _this.height = size2.height;
    _this.autoFit = autoFit;
    _this.localRefresh = localRefresh;
    _this.renderer = renderer;
    _this.wrapperElement = wrapperElement;
    _this.updateCanvasStyle();
    _this.bindAutoFit();
    _this.initDefaultInteractions(defaultInteractions);
    return _this;
  }
  Chart2.prototype.initDefaultInteractions = function(interactions) {
    var _this = this;
    each_default(interactions, function(interaction) {
      _this.interaction(interaction);
    });
  };
  Chart2.prototype.aria = function(ariaOption) {
    var ATTR = "aria-label";
    if (ariaOption === false) {
      this.ele.removeAttribute(ATTR);
    } else {
      this.ele.setAttribute(ATTR, ariaOption.label);
    }
  };
  Chart2.prototype.changeSize = function(width, height) {
    if (this.width === width && this.height === height) {
      return this;
    }
    this.emit(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE);
    this.width = width;
    this.height = height;
    this.canvas.changeSize(width, height);
    this.render(true);
    this.emit(VIEW_LIFE_CIRCLE.AFTER_CHANGE_SIZE);
    return this;
  };
  Chart2.prototype.clear = function() {
    _super.prototype.clear.call(this);
    this.aria(false);
  };
  Chart2.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    this.unbindAutoFit();
    this.canvas.destroy();
    removeDom(this.wrapperElement);
    this.wrapperElement = null;
  };
  Chart2.prototype.changeVisible = function(visible) {
    _super.prototype.changeVisible.call(this, visible);
    this.wrapperElement.style.display = visible ? "" : "none";
    return this;
  };
  Chart2.prototype.forceFit = function() {
    if (!this.destroyed) {
      var _a3 = getChartSize(this.ele, true, this.width, this.height), width = _a3.width, height = _a3.height;
      this.changeSize(width, height);
    }
  };
  Chart2.prototype.updateCanvasStyle = function() {
    modifyCSS(this.canvas.get("el"), {
      display: "inline-block",
      verticalAlign: "middle"
    });
  };
  Chart2.prototype.bindAutoFit = function() {
    if (this.autoFit) {
      window.addEventListener("resize", this.onResize);
    }
  };
  Chart2.prototype.unbindAutoFit = function() {
    if (this.autoFit) {
      window.removeEventListener("resize", this.onResize);
    }
  };
  return Chart2;
}(view_default);
var chart_default = Chart;

// node_modules/@antv/g2/esm/chart/controller/base.js
var Controller = function() {
  function Controller2(view) {
    this.visible = true;
    this.components = [];
    this.view = view;
  }
  Controller2.prototype.clear = function(includeOption) {
    each_default(this.components, function(co) {
      co.component.destroy();
    });
    this.components = [];
  };
  Controller2.prototype.destroy = function() {
    this.clear();
  };
  Controller2.prototype.getComponents = function() {
    return this.components;
  };
  Controller2.prototype.changeVisible = function(visible) {
    if (this.visible === visible) {
      return;
    }
    this.components.forEach(function(co) {
      if (visible) {
        co.component.show();
      } else {
        co.component.hide();
      }
    });
    this.visible = visible;
  };
  return Controller2;
}();

// node_modules/@antv/g2/esm/chart/controller/tooltip.js
function uniq3(items) {
  var uniqItems = [];
  var _loop_1 = function(index2) {
    var item = items[index2];
    var result = find_default(uniqItems, function(subItem) {
      return subItem.color === item.color && subItem.name === item.name && subItem.value === item.value && subItem.title === item.title;
    });
    if (!result) {
      uniqItems.push(item);
    }
  };
  for (var index = 0; index < items.length; index++) {
    _loop_1(index);
  }
  return uniqItems;
}
var Tooltip2 = function(_super) {
  __extends(Tooltip3, _super);
  function Tooltip3() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.isLocked = false;
    return _this;
  }
  Object.defineProperty(Tooltip3.prototype, "name", {
    get: function() {
      return "tooltip";
    },
    enumerable: false,
    configurable: true
  });
  Tooltip3.prototype.init = function() {
  };
  Tooltip3.prototype.isVisible = function() {
    var option = this.view.getOptions().tooltip;
    return option !== false;
  };
  Tooltip3.prototype.render = function() {
  };
  Tooltip3.prototype.showTooltip = function(point) {
    this.point = point;
    if (!this.isVisible()) {
      return;
    }
    var view = this.view;
    var items = this.getTooltipItems(point);
    if (!items.length) {
      this.hideTooltip();
      return;
    }
    var title = this.getTitle(items);
    var dataPoint = {
      x: items[0].x,
      y: items[0].y
    };
    view.emit("tooltip:show", event_default.fromData(view, "tooltip:show", __assign({ items, title }, point)));
    var cfg = this.getTooltipCfg();
    var follow = cfg.follow, showMarkers = cfg.showMarkers, showCrosshairs = cfg.showCrosshairs, showContent = cfg.showContent, marker = cfg.marker;
    var lastItems = this.items;
    var lastTitle = this.title;
    if (!is_equal_default(lastTitle, title) || !is_equal_default(lastItems, items)) {
      view.emit("tooltip:change", event_default.fromData(view, "tooltip:change", __assign({ items, title }, point)));
      if (is_function_default(showContent) ? showContent(items) : showContent) {
        if (!this.tooltip) {
          this.renderTooltip();
        }
        this.tooltip.update(mix({}, cfg, {
          items: this.getItemsAfterProcess(items),
          title
        }, follow ? point : {}));
        this.tooltip.show();
      }
      if (showMarkers) {
        this.renderTooltipMarkers(items, marker);
      }
    } else {
      if (this.tooltip && follow) {
        this.tooltip.update(point);
        this.tooltip.show();
      }
      if (this.tooltipMarkersGroup) {
        this.tooltipMarkersGroup.show();
      }
    }
    this.items = items;
    this.title = title;
    if (showCrosshairs) {
      var isCrosshairsFollowCursor = get_default(cfg, ["crosshairs", "follow"], false);
      this.renderCrosshairs(isCrosshairsFollowCursor ? point : dataPoint, cfg);
    }
  };
  Tooltip3.prototype.hideTooltip = function() {
    var follow = this.getTooltipCfg().follow;
    if (!follow) {
      this.point = null;
      return;
    }
    var tooltipMarkersGroup = this.tooltipMarkersGroup;
    if (tooltipMarkersGroup) {
      tooltipMarkersGroup.hide();
    }
    var xCrosshair = this.xCrosshair;
    var yCrosshair = this.yCrosshair;
    if (xCrosshair) {
      xCrosshair.hide();
    }
    if (yCrosshair) {
      yCrosshair.hide();
    }
    var tooltip = this.tooltip;
    if (tooltip) {
      tooltip.hide();
    }
    this.view.emit("tooltip:hide", event_default.fromData(this.view, "tooltip:hide", {}));
    this.point = null;
  };
  Tooltip3.prototype.lockTooltip = function() {
    this.isLocked = true;
    if (this.tooltip) {
      this.tooltip.setCapture(true);
    }
  };
  Tooltip3.prototype.unlockTooltip = function() {
    this.isLocked = false;
    var cfg = this.getTooltipCfg();
    if (this.tooltip) {
      this.tooltip.setCapture(cfg.capture);
    }
  };
  Tooltip3.prototype.isTooltipLocked = function() {
    return this.isLocked;
  };
  Tooltip3.prototype.clear = function() {
    var _a3 = this, tooltip = _a3.tooltip, xCrosshair = _a3.xCrosshair, yCrosshair = _a3.yCrosshair, tooltipMarkersGroup = _a3.tooltipMarkersGroup;
    if (tooltip) {
      tooltip.hide();
      tooltip.clear();
    }
    if (xCrosshair) {
      xCrosshair.clear();
    }
    if (yCrosshair) {
      yCrosshair.clear();
    }
    if (tooltipMarkersGroup) {
      tooltipMarkersGroup.clear();
    }
    if (tooltip === null || tooltip === void 0 ? void 0 : tooltip.get("customContent")) {
      this.tooltip.destroy();
      this.tooltip = null;
    }
    this.title = null;
    this.items = null;
  };
  Tooltip3.prototype.destroy = function() {
    if (this.tooltip) {
      this.tooltip.destroy();
    }
    if (this.xCrosshair) {
      this.xCrosshair.destroy();
    }
    if (this.yCrosshair) {
      this.yCrosshair.destroy();
    }
    if (this.guideGroup) {
      this.guideGroup.remove(true);
    }
    this.reset();
  };
  Tooltip3.prototype.reset = function() {
    this.items = null;
    this.title = null;
    this.tooltipMarkersGroup = null;
    this.tooltipCrosshairsGroup = null;
    this.xCrosshair = null;
    this.yCrosshair = null;
    this.tooltip = null;
    this.guideGroup = null;
    this.isLocked = false;
    this.point = null;
  };
  Tooltip3.prototype.changeVisible = function(visible) {
    if (this.visible === visible) {
      return;
    }
    var _a3 = this, tooltip = _a3.tooltip, tooltipMarkersGroup = _a3.tooltipMarkersGroup, xCrosshair = _a3.xCrosshair, yCrosshair = _a3.yCrosshair;
    if (visible) {
      if (tooltip) {
        tooltip.show();
      }
      if (tooltipMarkersGroup) {
        tooltipMarkersGroup.show();
      }
      if (xCrosshair) {
        xCrosshair.show();
      }
      if (yCrosshair) {
        yCrosshair.show();
      }
    } else {
      if (tooltip) {
        tooltip.hide();
      }
      if (tooltipMarkersGroup) {
        tooltipMarkersGroup.hide();
      }
      if (xCrosshair) {
        xCrosshair.hide();
      }
      if (yCrosshair) {
        yCrosshair.hide();
      }
    }
    this.visible = visible;
  };
  Tooltip3.prototype.getTooltipItems = function(point) {
    var e_1, _a3, e_2, _b, e_3, _c;
    var items = this.findItemsFromView(this.view, point);
    if (items.length) {
      items = flatten_default(items);
      try {
        for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
          var itemArr = items_1_1.value;
          try {
            for (var itemArr_1 = (e_2 = void 0, __values(itemArr)), itemArr_1_1 = itemArr_1.next(); !itemArr_1_1.done; itemArr_1_1 = itemArr_1.next()) {
              var item = itemArr_1_1.value;
              var _d = item.mappingData, x = _d.x, y = _d.y;
              item.x = is_array_default(x) ? x[x.length - 1] : x;
              item.y = is_array_default(y) ? y[y.length - 1] : y;
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (itemArr_1_1 && !itemArr_1_1.done && (_b = itemArr_1.return))
                _b.call(itemArr_1);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (items_1_1 && !items_1_1.done && (_a3 = items_1.return))
            _a3.call(items_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      var shared = this.getTooltipCfg().shared;
      if (shared === false && items.length > 1) {
        var snapItem = items[0];
        var min3 = Math.abs(point.y - snapItem[0].y);
        try {
          for (var items_2 = __values(items), items_2_1 = items_2.next(); !items_2_1.done; items_2_1 = items_2.next()) {
            var aItem = items_2_1.value;
            var yDistance = Math.abs(point.y - aItem[0].y);
            if (yDistance <= min3) {
              snapItem = aItem;
              min3 = yDistance;
            }
          }
        } catch (e_3_1) {
          e_3 = { error: e_3_1 };
        } finally {
          try {
            if (items_2_1 && !items_2_1.done && (_c = items_2.return))
              _c.call(items_2);
          } finally {
            if (e_3)
              throw e_3.error;
          }
        }
        items = [snapItem];
      }
      return uniq3(flatten_default(items));
    }
    return [];
  };
  Tooltip3.prototype.layout = function() {
  };
  Tooltip3.prototype.update = function() {
    if (this.point) {
      this.showTooltip(this.point);
    }
    if (this.tooltip) {
      var canvas = this.view.getCanvas();
      this.tooltip.set("region", {
        start: { x: 0, y: 0 },
        end: { x: canvas.get("width"), y: canvas.get("height") }
      });
    }
  };
  Tooltip3.prototype.isCursorEntered = function(point) {
    if (this.tooltip) {
      var el = this.tooltip.getContainer();
      var capture = this.tooltip.get("capture");
      if (el && capture) {
        var _a3 = el.getBoundingClientRect(), x = _a3.x, y = _a3.y, width = _a3.width, height = _a3.height;
        return new BBox(x, y, width, height).isPointIn(point);
      }
    }
    return false;
  };
  Tooltip3.prototype.getTooltipCfg = function() {
    var view = this.view;
    var option = view.getOptions().tooltip;
    var processOption = this.processCustomContent(option);
    var theme = view.getTheme();
    var defaultCfg = get_default(theme, ["components", "tooltip"], {});
    var enterable = get_default(processOption, "enterable", defaultCfg.enterable);
    return deep_mix_default({}, defaultCfg, processOption, {
      capture: enterable || this.isLocked ? true : false
    });
  };
  Tooltip3.prototype.processCustomContent = function(option) {
    if (is_boolean_default(option) || !get_default(option, "customContent")) {
      return option;
    }
    var currentCustomContent = option.customContent;
    var customContent = function(title, items) {
      var content = currentCustomContent(title, items) || "";
      return is_string_default(content) ? '<div class="g2-tooltip">' + content + "</div>" : content;
    };
    return __assign(__assign({}, option), { customContent });
  };
  Tooltip3.prototype.getTitle = function(items) {
    var title = items[0].title || items[0].name;
    this.title = title;
    return title;
  };
  Tooltip3.prototype.renderTooltip = function() {
    var canvas = this.view.getCanvas();
    var region = {
      start: { x: 0, y: 0 },
      end: { x: canvas.get("width"), y: canvas.get("height") }
    };
    var cfg = this.getTooltipCfg();
    var tooltip = new HtmlTooltip(__assign(__assign({ parent: canvas.get("el").parentNode, region }, cfg), { visible: false, crosshairs: null }));
    tooltip.init();
    this.tooltip = tooltip;
  };
  Tooltip3.prototype.renderTooltipMarkers = function(items, marker) {
    var e_4, _a3;
    var tooltipMarkersGroup = this.getTooltipMarkersGroup();
    var rootView = this.view.getRootView();
    var limitInPlot2 = rootView.limitInPlot;
    try {
      for (var items_3 = __values(items), items_3_1 = items_3.next(); !items_3_1.done; items_3_1 = items_3.next()) {
        var item = items_3_1.value;
        var x = item.x, y = item.y;
        if (limitInPlot2 || (tooltipMarkersGroup === null || tooltipMarkersGroup === void 0 ? void 0 : tooltipMarkersGroup.getClip())) {
          var _b = getCoordinateClipCfg(rootView.getCoordinate()), type = _b.type, attrs_1 = _b.attrs;
          tooltipMarkersGroup === null || tooltipMarkersGroup === void 0 ? void 0 : tooltipMarkersGroup.setClip({
            type,
            attrs: attrs_1
          });
        } else {
          tooltipMarkersGroup === null || tooltipMarkersGroup === void 0 ? void 0 : tooltipMarkersGroup.setClip(void 0);
        }
        var theme = this.view.getTheme();
        var markerDefaultCfg = get_default(theme, ["components", "tooltip", "marker"], {});
        var attrs = __assign(__assign({ fill: item.color, symbol: "circle", shadowColor: item.color }, is_function_default(marker) ? __assign(__assign({}, markerDefaultCfg), marker(item)) : marker), { x, y });
        tooltipMarkersGroup.addShape("marker", {
          attrs
        });
      }
    } catch (e_4_1) {
      e_4 = { error: e_4_1 };
    } finally {
      try {
        if (items_3_1 && !items_3_1.done && (_a3 = items_3.return))
          _a3.call(items_3);
      } finally {
        if (e_4)
          throw e_4.error;
      }
    }
  };
  Tooltip3.prototype.renderCrosshairs = function(point, cfg) {
    var crosshairsType = get_default(cfg, ["crosshairs", "type"], "x");
    if (crosshairsType === "x") {
      if (this.yCrosshair) {
        this.yCrosshair.hide();
      }
      this.renderXCrosshairs(point, cfg);
    } else if (crosshairsType === "y") {
      if (this.xCrosshair) {
        this.xCrosshair.hide();
      }
      this.renderYCrosshairs(point, cfg);
    } else if (crosshairsType === "xy") {
      this.renderXCrosshairs(point, cfg);
      this.renderYCrosshairs(point, cfg);
    }
  };
  Tooltip3.prototype.renderXCrosshairs = function(point, tooltipCfg) {
    var coordinate = this.getViewWithGeometry(this.view).getCoordinate();
    var start;
    var end;
    if (coordinate.isRect) {
      if (coordinate.isTransposed) {
        start = {
          x: coordinate.start.x,
          y: point.y
        };
        end = {
          x: coordinate.end.x,
          y: point.y
        };
      } else {
        start = {
          x: point.x,
          y: coordinate.end.y
        };
        end = {
          x: point.x,
          y: coordinate.start.y
        };
      }
    } else {
      var angle3 = getAngleByPoint(coordinate, point);
      var center = coordinate.getCenter();
      var radius = coordinate.getRadius();
      end = polarToCartesian(center.x, center.y, radius, angle3);
      start = center;
    }
    var cfg = deep_mix_default({
      start,
      end,
      container: this.getTooltipCrosshairsGroup()
    }, get_default(tooltipCfg, "crosshairs", {}), this.getCrosshairsText("x", point, tooltipCfg));
    delete cfg.type;
    var xCrosshair = this.xCrosshair;
    if (xCrosshair) {
      xCrosshair.update(cfg);
    } else {
      xCrosshair = new crosshair_exports.Line(cfg);
      xCrosshair.init();
    }
    xCrosshair.render();
    xCrosshair.show();
    this.xCrosshair = xCrosshair;
  };
  Tooltip3.prototype.renderYCrosshairs = function(point, tooltipCfg) {
    var coordinate = this.getViewWithGeometry(this.view).getCoordinate();
    var cfg;
    var type;
    if (coordinate.isRect) {
      var start = void 0;
      var end = void 0;
      if (coordinate.isTransposed) {
        start = {
          x: point.x,
          y: coordinate.end.y
        };
        end = {
          x: point.x,
          y: coordinate.start.y
        };
      } else {
        start = {
          x: coordinate.start.x,
          y: point.y
        };
        end = {
          x: coordinate.end.x,
          y: point.y
        };
      }
      cfg = {
        start,
        end
      };
      type = "Line";
    } else {
      cfg = {
        center: coordinate.getCenter(),
        radius: getDistanceToCenter(coordinate, point),
        startAngle: coordinate.startAngle,
        endAngle: coordinate.endAngle
      };
      type = "Circle";
    }
    cfg = deep_mix_default({
      container: this.getTooltipCrosshairsGroup()
    }, cfg, get_default(tooltipCfg, "crosshairs", {}), this.getCrosshairsText("y", point, tooltipCfg));
    delete cfg.type;
    var yCrosshair = this.yCrosshair;
    if (yCrosshair) {
      if (coordinate.isRect && yCrosshair.get("type") === "circle" || !coordinate.isRect && yCrosshair.get("type") === "line") {
        yCrosshair = new crosshair_exports[type](cfg);
        yCrosshair.init();
      } else {
        yCrosshair.update(cfg);
      }
    } else {
      yCrosshair = new crosshair_exports[type](cfg);
      yCrosshair.init();
    }
    yCrosshair.render();
    yCrosshair.show();
    this.yCrosshair = yCrosshair;
  };
  Tooltip3.prototype.getCrosshairsText = function(type, point, tooltipCfg) {
    var textCfg = get_default(tooltipCfg, ["crosshairs", "text"]);
    var follow = get_default(tooltipCfg, ["crosshairs", "follow"]);
    var items = this.items;
    if (textCfg) {
      var view = this.getViewWithGeometry(this.view);
      var firstItem = items[0];
      var xScale = view.getXScale();
      var yScale = view.getYScales()[0];
      var xValue = void 0;
      var yValue = void 0;
      if (follow) {
        var invertPoint = this.view.getCoordinate().invert(point);
        xValue = xScale.invert(invertPoint.x);
        yValue = yScale.invert(invertPoint.y);
      } else {
        xValue = firstItem.data[xScale.field];
        yValue = firstItem.data[yScale.field];
      }
      var content = type === "x" ? xValue : yValue;
      if (is_function_default(textCfg)) {
        textCfg = textCfg(type, content, items, point);
      } else {
        textCfg.content = content;
      }
      return {
        text: textCfg
      };
    }
  };
  Tooltip3.prototype.getGuideGroup = function() {
    if (!this.guideGroup) {
      var foregroundGroup = this.view.foregroundGroup;
      this.guideGroup = foregroundGroup.addGroup({
        name: "tooltipGuide",
        capture: false
      });
    }
    return this.guideGroup;
  };
  Tooltip3.prototype.getTooltipMarkersGroup = function() {
    var tooltipMarkersGroup = this.tooltipMarkersGroup;
    if (tooltipMarkersGroup && !tooltipMarkersGroup.destroyed) {
      tooltipMarkersGroup.clear();
      tooltipMarkersGroup.show();
    } else {
      tooltipMarkersGroup = this.getGuideGroup().addGroup({
        name: "tooltipMarkersGroup"
      });
      tooltipMarkersGroup.toFront();
      this.tooltipMarkersGroup = tooltipMarkersGroup;
    }
    return tooltipMarkersGroup;
  };
  Tooltip3.prototype.getTooltipCrosshairsGroup = function() {
    var tooltipCrosshairsGroup = this.tooltipCrosshairsGroup;
    if (!tooltipCrosshairsGroup) {
      tooltipCrosshairsGroup = this.getGuideGroup().addGroup({
        name: "tooltipCrosshairsGroup",
        capture: false
      });
      tooltipCrosshairsGroup.toBack();
      this.tooltipCrosshairsGroup = tooltipCrosshairsGroup;
    }
    return tooltipCrosshairsGroup;
  };
  Tooltip3.prototype.findItemsFromView = function(view, point) {
    var e_5, _a3;
    if (view.getOptions().tooltip === false) {
      return [];
    }
    var tooltipCfg = this.getTooltipCfg();
    var result = findItemsFromView(view, point, tooltipCfg);
    try {
      for (var _b = __values(view.views), _c = _b.next(); !_c.done; _c = _b.next()) {
        var childView = _c.value;
        result = result.concat(this.findItemsFromView(childView, point));
      }
    } catch (e_5_1) {
      e_5 = { error: e_5_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a3 = _b.return))
          _a3.call(_b);
      } finally {
        if (e_5)
          throw e_5.error;
      }
    }
    return result;
  };
  Tooltip3.prototype.getViewWithGeometry = function(view) {
    var _this = this;
    if (view.geometries.length) {
      return view;
    }
    return find_default(view.views, function(childView) {
      return _this.getViewWithGeometry(childView);
    });
  };
  Tooltip3.prototype.getItemsAfterProcess = function(originalItems) {
    var customItems = this.getTooltipCfg().customItems;
    var fn = customItems ? customItems : function(v) {
      return v;
    };
    return fn(originalItems);
  };
  return Tooltip3;
}(Controller);
var tooltip_default = Tooltip2;

// node_modules/@antv/g2/esm/animate/animation/index.js
var ANIMATIONS_MAP = {};
function getAnimation(type) {
  return ANIMATIONS_MAP[type.toLowerCase()];
}
function registerAnimation(type, animation) {
  ANIMATIONS_MAP[type.toLowerCase()] = animation;
}

// node_modules/@antv/g2/esm/animate/index.js
var DEFAULT_ANIMATE_CFG = {
  appear: {
    duration: 450,
    easing: "easeQuadOut"
  },
  update: {
    duration: 400,
    easing: "easeQuadInOut"
  },
  enter: {
    duration: 400,
    easing: "easeQuadInOut"
  },
  leave: {
    duration: 350,
    easing: "easeQuadIn"
  }
};
var GEOMETRY_ANIMATE_CFG = {
  interval: function(coordinate) {
    return {
      enter: {
        animation: coordinate.isRect ? coordinate.isTransposed ? "scale-in-x" : "scale-in-y" : "fade-in"
      },
      update: {
        animation: coordinate.isPolar && coordinate.isTransposed ? "sector-path-update" : null
      },
      leave: {
        animation: "fade-out"
      }
    };
  },
  line: {
    enter: {
      animation: "fade-in"
    },
    leave: {
      animation: "fade-out"
    }
  },
  path: {
    enter: {
      animation: "fade-in"
    },
    leave: {
      animation: "fade-out"
    }
  },
  point: {
    appear: {
      animation: "zoom-in"
    },
    enter: {
      animation: "zoom-in"
    },
    leave: {
      animation: "zoom-out"
    }
  },
  area: {
    enter: {
      animation: "fade-in"
    },
    leave: {
      animation: "fade-out"
    }
  },
  polygon: {
    enter: {
      animation: "fade-in"
    },
    leave: {
      animation: "fade-out"
    }
  },
  schema: {
    enter: {
      animation: "fade-in"
    },
    leave: {
      animation: "fade-out"
    }
  },
  edge: {
    enter: {
      animation: "fade-in"
    },
    leave: {
      animation: "fade-out"
    }
  },
  label: {
    appear: {
      animation: "fade-in",
      delay: 450
    },
    enter: {
      animation: "fade-in"
    },
    update: {
      animation: "position-update"
    },
    leave: {
      animation: "fade-out"
    }
  }
};
var GEOMETRY_GROUP_APPEAR_ANIMATION = {
  line: function() {
    return {
      animation: "wave-in"
    };
  },
  area: function() {
    return {
      animation: "wave-in"
    };
  },
  path: function() {
    return {
      animation: "fade-in"
    };
  },
  interval: function(coordinate) {
    var animation;
    if (coordinate.isRect) {
      animation = coordinate.isTransposed ? "grow-in-x" : "grow-in-y";
    } else {
      animation = "grow-in-xy";
      if (coordinate.isPolar && coordinate.isTransposed) {
        animation = "wave-in";
      }
    }
    return {
      animation
    };
  },
  schema: function(coordinate) {
    var animation;
    if (coordinate.isRect) {
      animation = coordinate.isTransposed ? "grow-in-x" : "grow-in-y";
    } else {
      animation = "grow-in-xy";
    }
    return {
      animation
    };
  },
  polygon: function() {
    return {
      animation: "fade-in",
      duration: 500
    };
  },
  edge: function() {
    return {
      animation: "fade-in"
    };
  }
};
function parseAnimateConfig(animateCfg, data) {
  return {
    delay: is_function_default(animateCfg.delay) ? animateCfg.delay(data) : animateCfg.delay,
    easing: is_function_default(animateCfg.easing) ? animateCfg.easing(data) : animateCfg.easing,
    duration: is_function_default(animateCfg.duration) ? animateCfg.duration(data) : animateCfg.duration,
    callback: animateCfg.callback,
    repeat: animateCfg.repeat
  };
}
function getDefaultAnimateCfg(elementName, coordinate, animateType) {
  var animateCfg = GEOMETRY_ANIMATE_CFG[elementName];
  if (animateCfg) {
    if (is_function_default(animateCfg)) {
      animateCfg = animateCfg(coordinate);
    }
    animateCfg = deep_mix_default({}, DEFAULT_ANIMATE_CFG, animateCfg);
    if (animateType) {
      return animateCfg[animateType];
    }
  }
  return animateCfg;
}
function doAnimate(shape, animateCfg, cfg) {
  var data = get_default(shape.get("origin"), "data", FIELD_ORIGIN);
  var animation = animateCfg.animation;
  var parsedAnimateCfg = parseAnimateConfig(animateCfg, data);
  if (animation) {
    var animateFunction = getAnimation(animation);
    if (animateFunction) {
      animateFunction(shape, parsedAnimateCfg, cfg);
    }
  } else {
    shape.animate(cfg.toAttrs, parsedAnimateCfg);
  }
}
function doGroupAppearAnimate(container, animateCfg, geometryType, coordinate, minYPoint) {
  if (GEOMETRY_GROUP_APPEAR_ANIMATION[geometryType]) {
    var defaultCfg = GEOMETRY_GROUP_APPEAR_ANIMATION[geometryType](coordinate);
    var animation = getAnimation(get_default(defaultCfg, "animation", ""));
    if (animation) {
      var cfg = __assign(__assign(__assign({}, DEFAULT_ANIMATE_CFG.appear), defaultCfg), animateCfg);
      container.stopAnimate();
      animation(container, cfg, {
        coordinate,
        minYPoint,
        toAttrs: null
      });
    }
  }
}

// node_modules/@antv/g2/esm/geometry/shape/constant.js
var BACKGROUND_SHAPE = "element-background";

// node_modules/@antv/g2/esm/geometry/element/index.js
var Element3 = function(_super) {
  __extends(Element4, _super);
  function Element4(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.labelShape = [];
    _this.states = [];
    var shapeFactory = cfg.shapeFactory, container = cfg.container, offscreenGroup = cfg.offscreenGroup, elementIndex = cfg.elementIndex, _a3 = cfg.visible, visible = _a3 === void 0 ? true : _a3;
    _this.shapeFactory = shapeFactory;
    _this.container = container;
    _this.offscreenGroup = offscreenGroup;
    _this.visible = visible;
    _this.elementIndex = elementIndex;
    return _this;
  }
  Element4.prototype.draw = function(model, isUpdate) {
    if (isUpdate === void 0) {
      isUpdate = false;
    }
    this.model = model;
    this.data = model.data;
    this.shapeType = this.getShapeType(model);
    this.drawShape(model, isUpdate);
    if (this.visible === false) {
      this.changeVisible(false);
    }
  };
  Element4.prototype.update = function(model) {
    var _a3 = this, shapeFactory = _a3.shapeFactory, shape = _a3.shape;
    if (!shape) {
      return;
    }
    this.model = model;
    this.data = model.data;
    this.shapeType = this.getShapeType(model);
    this.setShapeInfo(shape, model);
    var offscreenGroup = this.getOffscreenGroup();
    var newShape = shapeFactory.drawShape(this.shapeType, model, offscreenGroup);
    newShape.cfg.data = this.data;
    newShape.cfg.origin = model;
    newShape.cfg.element = this;
    this.syncShapeStyle(shape, newShape, this.getStates(), this.getAnimateCfg("update"));
  };
  Element4.prototype.destroy = function() {
    var _a3 = this, shapeFactory = _a3.shapeFactory, shape = _a3.shape;
    if (shape) {
      var animateCfg = this.getAnimateCfg("leave");
      if (animateCfg) {
        doAnimate(shape, animateCfg, {
          coordinate: shapeFactory.coordinate,
          toAttrs: __assign({}, shape.attr())
        });
      } else {
        shape.remove(true);
      }
    }
    this.states = [];
    this.shapeFactory = void 0;
    this.container = void 0;
    this.shape = void 0;
    this.animate = void 0;
    this.geometry = void 0;
    this.labelShape = [];
    this.model = void 0;
    this.data = void 0;
    this.offscreenGroup = void 0;
    this.statesStyle = void 0;
    _super.prototype.destroy.call(this);
  };
  Element4.prototype.changeVisible = function(visible) {
    _super.prototype.changeVisible.call(this, visible);
    if (visible) {
      if (this.shape) {
        this.shape.show();
      }
      if (this.labelShape) {
        this.labelShape.forEach(function(label) {
          label.show();
        });
      }
    } else {
      if (this.shape) {
        this.shape.hide();
      }
      if (this.labelShape) {
        this.labelShape.forEach(function(label) {
          label.hide();
        });
      }
    }
  };
  Element4.prototype.setState = function(stateName, stateStatus) {
    var _a3 = this, states = _a3.states, shapeFactory = _a3.shapeFactory, model = _a3.model, shape = _a3.shape, shapeType = _a3.shapeType;
    var index = states.indexOf(stateName);
    if (stateStatus) {
      if (index > -1) {
        return;
      }
      states.push(stateName);
      if (stateName === "active" || stateName === "selected") {
        shape === null || shape === void 0 ? void 0 : shape.toFront();
      }
    } else {
      if (index === -1) {
        return;
      }
      states.splice(index, 1);
      if (stateName === "active" || stateName === "selected") {
        var _b = this.geometry, sortZIndex = _b.sortZIndex, zIndexReversed = _b.zIndexReversed;
        var idx = zIndexReversed ? this.geometry.elements.length - this.elementIndex : this.elementIndex;
        sortZIndex ? shape.setZIndex(idx) : shape.set("zIndex", idx);
      }
    }
    var offscreenShape = shapeFactory.drawShape(shapeType, model, this.getOffscreenGroup());
    if (states.length) {
      this.syncShapeStyle(shape, offscreenShape, states, null);
    } else {
      this.syncShapeStyle(shape, offscreenShape, ["reset"], null);
    }
    offscreenShape.remove(true);
    var eventObject = {
      state: stateName,
      stateStatus,
      element: this,
      target: this.container
    };
    this.container.emit("statechange", eventObject);
    propagationDelegate(this.shape, "statechange", eventObject);
  };
  Element4.prototype.clearStates = function() {
    var _this = this;
    var states = this.states;
    each_default(states, function(state) {
      _this.setState(state, false);
    });
    this.states = [];
  };
  Element4.prototype.hasState = function(stateName) {
    return this.states.includes(stateName);
  };
  Element4.prototype.getStates = function() {
    return this.states;
  };
  Element4.prototype.getData = function() {
    return this.data;
  };
  Element4.prototype.getModel = function() {
    return this.model;
  };
  Element4.prototype.getBBox = function() {
    var _a3 = this, shape = _a3.shape, labelShape = _a3.labelShape;
    var bbox = {
      x: 0,
      y: 0,
      minX: 0,
      minY: 0,
      maxX: 0,
      maxY: 0,
      width: 0,
      height: 0
    };
    if (shape) {
      bbox = shape.getCanvasBBox();
    }
    if (labelShape) {
      labelShape.forEach(function(label) {
        var labelBBox = label.getCanvasBBox();
        bbox.x = Math.min(labelBBox.x, bbox.x);
        bbox.y = Math.min(labelBBox.y, bbox.y);
        bbox.minX = Math.min(labelBBox.minX, bbox.minX);
        bbox.minY = Math.min(labelBBox.minY, bbox.minY);
        bbox.maxX = Math.max(labelBBox.maxX, bbox.maxX);
        bbox.maxY = Math.max(labelBBox.maxY, bbox.maxY);
      });
    }
    bbox.width = bbox.maxX - bbox.minX;
    bbox.height = bbox.maxY - bbox.minY;
    return bbox;
  };
  Element4.prototype.getStatesStyle = function() {
    if (!this.statesStyle) {
      var _a3 = this, shapeType = _a3.shapeType, geometry = _a3.geometry, shapeFactory = _a3.shapeFactory;
      var stateOption = geometry.stateOption;
      var defaultShapeType = shapeFactory.defaultShapeType;
      var stateTheme = shapeFactory.theme[shapeType] || shapeFactory.theme[defaultShapeType];
      this.statesStyle = deep_mix_default({}, stateTheme, stateOption);
    }
    return this.statesStyle;
  };
  Element4.prototype.getStateStyle = function(stateName, shapeKey) {
    var statesStyle = this.getStatesStyle();
    var stateCfg = get_default(statesStyle, [stateName, "style"], {});
    var shapeStyle = stateCfg[shapeKey] || stateCfg;
    if (is_function_default(shapeStyle)) {
      return shapeStyle(this);
    }
    return shapeStyle;
  };
  Element4.prototype.getAnimateCfg = function(animateType) {
    var _this = this;
    var animate = this.animate;
    if (animate) {
      var cfg_1 = animate[animateType];
      if (cfg_1) {
        return __assign(__assign({}, cfg_1), { callback: function() {
          var _a3;
          is_function_default(cfg_1.callback) && cfg_1.callback();
          (_a3 = _this.geometry) === null || _a3 === void 0 ? void 0 : _a3.emit(GEOMETRY_LIFE_CIRCLE.AFTER_DRAW_ANIMATE);
        } });
      }
      return cfg_1;
    }
    return null;
  };
  Element4.prototype.drawShape = function(model, isUpdate) {
    var _a3;
    if (isUpdate === void 0) {
      isUpdate = false;
    }
    var _b = this, shapeFactory = _b.shapeFactory, container = _b.container, shapeType = _b.shapeType;
    this.shape = shapeFactory.drawShape(shapeType, model, container);
    if (this.shape) {
      this.setShapeInfo(this.shape, model);
      var name_1 = this.shape.cfg.name;
      if (!name_1) {
        this.shape.cfg.name = ["element", this.shapeFactory.geometryType];
      } else if (is_string_default(name_1)) {
        this.shape.cfg.name = ["element", name_1];
      }
      var animateType = isUpdate ? "enter" : "appear";
      var animateCfg = this.getAnimateCfg(animateType);
      if (animateCfg) {
        (_a3 = this.geometry) === null || _a3 === void 0 ? void 0 : _a3.emit(GEOMETRY_LIFE_CIRCLE.BEFORE_DRAW_ANIMATE);
        doAnimate(this.shape, animateCfg, {
          coordinate: shapeFactory.coordinate,
          toAttrs: __assign({}, this.shape.attr())
        });
      }
    }
  };
  Element4.prototype.getOffscreenGroup = function() {
    if (!this.offscreenGroup) {
      var GroupCtor = this.container.getGroupBase();
      this.offscreenGroup = new GroupCtor({});
    }
    return this.offscreenGroup;
  };
  Element4.prototype.setShapeInfo = function(shape, data) {
    var _this = this;
    shape.cfg.origin = data;
    shape.cfg.element = this;
    if (shape.isGroup()) {
      var children = shape.get("children");
      children.forEach(function(child) {
        _this.setShapeInfo(child, data);
      });
    }
  };
  Element4.prototype.syncShapeStyle = function(sourceShape, targetShape, states, animateCfg, index) {
    var _this = this;
    var _a3;
    if (states === void 0) {
      states = [];
    }
    if (index === void 0) {
      index = 0;
    }
    if (!sourceShape || !targetShape) {
      return;
    }
    var clip = sourceShape.get("clipShape");
    var newClip = targetShape.get("clipShape");
    this.syncShapeStyle(clip, newClip, states, animateCfg);
    if (sourceShape.isGroup()) {
      var children = sourceShape.get("children");
      var newChildren = targetShape.get("children");
      for (var i = 0; i < children.length; i++) {
        this.syncShapeStyle(children[i], newChildren[i], states, animateCfg, index + i);
      }
    } else {
      if (!is_empty_default(states) && !is_equal_default(states, ["reset"])) {
        var name_2 = sourceShape.get("name");
        if (is_array_default(name_2)) {
          name_2 = name_2[1];
        }
        each_default(states, function(state) {
          if (targetShape.get("name") !== BACKGROUND_SHAPE) {
            var style = _this.getStateStyle(state, name_2 || index);
            targetShape.attr(style);
          }
        });
      }
      var newAttrs = getReplaceAttrs(sourceShape, targetShape);
      if (this.animate) {
        if (animateCfg) {
          (_a3 = this.geometry) === null || _a3 === void 0 ? void 0 : _a3.emit(GEOMETRY_LIFE_CIRCLE.BEFORE_DRAW_ANIMATE);
          doAnimate(sourceShape, animateCfg, {
            coordinate: this.shapeFactory.coordinate,
            toAttrs: newAttrs,
            shapeModel: this.model
          });
        } else if (!is_empty_default(states)) {
          sourceShape.stopAnimate();
          sourceShape.animate(newAttrs, {
            duration: 300
          });
        } else {
          sourceShape.attr(newAttrs);
        }
      } else {
        sourceShape.attr(newAttrs);
      }
    }
  };
  Element4.prototype.getShapeType = function(model) {
    var shape = get_default(model, "shape");
    return is_array_default(shape) ? shape[0] : shape;
  };
  return Element4;
}(base_default);
var element_default2 = Element3;

// node_modules/@antv/g2/esm/geometry/label/index.js
var GEOMETRY_LABELS_MAP = {};
var GEOMETRY_LABELS_LAYOUT_MAP = {};
function getGeometryLabel(type) {
  return GEOMETRY_LABELS_MAP[type.toLowerCase()];
}
function registerGeometryLabel(type, ctor) {
  GEOMETRY_LABELS_MAP[type.toLowerCase()] = ctor;
}
function getGeometryLabelLayout(type) {
  return GEOMETRY_LABELS_LAYOUT_MAP[type.toLowerCase()];
}
function registerGeometryLabelLayout(type, layoutFn) {
  GEOMETRY_LABELS_LAYOUT_MAP[type.toLowerCase()] = layoutFn;
}

// node_modules/@antv/g2/esm/geometry/shape/base.js
var ShapeFactoryBase = {
  coordinate: null,
  defaultShapeType: null,
  theme: null,
  getShapePoints: function(shapeType, shapePoint) {
    var shape = this.getShape(shapeType);
    if (shape.getPoints) {
      return shape.getPoints(shapePoint);
    }
    return this.getDefaultPoints(shapePoint);
  },
  getShape: function(shapeType) {
    var shape = this[shapeType] || this[this.defaultShapeType];
    shape.coordinate = this.coordinate;
    return shape;
  },
  getDefaultPoints: function() {
    return [];
  },
  getDefaultStyle: function(geometryTheme) {
    return get_default(geometryTheme, [this.defaultShapeType, "default", "style"], {});
  },
  getMarker: function(shapeType, markerCfg) {
    var shape = this.getShape(shapeType);
    if (!shape.getMarker) {
      var defaultShapeType = this.defaultShapeType;
      shape = this.getShape(defaultShapeType);
    }
    var theme = this.theme;
    var shapeStyle = get_default(theme, [shapeType, "default"], {});
    var markerStyle = shape.getMarker(markerCfg);
    return deep_mix_default({}, shapeStyle, markerStyle);
  },
  drawShape: function(shapeType, cfg, container) {
    var shape = this.getShape(shapeType);
    return shape.draw(cfg, container);
  }
};
var ShapeBase = {
  coordinate: null,
  parsePath: function(path) {
    var coordinate = this.coordinate;
    var parsedPath = parsePathString2(path);
    if (coordinate.isPolar) {
      parsedPath = convertPolarPath(coordinate, parsedPath);
    } else {
      parsedPath = convertNormalPath(coordinate, parsedPath);
    }
    return parsedPath;
  },
  parsePoint: function(point) {
    var coordinate = this.coordinate;
    return coordinate.convert(point);
  },
  parsePoints: function(points) {
    var coordinate = this.coordinate;
    return points.map(function(point) {
      return coordinate.convert(point);
    });
  },
  draw: function(cfg, container) {
  }
};
var ShapeFactoryMap = {};
function registerShapeFactory(factoryName, cfg) {
  var className = upper_first_default(factoryName);
  var geomObj = __assign(__assign(__assign({}, ShapeFactoryBase), cfg), { geometryType: factoryName });
  ShapeFactoryMap[className] = geomObj;
  return geomObj;
}
function registerShape(factoryName, shapeType, cfg) {
  var className = upper_first_default(factoryName);
  var factory = ShapeFactoryMap[className];
  var shapeObj = __assign(__assign({}, ShapeBase), cfg);
  factory[shapeType] = shapeObj;
  return shapeObj;
}
function getShapeFactory(factoryName) {
  var className = upper_first_default(factoryName);
  return ShapeFactoryMap[className];
}

// node_modules/@antv/g2/esm/geometry/util/group-data.js
function group(data, fields, appendConditions) {
  var e_1, _a3;
  if (appendConditions === void 0) {
    appendConditions = {};
  }
  if (!fields) {
    return [data];
  }
  var groups = groupToMap(data, fields);
  var array = [];
  if (fields.length === 1 && appendConditions[fields[0]]) {
    var values2 = appendConditions[fields[0]];
    try {
      for (var values_1 = __values(values2), values_1_1 = values_1.next(); !values_1_1.done; values_1_1 = values_1.next()) {
        var value = values_1_1.value;
        var arr = groups["_".concat(value)];
        if (arr) {
          array.push(arr);
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (values_1_1 && !values_1_1.done && (_a3 = values_1.return))
          _a3.call(values_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
  } else {
    for (var k in groups) {
      if (groups.hasOwnProperty(k)) {
        var eachGroup = groups[k];
        array.push(eachGroup);
      }
    }
  }
  return array;
}

// node_modules/@antv/g2/esm/geometry/util/is-model-change.js
function isModelChange(currentModel, preModel) {
  return some_default(["color", "shape", "size", "x", "y", "isInCircle", "data", "style", "defaultStyle", "points", "mappingData"], function(key) {
    return !is_equal_default(currentModel[key], preModel[key]);
  });
}

// node_modules/@antv/g2/esm/geometry/util/parse-fields.js
function parseFields(field) {
  if (is_array_default(field)) {
    return field;
  }
  return field.split("*");
}

// node_modules/@antv/g2/esm/geometry/util/diff.js
function diff(keyItem, keys2) {
  var added = [];
  var updated = [];
  var removed = [];
  var keyIncluded = /* @__PURE__ */ new Map();
  for (var i = 0; i < keys2.length; i++) {
    var key = keys2[i];
    if (keyItem[key])
      updated.push(key);
    else
      added.push(key);
    keyIncluded.set(key, true);
  }
  Object.keys(keyItem).forEach(function(key2) {
    if (!keyIncluded.has(key2))
      removed.push(key2);
  });
  return {
    added,
    updated,
    removed
  };
}

// node_modules/@antv/g2/esm/geometry/base.js
var Geometry = function(_super) {
  __extends(Geometry2, _super);
  function Geometry2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.type = "base";
    _this.attributes = {};
    _this.elements = [];
    _this.elementsMap = {};
    _this.animateOption = true;
    _this.attributeOption = {};
    _this.lastElementsMap = {};
    _this.generatePoints = false;
    _this.beforeMappingData = null;
    _this.adjusts = {};
    _this.idFields = [];
    _this.hasSorted = false;
    _this.isCoordinateChanged = false;
    var container = cfg.container, labelsContainer = cfg.labelsContainer, coordinate = cfg.coordinate, data = cfg.data, _a3 = cfg.sortable, sortable = _a3 === void 0 ? false : _a3, _b = cfg.visible, visible = _b === void 0 ? true : _b, theme = cfg.theme, _c = cfg.scales, scales = _c === void 0 ? {} : _c, _d = cfg.scaleDefs, scaleDefs = _d === void 0 ? {} : _d, intervalPadding = cfg.intervalPadding, dodgePadding = cfg.dodgePadding, maxColumnWidth = cfg.maxColumnWidth, minColumnWidth = cfg.minColumnWidth, columnWidthRatio = cfg.columnWidthRatio, roseWidthRatio = cfg.roseWidthRatio, multiplePieWidthRatio = cfg.multiplePieWidthRatio, zIndexReversed = cfg.zIndexReversed, sortZIndex = cfg.sortZIndex, useDeferredLabel = cfg.useDeferredLabel;
    _this.container = container;
    _this.labelsContainer = labelsContainer;
    _this.coordinate = coordinate;
    _this.data = data;
    _this.sortable = sortable;
    _this.visible = visible;
    _this.userTheme = theme;
    _this.scales = scales;
    _this.scaleDefs = scaleDefs;
    _this.intervalPadding = intervalPadding;
    _this.dodgePadding = dodgePadding;
    _this.maxColumnWidth = maxColumnWidth;
    _this.minColumnWidth = minColumnWidth;
    _this.columnWidthRatio = columnWidthRatio;
    _this.roseWidthRatio = roseWidthRatio;
    _this.multiplePieWidthRatio = multiplePieWidthRatio;
    _this.zIndexReversed = zIndexReversed;
    _this.sortZIndex = sortZIndex;
    _this.useDeferredLabel = useDeferredLabel ? typeof useDeferredLabel === "number" ? useDeferredLabel : Infinity : null;
    return _this;
  }
  Geometry2.prototype.position = function(cfg) {
    var positionCfg = cfg;
    if (!is_plain_object_default(cfg)) {
      positionCfg = {
        fields: parseFields(cfg)
      };
    }
    var fields = get_default(positionCfg, "fields");
    if (fields.length === 1) {
      fields.unshift("1");
      set_default(positionCfg, "fields", fields);
    }
    set_default(this.attributeOption, "position", positionCfg);
    return this;
  };
  Geometry2.prototype.color = function(field, cfg) {
    this.createAttrOption("color", field, cfg);
    return this;
  };
  Geometry2.prototype.shape = function(field, cfg) {
    this.createAttrOption("shape", field, cfg);
    return this;
  };
  Geometry2.prototype.size = function(field, cfg) {
    this.createAttrOption("size", field, cfg);
    return this;
  };
  Geometry2.prototype.adjust = function(adjustCfg) {
    var adjusts = adjustCfg;
    if (is_string_default(adjustCfg) || is_plain_object_default(adjustCfg)) {
      adjusts = [adjustCfg];
    }
    each_default(adjusts, function(adjust, index) {
      if (!is_object_default(adjust)) {
        adjusts[index] = { type: adjust };
      }
    });
    this.adjustOption = adjusts;
    return this;
  };
  Geometry2.prototype.style = function(field, styleFunc) {
    if (is_string_default(field)) {
      var fields = parseFields(field);
      this.styleOption = {
        fields,
        callback: styleFunc
      };
    } else {
      var _a3 = field, fields = _a3.fields, callback = _a3.callback, cfg = _a3.cfg;
      if (fields || callback || cfg) {
        this.styleOption = field;
      } else {
        this.styleOption = {
          cfg: field
        };
      }
    }
    return this;
  };
  Geometry2.prototype.tooltip = function(field, cfg) {
    if (is_string_default(field)) {
      var fields = parseFields(field);
      this.tooltipOption = {
        fields,
        callback: cfg
      };
    } else {
      this.tooltipOption = field;
    }
    return this;
  };
  Geometry2.prototype.animate = function(cfg) {
    this.animateOption = cfg;
    return this;
  };
  Geometry2.prototype.label = function(field, secondParam, thirdParam) {
    if (is_string_default(field)) {
      var labelOption = {};
      var fields = parseFields(field);
      labelOption.fields = fields;
      if (is_function_default(secondParam)) {
        labelOption.callback = secondParam;
      } else if (is_plain_object_default(secondParam)) {
        labelOption.cfg = secondParam;
      }
      if (thirdParam) {
        labelOption.cfg = thirdParam;
      }
      this.labelOption = labelOption;
    } else {
      this.labelOption = field;
    }
    return this;
  };
  Geometry2.prototype.state = function(cfg) {
    this.stateOption = cfg;
    return this;
  };
  Geometry2.prototype.customInfo = function(cfg) {
    this.customOption = cfg;
    return this;
  };
  Geometry2.prototype.init = function(cfg) {
    if (cfg === void 0) {
      cfg = {};
    }
    this.setCfg(cfg);
    this.initAttributes();
    this.processData(this.data);
    this.adjustScale();
  };
  Geometry2.prototype.update = function(cfg) {
    if (cfg === void 0) {
      cfg = {};
    }
    var data = cfg.data, isDataChanged = cfg.isDataChanged, isCoordinateChanged = cfg.isCoordinateChanged;
    var _a3 = this, attributeOption = _a3.attributeOption, lastAttributeOption = _a3.lastAttributeOption;
    if (!is_equal_default(attributeOption, lastAttributeOption)) {
      this.init(cfg);
    } else if (data && (isDataChanged || !is_equal_default(data, this.data))) {
      this.setCfg(cfg);
      this.initAttributes();
      this.processData(data);
    } else {
      this.setCfg(cfg);
    }
    this.adjustScale();
    this.isCoordinateChanged = isCoordinateChanged;
  };
  Geometry2.prototype.paint = function(isUpdate) {
    var _this = this;
    if (isUpdate === void 0) {
      isUpdate = false;
    }
    if (this.animateOption) {
      this.animateOption = deep_mix_default({}, getDefaultAnimateCfg(this.type, this.coordinate), this.animateOption);
    }
    this.defaultSize = void 0;
    this.elementsMap = {};
    this.elements = [];
    var offscreenGroup = this.getOffscreenGroup();
    offscreenGroup.clear();
    var beforeMappingData = this.beforeMappingData;
    var dataArray = this.beforeMapping(beforeMappingData);
    this.dataArray = new Array(dataArray.length);
    for (var i = 0; i < dataArray.length; i++) {
      var data = dataArray[i];
      this.dataArray[i] = this.mapping(data);
    }
    this.updateElements(this.dataArray, isUpdate);
    this.lastElementsMap = this.elementsMap;
    if (this.canDoGroupAnimation(isUpdate)) {
      var container = this.container;
      var type = this.type;
      var coordinate = this.coordinate;
      var animateCfg = get_default(this.animateOption, "appear");
      var yScale = this.getYScale();
      var yMinPoint = coordinate.convert({
        x: 0,
        y: yScale.scale(this.getYMinValue())
      });
      doGroupAppearAnimate(container, animateCfg, type, coordinate, yMinPoint);
    }
    if (this.labelOption) {
      var deferred = this.useDeferredLabel;
      var callback = function() {
        return _this.renderLabels(flatten_default(_this.dataArray), isUpdate);
      }.bind(this);
      if (typeof deferred === "number") {
        var timeout2 = typeof deferred === "number" && deferred !== Infinity ? deferred : 0;
        if (!window.requestIdleCallback) {
          setTimeout(callback, timeout2);
        } else {
          var options = timeout2 && timeout2 !== Infinity ? { timeout: timeout2 } : void 0;
          window.requestIdleCallback(callback, options);
        }
      } else {
        callback();
      }
    }
    this.lastAttributeOption = __assign({}, this.attributeOption);
    if (this.visible === false) {
      this.changeVisible(false);
    }
  };
  Geometry2.prototype.clear = function() {
    var _a3 = this, container = _a3.container, geometryLabel = _a3.geometryLabel, offscreenGroup = _a3.offscreenGroup;
    if (container) {
      container.clear();
    }
    if (geometryLabel) {
      geometryLabel.clear();
    }
    if (offscreenGroup) {
      offscreenGroup.clear();
    }
    this.scaleDefs = void 0;
    this.attributes = {};
    this.scales = {};
    this.elementsMap = {};
    this.lastElementsMap = {};
    this.elements = [];
    this.adjusts = {};
    this.dataArray = null;
    this.beforeMappingData = null;
    this.lastAttributeOption = void 0;
    this.defaultSize = void 0;
    this.idFields = [];
    this.groupScales = void 0;
    this.hasSorted = false;
    this.isCoordinateChanged = false;
  };
  Geometry2.prototype.destroy = function() {
    this.clear();
    var container = this.container;
    container.remove(true);
    if (this.offscreenGroup) {
      this.offscreenGroup.remove(true);
      this.offscreenGroup = null;
    }
    if (this.geometryLabel) {
      this.geometryLabel.destroy();
      this.geometryLabel = null;
    }
    this.theme = void 0;
    this.shapeFactory = void 0;
    _super.prototype.destroy.call(this);
  };
  Geometry2.prototype.getGroupScales = function() {
    return this.groupScales;
  };
  Geometry2.prototype.getAttribute = function(name) {
    return this.attributes[name];
  };
  Geometry2.prototype.getXScale = function() {
    return this.getAttribute("position").scales[0];
  };
  Geometry2.prototype.getYScale = function() {
    return this.getAttribute("position").scales[1];
  };
  Geometry2.prototype.getGroupAttributes = function() {
    var rst = [];
    each_default(this.attributes, function(attr) {
      if (GROUP_ATTRS.includes(attr.type)) {
        rst.push(attr);
      }
    });
    return rst;
  };
  Geometry2.prototype.getDefaultValue = function(attrName) {
    var value;
    var attr = this.getAttribute(attrName);
    if (attr && is_empty_default(attr.scales)) {
      value = attr.values[0];
    }
    return value;
  };
  Geometry2.prototype.getAttributeValues = function(attr, obj) {
    var params = [];
    var scales = attr.scales;
    for (var index = 0, length_1 = scales.length; index < length_1; index++) {
      var scale5 = scales[index];
      var field = scale5.field;
      if (scale5.isIdentity) {
        params.push(scale5.values);
      } else {
        params.push(obj[field]);
      }
    }
    return attr.mapping.apply(attr, __spreadArray([], __read(params), false));
  };
  Geometry2.prototype.getAdjust = function(adjustType) {
    return this.adjusts[adjustType];
  };
  Geometry2.prototype.getCoordinate = function() {
    return this.coordinate;
  };
  Geometry2.prototype.getData = function() {
    return this.data;
  };
  Geometry2.prototype.getShapeMarker = function(shapeName, cfg) {
    var shapeFactory = this.getShapeFactory();
    return shapeFactory.getMarker(shapeName, cfg);
  };
  Geometry2.prototype.getElementsBy = function(condition) {
    return this.elements.filter(function(element) {
      return condition(element);
    });
  };
  Geometry2.prototype.getElements = function() {
    return this.elements;
  };
  Geometry2.prototype.getElementId = function(data) {
    data = is_array_default(data) ? data[0] : data;
    var originData = data[FIELD_ORIGIN];
    if (this.idFields.length) {
      var elementId = originData[this.idFields[0]];
      for (var index = 1; index < this.idFields.length; index++) {
        elementId += "-" + originData[this.idFields[index]];
      }
      return elementId;
    }
    var type = this.type;
    var xScale = this.getXScale();
    var yScale = this.getYScale();
    var xField = xScale.field || "x";
    var yField = yScale.field || "y";
    var yVal = originData[yField];
    var xVal;
    if (xScale.type === "identity") {
      xVal = xScale.values[0];
    } else {
      xVal = originData[xField];
    }
    var id;
    if (type === "interval" || type === "schema") {
      id = "".concat(xVal);
    } else if (type === "line" || type === "area" || type === "path") {
      id = type;
    } else {
      id = "".concat(xVal, "-").concat(yVal);
    }
    var groupScales = this.groupScales;
    for (var index = 0, length_2 = groupScales.length; index < length_2; index++) {
      var groupScale = groupScales[index];
      var field = groupScale.field;
      id = "".concat(id, "-").concat(originData[field]);
    }
    var dodgeAdjust = this.getAdjust("dodge");
    if (dodgeAdjust) {
      var dodgeBy = dodgeAdjust.dodgeBy;
      if (dodgeBy) {
        id = "".concat(id, "-").concat(originData[dodgeBy]);
      }
    }
    if (this.getAdjust("jitter")) {
      id = "".concat(id, "-").concat(data.x, "-").concat(data.y);
    }
    return id;
  };
  Geometry2.prototype.getScaleFields = function() {
    var fields = [];
    var tmpMap = /* @__PURE__ */ new Map();
    var _a3 = this, attributeOption = _a3.attributeOption, labelOption = _a3.labelOption, tooltipOption = _a3.tooltipOption;
    for (var attributeType in attributeOption) {
      if (attributeOption.hasOwnProperty(attributeType)) {
        var eachOpt = attributeOption[attributeType];
        if (eachOpt.fields) {
          uniq2(eachOpt.fields, fields, tmpMap);
        } else if (eachOpt.values) {
          uniq2(eachOpt.values, fields, tmpMap);
        }
      }
    }
    if (labelOption && labelOption.fields) {
      uniq2(labelOption.fields, fields, tmpMap);
    }
    if (is_object_default(tooltipOption) && tooltipOption.fields) {
      uniq2(tooltipOption.fields, fields, tmpMap);
    }
    return fields;
  };
  Geometry2.prototype.changeVisible = function(visible) {
    _super.prototype.changeVisible.call(this, visible);
    var elements = this.elements;
    for (var index = 0, length_3 = elements.length; index < length_3; index++) {
      var element = elements[index];
      element.changeVisible(visible);
    }
    if (visible) {
      if (this.container) {
        this.container.show();
      }
      if (this.labelsContainer) {
        this.labelsContainer.show();
      }
    } else {
      if (this.container) {
        this.container.hide();
      }
      if (this.labelsContainer) {
        this.labelsContainer.hide();
      }
    }
  };
  Geometry2.prototype.getFields = function() {
    var uniqMap = /* @__PURE__ */ new Map();
    var fields = [];
    Object.values(this.attributeOption).forEach(function(cfg) {
      var fs = (cfg === null || cfg === void 0 ? void 0 : cfg.fields) || [];
      fs.forEach(function(f) {
        if (!uniqMap.has(f)) {
          fields.push(f);
        }
        uniqMap.set(f, true);
      });
    }, []);
    return fields;
  };
  Geometry2.prototype.getGroupFields = function() {
    var groupFields = [];
    var tmpMap = /* @__PURE__ */ new Map();
    for (var index = 0, length_4 = GROUP_ATTRS.length; index < length_4; index++) {
      var attributeName = GROUP_ATTRS[index];
      var cfg = this.attributeOption[attributeName];
      if (cfg && cfg.fields) {
        uniq2(cfg.fields, groupFields, tmpMap);
      }
    }
    return groupFields;
  };
  Geometry2.prototype.getXYFields = function() {
    var _a3 = __read(this.attributeOption.position.fields, 2), x = _a3[0], y = _a3[1];
    return [x, y];
  };
  Geometry2.prototype.getXField = function() {
    return get_default(this.getXYFields(), [0]);
  };
  Geometry2.prototype.getYField = function() {
    return get_default(this.getXYFields(), [1]);
  };
  Geometry2.prototype.getShapes = function() {
    return this.elements.map(function(element) {
      return element.shape;
    });
  };
  Geometry2.prototype.getOffscreenGroup = function() {
    if (!this.offscreenGroup) {
      var GroupCtor = this.container.getGroupBase();
      this.offscreenGroup = new GroupCtor({});
    }
    return this.offscreenGroup;
  };
  Geometry2.prototype.sort = function(mappingArray) {
    if (!this.hasSorted) {
      var xScale_1 = this.getXScale();
      var xField_1 = xScale_1.field;
      for (var index = 0; index < mappingArray.length; index++) {
        var itemArr = mappingArray[index];
        itemArr.sort(function(obj1, obj2) {
          return xScale_1.translate(obj1[FIELD_ORIGIN][xField_1]) - xScale_1.translate(obj2[FIELD_ORIGIN][xField_1]);
        });
      }
    }
    this.hasSorted = true;
  };
  Geometry2.prototype.adjustScale = function() {
    var yScale = this.getYScale();
    if (yScale && this.getAdjust("stack")) {
      this.updateStackRange(yScale, this.beforeMappingData);
    }
  };
  Geometry2.prototype.getShapeFactory = function() {
    var shapeType = this.shapeType;
    if (!getShapeFactory(shapeType)) {
      return;
    }
    if (!this.shapeFactory) {
      this.shapeFactory = clone_default(getShapeFactory(shapeType));
    }
    this.shapeFactory.coordinate = this.coordinate;
    this.shapeFactory.theme = this.theme.geometries[shapeType] || {};
    return this.shapeFactory;
  };
  Geometry2.prototype.createShapePointsCfg = function(obj) {
    var xScale = this.getXScale();
    var yScale = this.getYScale();
    var x = this.normalizeValues(obj[xScale.field], xScale);
    var y;
    if (yScale) {
      y = this.normalizeValues(obj[yScale.field], yScale);
    } else {
      y = obj.y ? obj.y : 0.1;
    }
    return {
      x,
      y,
      y0: yScale ? yScale.scale(this.getYMinValue()) : void 0
    };
  };
  Geometry2.prototype.createElement = function(mappingDatum, index, isUpdate) {
    if (isUpdate === void 0) {
      isUpdate = false;
    }
    var container = this.container;
    var shapeCfg = this.getDrawCfg(mappingDatum);
    var shapeFactory = this.getShapeFactory();
    var element = new element_default2({
      shapeFactory,
      container,
      offscreenGroup: this.getOffscreenGroup(),
      elementIndex: index
    });
    element.animate = this.animateOption;
    element.geometry = this;
    element.draw(shapeCfg, isUpdate);
    return element;
  };
  Geometry2.prototype.getDrawCfg = function(mappingDatum) {
    var originData = mappingDatum[FIELD_ORIGIN];
    var cfg = {
      mappingData: mappingDatum,
      data: originData,
      x: mappingDatum.x,
      y: mappingDatum.y,
      color: mappingDatum.color,
      size: mappingDatum.size,
      isInCircle: this.coordinate.isPolar,
      customInfo: this.customOption
    };
    var shapeName = mappingDatum.shape;
    if (!shapeName && this.getShapeFactory()) {
      shapeName = this.getShapeFactory().defaultShapeType;
    }
    cfg.shape = shapeName;
    var theme = this.theme.geometries[this.shapeType];
    cfg.defaultStyle = get_default(theme, [shapeName, "default"], {}).style;
    if (!cfg.defaultStyle && this.getShapeFactory()) {
      cfg.defaultStyle = this.getShapeFactory().getDefaultStyle(theme);
    }
    var styleOption = this.styleOption;
    if (styleOption) {
      cfg.style = this.getStyleCfg(styleOption, originData);
    }
    if (this.generatePoints) {
      cfg.points = mappingDatum.points;
      cfg.nextPoints = mappingDatum.nextPoints;
    }
    return cfg;
  };
  Geometry2.prototype.updateElements = function(mappingDataArray, isUpdate) {
    var e_1, _a3, e_2, _b, e_3, _c;
    if (isUpdate === void 0) {
      isUpdate = false;
    }
    var keyDatum = /* @__PURE__ */ new Map();
    var keys2 = [];
    var keyIndex = /* @__PURE__ */ new Map();
    var index = 0;
    for (var i = 0; i < mappingDataArray.length; i++) {
      var mappingData = mappingDataArray[i];
      for (var j = 0; j < mappingData.length; j++) {
        var mappingDatum = mappingData[j];
        var key = this.getElementId(mappingDatum);
        var finalKey = keyDatum.has(key) ? "".concat(key, "-").concat(i, "-").concat(j) : key;
        keys2.push(finalKey);
        keyDatum.set(finalKey, mappingDatum);
        keyIndex.set(finalKey, index);
        index++;
      }
    }
    this.elements = new Array(index);
    var _d = diff(this.lastElementsMap, keys2), added = _d.added, updated = _d.updated, removed = _d.removed;
    try {
      for (var added_1 = __values(added), added_1_1 = added_1.next(); !added_1_1.done; added_1_1 = added_1.next()) {
        var key = added_1_1.value;
        var mappingDatum = keyDatum.get(key);
        var i = keyIndex.get(key);
        var element = this.createElement(mappingDatum, i, isUpdate);
        this.elements[i] = element;
        this.elementsMap[key] = element;
        if (element.shape) {
          element.shape.set("zIndex", this.zIndexReversed ? this.elements.length - i : i);
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (added_1_1 && !added_1_1.done && (_a3 = added_1.return))
          _a3.call(added_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    try {
      for (var updated_1 = __values(updated), updated_1_1 = updated_1.next(); !updated_1_1.done; updated_1_1 = updated_1.next()) {
        var key = updated_1_1.value;
        var element = this.lastElementsMap[key];
        var mappingDatum = keyDatum.get(key);
        var currentShapeCfg = this.getDrawCfg(mappingDatum);
        var preShapeCfg = element.getModel();
        var i = keyIndex.get(key);
        if (this.isCoordinateChanged || isModelChange(currentShapeCfg, preShapeCfg)) {
          element.animate = this.animateOption;
          element.update(currentShapeCfg);
        }
        this.elements[i] = element;
        this.elementsMap[key] = element;
        if (element.shape) {
          element.shape.set("zIndex", this.zIndexReversed ? this.elements.length - i : i);
        }
      }
    } catch (e_2_1) {
      e_2 = { error: e_2_1 };
    } finally {
      try {
        if (updated_1_1 && !updated_1_1.done && (_b = updated_1.return))
          _b.call(updated_1);
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
    if (this.container) {
      this.container.sort();
    }
    try {
      for (var removed_1 = __values(removed), removed_1_1 = removed_1.next(); !removed_1_1.done; removed_1_1 = removed_1.next()) {
        var key = removed_1_1.value;
        var element = this.lastElementsMap[key];
        element.animate = this.animateOption;
        element.destroy();
      }
    } catch (e_3_1) {
      e_3 = { error: e_3_1 };
    } finally {
      try {
        if (removed_1_1 && !removed_1_1.done && (_c = removed_1.return))
          _c.call(removed_1);
      } finally {
        if (e_3)
          throw e_3.error;
      }
    }
  };
  Geometry2.prototype.getLabelType = function() {
    var _a3 = this, labelOption = _a3.labelOption, coordinate = _a3.coordinate, type = _a3.type;
    var coordinateType = coordinate.type, isTransposed = coordinate.isTransposed;
    var labelType = get_default(labelOption, ["cfg", "type"]);
    if (!labelType) {
      if (coordinateType === "polar") {
        labelType = isTransposed ? "pie" : "polar";
      } else if (coordinateType === "theta") {
        labelType = "pie";
      } else if (type === "interval" || type === "polygon") {
        labelType = "interval";
      } else {
        labelType = "base";
      }
    }
    return labelType;
  };
  Geometry2.prototype.getYMinValue = function() {
    var yScale = this.getYScale();
    var min3 = yScale.min, max3 = yScale.max;
    var value;
    if (min3 >= 0) {
      value = min3;
    } else if (max3 <= 0) {
      value = max3;
    } else {
      value = 0;
    }
    return value;
  };
  Geometry2.prototype.createAttrOption = function(attrName, field, cfg) {
    if (is_nil_default(field) || is_object_default(field)) {
      if (is_object_default(field) && is_equal_default(Object.keys(field), ["values"])) {
        set_default(this.attributeOption, attrName, {
          fields: field.values
        });
      } else {
        set_default(this.attributeOption, attrName, field);
      }
    } else {
      var attrCfg = {};
      if (is_number_default(field)) {
        attrCfg.values = [field];
      } else {
        attrCfg.fields = parseFields(field);
      }
      if (cfg) {
        if (is_function_default(cfg)) {
          attrCfg.callback = cfg;
        } else {
          attrCfg.values = cfg;
        }
      }
      set_default(this.attributeOption, attrName, attrCfg);
    }
  };
  Geometry2.prototype.initAttributes = function() {
    var _this = this;
    var _a3 = this, attributes = _a3.attributes, attributeOption = _a3.attributeOption, theme = _a3.theme, shapeType = _a3.shapeType;
    this.groupScales = [];
    var tmpMap = {};
    var _loop_1 = function(attrType2) {
      if (attributeOption.hasOwnProperty(attrType2)) {
        var option = attributeOption[attrType2];
        if (!option) {
          return { value: void 0 };
        }
        var attrCfg = __assign({}, option);
        var callback = attrCfg.callback, values2 = attrCfg.values, _b = attrCfg.fields, fields = _b === void 0 ? [] : _b;
        var scales = fields.map(function(field) {
          var scale5 = _this.scales[field];
          if (!tmpMap[field] && GROUP_ATTRS.includes(attrType2)) {
            var inferedScaleType = inferScaleType(scale5, get_default(_this.scaleDefs, field), attrType2, _this.type);
            if (inferedScaleType === "cat") {
              _this.groupScales.push(scale5);
              tmpMap[field] = true;
            }
          }
          return scale5;
        });
        attrCfg.scales = scales;
        if (attrType2 !== "position" && scales.length === 1 && scales[0].type === "identity") {
          attrCfg.values = scales[0].values;
        } else if (!callback && !values2) {
          if (attrType2 === "size") {
            attrCfg.values = theme.sizes;
          } else if (attrType2 === "shape") {
            attrCfg.values = theme.shapes[shapeType] || [];
          } else if (attrType2 === "color") {
            if (scales.length) {
              attrCfg.values = scales[0].values.length <= 10 ? theme.colors10 : theme.colors20;
            } else {
              attrCfg.values = theme.colors10;
            }
          }
        }
        var AttributeCtor = getAttribute(attrType2);
        attributes[attrType2] = new AttributeCtor(attrCfg);
      }
    };
    for (var attrType in attributeOption) {
      var state_1 = _loop_1(attrType);
      if (typeof state_1 === "object")
        return state_1.value;
    }
  };
  Geometry2.prototype.processData = function(data) {
    var e_4, _a3;
    this.hasSorted = false;
    var scales = this.getAttribute("position").scales;
    var categoryScales = scales.filter(function(scale6) {
      return scale6.isCategory;
    });
    var groupedArray = this.groupData(data);
    var beforeAdjust = [];
    for (var i = 0, len3 = groupedArray.length; i < len3; i++) {
      var subData = groupedArray[i];
      var arr = [];
      for (var j = 0, subLen = subData.length; j < subLen; j++) {
        var originData = subData[j];
        var item = {};
        for (var k in originData) {
          item[k] = originData[k];
        }
        item[FIELD_ORIGIN] = originData;
        try {
          for (var categoryScales_1 = (e_4 = void 0, __values(categoryScales)), categoryScales_1_1 = categoryScales_1.next(); !categoryScales_1_1.done; categoryScales_1_1 = categoryScales_1.next()) {
            var scale5 = categoryScales_1_1.value;
            var field = scale5.field;
            item[field] = scale5.translate(item[field]);
          }
        } catch (e_4_1) {
          e_4 = { error: e_4_1 };
        } finally {
          try {
            if (categoryScales_1_1 && !categoryScales_1_1.done && (_a3 = categoryScales_1.return))
              _a3.call(categoryScales_1);
          } finally {
            if (e_4)
              throw e_4.error;
          }
        }
        arr.push(item);
      }
      beforeAdjust.push(arr);
    }
    var dataArray = this.adjustData(beforeAdjust);
    this.beforeMappingData = dataArray;
    return dataArray;
  };
  Geometry2.prototype.adjustData = function(dataArray) {
    var adjustOption = this.adjustOption;
    var _a3 = this, intervalPadding = _a3.intervalPadding, dodgePadding = _a3.dodgePadding, theme = _a3.theme;
    var maxColumnWidth = this.maxColumnWidth || theme.maxColumnWidth;
    var minColumnWidth = this.minColumnWidth || theme.minColumnWidth;
    var columnWidthRatio = this.columnWidthRatio || theme.columnWidthRatio;
    var result = dataArray;
    if (adjustOption) {
      var xScale_2 = this.getXScale();
      var yScale = this.getYScale();
      var xField = xScale_2.field;
      var yField = yScale ? yScale.field : null;
      var xDimensionLength = getXDimensionLength(this.coordinate);
      var groupNum = xScale_2.values.length;
      var sizeAttr = this.getAttribute("size");
      var defaultSize = void 0;
      if (sizeAttr) {
        defaultSize = sizeAttr.values[0];
      }
      for (var i = 0, len3 = adjustOption.length; i < len3; i++) {
        var adjust = adjustOption[i];
        var adjustCfg = __assign({ xField, yField, intervalPadding, dodgePadding, xDimensionLength, groupNum, defaultSize, maxColumnWidth, minColumnWidth, columnWidthRatio }, adjust);
        var type = adjust.type;
        if (type === "dodge") {
          var adjustNames = [];
          if (xScale_2.isCategory || xScale_2.type === "identity") {
            adjustNames.push("x");
          } else if (!yScale) {
            adjustNames.push("y");
          } else {
            throw new Error("dodge is not support linear attribute, please use category attribute!");
          }
          adjustCfg.adjustNames = adjustNames;
          adjustCfg.dodgeRatio = columnWidthRatio;
        } else if (type === "stack") {
          var coordinate = this.coordinate;
          if (!yScale) {
            adjustCfg.height = coordinate.getHeight();
            var size2 = this.getDefaultValue("size") || 3;
            adjustCfg.size = size2;
          }
          if (!coordinate.isTransposed && is_nil_default(adjustCfg.reverseOrder)) {
            adjustCfg.reverseOrder = true;
          }
        }
        var adjustCtor = getAdjust(type);
        adjustCfg.dimValuesMap = {};
        if (xScale_2 && xScale_2.values) {
          adjustCfg.dimValuesMap[xScale_2.field] = xScale_2.values.map(function(v) {
            return xScale_2.translate(v);
          });
        }
        var adjustInstance = new adjustCtor(adjustCfg);
        result = adjustInstance.process(result);
        this.adjusts[type] = adjustInstance;
      }
    }
    return result;
  };
  Geometry2.prototype.groupData = function(data) {
    var groupScales = this.getGroupScales();
    var scaleDefs = this.scaleDefs;
    var appendConditions = {};
    var groupFields = [];
    for (var index = 0; index < groupScales.length; index++) {
      var scale5 = groupScales[index];
      var field = scale5.field;
      groupFields.push(field);
      if (get_default(scaleDefs, [field, "values"])) {
        appendConditions[field] = scaleDefs[field].values;
      }
    }
    return group(data, groupFields, appendConditions);
  };
  Geometry2.prototype.updateStackRange = function(scale5, dataArray) {
    var mergeArray = flatten_default(dataArray);
    var field = scale5.field;
    var min3 = scale5.min;
    var max3 = scale5.max;
    for (var index = 0; index < mergeArray.length; index++) {
      var obj = mergeArray[index];
      var tmpMin = Math.min.apply(null, obj[field]);
      var tmpMax = Math.max.apply(null, obj[field]);
      if (tmpMin < min3) {
        min3 = tmpMin;
      }
      if (tmpMax > max3) {
        max3 = tmpMax;
      }
    }
    var scaleDefs = this.scaleDefs;
    var cfg = {};
    if (min3 < scale5.min && !get_default(scaleDefs, [field, "min"])) {
      cfg.min = min3;
    }
    if (max3 > scale5.max && !get_default(scaleDefs, [field, "max"])) {
      cfg.max = max3;
    }
    scale5.change(cfg);
  };
  Geometry2.prototype.beforeMapping = function(beforeMappingData) {
    var source = beforeMappingData;
    if (this.sortable) {
      this.sort(source);
    }
    if (this.generatePoints) {
      for (var index = 0, length_5 = source.length; index < length_5; index++) {
        var currentData = source[index];
        this.generateShapePoints(currentData);
        var nextData = source[index + 1];
        if (nextData) {
          this.generateShapePoints(nextData);
          currentData[0].nextPoints = nextData[0].points;
        }
      }
    }
    return source;
  };
  Geometry2.prototype.generateShapePoints = function(data) {
    var shapeFactory = this.getShapeFactory();
    var shapeAttr = this.getAttribute("shape");
    for (var index = 0; index < data.length; index++) {
      var obj = data[index];
      var cfg = this.createShapePointsCfg(obj);
      var shape = shapeAttr ? this.getAttributeValues(shapeAttr, obj) : null;
      var points = shapeFactory.getShapePoints(shape, cfg);
      obj.points = points;
    }
  };
  Geometry2.prototype.normalizeValues = function(values2, scale5) {
    var rst = [];
    if (is_array_default(values2)) {
      for (var index = 0; index < values2.length; index++) {
        var value = values2[index];
        rst.push(scale5.scale(value));
      }
    } else {
      rst = scale5.scale(values2);
    }
    return rst;
  };
  Geometry2.prototype.mapping = function(data) {
    var attributes = this.attributes;
    var mappingData = [];
    for (var index = 0; index < data.length; index++) {
      var record = data[index];
      var newRecord = {
        _origin: record[FIELD_ORIGIN],
        points: record.points,
        nextPoints: record.nextPoints
      };
      for (var k in attributes) {
        if (attributes.hasOwnProperty(k)) {
          var attr = attributes[k];
          var names = attr.names;
          var values2 = this.getAttributeValues(attr, record);
          if (names.length > 1) {
            for (var j = 0; j < values2.length; j += 1) {
              var val = values2[j];
              var name_1 = names[j];
              newRecord[name_1] = is_array_default(val) && val.length === 1 ? val[0] : val;
            }
          } else {
            newRecord[names[0]] = values2.length === 1 ? values2[0] : values2;
          }
        }
      }
      this.convertPoint(newRecord);
      mappingData.push(newRecord);
    }
    return mappingData;
  };
  Geometry2.prototype.convertPoint = function(mappingRecord) {
    var x = mappingRecord.x, y = mappingRecord.y;
    var rstX;
    var rstY;
    var obj;
    var coordinate = this.coordinate;
    if (is_array_default(x) && is_array_default(y)) {
      rstX = [];
      rstY = [];
      for (var i = 0, j = 0, xLen = x.length, yLen = y.length; i < xLen && j < yLen; i += 1, j += 1) {
        obj = coordinate.convert({
          x: x[i],
          y: y[j]
        });
        rstX.push(obj.x);
        rstY.push(obj.y);
      }
    } else if (is_array_default(y)) {
      rstY = [];
      for (var index = 0; index < y.length; index++) {
        var yVal = y[index];
        obj = coordinate.convert({
          x,
          y: yVal
        });
        if (rstX && rstX !== obj.x) {
          if (!is_array_default(rstX)) {
            rstX = [rstX];
          }
          rstX.push(obj.x);
        } else {
          rstX = obj.x;
        }
        rstY.push(obj.y);
      }
    } else if (is_array_default(x)) {
      rstX = [];
      for (var index = 0; index < x.length; index++) {
        var xVal = x[index];
        obj = coordinate.convert({
          x: xVal,
          y
        });
        if (rstY && rstY !== obj.y) {
          if (!is_array_default(rstY)) {
            rstY = [rstY];
          }
          rstY.push(obj.y);
        } else {
          rstY = obj.y;
        }
        rstX.push(obj.x);
      }
    } else {
      var point = coordinate.convert({
        x,
        y
      });
      rstX = point.x;
      rstY = point.y;
    }
    mappingRecord.x = rstX;
    mappingRecord.y = rstY;
  };
  Geometry2.prototype.getStyleCfg = function(styleOption, originData) {
    var _a3 = styleOption.fields, fields = _a3 === void 0 ? [] : _a3, callback = styleOption.callback, cfg = styleOption.cfg;
    if (cfg) {
      return cfg;
    }
    var params = fields.map(function(field) {
      return originData[field];
    });
    return callback.apply(void 0, __spreadArray([], __read(params), false));
  };
  Geometry2.prototype.setCfg = function(cfg) {
    var _this = this;
    var coordinate = cfg.coordinate, data = cfg.data, theme = cfg.theme, scaleDefs = cfg.scaleDefs;
    if (coordinate) {
      this.coordinate = coordinate;
    }
    if (data) {
      this.data = data;
    }
    if (scaleDefs) {
      this.scaleDefs = scaleDefs;
      this.idFields = [];
      each_default(scaleDefs, function(scaleDef, field) {
        if (scaleDef && scaleDef.key) {
          _this.idFields.push(field);
        }
      });
    }
    if (theme) {
      this.theme = this.userTheme ? deep_mix_default({}, theme, this.userTheme) : theme;
    }
  };
  Geometry2.prototype.renderLabels = function(mappingArray, isUpdate) {
    if (isUpdate === void 0) {
      isUpdate = false;
    }
    return __awaiter(this, void 0, void 0, function() {
      var geometryLabel, labelType, GeometryLabelsCtor, labelsMap, elementLabels, _a3, _b, _c, element, labels;
      var e_5, _d;
      var _this = this;
      return __generator(this, function(_e) {
        switch (_e.label) {
          case 0:
            geometryLabel = this.geometryLabel;
            this.emit(GEOMETRY_LIFE_CIRCLE.BEFORE_RENDER_LABEL);
            if (!geometryLabel) {
              labelType = this.getLabelType();
              GeometryLabelsCtor = getGeometryLabel(labelType);
              geometryLabel = new GeometryLabelsCtor(this);
              this.geometryLabel = geometryLabel;
            }
            return [4, geometryLabel.render(mappingArray, isUpdate)];
          case 1:
            _e.sent();
            labelsMap = geometryLabel.labelsRenderer.shapesMap;
            elementLabels = /* @__PURE__ */ new Map();
            each_default(labelsMap, function(labelGroup, labelGroupId) {
              var labelChildren = labelGroup.getChildren() || [];
              for (var j = 0; j < labelChildren.length; j++) {
                var labelShape = labelChildren[j];
                var element2 = _this.elementsMap[labelShape.get("elementId") || labelGroupId.split(" ")[0]];
                if (element2) {
                  labelShape.cfg.name = ["element", "label"];
                  labelShape.cfg.element = element2;
                  var labels2 = elementLabels.get(element2) || /* @__PURE__ */ new Set();
                  labels2.add(labelGroup);
                  elementLabels.set(element2, labels2);
                }
              }
            });
            try {
              for (_a3 = __values(elementLabels.entries()), _b = _a3.next(); !_b.done; _b = _a3.next()) {
                _c = __read(_b.value, 2), element = _c[0], labels = _c[1];
                element.labelShape = __spreadArray([], __read(labels), false);
              }
            } catch (e_5_1) {
              e_5 = { error: e_5_1 };
            } finally {
              try {
                if (_b && !_b.done && (_d = _a3.return))
                  _d.call(_a3);
              } finally {
                if (e_5)
                  throw e_5.error;
              }
            }
            this.emit(GEOMETRY_LIFE_CIRCLE.AFTER_RENDER_LABEL);
            return [2];
        }
      });
    });
  };
  Geometry2.prototype.canDoGroupAnimation = function(isUpdate) {
    return !isUpdate && this.animateOption && (get_default(this.animateOption, "appear") === void 0 || get_default(this.animateOption, "appear") && get_default(this.animateOption, ["appear", "animation"]) === void 0);
  };
  return Geometry2;
}(base_default);
var base_default13 = Geometry;

// node_modules/@antv/g2/esm/util/transform.js
var transform3 = ext_exports.transform;
function translate2(element, x, y) {
  var matrix = transform3(element.getMatrix(), [["t", x, y]]);
  element.setMatrix(matrix);
}
function getRotateMatrix(element, rotateRadian) {
  var _a3 = element.attr(), x = _a3.x, y = _a3.y;
  var matrix = transform3(element.getMatrix(), [
    ["t", -x, -y],
    ["r", rotateRadian],
    ["t", x, y]
  ]);
  return matrix;
}
function rotate4(element, rotateRadian) {
  var matrix = getRotateMatrix(element, rotateRadian);
  element.setMatrix(matrix);
}
function zoom(element, ratio) {
  var bbox = element.getBBox();
  var x = (bbox.minX + bbox.maxX) / 2;
  var y = (bbox.minY + bbox.maxY) / 2;
  element.applyToMatrix([x, y, 1]);
  var matrix = transform3(element.getMatrix(), [
    ["t", -x, -y],
    ["s", ratio, ratio],
    ["t", x, y]
  ]);
  element.setMatrix(matrix);
}

// node_modules/@antv/g2/esm/geometry/label/util/index.js
function findLabelTextShape(label) {
  return label.find(function(el) {
    return el.get("type") === "text";
  });
}
function getLabelBackgroundInfo(labelGroup, labelItem, padding) {
  if (padding === void 0) {
    padding = [0, 0, 0, 0];
  }
  var content = labelGroup && labelGroup.getChildren()[0];
  if (content) {
    var labelShape = content.clone();
    if (labelItem === null || labelItem === void 0 ? void 0 : labelItem.rotate) {
      rotate4(labelShape, -labelItem.rotate);
    }
    var _a3 = labelShape.getCanvasBBox(), x = _a3.x, y = _a3.y, width = _a3.width, height = _a3.height;
    labelShape.destroy();
    var boxPadding = padding;
    if (is_nil_default(boxPadding)) {
      boxPadding = [2, 2, 2, 2];
    } else if (is_number_default(boxPadding)) {
      boxPadding = new Array(4).fill(boxPadding);
    }
    return {
      x: x - boxPadding[3],
      y: y - boxPadding[0],
      width: width + boxPadding[1] + boxPadding[3],
      height: height + boxPadding[0] + boxPadding[2],
      rotation: (labelItem === null || labelItem === void 0 ? void 0 : labelItem.rotate) || 0
    };
  }
  return { x: 0, y: 0, width: 0, height: 0, rotation: 0 };
}
function getOverlapArea(a, b, margin) {
  if (margin === void 0) {
    margin = 0;
  }
  var xOverlap = Math.max(0, Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin));
  var yOverlap = Math.max(0, Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin));
  return xOverlap * yOverlap;
}
function checkShapeOverlap(cur, dones) {
  var box2 = cur.getBBox();
  return some_default(dones, function(done) {
    var target = done.getBBox();
    return getOverlapArea(box2, target, 2) > 0;
  });
}

// node_modules/@antv/g2/esm/component/update-label.js
function updateLabel(fromShape, toShape, cfg) {
  var data = cfg.data, origin = cfg.origin, animateCfg = cfg.animateCfg, coordinate = cfg.coordinate;
  var updateAnimateCfg = get_default(animateCfg, "update");
  fromShape.set("data", data);
  fromShape.set("origin", origin);
  fromShape.set("animateCfg", animateCfg);
  fromShape.set("coordinate", coordinate);
  fromShape.set("visible", toShape.get("visible"));
  (fromShape.getChildren() || []).forEach(function(fromChild, idx) {
    var toChild = toShape.getChildByIndex(idx);
    if (!toChild) {
      fromShape.removeChild(fromChild);
      fromChild.remove(true);
    } else {
      fromChild.set("data", data);
      fromChild.set("origin", origin);
      fromChild.set("animateCfg", animateCfg);
      fromChild.set("coordinate", coordinate);
      var newAttrs = getReplaceAttrs(fromChild, toChild);
      if (updateAnimateCfg) {
        doAnimate(fromChild, updateAnimateCfg, {
          toAttrs: newAttrs,
          coordinate
        });
      } else {
        fromChild.attr(newAttrs);
      }
      if (toChild.isGroup()) {
        updateLabel(fromChild, toChild, cfg);
      }
    }
  });
  each_default(toShape.getChildren(), function(child, idx) {
    if (idx >= fromShape.getCount()) {
      if (!child.destroyed) {
        fromShape.add(child);
      }
    }
  });
}

// node_modules/@antv/g2/esm/component/labels.js
var Labels = function() {
  function Labels2(cfg) {
    this.shapesMap = {};
    var layout2 = cfg.layout, container = cfg.container;
    this.layout = layout2;
    this.container = container;
  }
  Labels2.prototype.render = function(items, shapes, isUpdate) {
    if (isUpdate === void 0) {
      isUpdate = false;
    }
    return __awaiter(this, void 0, void 0, function() {
      var shapesMap, offscreenGroup, items_1, items_1_1, item, lastShapesMap;
      var e_1, _a3;
      var _this = this;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            shapesMap = {};
            offscreenGroup = this.createOffscreenGroup();
            if (!items.length)
              return [3, 2];
            try {
              for (items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
                item = items_1_1.value;
                if (item) {
                  shapesMap[item.id] = this.renderLabel(item, offscreenGroup);
                }
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (items_1_1 && !items_1_1.done && (_a3 = items_1.return))
                  _a3.call(items_1);
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
            return [4, this.doLayout(items, shapes, shapesMap)];
          case 1:
            _b.sent();
            this.renderLabelLine(items, shapesMap);
            this.renderLabelBackground(items, shapesMap);
            this.adjustLabel(items, shapesMap);
            _b.label = 2;
          case 2:
            lastShapesMap = this.shapesMap;
            each_default(shapesMap, function(shape, id) {
              if (shape.destroyed) {
                delete shapesMap[id];
              } else {
                if (lastShapesMap[id]) {
                  var data = shape.get("data");
                  var origin_1 = shape.get("origin");
                  var coordinate = shape.get("coordinate");
                  var currentAnimateCfg = shape.get("animateCfg");
                  var currentShape = lastShapesMap[id];
                  updateLabel(currentShape, shapesMap[id], {
                    data,
                    origin: origin_1,
                    animateCfg: currentAnimateCfg,
                    coordinate
                  });
                  shapesMap[id] = currentShape;
                } else {
                  if (_this.container.destroyed)
                    return;
                  _this.container.add(shape);
                  var animateCfg = get_default(shape.get("animateCfg"), isUpdate ? "enter" : "appear");
                  if (animateCfg) {
                    doAnimate(shape, animateCfg, {
                      toAttrs: __assign({}, shape.attr()),
                      coordinate: shape.get("coordinate")
                    });
                  }
                }
                delete lastShapesMap[id];
              }
            });
            each_default(lastShapesMap, function(deleteShape) {
              var animateCfg = get_default(deleteShape.get("animateCfg"), "leave");
              if (animateCfg) {
                doAnimate(deleteShape, animateCfg, {
                  toAttrs: null,
                  coordinate: deleteShape.get("coordinate")
                });
              } else {
                deleteShape.remove(true);
              }
            });
            this.shapesMap = shapesMap;
            offscreenGroup.destroy();
            return [2];
        }
      });
    });
  };
  Labels2.prototype.clear = function() {
    this.container.clear();
    this.shapesMap = {};
  };
  Labels2.prototype.destroy = function() {
    this.container.destroy();
    this.shapesMap = null;
  };
  Labels2.prototype.renderLabel = function(cfg, container) {
    var id = cfg.id, elementId = cfg.elementId, data = cfg.data, mappingData = cfg.mappingData, coordinate = cfg.coordinate, animate = cfg.animate, content = cfg.content, capture = cfg.capture;
    var shapeAppendCfg = {
      id,
      elementId,
      capture,
      data,
      origin: __assign(__assign({}, mappingData), { data: mappingData[FIELD_ORIGIN] }),
      coordinate
    };
    var labelGroup = container.addGroup(__assign({
      name: "label",
      animateCfg: this.animate === false || animate === null || animate === false ? false : deep_mix_default({}, this.animate, animate)
    }, shapeAppendCfg));
    var labelShape;
    if (content.isGroup && content.isGroup() || content.isShape && content.isShape()) {
      var _a3 = content.getCanvasBBox(), width = _a3.width, height = _a3.height;
      var textAlign = get_default(cfg, "textAlign", "left");
      var x = cfg.x;
      var y = cfg.y - height / 2;
      if (textAlign === "center") {
        x = x - width / 2;
      } else if (textAlign === "right" || textAlign === "end") {
        x = x - width;
      }
      translate2(content, x, y);
      labelShape = content;
      labelGroup.add(content);
    } else {
      var fill = get_default(cfg, ["style", "fill"]);
      labelShape = labelGroup.addShape("text", __assign({ attrs: __assign(__assign({ x: cfg.x, y: cfg.y, textAlign: cfg.textAlign, textBaseline: get_default(cfg, "textBaseline", "middle"), text: cfg.content }, cfg.style), { fill: is_null_default(fill) ? cfg.color : fill }) }, shapeAppendCfg));
    }
    if (cfg.rotate) {
      rotate4(labelShape, cfg.rotate);
    }
    return labelGroup;
  };
  Labels2.prototype.doLayout = function(items, shapes, shapesMap) {
    return __awaiter(this, void 0, void 0, function() {
      var layouts;
      var _this = this;
      return __generator(this, function(_a3) {
        switch (_a3.label) {
          case 0:
            if (!this.layout)
              return [3, 2];
            layouts = is_array_default(this.layout) ? this.layout : [this.layout];
            return [4, Promise.all(layouts.map(function(layout2) {
              var layoutFn = getGeometryLabelLayout(get_default(layout2, "type", ""));
              if (!layoutFn)
                return;
              var labelShapes = [];
              var geometryShapes = [];
              each_default(shapesMap, function(labelShape, id) {
                labelShapes.push(labelShape);
                geometryShapes.push(shapes[labelShape.get("elementId")]);
              });
              return layoutFn(items, labelShapes, geometryShapes, _this.region, layout2.cfg);
            }))];
          case 1:
            _a3.sent();
            _a3.label = 2;
          case 2:
            return [2];
        }
      });
    });
  };
  Labels2.prototype.renderLabelLine = function(labelItems, shapesMap) {
    each_default(labelItems, function(labelItem) {
      var coordinate = get_default(labelItem, "coordinate");
      if (!labelItem || !coordinate) {
        return;
      }
      var center = coordinate.getCenter();
      var radius = coordinate.getRadius();
      if (!labelItem.labelLine) {
        return;
      }
      var labelLineCfg = get_default(labelItem, "labelLine", {});
      var id = labelItem.id;
      var path = labelLineCfg.path;
      if (!path) {
        var start = polarToCartesian(center.x, center.y, radius, labelItem.angle);
        path = [
          ["M", start.x, start.y],
          ["L", labelItem.x, labelItem.y]
        ];
      }
      var labelGroup = shapesMap[id];
      if (!labelGroup.destroyed) {
        labelGroup.addShape("path", {
          capture: false,
          attrs: __assign({ path, stroke: labelItem.color ? labelItem.color : get_default(labelItem, ["style", "fill"], "#000"), fill: null }, labelLineCfg.style),
          id,
          origin: labelItem.mappingData,
          data: labelItem.data,
          coordinate: labelItem.coordinate
        });
      }
    });
  };
  Labels2.prototype.renderLabelBackground = function(labelItems, shapesMap) {
    each_default(labelItems, function(labelItem) {
      var coordinate = get_default(labelItem, "coordinate");
      var background = get_default(labelItem, "background");
      if (!background || !coordinate) {
        return;
      }
      var id = labelItem.id;
      var labelGroup = shapesMap[id];
      if (!labelGroup.destroyed) {
        var labelContentShape = labelGroup.getChildren()[0];
        if (labelContentShape) {
          var _a3 = getLabelBackgroundInfo(labelGroup, labelItem, background.padding), rotation = _a3.rotation, box2 = __rest(_a3, ["rotation"]);
          var backgroundShape = labelGroup.addShape("rect", {
            attrs: __assign(__assign({}, box2), background.style || {}),
            id,
            origin: labelItem.mappingData,
            data: labelItem.data,
            coordinate: labelItem.coordinate
          });
          backgroundShape.setZIndex(-1);
          if (rotation) {
            var matrix = labelContentShape.getMatrix();
            backgroundShape.setMatrix(matrix);
          }
        }
      }
    });
  };
  Labels2.prototype.createOffscreenGroup = function() {
    var container = this.container;
    var GroupClass = container.getGroupBase();
    var newGroup = new GroupClass({});
    return newGroup;
  };
  Labels2.prototype.adjustLabel = function(items, shapesMap) {
    each_default(items, function(item) {
      if (item) {
        var id = item.id;
        var labelGroup = shapesMap[id];
        if (!labelGroup.destroyed) {
          var labelShapes = labelGroup.findAll(function(ele) {
            return ele.get("type") !== "path";
          });
          each_default(labelShapes, function(labelShape) {
            if (labelShape) {
              if (item.offsetX) {
                labelShape.attr("x", labelShape.attr("x") + item.offsetX);
              }
              if (item.offsetY) {
                labelShape.attr("y", labelShape.attr("y") + item.offsetY);
              }
            }
          });
        }
      }
    });
  };
  return Labels2;
}();
var labels_default = Labels;

// node_modules/@antv/g2/esm/geometry/label/base.js
function avg(arr) {
  var sum = 0;
  each_default(arr, function(value) {
    sum += value;
  });
  return sum / arr.length;
}
var GeometryLabel = function() {
  function GeometryLabel2(geometry) {
    this.geometry = geometry;
  }
  GeometryLabel2.prototype.getLabelItems = function(mapppingArray) {
    var _this = this;
    var items = [];
    var labelCfgs = this.getLabelCfgs(mapppingArray);
    each_default(mapppingArray, function(mappingData, index) {
      var labelCfg = labelCfgs[index];
      if (!labelCfg || is_nil_default(mappingData.x) || is_nil_default(mappingData.y)) {
        items.push(null);
        return;
      }
      var labelContent = !is_array_default(labelCfg.content) ? [labelCfg.content] : labelCfg.content;
      labelCfg.content = labelContent;
      var total = labelContent.length;
      each_default(labelContent, function(content, subIndex) {
        if (is_nil_default(content) || content === "") {
          items.push(null);
          return;
        }
        var item = __assign(__assign({}, labelCfg), _this.getLabelPoint(labelCfg, mappingData, subIndex));
        if (!item.textAlign) {
          item.textAlign = _this.getLabelAlign(item, subIndex, total);
        }
        if (item.offset <= 0) {
          item.labelLine = null;
        }
        items.push(item);
      });
    });
    return items;
  };
  GeometryLabel2.prototype.render = function(mappingArray, isUpdate) {
    if (isUpdate === void 0) {
      isUpdate = false;
    }
    return __awaiter(this, void 0, void 0, function() {
      var labelItems, labelsRenderer, shapes;
      return __generator(this, function(_a3) {
        switch (_a3.label) {
          case 0:
            labelItems = this.getLabelItems(mappingArray);
            labelsRenderer = this.getLabelsRenderer();
            shapes = this.getGeometryShapes();
            return [4, labelsRenderer.render(labelItems, shapes, isUpdate)];
          case 1:
            _a3.sent();
            return [2];
        }
      });
    });
  };
  GeometryLabel2.prototype.clear = function() {
    var labelsRenderer = this.labelsRenderer;
    if (labelsRenderer) {
      labelsRenderer.clear();
    }
  };
  GeometryLabel2.prototype.destroy = function() {
    var labelsRenderer = this.labelsRenderer;
    if (labelsRenderer) {
      labelsRenderer.destroy();
    }
    this.labelsRenderer = null;
  };
  GeometryLabel2.prototype.getCoordinate = function() {
    return this.geometry.coordinate;
  };
  GeometryLabel2.prototype.getDefaultLabelCfg = function(offset, position) {
    var geometry = this.geometry;
    var type = geometry.type, theme = geometry.theme;
    if (type === "polygon" || type === "interval" && position === "middle" || offset < 0 && !["line", "point", "path"].includes(type)) {
      return get_default(theme, "innerLabels", {});
    }
    return get_default(theme, "labels", {});
  };
  GeometryLabel2.prototype.getThemedLabelCfg = function(labelCfg) {
    var geometry = this.geometry;
    var defaultLabelCfg = this.getDefaultLabelCfg();
    var type = geometry.type, theme = geometry.theme;
    var themedLabelCfg;
    if (type === "polygon" || labelCfg.offset < 0 && !["line", "point", "path"].includes(type)) {
      themedLabelCfg = deep_mix_default({}, defaultLabelCfg, theme.innerLabels, labelCfg);
    } else {
      themedLabelCfg = deep_mix_default({}, defaultLabelCfg, theme.labels, labelCfg);
    }
    return themedLabelCfg;
  };
  GeometryLabel2.prototype.setLabelPosition = function(labelPointCfg, mappingData, index, position) {
  };
  GeometryLabel2.prototype.getLabelOffset = function(offset) {
    var coordinate = this.getCoordinate();
    var vector = this.getOffsetVector(offset);
    return coordinate.isTransposed ? vector[0] : vector[1];
  };
  GeometryLabel2.prototype.getLabelOffsetPoint = function(labelCfg, index, total) {
    var offset = labelCfg.offset;
    var coordinate = this.getCoordinate();
    var transposed = coordinate.isTransposed;
    var dim = transposed ? "x" : "y";
    var factor = transposed ? 1 : -1;
    var offsetPoint = {
      x: 0,
      y: 0
    };
    if (index > 0 || total === 1) {
      offsetPoint[dim] = offset * factor;
    } else {
      offsetPoint[dim] = offset * factor * -1;
    }
    return offsetPoint;
  };
  GeometryLabel2.prototype.getLabelPoint = function(labelCfg, mappingData, index) {
    var coordinate = this.getCoordinate();
    var total = labelCfg.content.length;
    function getDimValue(value, idx, isAvg) {
      if (isAvg === void 0) {
        isAvg = false;
      }
      var v = value;
      if (is_array_default(v)) {
        if (labelCfg.content.length === 1) {
          if (isAvg) {
            v = avg(v);
          } else {
            if (v.length <= 2) {
              v = v[value.length - 1];
            } else {
              v = avg(v);
            }
          }
        } else {
          v = v[idx];
        }
      }
      return v;
    }
    var label = {
      content: labelCfg.content[index],
      x: 0,
      y: 0,
      start: { x: 0, y: 0 },
      color: "#fff"
    };
    var shape = is_array_default(mappingData.shape) ? mappingData.shape[0] : mappingData.shape;
    var isFunnel = shape === "funnel" || shape === "pyramid";
    if (this.geometry.type === "polygon") {
      var centroid = getPolygonCentroid(mappingData.x, mappingData.y);
      label.x = centroid[0];
      label.y = centroid[1];
    } else if (this.geometry.type === "interval" && !isFunnel) {
      label.x = getDimValue(mappingData.x, index, true);
      label.y = getDimValue(mappingData.y, index);
    } else {
      label.x = getDimValue(mappingData.x, index);
      label.y = getDimValue(mappingData.y, index);
    }
    if (isFunnel) {
      var nextPoints = get_default(mappingData, "nextPoints");
      var points = get_default(mappingData, "points");
      if (nextPoints) {
        var point1 = coordinate.convert(points[1]);
        var point2 = coordinate.convert(nextPoints[1]);
        label.x = (point1.x + point2.x) / 2;
        label.y = (point1.y + point2.y) / 2;
      } else if (shape === "pyramid") {
        var point1 = coordinate.convert(points[1]);
        var point2 = coordinate.convert(points[2]);
        label.x = (point1.x + point2.x) / 2;
        label.y = (point1.y + point2.y) / 2;
      }
    }
    if (labelCfg.position) {
      this.setLabelPosition(label, mappingData, index, labelCfg.position);
    }
    var offsetPoint = this.getLabelOffsetPoint(labelCfg, index, total);
    label.start = { x: label.x, y: label.y };
    label.x += offsetPoint.x;
    label.y += offsetPoint.y;
    label.color = mappingData.color;
    return label;
  };
  GeometryLabel2.prototype.getLabelAlign = function(item, index, total) {
    var align = "center";
    var coordinate = this.getCoordinate();
    if (coordinate.isTransposed) {
      var offset = item.offset;
      if (offset < 0) {
        align = "right";
      } else if (offset === 0) {
        align = "center";
      } else {
        align = "left";
      }
      if (total > 1 && index === 0) {
        if (align === "right") {
          align = "left";
        } else if (align === "left") {
          align = "right";
        }
      }
    }
    return align;
  };
  GeometryLabel2.prototype.getLabelId = function(mappingData) {
    var geometry = this.geometry;
    var type = geometry.type;
    var xScale = geometry.getXScale();
    var yScale = geometry.getYScale();
    var origin = mappingData[FIELD_ORIGIN];
    var labelId = geometry.getElementId(mappingData);
    if (type === "line" || type === "area") {
      labelId += " ".concat(origin[xScale.field]);
    } else if (type === "path") {
      labelId += " ".concat(origin[xScale.field], "-").concat(origin[yScale.field]);
    }
    return labelId;
  };
  GeometryLabel2.prototype.getLabelsRenderer = function() {
    var _a3 = this.geometry, labelsContainer = _a3.labelsContainer, labelOption = _a3.labelOption, canvasRegion = _a3.canvasRegion, animateOption = _a3.animateOption;
    var coordinate = this.geometry.coordinate;
    var labelsRenderer = this.labelsRenderer;
    if (!labelsRenderer) {
      labelsRenderer = new labels_default({
        container: labelsContainer,
        layout: get_default(labelOption, ["cfg", "layout"], {
          type: this.defaultLayout
        })
      });
      this.labelsRenderer = labelsRenderer;
    }
    labelsRenderer.region = canvasRegion;
    labelsRenderer.animate = animateOption ? getDefaultAnimateCfg("label", coordinate) : false;
    return labelsRenderer;
  };
  GeometryLabel2.prototype.getLabelCfgs = function(mapppingArray) {
    var _this = this;
    var geometry = this.geometry;
    var labelOption = geometry.labelOption, scales = geometry.scales, coordinate = geometry.coordinate;
    var _a3 = labelOption, fields = _a3.fields, callback = _a3.callback, cfg = _a3.cfg;
    var labelScales = fields.map(function(field) {
      return scales[field];
    });
    var labelCfgs = [];
    each_default(mapppingArray, function(mappingData, index) {
      var origin = mappingData[FIELD_ORIGIN];
      var originText = _this.getLabelText(origin, labelScales);
      var callbackCfg;
      if (callback) {
        var originValues = fields.map(function(field) {
          return origin[field];
        });
        callbackCfg = callback.apply(void 0, __spreadArray([], __read(originValues), false));
        if (is_nil_default(callbackCfg)) {
          labelCfgs.push(null);
          return;
        }
      }
      var labelCfg = __assign(__assign({
        id: _this.getLabelId(mappingData),
        elementId: _this.geometry.getElementId(mappingData),
        data: origin,
        mappingData,
        coordinate
      }, cfg), callbackCfg);
      if (is_function_default(labelCfg.position)) {
        labelCfg.position = labelCfg.position(origin, mappingData, index);
      }
      var offset = _this.getLabelOffset(labelCfg.offset || 0);
      var defaultLabelCfg = _this.getDefaultLabelCfg(offset, labelCfg.position);
      labelCfg = deep_mix_default({}, defaultLabelCfg, labelCfg);
      labelCfg.offset = _this.getLabelOffset(labelCfg.offset || 0);
      var content = labelCfg.content;
      if (is_function_default(content)) {
        labelCfg.content = content(origin, mappingData, index);
      } else if (is_undefined_default(content)) {
        labelCfg.content = originText[0];
      }
      labelCfgs.push(labelCfg);
    });
    return labelCfgs;
  };
  GeometryLabel2.prototype.getLabelText = function(origin, scales) {
    var labelTexts = [];
    each_default(scales, function(scale5) {
      var value = origin[scale5.field];
      if (is_array_default(value)) {
        value = value.map(function(subVal) {
          return scale5.getText(subVal);
        });
      } else {
        value = scale5.getText(value);
      }
      if (is_nil_default(value) || value === "") {
        labelTexts.push(null);
      } else {
        labelTexts.push(value);
      }
    });
    return labelTexts;
  };
  GeometryLabel2.prototype.getOffsetVector = function(offset) {
    if (offset === void 0) {
      offset = 0;
    }
    var coordinate = this.getCoordinate();
    var actualOffset = 0;
    if (is_number_default(offset)) {
      actualOffset = offset;
    }
    return coordinate.isTransposed ? coordinate.applyMatrix(actualOffset, 0) : coordinate.applyMatrix(0, actualOffset);
  };
  GeometryLabel2.prototype.getGeometryShapes = function() {
    var geometry = this.geometry;
    var shapes = {};
    each_default(geometry.elementsMap, function(element, id) {
      shapes[id] = element.shape;
    });
    each_default(geometry.getOffscreenGroup().getChildren(), function(child) {
      var id = geometry.getElementId(child.get("origin").mappingData);
      shapes[id] = child;
    });
    return shapes;
  };
  return GeometryLabel2;
}();
var base_default14 = GeometryLabel;

// node_modules/@antv/g2/esm/util/attr.js
function getMappingValue(attr, value, def) {
  if (!attr) {
    return def;
  }
  var r;
  if (attr.callback && attr.callback.length > 1) {
    var restArgs = Array(attr.callback.length - 1).fill("");
    r = attr.mapping.apply(attr, __spreadArray([value], __read(restArgs), false)).join("");
  } else {
    r = attr.mapping(value).join("");
  }
  return r || def;
}

// node_modules/@antv/g2/esm/util/marker.js
var MarkerSymbols = {
  hexagon: function(x, y, r) {
    var diffX = r / 2 * Math.sqrt(3);
    return [
      ["M", x, y - r],
      ["L", x + diffX, y - r / 2],
      ["L", x + diffX, y + r / 2],
      ["L", x, y + r],
      ["L", x - diffX, y + r / 2],
      ["L", x - diffX, y - r / 2],
      ["Z"]
    ];
  },
  bowtie: function(x, y, r) {
    var diffY = r - 1.5;
    return [["M", x - r, y - diffY], ["L", x + r, y + diffY], ["L", x + r, y - diffY], ["L", x - r, y + diffY], ["Z"]];
  },
  cross: function(x, y, r) {
    return [
      ["M", x - r, y - r],
      ["L", x + r, y + r],
      ["M", x + r, y - r],
      ["L", x - r, y + r]
    ];
  },
  tick: function(x, y, r) {
    return [
      ["M", x - r / 2, y - r],
      ["L", x + r / 2, y - r],
      ["M", x, y - r],
      ["L", x, y + r],
      ["M", x - r / 2, y + r],
      ["L", x + r / 2, y + r]
    ];
  },
  plus: function(x, y, r) {
    return [
      ["M", x - r, y],
      ["L", x + r, y],
      ["M", x, y - r],
      ["L", x, y + r]
    ];
  },
  hyphen: function(x, y, r) {
    return [
      ["M", x - r, y],
      ["L", x + r, y]
    ];
  },
  line: function(x, y, r) {
    return [
      ["M", x, y - r],
      ["L", x, y + r]
    ];
  }
};

// node_modules/@antv/g2/esm/util/legend.js
var STROKES_SYMBOLS = ["line", "cross", "tick", "plus", "hyphen"];
function handleUserMarkerStyle(markerStyle, style) {
  if (is_function_default(style)) {
    return style(markerStyle);
  }
  return deep_mix_default({}, markerStyle, style);
}
function adpatorMarkerStyle(marker, color2) {
  var symbol = marker.symbol;
  if (is_string_default(symbol) && STROKES_SYMBOLS.indexOf(symbol) !== -1) {
    var markerStyle = get_default(marker, "style", {});
    var lineWidth = get_default(markerStyle, "lineWidth", 1);
    var stroke = markerStyle.stroke || markerStyle.fill || color2;
    marker.style = deep_mix_default({}, marker.style, { lineWidth, stroke, fill: null });
  }
}
function setMarkerSymbol(marker) {
  var symbol = marker.symbol;
  if (is_string_default(symbol) && MarkerSymbols[symbol]) {
    marker.symbol = MarkerSymbols[symbol];
  }
}
function getLegendLayout(direction2) {
  return direction2.startsWith(DIRECTION.LEFT) || direction2.startsWith(DIRECTION.RIGHT) ? "vertical" : "horizontal";
}
function getLegendItems(view, geometry, attr, themeMarker, userMarker) {
  var scale5 = attr.getScale(attr.type);
  if (scale5.isCategory) {
    var field_1 = scale5.field;
    var colorAttr_1 = geometry.getAttribute("color");
    var shapeAttr_1 = geometry.getAttribute("shape");
    var defaultColor_1 = view.getTheme().defaultColor;
    var isInPolar_1 = geometry.coordinate.isPolar;
    return scale5.getTicks().map(function(tick, index) {
      var _a3;
      var text = tick.text, scaleValue = tick.value;
      var name = text;
      var value = scale5.invert(scaleValue);
      var unchecked = view.filterFieldData(field_1, [(_a3 = {}, _a3[field_1] = value, _a3)]).length === 0;
      each_default(view.views, function(subView) {
        var _a4;
        if (!subView.filterFieldData(field_1, [(_a4 = {}, _a4[field_1] = value, _a4)]).length) {
          unchecked = true;
        }
      });
      var color2 = getMappingValue(colorAttr_1, value, defaultColor_1);
      var shape = getMappingValue(shapeAttr_1, value, "point");
      var marker = geometry.getShapeMarker(shape, {
        color: color2,
        isInPolar: isInPolar_1
      });
      var markerCfg = userMarker;
      if (is_function_default(markerCfg)) {
        markerCfg = markerCfg(name, index, __assign({ name, value }, deep_mix_default({}, themeMarker, marker)));
      }
      marker = deep_mix_default({}, themeMarker, marker, omit(__assign({}, markerCfg), ["style"]));
      adpatorMarkerStyle(marker, color2);
      if (markerCfg && markerCfg.style) {
        marker.style = handleUserMarkerStyle(marker.style, markerCfg.style);
      }
      setMarkerSymbol(marker);
      return { id: value, name, value, marker, unchecked };
    });
  }
  return [];
}
function getCustomLegendItems(themeMarker, userMarker, customItems) {
  return customItems.map(function(item, index) {
    var markerCfg = userMarker;
    if (is_function_default(markerCfg)) {
      markerCfg = markerCfg(item.name, index, deep_mix_default({}, themeMarker, item));
    }
    var itemMarker = is_function_default(item.marker) ? item.marker(item.name, index, deep_mix_default({}, themeMarker, item)) : item.marker;
    var marker = deep_mix_default({}, themeMarker, markerCfg, itemMarker);
    setMarkerSymbol(marker);
    item.marker = marker;
    return item;
  });
}
function getLegendThemeCfg(theme, direction2) {
  var legendTheme = get_default(theme, ["components", "legend"], {});
  return deep_mix_default({}, get_default(legendTheme, ["common"], {}), deep_mix_default({}, get_default(legendTheme, [direction2], {})));
}

// node_modules/@antv/g2/esm/geometry/shape/util/get-path-points.js
function isValueEmpty(value) {
  if (value) {
    return false;
  }
  return value === null || value === void 0 || isNaN(value);
}
function isYNil(point) {
  if (is_array_default(point)) {
    return isValueEmpty(point[1].y);
  }
  var value = point.y;
  return is_array_default(value) ? isValueEmpty(value[0]) : isValueEmpty(value);
}
function getPathPoints(points, connectNulls, showSinglePoint) {
  if (connectNulls === void 0) {
    connectNulls = false;
  }
  if (showSinglePoint === void 0) {
    showSinglePoint = true;
  }
  if (!points.length || points.length === 1 && !showSinglePoint) {
    return [];
  }
  if (connectNulls) {
    var filtered = [];
    for (var i = 0, len3 = points.length; i < len3; i++) {
      var point = points[i];
      if (!isYNil(point)) {
        filtered.push(point);
      }
    }
    return [filtered];
  }
  var result = [];
  var tmp = [];
  for (var i = 0, len3 = points.length; i < len3; i++) {
    var point = points[i];
    if (isYNil(point)) {
      if (tmp.length) {
        if (!(tmp.length === 1 && !showSinglePoint)) {
          result.push(tmp);
        }
        tmp = [];
      }
    } else {
      tmp.push(point);
    }
  }
  if (tmp.length) {
    result.push(tmp);
  }
  return result;
}
function getViolinPath(points) {
  var path = [];
  for (var i = 0; i < points.length; i++) {
    var point = points[i];
    if (point) {
      var action = i === 0 ? "M" : "L";
      path.push([action, point.x, point.y]);
    }
  }
  var first = points[0];
  if (first) {
    path.push(["L", first.x, first.y]);
    path.push(["z"]);
  }
  return path;
}
function getSmoothViolinPath(points) {
  var half = points.length / 2;
  var leftPoints = [];
  var rightPoints = [];
  for (var i = 0; i < points.length; i++) {
    if (i < half) {
      leftPoints.push(points[i]);
    } else {
      rightPoints.push(points[i]);
    }
  }
  var leftPath = getSplinePath(leftPoints, false);
  var rightPath = getSplinePath(rightPoints, false);
  if (rightPoints.length) {
    leftPath.push(["L", rightPoints[0].x, rightPoints[0].y]);
  }
  rightPath.shift();
  var path = leftPath.concat(rightPath);
  if (leftPoints.length) {
    path.push(["L", leftPoints[0].x, leftPoints[0].y]);
  }
  path.push(["z"]);
  return path;
}

// node_modules/@antv/g2/esm/geometry/shape/util/get-style.js
function getStyle2(cfg, isStroke, isFill, sizeName) {
  if (sizeName === void 0) {
    sizeName = "";
  }
  var _a3 = cfg.style, style = _a3 === void 0 ? {} : _a3, defaultStyle = cfg.defaultStyle, color2 = cfg.color, size2 = cfg.size;
  var attrs = __assign(__assign({}, defaultStyle), style);
  if (color2) {
    if (isStroke) {
      if (!style.stroke) {
        attrs.stroke = color2;
      }
    }
    if (isFill) {
      if (!style.fill) {
        attrs.fill = color2;
      }
    }
  }
  if (sizeName && is_nil_default(style[sizeName]) && !is_nil_default(size2)) {
    attrs[sizeName] = size2;
  }
  return attrs;
}
function getBackgroundRectStyle(cfg) {
  return deep_mix_default({}, {
    fill: "#CCD6EC",
    fillOpacity: 0.3
  }, get_default(cfg, ["background", "style"]));
}

// node_modules/@antv/g2/esm/geometry/shape/util/split-points.js
function splitPoints(obj) {
  var x = obj.x;
  var y = is_array_default(obj.y) ? obj.y : [obj.y];
  return y.map(function(eachY, index) {
    return {
      x: is_array_default(x) ? x[index] : x,
      y: eachY
    };
  });
}

// node_modules/@antv/g2/esm/geometry/shape/line/util.js
var LineSymbols = {
  line: function(x, y, r) {
    return [
      ["M", x - r, y],
      ["L", x + r, y]
    ];
  },
  dot: function(x, y, r) {
    return [
      ["M", x - r, y],
      ["L", x + r, y]
    ];
  },
  dash: function(x, y, r) {
    return [
      ["M", x - r, y],
      ["L", x + r, y]
    ];
  },
  smooth: function(x, y, r) {
    return [
      ["M", x - r, y],
      ["A", r / 2, r / 2, 0, 1, 1, x, y],
      ["A", r / 2, r / 2, 0, 1, 0, x + r, y]
    ];
  },
  hv: function(x, y, r) {
    return [
      ["M", x - r - 1, y - 2.5],
      ["L", x, y - 2.5],
      ["L", x, y + 2.5],
      ["L", x + r + 1, y + 2.5]
    ];
  },
  vh: function(x, y, r) {
    return [
      ["M", x - r - 1, y + 2.5],
      ["L", x, y + 2.5],
      ["L", x, y - 2.5],
      ["L", x + r + 1, y - 2.5]
    ];
  },
  hvh: function(x, y, r) {
    return [
      ["M", x - (r + 1), y + 2.5],
      ["L", x - r / 2, y + 2.5],
      ["L", x - r / 2, y - 2.5],
      ["L", x + r / 2, y - 2.5],
      ["L", x + r / 2, y + 2.5],
      ["L", x + r + 1, y + 2.5]
    ];
  },
  vhv: function(x, y) {
    return [
      ["M", x - 5, y + 2.5],
      ["L", x - 5, y],
      ["L", x, y],
      ["L", x, y - 3],
      ["L", x, y + 3],
      ["L", x + 6.5, y + 3]
    ];
  }
};
function getLineMarker(markerCfg, shapeType) {
  var color2 = markerCfg.color;
  return {
    symbol: LineSymbols[shapeType],
    style: {
      lineWidth: 2,
      r: 6,
      stroke: color2
    }
  };
}

// node_modules/@antv/g2/esm/geometry/shape/line/index.js
function getShapeAttrs(cfg, smooth, constraint) {
  var isStack = cfg.isStack, connectNulls = cfg.connectNulls, isInCircle = cfg.isInCircle, showSinglePoint = cfg.showSinglePoint;
  var shapeAttrs = getStyle2(cfg, true, false, "lineWidth");
  var points = getPathPoints(cfg.points, connectNulls, showSinglePoint);
  var path = [];
  for (var i = 0, len3 = points.length; i < len3; i++) {
    var eachLinePoints = points[i];
    path = path.concat(getPath(eachLinePoints, isInCircle, isStack, smooth, constraint, shapeAttrs));
  }
  shapeAttrs.path = path;
  return shapeAttrs;
}
function getSinglePath(points, isInCircle, smooth, constraint, style) {
  if (points.length === 1) {
    return [
      ["M", points[0].x, points[0].y - style.lineWidth / 2],
      ["L", points[0].x, points[0].y],
      ["L", points[0].x, points[0].y + style.lineWidth / 2]
    ];
  }
  var path;
  if (!smooth) {
    path = getLinePath2(points, false);
    if (isInCircle) {
      path.push(["Z"]);
    }
  } else {
    if (isInCircle && points.length) {
      points.push({ x: points[0].x, y: points[0].y });
    }
    path = getSplinePath(points, false, constraint);
  }
  return path;
}
function getRangePath(points, isInCircle, isStack, smooth, constraint, style) {
  var topPoints = [];
  var bottomPoints = [];
  each_default(points, function(point) {
    var result = splitPoints(point);
    topPoints.push(result[1]);
    bottomPoints.push(result[0]);
  });
  var topPath = getSinglePath(topPoints, isInCircle, smooth, constraint, style);
  var bottomPath = getSinglePath(bottomPoints, isInCircle, smooth, constraint, style);
  if (isStack) {
    return topPath;
  }
  return topPath.concat(bottomPath);
}
function getPath(points, isInCircle, isStack, smooth, constraint, style) {
  if (points.length) {
    var first = points[0];
    return is_array_default(first.y) ? getRangePath(points, isInCircle, isStack, smooth, constraint, style) : getSinglePath(points, isInCircle, smooth, constraint, style);
  }
  return [];
}
var LineShapeFactory = registerShapeFactory("line", {
  defaultShapeType: "line"
});
each_default(["line", "dot", "dash", "smooth"], function(shapeType) {
  registerShape("line", shapeType, {
    draw: function(cfg, container) {
      var smooth = shapeType === "smooth";
      var constraint;
      if (smooth) {
        var _a3 = this.coordinate, start = _a3.start, end = _a3.end;
        constraint = [
          [start.x, end.y],
          [end.x, start.y]
        ];
      }
      var attrs = getShapeAttrs(cfg, smooth, constraint);
      var shape = container.addShape({
        type: "path",
        attrs,
        name: "line",
        capture: !smooth
      });
      return shape;
    },
    getMarker: function(markerCfg) {
      return getLineMarker(markerCfg, shapeType);
    }
  });
});

// node_modules/@antv/g2/esm/core.js
var VERSION = "4.2.7";
var Util = {
  getLegendItems,
  translate: translate2,
  rotate: rotate4,
  zoom,
  transform: transform3,
  getAngle: getAngle2,
  getSectorPath,
  polarToCartesian,
  getDelegationObject,
  getTooltipItems,
  getMappingValue,
  getPath,
  getPathPoints
};

// node_modules/@antv/g2/esm/theme/style-sheet/dark.js
var WHITE_COLORS2 = {
  100: "#000",
  95: "#0D0D0D",
  85: "#262626",
  65: "#595959",
  45: "#8C8C8C",
  25: "#BFBFBF",
  15: "#D9D9D9",
  6: "#F0F0F0"
};
var BLACK_COLORS2 = {
  100: "#FFFFFF",
  95: "#F2F2F2",
  85: "#D9D9D9",
  65: "#A6A6A6",
  45: "#737373",
  25: "#404040",
  15: "#262626",
  6: "#0F0F0F"
};
var QUALITATIVE_102 = [
  "#5B8FF9",
  "#5AD8A6",
  "#5D7092",
  "#F6BD16",
  "#E86452",
  "#6DC8EC",
  "#945FB9",
  "#FF9845",
  "#1E9493",
  "#FF99C3"
];
var QUALITATIVE_202 = [
  "#5B8FF9",
  "#CDDDFD",
  "#5AD8A6",
  "#CDF3E4",
  "#5D7092",
  "#CED4DE",
  "#F6BD16",
  "#FCEBB9",
  "#E86452",
  "#F8D0CB",
  "#6DC8EC",
  "#D3EEF9",
  "#945FB9",
  "#DECFEA",
  "#FF9845",
  "#FFE0C7",
  "#1E9493",
  "#BBDEDE",
  "#FF99C3",
  "#FFE0ED"
];
var SINGLE_SEQUENCE2 = [
  "#B8E1FF",
  "#9AC5FF",
  "#7DAAFF",
  "#5B8FF9",
  "#3D76DD",
  "#085EC0",
  "#0047A5",
  "#00318A",
  "#001D70"
];
var createDarkStyleSheet = function(cfg) {
  if (cfg === void 0) {
    cfg = {};
  }
  var _a3 = cfg.paletteQualitative10, paletteQualitative10 = _a3 === void 0 ? QUALITATIVE_102 : _a3, _b = cfg.paletteQualitative20, paletteQualitative20 = _b === void 0 ? QUALITATIVE_202 : _b;
  var _c = cfg.brandColor, brandColor = _c === void 0 ? paletteQualitative10[0] : _c;
  var token2 = {
    backgroundColor: "#141414",
    brandColor,
    subColor: "rgba(255,255,255,0.05)",
    paletteQualitative10,
    paletteQualitative20,
    paletteSemanticRed: "#F4664A",
    paletteSemanticGreen: "#30BF78",
    paletteSemanticYellow: "#FAAD14",
    paletteSequence: SINGLE_SEQUENCE2,
    fontFamily: '"Segoe UI", Roboto, "Helvetica Neue", Arial,\n    "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol",\n    "Noto Color Emoji"',
    axisLineBorderColor: BLACK_COLORS2[25],
    axisLineBorder: 1,
    axisLineDash: null,
    axisTitleTextFillColor: BLACK_COLORS2[65],
    axisTitleTextFontSize: 12,
    axisTitleTextLineHeight: 12,
    axisTitleTextFontWeight: "normal",
    axisTitleSpacing: 12,
    axisDescriptionIconFillColor: WHITE_COLORS2[85],
    axisTickLineBorderColor: BLACK_COLORS2[25],
    axisTickLineLength: 4,
    axisTickLineBorder: 1,
    axisSubTickLineBorderColor: BLACK_COLORS2[15],
    axisSubTickLineLength: 2,
    axisSubTickLineBorder: 1,
    axisLabelFillColor: BLACK_COLORS2[45],
    axisLabelFontSize: 12,
    axisLabelLineHeight: 12,
    axisLabelFontWeight: "normal",
    axisLabelOffset: 8,
    axisGridBorderColor: BLACK_COLORS2[15],
    axisGridBorder: 1,
    axisGridLineDash: null,
    legendTitleTextFillColor: BLACK_COLORS2[45],
    legendTitleTextFontSize: 12,
    legendTitleTextLineHeight: 21,
    legendTitleTextFontWeight: "normal",
    legendMarkerColor: QUALITATIVE_102[0],
    legendMarkerSpacing: 8,
    legendMarkerSize: 4,
    legendCircleMarkerSize: 4,
    legendSquareMarkerSize: 4,
    legendLineMarkerSize: 5,
    legendItemNameFillColor: BLACK_COLORS2[65],
    legendItemNameFontSize: 12,
    legendItemNameLineHeight: 12,
    legendItemNameFontWeight: "normal",
    legendItemSpacing: 24,
    legendItemMarginBottom: 12,
    legendSpacing: 16,
    legendPadding: [8, 8, 8, 8],
    legendHorizontalPadding: [8, 0, 8, 0],
    legendVerticalPadding: [0, 8, 0, 8],
    legendPageNavigatorMarkerSize: 12,
    legendPageNavigatorMarkerInactiveFillColor: BLACK_COLORS2[45],
    legendPageNavigatorMarkerInactiveFillOpacity: 0.45,
    legendPageNavigatorMarkerFillColor: BLACK_COLORS2[45],
    legendPageNavigatorMarkerFillOpacity: 1,
    legendPageNavigatorTextFillColor: BLACK_COLORS2[65],
    legendPageNavigatorTextFontSize: 12,
    sliderRailFillColor: BLACK_COLORS2[15],
    sliderRailBorder: 0,
    sliderRailBorderColor: null,
    sliderRailWidth: 100,
    sliderRailHeight: 12,
    sliderLabelTextFillColor: BLACK_COLORS2[45],
    sliderLabelTextFontSize: 12,
    sliderLabelTextLineHeight: 12,
    sliderLabelTextFontWeight: "normal",
    sliderHandlerFillColor: WHITE_COLORS2[6],
    sliderHandlerWidth: 10,
    sliderHandlerHeight: 14,
    sliderHandlerBorder: 1,
    sliderHandlerBorderColor: WHITE_COLORS2[25],
    annotationArcBorderColor: BLACK_COLORS2[15],
    annotationArcBorder: 1,
    annotationLineBorderColor: BLACK_COLORS2[25],
    annotationLineBorder: 1,
    annotationLineDash: null,
    annotationTextFillColor: BLACK_COLORS2[65],
    annotationTextFontSize: 12,
    annotationTextLineHeight: 12,
    annotationTextFontWeight: "normal",
    annotationTextBorderColor: null,
    annotationTextBorder: 0,
    annotationRegionFillColor: BLACK_COLORS2[100],
    annotationRegionFillOpacity: 0.06,
    annotationRegionBorder: 0,
    annotationRegionBorderColor: null,
    annotationDataMarkerLineLength: 16,
    tooltipCrosshairsBorderColor: BLACK_COLORS2[25],
    tooltipCrosshairsBorder: 1,
    tooltipCrosshairsLineDash: null,
    tooltipContainerFillColor: "#1f1f1f",
    tooltipContainerFillOpacity: 0.95,
    tooltipContainerShadow: "0px 2px 4px rgba(0,0,0,.5)",
    tooltipContainerBorderRadius: 3,
    tooltipTextFillColor: BLACK_COLORS2[65],
    tooltipTextFontSize: 12,
    tooltipTextLineHeight: 12,
    tooltipTextFontWeight: "bold",
    labelFillColor: BLACK_COLORS2[65],
    labelFillColorDark: "#2c3542",
    labelFillColorLight: "#ffffff",
    labelFontSize: 12,
    labelLineHeight: 12,
    labelFontWeight: "normal",
    labelBorderColor: null,
    labelBorder: 0,
    innerLabelFillColor: WHITE_COLORS2[100],
    innerLabelFontSize: 12,
    innerLabelLineHeight: 12,
    innerLabelFontWeight: "normal",
    innerLabelBorderColor: null,
    innerLabelBorder: 0,
    overflowLabelFillColor: BLACK_COLORS2[65],
    overflowLabelFillColorDark: "#2c3542",
    overflowLabelFillColorLight: "#ffffff",
    overflowLabelFontSize: 12,
    overflowLabelLineHeight: 12,
    overflowLabelFontWeight: "normal",
    overflowLabelBorderColor: WHITE_COLORS2[100],
    overflowLabelBorder: 1,
    labelLineBorder: 1,
    labelLineBorderColor: BLACK_COLORS2[25],
    cSliderRailHieght: 16,
    cSliderBackgroundFillColor: "#416180",
    cSliderBackgroundFillOpacity: 0.05,
    cSliderForegroundFillColor: "#5B8FF9",
    cSliderForegroundFillOpacity: 0.15,
    cSliderHandlerHeight: 24,
    cSliderHandlerWidth: 10,
    cSliderHandlerFillColor: "#F7F7F7",
    cSliderHandlerFillOpacity: 1,
    cSliderHandlerHighlightFillColor: "#FFF",
    cSliderHandlerBorderColor: "#BFBFBF",
    cSliderHandlerBorder: 1,
    cSliderHandlerBorderRadius: 2,
    cSliderTextFillColor: "#fff",
    cSliderTextFillOpacity: 0.45,
    cSliderTextFontSize: 12,
    cSliderTextLineHeight: 12,
    cSliderTextFontWeight: "normal",
    cSliderTextBorderColor: null,
    cSliderTextBorder: 0,
    scrollbarTrackFillColor: "rgba(255,255,255,0.65)",
    scrollbarThumbFillColor: "rgba(0,0,0,0.35)",
    scrollbarThumbHighlightFillColor: "rgba(0,0,0,0.45)",
    pointFillColor: QUALITATIVE_102[0],
    pointFillOpacity: 0.95,
    pointSize: 4,
    pointBorder: 1,
    pointBorderColor: WHITE_COLORS2[100],
    pointBorderOpacity: 1,
    pointActiveBorderColor: BLACK_COLORS2[100],
    pointSelectedBorder: 2,
    pointSelectedBorderColor: BLACK_COLORS2[100],
    pointInactiveFillOpacity: 0.3,
    pointInactiveBorderOpacity: 0.3,
    hollowPointSize: 4,
    hollowPointBorder: 1,
    hollowPointBorderColor: QUALITATIVE_102[0],
    hollowPointBorderOpacity: 0.95,
    hollowPointFillColor: WHITE_COLORS2[100],
    hollowPointActiveBorder: 1,
    hollowPointActiveBorderColor: BLACK_COLORS2[100],
    hollowPointActiveBorderOpacity: 1,
    hollowPointSelectedBorder: 2,
    hollowPointSelectedBorderColor: BLACK_COLORS2[100],
    hollowPointSelectedBorderOpacity: 1,
    hollowPointInactiveBorderOpacity: 0.3,
    lineBorder: 2,
    lineBorderColor: QUALITATIVE_102[0],
    lineBorderOpacity: 1,
    lineActiveBorder: 3,
    lineSelectedBorder: 3,
    lineInactiveBorderOpacity: 0.3,
    areaFillColor: QUALITATIVE_102[0],
    areaFillOpacity: 0.25,
    areaActiveFillColor: QUALITATIVE_102[0],
    areaActiveFillOpacity: 0.5,
    areaSelectedFillColor: QUALITATIVE_102[0],
    areaSelectedFillOpacity: 0.5,
    areaInactiveFillOpacity: 0.3,
    hollowAreaBorderColor: QUALITATIVE_102[0],
    hollowAreaBorder: 2,
    hollowAreaBorderOpacity: 1,
    hollowAreaActiveBorder: 3,
    hollowAreaActiveBorderColor: BLACK_COLORS2[100],
    hollowAreaSelectedBorder: 3,
    hollowAreaSelectedBorderColor: BLACK_COLORS2[100],
    hollowAreaInactiveBorderOpacity: 0.3,
    intervalFillColor: QUALITATIVE_102[0],
    intervalFillOpacity: 0.95,
    intervalActiveBorder: 1,
    intervalActiveBorderColor: BLACK_COLORS2[100],
    intervalActiveBorderOpacity: 1,
    intervalSelectedBorder: 2,
    intervalSelectedBorderColor: BLACK_COLORS2[100],
    intervalSelectedBorderOpacity: 1,
    intervalInactiveBorderOpacity: 0.3,
    intervalInactiveFillOpacity: 0.3,
    hollowIntervalBorder: 2,
    hollowIntervalBorderColor: QUALITATIVE_102[0],
    hollowIntervalBorderOpacity: 1,
    hollowIntervalFillColor: WHITE_COLORS2[100],
    hollowIntervalActiveBorder: 2,
    hollowIntervalActiveBorderColor: BLACK_COLORS2[100],
    hollowIntervalSelectedBorder: 3,
    hollowIntervalSelectedBorderColor: BLACK_COLORS2[100],
    hollowIntervalSelectedBorderOpacity: 1,
    hollowIntervalInactiveBorderOpacity: 0.3
  };
  return __assign(__assign({}, token2), cfg);
};
var antvDark = createDarkStyleSheet();

// node_modules/@antv/g-canvas/esm/index.js
var esm_exports2 = {};
__export(esm_exports2, {
  AbstractCanvas: () => canvas_default,
  AbstractGroup: () => group_default2,
  AbstractShape: () => shape_default,
  Base: () => base_default2,
  Canvas: () => canvas_default2,
  Event: () => graph_event_default,
  Group: () => group_default3,
  PathUtil: () => path_exports,
  Shape: () => shape_exports,
  assembleFont: () => assembleFont,
  getArcParams: () => getArcParams2,
  getBBoxMethod: () => getMethod,
  getOffScreenContext: () => getOffScreenContext,
  getTextHeight: () => getTextHeight,
  invert: () => invert2,
  isAllowCapture: () => isAllowCapture,
  multiplyVec2: () => multiplyVec2,
  registerBBox: () => register,
  registerEasing: () => registerEasing,
  version: () => version
});

// node_modules/@antv/g-canvas/esm/shape/index.js
var shape_exports = {};
__export(shape_exports, {
  Base: () => base_default15,
  Circle: () => circle_default5,
  Ellipse: () => ellipse_default3,
  Image: () => image_default2,
  Line: () => line_default7,
  Marker: () => marker_default,
  Path: () => path_default2,
  Polygon: () => polygon_default3,
  Polyline: () => polyline_default3,
  Rect: () => rect_default2,
  Text: () => text_default3
});

// node_modules/@antv/g-canvas/esm/util/util.js
function getPixelRatio() {
  return window ? window.devicePixelRatio : 1;
}
function distance7(x1, y1, x2, y2) {
  var dx = x1 - x2;
  var dy = y1 - y2;
  return Math.sqrt(dx * dx + dy * dy);
}
function inBox(minX, minY, width, height, x, y) {
  return x >= minX && x <= minX + width && y >= minY && y <= minY + height;
}
function intersectRect2(box1, box2) {
  return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);
}
function mergeRegion(region1, region2) {
  if (!region1 || !region2) {
    return region1 || region2;
  }
  return {
    minX: Math.min(region1.minX, region2.minX),
    minY: Math.min(region1.minY, region2.minY),
    maxX: Math.max(region1.maxX, region2.maxX),
    maxY: Math.max(region1.maxY, region2.maxY)
  };
}
function isSamePoint2(point1, point2) {
  return point1[0] === point2[0] && point1[1] === point2[1];
}

// node_modules/@antv/g-canvas/esm/util/parse.js
var regexLG2 = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
var regexRG2 = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
var regexPR = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i;
var regexColorStop2 = /[\d.]+:(#[^\s]+|[^\)]+\))/gi;
function addStop(steps, gradient2) {
  var arr = steps.match(regexColorStop2);
  each_default(arr, function(item) {
    var itemArr = item.split(":");
    gradient2.addColorStop(itemArr[0], itemArr[1]);
  });
}
function parseLineGradient(context, element, gradientStr) {
  var arr = regexLG2.exec(gradientStr);
  var angle3 = parseFloat(arr[1]) % 360 * (Math.PI / 180);
  var steps = arr[2];
  var box2 = element.getBBox();
  var start;
  var end;
  if (angle3 >= 0 && angle3 < 1 / 2 * Math.PI) {
    start = {
      x: box2.minX,
      y: box2.minY
    };
    end = {
      x: box2.maxX,
      y: box2.maxY
    };
  } else if (1 / 2 * Math.PI <= angle3 && angle3 < Math.PI) {
    start = {
      x: box2.maxX,
      y: box2.minY
    };
    end = {
      x: box2.minX,
      y: box2.maxY
    };
  } else if (Math.PI <= angle3 && angle3 < 3 / 2 * Math.PI) {
    start = {
      x: box2.maxX,
      y: box2.maxY
    };
    end = {
      x: box2.minX,
      y: box2.minY
    };
  } else {
    start = {
      x: box2.minX,
      y: box2.maxY
    };
    end = {
      x: box2.maxX,
      y: box2.minY
    };
  }
  var tanTheta = Math.tan(angle3);
  var tanTheta2 = tanTheta * tanTheta;
  var x = (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.x;
  var y = tanTheta * (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.y;
  var gradient2 = context.createLinearGradient(start.x, start.y, x, y);
  addStop(steps, gradient2);
  return gradient2;
}
function parseRadialGradient(context, element, gradientStr) {
  var arr = regexRG2.exec(gradientStr);
  var fx = parseFloat(arr[1]);
  var fy = parseFloat(arr[2]);
  var fr = parseFloat(arr[3]);
  var steps = arr[4];
  if (fr === 0) {
    var colors = steps.match(regexColorStop2);
    return colors[colors.length - 1].split(":")[1];
  }
  var box2 = element.getBBox();
  var width = box2.maxX - box2.minX;
  var height = box2.maxY - box2.minY;
  var r = Math.sqrt(width * width + height * height) / 2;
  var gradient2 = context.createRadialGradient(box2.minX + width * fx, box2.minY + height * fy, 0, box2.minX + width / 2, box2.minY + height / 2, fr * r);
  addStop(steps, gradient2);
  return gradient2;
}
function parsePattern(context, element, patternStr) {
  if (element.get("patternSource") && element.get("patternSource") === patternStr) {
    return element.get("pattern");
  }
  var pattern;
  var img;
  var arr = regexPR.exec(patternStr);
  var repeat = arr[1];
  var source = arr[2];
  function onload() {
    pattern = context.createPattern(img, repeat);
    element.set("pattern", pattern);
    element.set("patternSource", patternStr);
  }
  switch (repeat) {
    case "a":
      repeat = "repeat";
      break;
    case "x":
      repeat = "repeat-x";
      break;
    case "y":
      repeat = "repeat-y";
      break;
    case "n":
      repeat = "no-repeat";
      break;
    default:
      repeat = "no-repeat";
  }
  img = new Image();
  if (!source.match(/^data:/i)) {
    img.crossOrigin = "Anonymous";
  }
  img.src = source;
  if (img.complete) {
    onload();
  } else {
    img.onload = onload;
    img.src = img.src;
  }
  return pattern;
}
function parseStyle(context, element, color2) {
  var bbox = element.getBBox();
  if (isNaN(bbox.x) || isNaN(bbox.y) || isNaN(bbox.width) || isNaN(bbox.height)) {
    return color2;
  }
  if (is_string_default(color2)) {
    if (color2[1] === "(" || color2[2] === "(") {
      if (color2[0] === "l") {
        return parseLineGradient(context, element, color2);
      }
      if (color2[0] === "r") {
        return parseRadialGradient(context, element, color2);
      }
      if (color2[0] === "p") {
        return parsePattern(context, element, color2);
      }
    }
    return color2;
  }
  if (color2 instanceof CanvasPattern) {
    return color2;
  }
}
function parseRadius(radius) {
  var r1 = 0;
  var r2 = 0;
  var r3 = 0;
  var r4 = 0;
  if (is_array_default(radius)) {
    if (radius.length === 1) {
      r1 = r2 = r3 = r4 = radius[0];
    } else if (radius.length === 2) {
      r1 = r3 = radius[0];
      r2 = r4 = radius[1];
    } else if (radius.length === 3) {
      r1 = radius[0];
      r2 = r4 = radius[1];
      r3 = radius[2];
    } else {
      r1 = radius[0];
      r2 = radius[1];
      r3 = radius[2];
      r4 = radius[3];
    }
  } else {
    r1 = r2 = r3 = r4 = radius;
  }
  return [r1, r2, r3, r4];
}

// node_modules/@antv/g-canvas/esm/util/arc-params.js
function vMag2(v) {
  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
}
function vRatio2(u, v) {
  return vMag2(u) * vMag2(v) ? (u[0] * v[0] + u[1] * v[1]) / (vMag2(u) * vMag2(v)) : 1;
}
function vAngle2(u, v) {
  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio2(u, v));
}
function getArcParams2(startPoint, params) {
  var rx = params[1];
  var ry = params[2];
  var xRotation = mod_default(to_radian_default(params[3]), Math.PI * 2);
  var arcFlag = params[4];
  var sweepFlag = params[5];
  var x1 = startPoint[0];
  var y1 = startPoint[1];
  var x2 = params[6];
  var y2 = params[7];
  var xp = Math.cos(xRotation) * (x1 - x2) / 2 + Math.sin(xRotation) * (y1 - y2) / 2;
  var yp = -1 * Math.sin(xRotation) * (x1 - x2) / 2 + Math.cos(xRotation) * (y1 - y2) / 2;
  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  var diff2 = rx * rx * (yp * yp) + ry * ry * (xp * xp);
  var f = diff2 ? Math.sqrt((rx * rx * (ry * ry) - diff2) / diff2) : 1;
  if (arcFlag === sweepFlag) {
    f *= -1;
  }
  if (isNaN(f)) {
    f = 0;
  }
  var cxp = ry ? f * rx * yp / ry : 0;
  var cyp = rx ? f * -ry * xp / rx : 0;
  var cx = (x1 + x2) / 2 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;
  var cy = (y1 + y2) / 2 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;
  var u = [(xp - cxp) / rx, (yp - cyp) / ry];
  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
  var theta = vAngle2([1, 0], u);
  var dTheta = vAngle2(u, v);
  if (vRatio2(u, v) <= -1) {
    dTheta = Math.PI;
  }
  if (vRatio2(u, v) >= 1) {
    dTheta = 0;
  }
  if (sweepFlag === 0 && dTheta > 0) {
    dTheta = dTheta - 2 * Math.PI;
  }
  if (sweepFlag === 1 && dTheta < 0) {
    dTheta = dTheta + 2 * Math.PI;
  }
  return {
    cx,
    cy,
    rx: isSamePoint2(startPoint, [x2, y2]) ? 0 : rx,
    ry: isSamePoint2(startPoint, [x2, y2]) ? 0 : ry,
    startAngle: theta,
    endAngle: theta + dTheta,
    xRotation,
    arcFlag,
    sweepFlag
  };
}

// node_modules/@antv/g-canvas/esm/util/arrow.js
var sin = Math.sin;
var cos = Math.cos;
var atan2 = Math.atan2;
var PI = Math.PI;
function _addDefaultArrow(shape, attrs, x1, y1, x2, y2, isStart) {
  var stroke = attrs.stroke, lineWidth = attrs.lineWidth;
  var x = x1 - x2;
  var y = y1 - y2;
  var rad = atan2(y, x);
  var arrowShape = new path_default2({
    type: "path",
    canvas: shape.get("canvas"),
    isArrowShape: true,
    attrs: {
      path: "M" + 10 * cos(PI / 6) + "," + 10 * sin(PI / 6) + " L0,0 L" + 10 * cos(PI / 6) + ",-" + 10 * sin(PI / 6),
      stroke,
      lineWidth
    }
  });
  arrowShape.translate(x2, y2);
  arrowShape.rotateAtPoint(x2, y2, rad);
  shape.set(isStart ? "startArrowShape" : "endArrowShape", arrowShape);
}
function _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, isStart) {
  var startArrow = attrs.startArrow, endArrow = attrs.endArrow, stroke = attrs.stroke, lineWidth = attrs.lineWidth;
  var arrowAttrs = isStart ? startArrow : endArrow;
  var d = arrowAttrs.d, arrowFill = arrowAttrs.fill, arrowStroke = arrowAttrs.stroke, arrowLineWidth = arrowAttrs.lineWidth, restAttrs = __rest(arrowAttrs, ["d", "fill", "stroke", "lineWidth"]);
  var x = x1 - x2;
  var y = y1 - y2;
  var rad = atan2(y, x);
  if (d) {
    x2 = x2 - cos(rad) * d;
    y2 = y2 - sin(rad) * d;
  }
  var arrowShape = new path_default2({
    type: "path",
    canvas: shape.get("canvas"),
    isArrowShape: true,
    attrs: __assign(__assign({}, restAttrs), {
      stroke: arrowStroke || stroke,
      lineWidth: arrowLineWidth || lineWidth,
      fill: arrowFill
    })
  });
  arrowShape.translate(x2, y2);
  arrowShape.rotateAtPoint(x2, y2, rad);
  shape.set(isStart ? "startArrowShape" : "endArrowShape", arrowShape);
}
function getShortenOffset(x1, y1, x2, y2, d) {
  var rad = atan2(y2 - y1, x2 - x1);
  return {
    dx: cos(rad) * d,
    dy: sin(rad) * d
  };
}
function addStartArrow(shape, attrs, x1, y1, x2, y2) {
  if (typeof attrs.startArrow === "object") {
    _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, true);
  } else if (attrs.startArrow) {
    _addDefaultArrow(shape, attrs, x1, y1, x2, y2, true);
  } else {
    shape.set("startArrowShape", null);
  }
}
function addEndArrow(shape, attrs, x1, y1, x2, y2) {
  if (typeof attrs.endArrow === "object") {
    _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, false);
  } else if (attrs.endArrow) {
    _addDefaultArrow(shape, attrs, x1, y1, x2, y2, false);
  } else {
    shape.set("startArrowShape", null);
  }
}

// node_modules/@antv/g-canvas/esm/util/draw.js
var SHAPE_ATTRS_MAP = {
  fill: "fillStyle",
  stroke: "strokeStyle",
  opacity: "globalAlpha"
};
function applyAttrsToContext(context, element) {
  var attrs = element.attr();
  for (var k in attrs) {
    var v = attrs[k];
    var name_1 = SHAPE_ATTRS_MAP[k] ? SHAPE_ATTRS_MAP[k] : k;
    if (name_1 === "matrix" && v) {
      context.transform(v[0], v[1], v[3], v[4], v[6], v[7]);
    } else if (name_1 === "lineDash" && context.setLineDash) {
      is_array_default(v) && context.setLineDash(v);
    } else {
      if (name_1 === "strokeStyle" || name_1 === "fillStyle") {
        v = parseStyle(context, element, v);
      } else if (name_1 === "globalAlpha") {
        v = v * context.globalAlpha;
      }
      context[name_1] = v;
    }
  }
}
function drawChildren(context, children, region) {
  for (var i = 0; i < children.length; i++) {
    var child = children[i];
    if (child.cfg.visible) {
      child.draw(context, region);
    } else {
      child.skipDraw();
    }
  }
}
function checkRefresh(canvas, children, region) {
  var refreshElements = canvas.get("refreshElements");
  each_default(refreshElements, function(el) {
    if (el !== canvas) {
      var parent_1 = el.cfg.parent;
      while (parent_1 && parent_1 !== canvas && !parent_1.cfg.refresh) {
        parent_1.cfg.refresh = true;
        parent_1 = parent_1.cfg.parent;
      }
    }
  });
  if (refreshElements[0] === canvas) {
    setChildrenRefresh(children, region);
  } else {
    checkChildrenRefresh(children, region);
  }
}
function checkChildrenRefresh(children, region) {
  for (var i = 0; i < children.length; i++) {
    var child = children[i];
    if (child.cfg.visible) {
      if (child.cfg.hasChanged) {
        child.cfg.refresh = true;
        if (child.isGroup()) {
          setChildrenRefresh(child.cfg.children, region);
        }
      } else if (child.cfg.refresh) {
        if (child.isGroup()) {
          checkChildrenRefresh(child.cfg.children, region);
        }
      } else {
        var refresh = checkElementRefresh(child, region);
        child.cfg.refresh = refresh;
        if (refresh && child.isGroup()) {
          checkChildrenRefresh(child.cfg.children, region);
        }
      }
    }
  }
}
function clearChanged(elements) {
  for (var i = 0; i < elements.length; i++) {
    var el = elements[i];
    el.cfg.hasChanged = false;
    if (el.isGroup() && !el.destroyed) {
      clearChanged(el.cfg.children);
    }
  }
}
function setChildrenRefresh(children, region) {
  for (var i = 0; i < children.length; i++) {
    var child = children[i];
    child.cfg.refresh = true;
    if (child.isGroup()) {
      setChildrenRefresh(child.get("children"), region);
    }
  }
}
function checkElementRefresh(shape, region) {
  var bbox = shape.cfg.cacheCanvasBBox;
  var isAllow = shape.cfg.isInView && bbox && intersectRect2(bbox, region);
  return isAllow;
}
function drawPath(shape, context, attrs, arcParamsCache) {
  var path = attrs.path, startArrow = attrs.startArrow, endArrow = attrs.endArrow;
  if (!path) {
    return;
  }
  var currentPoint = [0, 0];
  var startMovePoint = [0, 0];
  var distance8 = {
    dx: 0,
    dy: 0
  };
  context.beginPath();
  for (var i = 0; i < path.length; i++) {
    var params = path[i];
    var command = params[0];
    if (i === 0 && startArrow && startArrow.d) {
      var tangent = shape.getStartTangent();
      distance8 = getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], startArrow.d);
    } else if (i === path.length - 2 && path[i + 1][0] === "Z" && endArrow && endArrow.d) {
      var lastPath = path[i + 1];
      if (lastPath[0] === "Z") {
        var tangent = shape.getEndTangent();
        distance8 = getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], endArrow.d);
      }
    } else if (i === path.length - 1 && endArrow && endArrow.d) {
      if (path[0] !== "Z") {
        var tangent = shape.getEndTangent();
        distance8 = getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], endArrow.d);
      }
    }
    var dx = distance8.dx, dy = distance8.dy;
    switch (command) {
      case "M":
        context.moveTo(params[1] - dx, params[2] - dy);
        startMovePoint = [params[1], params[2]];
        break;
      case "L":
        context.lineTo(params[1] - dx, params[2] - dy);
        break;
      case "Q":
        context.quadraticCurveTo(params[1], params[2], params[3] - dx, params[4] - dy);
        break;
      case "C":
        context.bezierCurveTo(params[1], params[2], params[3], params[4], params[5] - dx, params[6] - dy);
        break;
      case "A": {
        var arcParams = void 0;
        if (arcParamsCache) {
          arcParams = arcParamsCache[i];
          if (!arcParams) {
            arcParams = getArcParams2(currentPoint, params);
            arcParamsCache[i] = arcParams;
          }
        } else {
          arcParams = getArcParams2(currentPoint, params);
        }
        var cx = arcParams.cx, cy = arcParams.cy, rx = arcParams.rx, ry = arcParams.ry, startAngle = arcParams.startAngle, endAngle = arcParams.endAngle, xRotation = arcParams.xRotation, sweepFlag = arcParams.sweepFlag;
        if (context.ellipse) {
          context.ellipse(cx, cy, rx, ry, xRotation, startAngle, endAngle, 1 - sweepFlag);
        } else {
          var r = rx > ry ? rx : ry;
          var scaleX = rx > ry ? 1 : rx / ry;
          var scaleY = rx > ry ? ry / rx : 1;
          context.translate(cx, cy);
          context.rotate(xRotation);
          context.scale(scaleX, scaleY);
          context.arc(0, 0, r, startAngle, endAngle, 1 - sweepFlag);
          context.scale(1 / scaleX, 1 / scaleY);
          context.rotate(-xRotation);
          context.translate(-cx, -cy);
        }
        break;
      }
      case "Z":
        context.closePath();
        break;
      default:
        break;
    }
    if (command === "Z") {
      currentPoint = startMovePoint;
    } else {
      var len3 = params.length;
      currentPoint = [params[len3 - 2], params[len3 - 1]];
    }
  }
}
function refreshElement(element, changeType) {
  var canvas = element.get("canvas");
  if (canvas) {
    if (changeType === "remove") {
      element._cacheCanvasBBox = element.get("cacheCanvasBBox");
    }
    if (!element.get("hasChanged")) {
      element.set("hasChanged", true);
      if (!(element.cfg.parent && element.cfg.parent.get("hasChanged"))) {
        canvas.refreshElement(element, changeType, canvas);
        if (canvas.get("autoDraw")) {
          canvas.draw();
        }
      }
    }
  }
}
function getRefreshRegion(element) {
  var region;
  if (!element.destroyed) {
    var cacheBox = element.get("cacheCanvasBBox");
    var validCache = cacheBox && !!(cacheBox.width && cacheBox.height);
    var bbox = element.getCanvasBBox();
    var validBBox = bbox && !!(bbox.width && bbox.height);
    if (validCache && validBBox) {
      region = mergeRegion(cacheBox, bbox);
    } else if (validCache) {
      region = cacheBox;
    } else if (validBBox) {
      region = bbox;
    }
  } else {
    region = element["_cacheCanvasBBox"];
  }
  return region;
}
function getMergedRegion(elements) {
  if (!elements.length) {
    return null;
  }
  var minXArr = [];
  var minYArr = [];
  var maxXArr = [];
  var maxYArr = [];
  each_default(elements, function(el) {
    var region = getRefreshRegion(el);
    if (region) {
      minXArr.push(region.minX);
      minYArr.push(region.minY);
      maxXArr.push(region.maxX);
      maxYArr.push(region.maxY);
    }
  });
  return {
    minX: min_default(minXArr),
    minY: min_default(minYArr),
    maxX: max_default(maxXArr),
    maxY: max_default(maxYArr)
  };
}
function mergeView(region, viewRegion) {
  if (!region || !viewRegion) {
    return null;
  }
  if (!intersectRect2(region, viewRegion)) {
    return null;
  }
  return {
    minX: Math.max(region.minX, viewRegion.minX),
    minY: Math.max(region.minY, viewRegion.minY),
    maxX: Math.min(region.maxX, viewRegion.maxX),
    maxY: Math.min(region.maxY, viewRegion.maxY)
  };
}

// node_modules/@antv/g-canvas/esm/group.js
var Group = function(_super) {
  __extends(Group3, _super);
  function Group3() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Group3.prototype.onCanvasChange = function(changeType) {
    refreshElement(this, changeType);
  };
  Group3.prototype.getShapeBase = function() {
    return shape_exports;
  };
  Group3.prototype.getGroupBase = function() {
    return Group3;
  };
  Group3.prototype._applyClip = function(context, clip) {
    if (clip) {
      context.save();
      applyAttrsToContext(context, clip);
      clip.createPath(context);
      context.restore();
      context.clip();
      clip._afterDraw();
    }
  };
  Group3.prototype.cacheCanvasBBox = function() {
    var children = this.cfg.children;
    var xArr = [];
    var yArr = [];
    each_default(children, function(child) {
      var bbox2 = child.cfg.cacheCanvasBBox;
      if (bbox2 && child.cfg.isInView) {
        xArr.push(bbox2.minX, bbox2.maxX);
        yArr.push(bbox2.minY, bbox2.maxY);
      }
    });
    var bbox = null;
    if (xArr.length) {
      var minX = min_default(xArr);
      var maxX = max_default(xArr);
      var minY = min_default(yArr);
      var maxY = max_default(yArr);
      bbox = {
        minX,
        minY,
        x: minX,
        y: minY,
        maxX,
        maxY,
        width: maxX - minX,
        height: maxY - minY
      };
      var canvas = this.cfg.canvas;
      if (canvas) {
        var viewRange = canvas.getViewRange();
        this.set("isInView", intersectRect2(bbox, viewRange));
      }
    } else {
      this.set("isInView", false);
    }
    this.set("cacheCanvasBBox", bbox);
  };
  Group3.prototype.draw = function(context, region) {
    var children = this.cfg.children;
    var allowDraw = region ? this.cfg.refresh : true;
    if (children.length && allowDraw) {
      context.save();
      applyAttrsToContext(context, this);
      this._applyClip(context, this.getClip());
      drawChildren(context, children, region);
      context.restore();
      this.cacheCanvasBBox();
    }
    this.cfg.refresh = null;
    this.set("hasChanged", false);
  };
  Group3.prototype.skipDraw = function() {
    this.set("cacheCanvasBBox", null);
    this.set("hasChanged", false);
  };
  return Group3;
}(group_default2);
var group_default3 = Group;

// node_modules/@antv/g-canvas/esm/shape/base.js
var ShapeBase2 = function(_super) {
  __extends(ShapeBase4, _super);
  function ShapeBase4() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ShapeBase4.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign(__assign({}, attrs), { lineWidth: 1, lineAppendWidth: 0, strokeOpacity: 1, fillOpacity: 1 });
  };
  ShapeBase4.prototype.getShapeBase = function() {
    return shape_exports;
  };
  ShapeBase4.prototype.getGroupBase = function() {
    return group_default3;
  };
  ShapeBase4.prototype.onCanvasChange = function(changeType) {
    refreshElement(this, changeType);
  };
  ShapeBase4.prototype.calculateBBox = function() {
    var type = this.get("type");
    var lineWidth = this.getHitLineWidth();
    var bboxMethod = getMethod(type);
    var box2 = bboxMethod(this);
    var halfLineWidth = lineWidth / 2;
    var minX = box2.x - halfLineWidth;
    var minY = box2.y - halfLineWidth;
    var maxX = box2.x + box2.width + halfLineWidth;
    var maxY = box2.y + box2.height + halfLineWidth;
    return {
      x: minX,
      minX,
      y: minY,
      minY,
      width: box2.width + lineWidth,
      height: box2.height + lineWidth,
      maxX,
      maxY
    };
  };
  ShapeBase4.prototype.isFill = function() {
    return !!this.attrs["fill"] || this.isClipShape();
  };
  ShapeBase4.prototype.isStroke = function() {
    return !!this.attrs["stroke"];
  };
  ShapeBase4.prototype._applyClip = function(context, clip) {
    if (clip) {
      context.save();
      applyAttrsToContext(context, clip);
      clip.createPath(context);
      context.restore();
      context.clip();
      clip._afterDraw();
    }
  };
  ShapeBase4.prototype.draw = function(context, region) {
    var clip = this.cfg.clipShape;
    if (region) {
      if (this.cfg.refresh === false) {
        this.set("hasChanged", false);
        return;
      }
      var bbox = this.getCanvasBBox();
      if (!intersectRect2(region, bbox)) {
        this.set("hasChanged", false);
        if (this.cfg.isInView) {
          this._afterDraw();
        }
        return;
      }
    }
    context.save();
    applyAttrsToContext(context, this);
    this._applyClip(context, clip);
    this.drawPath(context);
    context.restore();
    this._afterDraw();
  };
  ShapeBase4.prototype.getCanvasViewBox = function() {
    var canvas = this.cfg.canvas;
    if (canvas) {
      return canvas.getViewRange();
    }
    return null;
  };
  ShapeBase4.prototype.cacheCanvasBBox = function() {
    var canvasBBox = this.getCanvasViewBox();
    if (canvasBBox) {
      var bbox = this.getCanvasBBox();
      var isInView = intersectRect2(bbox, canvasBBox);
      this.set("isInView", isInView);
      if (isInView) {
        this.set("cacheCanvasBBox", bbox);
      } else {
        this.set("cacheCanvasBBox", null);
      }
    }
  };
  ShapeBase4.prototype._afterDraw = function() {
    this.cacheCanvasBBox();
    this.set("hasChanged", false);
    this.set("refresh", null);
  };
  ShapeBase4.prototype.skipDraw = function() {
    this.set("cacheCanvasBBox", null);
    this.set("isInView", null);
    this.set("hasChanged", false);
  };
  ShapeBase4.prototype.drawPath = function(context) {
    this.createPath(context);
    this.strokeAndFill(context);
    this.afterDrawPath(context);
  };
  ShapeBase4.prototype.fill = function(context) {
    context.fill();
  };
  ShapeBase4.prototype.stroke = function(context) {
    context.stroke();
  };
  ShapeBase4.prototype.strokeAndFill = function(context) {
    var _a3 = this.attrs, lineWidth = _a3.lineWidth, opacity = _a3.opacity, strokeOpacity = _a3.strokeOpacity, fillOpacity = _a3.fillOpacity;
    if (this.isFill()) {
      if (!is_nil_default(fillOpacity) && fillOpacity !== 1) {
        context.globalAlpha = fillOpacity;
        this.fill(context);
        context.globalAlpha = opacity;
      } else {
        this.fill(context);
      }
    }
    if (this.isStroke()) {
      if (lineWidth > 0) {
        if (!is_nil_default(strokeOpacity) && strokeOpacity !== 1) {
          context.globalAlpha = strokeOpacity;
        }
        this.stroke(context);
      }
    }
    this.afterDrawPath(context);
  };
  ShapeBase4.prototype.createPath = function(context) {
  };
  ShapeBase4.prototype.afterDrawPath = function(context) {
  };
  ShapeBase4.prototype.isInShape = function(refX, refY) {
    var isStroke = this.isStroke();
    var isFill = this.isFill();
    var lineWidth = this.getHitLineWidth();
    return this.isInStrokeOrPath(refX, refY, isStroke, isFill, lineWidth);
  };
  ShapeBase4.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
    return false;
  };
  ShapeBase4.prototype.getHitLineWidth = function() {
    if (!this.isStroke()) {
      return 0;
    }
    var attrs = this.attrs;
    return attrs["lineWidth"] + attrs["lineAppendWidth"];
  };
  return ShapeBase4;
}(shape_default);
var base_default15 = ShapeBase2;

// node_modules/@antv/g-canvas/esm/shape/circle.js
var Circle3 = function(_super) {
  __extends(Circle6, _super);
  function Circle6() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Circle6.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign(__assign({}, attrs), { x: 0, y: 0, r: 0 });
  };
  Circle6.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
    var attrs = this.attr();
    var cx = attrs.x;
    var cy = attrs.y;
    var r = attrs.r;
    var halfLineWidth = lineWidth / 2;
    var absDistance = distance7(cx, cy, x, y);
    if (isFill && isStroke) {
      return absDistance <= r + halfLineWidth;
    }
    if (isFill) {
      return absDistance <= r;
    }
    if (isStroke) {
      return absDistance >= r - halfLineWidth && absDistance <= r + halfLineWidth;
    }
    return false;
  };
  Circle6.prototype.createPath = function(context) {
    var attrs = this.attr();
    var cx = attrs.x;
    var cy = attrs.y;
    var r = attrs.r;
    context.beginPath();
    context.arc(cx, cy, r, 0, Math.PI * 2, false);
    context.closePath();
  };
  return Circle6;
}(base_default15);
var circle_default5 = Circle3;

// node_modules/@antv/g-canvas/esm/shape/ellipse.js
function ellipseDistance(squareX, squareY, rx, ry) {
  return squareX / (rx * rx) + squareY / (ry * ry);
}
var Ellipse = function(_super) {
  __extends(Ellipse3, _super);
  function Ellipse3() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Ellipse3.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign(__assign({}, attrs), { x: 0, y: 0, rx: 0, ry: 0 });
  };
  Ellipse3.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
    var attrs = this.attr();
    var halfLineWith = lineWidth / 2;
    var cx = attrs.x;
    var cy = attrs.y;
    var rx = attrs.rx, ry = attrs.ry;
    var squareX = (x - cx) * (x - cx);
    var squareY = (y - cy) * (y - cy);
    if (isFill && isStroke) {
      return ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;
    }
    if (isFill) {
      return ellipseDistance(squareX, squareY, rx, ry) <= 1;
    }
    if (isStroke) {
      return ellipseDistance(squareX, squareY, rx - halfLineWith, ry - halfLineWith) >= 1 && ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;
    }
    return false;
  };
  Ellipse3.prototype.createPath = function(context) {
    var attrs = this.attr();
    var cx = attrs.x;
    var cy = attrs.y;
    var rx = attrs.rx;
    var ry = attrs.ry;
    context.beginPath();
    if (context.ellipse) {
      context.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2, false);
    } else {
      var r = rx > ry ? rx : ry;
      var scaleX = rx > ry ? 1 : rx / ry;
      var scaleY = rx > ry ? ry / rx : 1;
      context.save();
      context.translate(cx, cy);
      context.scale(scaleX, scaleY);
      context.arc(0, 0, r, 0, Math.PI * 2);
      context.restore();
      context.closePath();
    }
  };
  return Ellipse3;
}(base_default15);
var ellipse_default3 = Ellipse;

// node_modules/@antv/g-canvas/esm/shape/image.js
function isCanvas(dom) {
  return dom instanceof HTMLElement && is_string_default(dom.nodeName) && dom.nodeName.toUpperCase() === "CANVAS";
}
var ImageShape = function(_super) {
  __extends(ImageShape2, _super);
  function ImageShape2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ImageShape2.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign(__assign({}, attrs), { x: 0, y: 0, width: 0, height: 0 });
  };
  ImageShape2.prototype.initAttrs = function(attrs) {
    this._setImage(attrs.img);
  };
  ImageShape2.prototype.isStroke = function() {
    return false;
  };
  ImageShape2.prototype.isOnlyHitBox = function() {
    return true;
  };
  ImageShape2.prototype._afterLoading = function() {
    if (this.get("toDraw") === true) {
      var canvas = this.get("canvas");
      if (canvas) {
        canvas.draw();
      } else {
        this.createPath(this.get("context"));
      }
    }
  };
  ImageShape2.prototype._setImage = function(img) {
    var _this = this;
    var attrs = this.attrs;
    if (is_string_default(img)) {
      var image_1 = new Image();
      image_1.onload = function() {
        if (_this.destroyed) {
          return false;
        }
        _this.attr("img", image_1);
        _this.set("loading", false);
        _this._afterLoading();
        var callback = _this.get("callback");
        if (callback) {
          callback.call(_this);
        }
      };
      image_1.crossOrigin = "Anonymous";
      image_1.src = img;
      this.set("loading", true);
    } else if (img instanceof Image) {
      if (!attrs.width) {
        attrs.width = img.width;
      }
      if (!attrs.height) {
        attrs.height = img.height;
      }
    } else if (isCanvas(img)) {
      if (!attrs.width) {
        attrs.width = Number(img.getAttribute("width"));
      }
      if (!attrs.height) {
        attrs.height, Number(img.getAttribute("height"));
      }
    }
  };
  ImageShape2.prototype.onAttrChange = function(name, value, originValue) {
    _super.prototype.onAttrChange.call(this, name, value, originValue);
    if (name === "img") {
      this._setImage(value);
    }
  };
  ImageShape2.prototype.createPath = function(context) {
    if (this.get("loading")) {
      this.set("toDraw", true);
      this.set("context", context);
      return;
    }
    var attrs = this.attr();
    var x = attrs.x, y = attrs.y, width = attrs.width, height = attrs.height, sx = attrs.sx, sy = attrs.sy, swidth = attrs.swidth, sheight = attrs.sheight;
    var img = attrs.img;
    if (img instanceof Image || isCanvas(img)) {
      if (!is_nil_default(sx) && !is_nil_default(sy) && !is_nil_default(swidth) && !is_nil_default(sheight)) {
        context.drawImage(img, sx, sy, swidth, sheight, x, y, width, height);
      } else {
        context.drawImage(img, x, y, width, height);
      }
    }
  };
  return ImageShape2;
}(base_default15);
var image_default2 = ImageShape;

// node_modules/@antv/g-canvas/esm/util/in-stroke/line.js
function inLine(x1, y1, x2, y2, lineWidth, x, y) {
  var minX = Math.min(x1, x2);
  var maxX = Math.max(x1, x2);
  var minY = Math.min(y1, y2);
  var maxY = Math.max(y1, y2);
  var halfWidth = lineWidth / 2;
  if (!(x >= minX - halfWidth && x <= maxX + halfWidth && y >= minY - halfWidth && y <= maxY + halfWidth)) {
    return false;
  }
  return line_default.pointToLine(x1, y1, x2, y2, x, y) <= lineWidth / 2;
}

// node_modules/@antv/g-canvas/esm/shape/line.js
var Line3 = function(_super) {
  __extends(Line6, _super);
  function Line6() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Line6.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign(__assign({}, attrs), { x1: 0, y1: 0, x2: 0, y2: 0, startArrow: false, endArrow: false });
  };
  Line6.prototype.initAttrs = function(attrs) {
    this.setArrow();
  };
  Line6.prototype.onAttrChange = function(name, value, originValue) {
    _super.prototype.onAttrChange.call(this, name, value, originValue);
    this.setArrow();
  };
  Line6.prototype.setArrow = function() {
    var attrs = this.attr();
    var x1 = attrs.x1, y1 = attrs.y1, x2 = attrs.x2, y2 = attrs.y2, startArrow = attrs.startArrow, endArrow = attrs.endArrow;
    if (startArrow) {
      addStartArrow(this, attrs, x2, y2, x1, y1);
    }
    if (endArrow) {
      addEndArrow(this, attrs, x1, y1, x2, y2);
    }
  };
  Line6.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
    if (!isStroke || !lineWidth) {
      return false;
    }
    var _a3 = this.attr(), x1 = _a3.x1, y1 = _a3.y1, x2 = _a3.x2, y2 = _a3.y2;
    return inLine(x1, y1, x2, y2, lineWidth, x, y);
  };
  Line6.prototype.createPath = function(context) {
    var attrs = this.attr();
    var x1 = attrs.x1, y1 = attrs.y1, x2 = attrs.x2, y2 = attrs.y2, startArrow = attrs.startArrow, endArrow = attrs.endArrow;
    var startArrowDistance = {
      dx: 0,
      dy: 0
    };
    var endArrowDistance = {
      dx: 0,
      dy: 0
    };
    if (startArrow && startArrow.d) {
      startArrowDistance = getShortenOffset(x1, y1, x2, y2, attrs.startArrow.d);
    }
    if (endArrow && endArrow.d) {
      endArrowDistance = getShortenOffset(x1, y1, x2, y2, attrs.endArrow.d);
    }
    context.beginPath();
    context.moveTo(x1 + startArrowDistance.dx, y1 + startArrowDistance.dy);
    context.lineTo(x2 - endArrowDistance.dx, y2 - endArrowDistance.dy);
  };
  Line6.prototype.afterDrawPath = function(context) {
    var startArrowShape = this.get("startArrowShape");
    var endArrowShape = this.get("endArrowShape");
    if (startArrowShape) {
      startArrowShape.draw(context);
    }
    if (endArrowShape) {
      endArrowShape.draw(context);
    }
  };
  Line6.prototype.getTotalLength = function() {
    var _a3 = this.attr(), x1 = _a3.x1, y1 = _a3.y1, x2 = _a3.x2, y2 = _a3.y2;
    return line_default.length(x1, y1, x2, y2);
  };
  Line6.prototype.getPoint = function(ratio) {
    var _a3 = this.attr(), x1 = _a3.x1, y1 = _a3.y1, x2 = _a3.x2, y2 = _a3.y2;
    return line_default.pointAt(x1, y1, x2, y2, ratio);
  };
  return Line6;
}(base_default15);
var line_default7 = Line3;

// node_modules/@antv/g-canvas/esm/shape/marker.js
var Symbols = {
  circle: function(x, y, r) {
    return [
      ["M", x - r, y],
      ["A", r, r, 0, 1, 0, x + r, y],
      ["A", r, r, 0, 1, 0, x - r, y]
    ];
  },
  square: function(x, y, r) {
    return [["M", x - r, y - r], ["L", x + r, y - r], ["L", x + r, y + r], ["L", x - r, y + r], ["Z"]];
  },
  diamond: function(x, y, r) {
    return [["M", x - r, y], ["L", x, y - r], ["L", x + r, y], ["L", x, y + r], ["Z"]];
  },
  triangle: function(x, y, r) {
    var diffY = r * Math.sin(1 / 3 * Math.PI);
    return [["M", x - r, y + diffY], ["L", x, y - diffY], ["L", x + r, y + diffY], ["Z"]];
  },
  "triangle-down": function(x, y, r) {
    var diffY = r * Math.sin(1 / 3 * Math.PI);
    return [["M", x - r, y - diffY], ["L", x + r, y - diffY], ["L", x, y + diffY], ["Z"]];
  }
};
var Marker = function(_super) {
  __extends(Marker3, _super);
  function Marker3() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Marker3.prototype.initAttrs = function(attrs) {
    this._resetParamsCache();
  };
  Marker3.prototype._resetParamsCache = function() {
    this.set("paramsCache", {});
  };
  Marker3.prototype.onAttrChange = function(name, value, originValue) {
    _super.prototype.onAttrChange.call(this, name, value, originValue);
    if (["symbol", "x", "y", "r", "radius"].indexOf(name) !== -1) {
      this._resetParamsCache();
    }
  };
  Marker3.prototype.isOnlyHitBox = function() {
    return true;
  };
  Marker3.prototype._getR = function(attrs) {
    return is_nil_default(attrs.r) ? attrs.radius : attrs.r;
  };
  Marker3.prototype._getPath = function() {
    var attrs = this.attr();
    var x = attrs.x, y = attrs.y;
    var symbol = attrs.symbol || "circle";
    var r = this._getR(attrs);
    var method;
    var path;
    if (is_function_default(symbol)) {
      method = symbol;
      path = method(x, y, r);
      path = pathToAbsolute2(path);
    } else {
      method = Marker3.Symbols[symbol];
      if (!method) {
        console.warn(symbol + " marker is not supported.");
        return null;
      }
      path = method(x, y, r);
    }
    return path;
  };
  Marker3.prototype.createPath = function(context) {
    var path = this._getPath();
    var paramsCache = this.get("paramsCache");
    drawPath(this, context, { path }, paramsCache);
  };
  Marker3.Symbols = Symbols;
  return Marker3;
}(base_default15);
var marker_default = Marker;

// node_modules/@antv/g-canvas/esm/util/in-path/point-in-path.js
function isPointInPath(shape, x, y) {
  var ctx3 = getOffScreenContext();
  shape.createPath(ctx3);
  return ctx3.isPointInPath(x, y);
}

// node_modules/@antv/g-canvas/esm/util/in-path/polygon.js
var tolerance2 = 1e-6;
function dcmp2(x) {
  if (Math.abs(x) < tolerance2) {
    return 0;
  }
  return x < 0 ? -1 : 1;
}
function onSegment2(p1, p2, q) {
  if ((q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q[0] && q[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q[1] && q[1] <= Math.max(p1[1], p2[1])) {
    return true;
  }
  return false;
}
function isInPolygon2(points, x, y) {
  var isHit = false;
  var n = points.length;
  if (n <= 2) {
    return false;
  }
  for (var i = 0; i < n; i++) {
    var p1 = points[i];
    var p2 = points[(i + 1) % n];
    if (onSegment2(p1, p2, [x, y])) {
      return true;
    }
    if (dcmp2(p1[1] - y) > 0 !== dcmp2(p2[1] - y) > 0 && dcmp2(x - (y - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) {
      isHit = !isHit;
    }
  }
  return isHit;
}

// node_modules/@antv/g-canvas/esm/util/in-stroke/arc.js
function arc(cx, cy, r, startAngle, endAngle, lineWidth, x, y) {
  var angle3 = (Math.atan2(y - cy, x - cx) + Math.PI * 2) % (Math.PI * 2);
  if (angle3 < startAngle || angle3 > endAngle) {
    return false;
  }
  var point = {
    x: cx + r * Math.cos(angle3),
    y: cy + r * Math.sin(angle3)
  };
  return distance7(point.x, point.y, x, y) <= lineWidth / 2;
}

// node_modules/@antv/g-canvas/esm/util/path.js
var transform4 = ext_exports.transform;
function hasArc(path) {
  var hasArc2 = false;
  var count = path.length;
  for (var i = 0; i < count; i++) {
    var params = path[i];
    var cmd = params[0];
    if (cmd === "C" || cmd === "A" || cmd === "Q") {
      hasArc2 = true;
      break;
    }
  }
  return hasArc2;
}
function isPointInStroke(segments, lineWidth, x, y, length5) {
  var isHit = false;
  var halfWidth = lineWidth / 2;
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint, box2 = segment.box;
    if (box2 && !inBox(box2.x - halfWidth, box2.y - halfWidth, box2.width + lineWidth, box2.height + lineWidth, x, y)) {
      continue;
    }
    switch (segment.command) {
      case "L":
      case "Z":
        isHit = inLine(prePoint[0], prePoint[1], currentPoint[0], currentPoint[1], lineWidth, x, y);
        break;
      case "Q":
        var qDistance = quadratic_default.pointDistance(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], x, y);
        isHit = qDistance <= lineWidth / 2;
        break;
      case "C":
        var cDistance = cubic_default.pointDistance(
          prePoint[0],
          prePoint[1],
          params[1],
          params[2],
          params[3],
          params[4],
          params[5],
          params[6],
          x,
          y,
          length5
        );
        isHit = cDistance <= lineWidth / 2;
        break;
      case "A":
        var arcParams = segment.arcParams;
        var cx = arcParams.cx, cy = arcParams.cy, rx = arcParams.rx, ry = arcParams.ry, startAngle = arcParams.startAngle, endAngle = arcParams.endAngle, xRotation = arcParams.xRotation;
        var p = [x, y, 1];
        var r = rx > ry ? rx : ry;
        var scaleX = rx > ry ? 1 : rx / ry;
        var scaleY = rx > ry ? ry / rx : 1;
        var m = transform4(null, [
          ["t", -cx, -cy],
          ["r", -xRotation],
          ["s", 1 / scaleX, 1 / scaleY]
        ]);
        transformMat3(p, p, m);
        isHit = arc(0, 0, r, startAngle, endAngle, lineWidth, p[0], p[1]);
        break;
      default:
        break;
    }
    if (isHit) {
      break;
    }
  }
  return isHit;
}
function extractPolygons(path) {
  var count = path.length;
  var polygons = [];
  var polylines = [];
  var points = [];
  for (var i = 0; i < count; i++) {
    var params = path[i];
    var cmd = params[0];
    if (cmd === "M") {
      if (points.length) {
        polylines.push(points);
        points = [];
      }
      points.push([params[1], params[2]]);
    } else if (cmd === "Z") {
      if (points.length) {
        polygons.push(points);
        points = [];
      }
    } else {
      points.push([params[1], params[2]]);
    }
  }
  if (points.length > 0) {
    polylines.push(points);
  }
  return {
    polygons,
    polylines
  };
}
var path_default3 = __assign({ hasArc, extractPolygons, isPointInStroke }, path_exports);

// node_modules/@antv/g-canvas/esm/shape/path.js
function isInPolygons(polygons, x, y) {
  var isHit = false;
  for (var i = 0; i < polygons.length; i++) {
    var points = polygons[i];
    isHit = isInPolygon2(points, x, y);
    if (isHit) {
      break;
    }
  }
  return isHit;
}
var Path = function(_super) {
  __extends(Path4, _super);
  function Path4() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Path4.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign(__assign({}, attrs), { startArrow: false, endArrow: false });
  };
  Path4.prototype.initAttrs = function(attrs) {
    this._setPathArr(attrs.path);
    this.setArrow();
  };
  Path4.prototype.onAttrChange = function(name, value, originValue) {
    _super.prototype.onAttrChange.call(this, name, value, originValue);
    if (name === "path") {
      this._setPathArr(value);
    }
    this.setArrow();
  };
  Path4.prototype._setPathArr = function(path) {
    this.attrs.path = pathToAbsolute2(path);
    var hasArc2 = path_default3.hasArc(path);
    this.set("hasArc", hasArc2);
    this.set("paramsCache", {});
    this.set("segments", null);
    this.set("curve", null);
    this.set("tCache", null);
    this.set("totalLength", null);
  };
  Path4.prototype.getSegments = function() {
    var segments = this.get("segements");
    if (!segments) {
      segments = getSegments(this.attr("path"));
      this.set("segments", segments);
    }
    return segments;
  };
  Path4.prototype.setArrow = function() {
    var attrs = this.attr();
    var startArrow = attrs.startArrow, endArrow = attrs.endArrow;
    if (startArrow) {
      var tangent = this.getStartTangent();
      addStartArrow(this, attrs, tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1]);
    }
    if (endArrow) {
      var tangent = this.getEndTangent();
      addEndArrow(this, attrs, tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1]);
    }
  };
  Path4.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
    var segments = this.getSegments();
    var hasArc2 = this.get("hasArc");
    var isHit = false;
    if (isStroke) {
      var length_1 = this.getTotalLength();
      isHit = path_default3.isPointInStroke(segments, lineWidth, x, y, length_1);
    }
    if (!isHit && isFill) {
      if (hasArc2) {
        isHit = isPointInPath(this, x, y);
      } else {
        var path = this.attr("path");
        var extractResutl = path_default3.extractPolygons(path);
        isHit = isInPolygons(extractResutl.polygons, x, y) || isInPolygons(extractResutl.polylines, x, y);
      }
    }
    return isHit;
  };
  Path4.prototype.createPath = function(context) {
    var attrs = this.attr();
    var paramsCache = this.get("paramsCache");
    drawPath(this, context, attrs, paramsCache);
  };
  Path4.prototype.afterDrawPath = function(context) {
    var startArrowShape = this.get("startArrowShape");
    var endArrowShape = this.get("endArrowShape");
    if (startArrowShape) {
      startArrowShape.draw(context);
    }
    if (endArrowShape) {
      endArrowShape.draw(context);
    }
  };
  Path4.prototype.getTotalLength = function() {
    var totalLength = this.get("totalLength");
    if (!is_nil_default(totalLength)) {
      return totalLength;
    }
    this._calculateCurve();
    this._setTcache();
    return this.get("totalLength");
  };
  Path4.prototype.getPoint = function(ratio) {
    var tCache = this.get("tCache");
    if (!tCache) {
      this._calculateCurve();
      this._setTcache();
      tCache = this.get("tCache");
    }
    var subt;
    var index;
    var curve = this.get("curve");
    if (!tCache || tCache.length === 0) {
      if (curve) {
        return {
          x: curve[0][1],
          y: curve[0][2]
        };
      }
      return null;
    }
    each_default(tCache, function(v, i) {
      if (ratio >= v[0] && ratio <= v[1]) {
        subt = (ratio - v[0]) / (v[1] - v[0]);
        index = i;
      }
    });
    var seg = curve[index];
    if (is_nil_default(seg) || is_nil_default(index)) {
      return null;
    }
    var l = seg.length;
    var nextSeg = curve[index + 1];
    return cubic_default.pointAt(seg[l - 2], seg[l - 1], nextSeg[1], nextSeg[2], nextSeg[3], nextSeg[4], nextSeg[5], nextSeg[6], subt);
  };
  Path4.prototype._calculateCurve = function() {
    var path = this.attr().path;
    this.set("curve", path_default3.pathToCurve(path));
  };
  Path4.prototype._setTcache = function() {
    var totalLength = 0;
    var tempLength = 0;
    var tCache = [];
    var segmentT;
    var segmentL;
    var segmentN;
    var l;
    var curve = this.get("curve");
    if (!curve) {
      return;
    }
    each_default(curve, function(segment, i) {
      segmentN = curve[i + 1];
      l = segment.length;
      if (segmentN) {
        totalLength += cubic_default.length(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]) || 0;
      }
    });
    this.set("totalLength", totalLength);
    if (totalLength === 0) {
      this.set("tCache", []);
      return;
    }
    each_default(curve, function(segment, i) {
      segmentN = curve[i + 1];
      l = segment.length;
      if (segmentN) {
        segmentT = [];
        segmentT[0] = tempLength / totalLength;
        segmentL = cubic_default.length(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]);
        tempLength += segmentL || 0;
        segmentT[1] = tempLength / totalLength;
        tCache.push(segmentT);
      }
    });
    this.set("tCache", tCache);
  };
  Path4.prototype.getStartTangent = function() {
    var segments = this.getSegments();
    var result;
    if (segments.length > 1) {
      var startPoint = segments[0].currentPoint;
      var endPoint = segments[1].currentPoint;
      var tangent = segments[1].startTangent;
      result = [];
      if (tangent) {
        result.push([startPoint[0] - tangent[0], startPoint[1] - tangent[1]]);
        result.push([startPoint[0], startPoint[1]]);
      } else {
        result.push([endPoint[0], endPoint[1]]);
        result.push([startPoint[0], startPoint[1]]);
      }
    }
    return result;
  };
  Path4.prototype.getEndTangent = function() {
    var segments = this.getSegments();
    var length5 = segments.length;
    var result;
    if (length5 > 1) {
      var startPoint = segments[length5 - 2].currentPoint;
      var endPoint = segments[length5 - 1].currentPoint;
      var tangent = segments[length5 - 1].endTangent;
      result = [];
      if (tangent) {
        result.push([endPoint[0] - tangent[0], endPoint[1] - tangent[1]]);
        result.push([endPoint[0], endPoint[1]]);
      } else {
        result.push([startPoint[0], startPoint[1]]);
        result.push([endPoint[0], endPoint[1]]);
      }
    }
    return result;
  };
  return Path4;
}(base_default15);
var path_default2 = Path;

// node_modules/@antv/g-canvas/esm/util/in-stroke/polyline.js
function inPolyline(points, lineWidth, x, y, isClose) {
  var count = points.length;
  if (count < 2) {
    return false;
  }
  for (var i = 0; i < count - 1; i++) {
    var x1 = points[i][0];
    var y1 = points[i][1];
    var x2 = points[i + 1][0];
    var y2 = points[i + 1][1];
    if (inLine(x1, y1, x2, y2, lineWidth, x, y)) {
      return true;
    }
  }
  if (isClose) {
    var first = points[0];
    var last2 = points[count - 1];
    if (inLine(first[0], first[1], last2[0], last2[1], lineWidth, x, y)) {
      return true;
    }
  }
  return false;
}

// node_modules/@antv/g-canvas/esm/shape/polygon.js
var Polygon = function(_super) {
  __extends(Polygon4, _super);
  function Polygon4() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Polygon4.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
    var points = this.attr().points;
    var isHit = false;
    if (isStroke) {
      isHit = inPolyline(points, lineWidth, x, y, true);
    }
    if (!isHit && isFill) {
      isHit = isInPolygon2(points, x, y);
    }
    return isHit;
  };
  Polygon4.prototype.createPath = function(context) {
    var attrs = this.attr();
    var points = attrs.points;
    if (points.length < 2) {
      return;
    }
    context.beginPath();
    for (var i = 0; i < points.length; i++) {
      var point = points[i];
      if (i === 0) {
        context.moveTo(point[0], point[1]);
      } else {
        context.lineTo(point[0], point[1]);
      }
    }
    context.closePath();
  };
  return Polygon4;
}(base_default15);
var polygon_default3 = Polygon;

// node_modules/@antv/g-canvas/esm/shape/polyline.js
var PolyLine = function(_super) {
  __extends(PolyLine2, _super);
  function PolyLine2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  PolyLine2.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign(__assign({}, attrs), { startArrow: false, endArrow: false });
  };
  PolyLine2.prototype.initAttrs = function(attrs) {
    this.setArrow();
  };
  PolyLine2.prototype.onAttrChange = function(name, value, originValue) {
    _super.prototype.onAttrChange.call(this, name, value, originValue);
    this.setArrow();
    if (["points"].indexOf(name) !== -1) {
      this._resetCache();
    }
  };
  PolyLine2.prototype._resetCache = function() {
    this.set("totalLength", null);
    this.set("tCache", null);
  };
  PolyLine2.prototype.setArrow = function() {
    var attrs = this.attr();
    var _a3 = this.attrs, points = _a3.points, startArrow = _a3.startArrow, endArrow = _a3.endArrow;
    var length5 = points.length;
    var x1 = points[0][0];
    var y1 = points[0][1];
    var x2 = points[length5 - 1][0];
    var y2 = points[length5 - 1][1];
    if (startArrow) {
      addStartArrow(this, attrs, points[1][0], points[1][1], x1, y1);
    }
    if (endArrow) {
      addEndArrow(this, attrs, points[length5 - 2][0], points[length5 - 2][1], x2, y2);
    }
  };
  PolyLine2.prototype.isFill = function() {
    return false;
  };
  PolyLine2.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
    if (!isStroke || !lineWidth) {
      return false;
    }
    var points = this.attr().points;
    return inPolyline(points, lineWidth, x, y, false);
  };
  PolyLine2.prototype.isStroke = function() {
    return true;
  };
  PolyLine2.prototype.createPath = function(context) {
    var _a3 = this.attr(), points = _a3.points, startArrow = _a3.startArrow, endArrow = _a3.endArrow;
    var length5 = points.length;
    if (points.length < 2) {
      return;
    }
    var x1 = points[0][0];
    var y1 = points[0][1];
    var x2 = points[length5 - 1][0];
    var y2 = points[length5 - 1][1];
    if (startArrow && startArrow.d) {
      var distance8 = getShortenOffset(x1, y1, points[1][0], points[1][1], startArrow.d);
      x1 += distance8.dx;
      y1 += distance8.dy;
    }
    if (endArrow && endArrow.d) {
      var distance8 = getShortenOffset(points[length5 - 2][0], points[length5 - 2][1], x2, y2, endArrow.d);
      x2 -= distance8.dx;
      y2 -= distance8.dy;
    }
    context.beginPath();
    context.moveTo(x1, y1);
    for (var i = 0; i < length5 - 1; i++) {
      var point = points[i];
      context.lineTo(point[0], point[1]);
    }
    context.lineTo(x2, y2);
  };
  PolyLine2.prototype.afterDrawPath = function(context) {
    var startArrowShape = this.get("startArrowShape");
    var endArrowShape = this.get("endArrowShape");
    if (startArrowShape) {
      startArrowShape.draw(context);
    }
    if (endArrowShape) {
      endArrowShape.draw(context);
    }
  };
  PolyLine2.prototype.getTotalLength = function() {
    var points = this.attr().points;
    var totalLength = this.get("totalLength");
    if (!is_nil_default(totalLength)) {
      return totalLength;
    }
    this.set("totalLength", polyline_default.length(points));
    return this.get("totalLength");
  };
  PolyLine2.prototype.getPoint = function(ratio) {
    var points = this.attr().points;
    var tCache = this.get("tCache");
    if (!tCache) {
      this._setTcache();
      tCache = this.get("tCache");
    }
    var subt;
    var index;
    each_default(tCache, function(v, i) {
      if (ratio >= v[0] && ratio <= v[1]) {
        subt = (ratio - v[0]) / (v[1] - v[0]);
        index = i;
      }
    });
    return line_default.pointAt(points[index][0], points[index][1], points[index + 1][0], points[index + 1][1], subt);
  };
  PolyLine2.prototype._setTcache = function() {
    var points = this.attr().points;
    if (!points || points.length === 0) {
      return;
    }
    var totalLength = this.getTotalLength();
    if (totalLength <= 0) {
      return;
    }
    var tempLength = 0;
    var tCache = [];
    var segmentT;
    var segmentL;
    each_default(points, function(p, i) {
      if (points[i + 1]) {
        segmentT = [];
        segmentT[0] = tempLength / totalLength;
        segmentL = line_default.length(p[0], p[1], points[i + 1][0], points[i + 1][1]);
        tempLength += segmentL;
        segmentT[1] = tempLength / totalLength;
        tCache.push(segmentT);
      }
    });
    this.set("tCache", tCache);
  };
  PolyLine2.prototype.getStartTangent = function() {
    var points = this.attr().points;
    var result = [];
    result.push([points[1][0], points[1][1]]);
    result.push([points[0][0], points[0][1]]);
    return result;
  };
  PolyLine2.prototype.getEndTangent = function() {
    var points = this.attr().points;
    var l = points.length - 1;
    var result = [];
    result.push([points[l - 1][0], points[l - 1][1]]);
    result.push([points[l][0], points[l][1]]);
    return result;
  };
  return PolyLine2;
}(base_default15);
var polyline_default3 = PolyLine;

// node_modules/@antv/g-canvas/esm/util/in-stroke/rect.js
function inRect(minX, minY, width, height, lineWidth, x, y) {
  var halfWidth = lineWidth / 2;
  return inBox(minX - halfWidth, minY - halfWidth, width, lineWidth, x, y) || inBox(minX + width - halfWidth, minY - halfWidth, lineWidth, height, x, y) || inBox(minX + halfWidth, minY + height - halfWidth, width, lineWidth, x, y) || inBox(minX - halfWidth, minY + halfWidth, lineWidth, height, x, y);
}

// node_modules/@antv/g-canvas/esm/util/in-stroke/rect-radius.js
function rectWithRadius(minX, minY, width, height, radius, lineWidth, x, y) {
  var halfWidth = lineWidth / 2;
  return inLine(minX + radius, minY, minX + width - radius, minY, lineWidth, x, y) || inLine(minX + width, minY + radius, minX + width, minY + height - radius, lineWidth, x, y) || inLine(minX + width - radius, minY + height, minX + radius, minY + height, lineWidth, x, y) || inLine(minX, minY + height - radius, minX, minY + radius, lineWidth, x, y) || arc(minX + width - radius, minY + radius, radius, 1.5 * Math.PI, 2 * Math.PI, lineWidth, x, y) || arc(minX + width - radius, minY + height - radius, radius, 0, 0.5 * Math.PI, lineWidth, x, y) || arc(minX + radius, minY + height - radius, radius, 0.5 * Math.PI, Math.PI, lineWidth, x, y) || arc(minX + radius, minY + radius, radius, Math.PI, 1.5 * Math.PI, lineWidth, x, y);
}

// node_modules/@antv/g-canvas/esm/shape/rect.js
var Rect = function(_super) {
  __extends(Rect4, _super);
  function Rect4() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Rect4.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign(__assign({}, attrs), { x: 0, y: 0, width: 0, height: 0, radius: 0 });
  };
  Rect4.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
    var attrs = this.attr();
    var minX = attrs.x;
    var minY = attrs.y;
    var width = attrs.width;
    var height = attrs.height;
    var radius = attrs.radius;
    if (!radius) {
      var halfWidth = lineWidth / 2;
      if (isFill && isStroke) {
        return inBox(minX - halfWidth, minY - halfWidth, width + halfWidth, height + halfWidth, x, y);
      }
      if (isFill) {
        return inBox(minX, minY, width, height, x, y);
      }
      if (isStroke) {
        return inRect(minX, minY, width, height, lineWidth, x, y);
      }
    } else {
      var isHit = false;
      if (isStroke) {
        isHit = rectWithRadius(minX, minY, width, height, radius, lineWidth, x, y);
      }
      if (!isHit && isFill) {
        isHit = isPointInPath(this, x, y);
      }
      return isHit;
    }
  };
  Rect4.prototype.createPath = function(context) {
    var attrs = this.attr();
    var x = attrs.x;
    var y = attrs.y;
    var width = attrs.width;
    var height = attrs.height;
    var radius = attrs.radius;
    context.beginPath();
    if (radius === 0) {
      context.rect(x, y, width, height);
    } else {
      var _a3 = parseRadius(radius), r1 = _a3[0], r2 = _a3[1], r3 = _a3[2], r4 = _a3[3];
      context.moveTo(x + r1, y);
      context.lineTo(x + width - r2, y);
      r2 !== 0 && context.arc(x + width - r2, y + r2, r2, -Math.PI / 2, 0);
      context.lineTo(x + width, y + height - r3);
      r3 !== 0 && context.arc(x + width - r3, y + height - r3, r3, 0, Math.PI / 2);
      context.lineTo(x + r4, y + height);
      r4 !== 0 && context.arc(x + r4, y + height - r4, r4, Math.PI / 2, Math.PI);
      context.lineTo(x, y + r1);
      r1 !== 0 && context.arc(x + r1, y + r1, r1, Math.PI, Math.PI * 1.5);
      context.closePath();
    }
  };
  return Rect4;
}(base_default15);
var rect_default2 = Rect;

// node_modules/@antv/g-canvas/esm/shape/text.js
var Text = function(_super) {
  __extends(Text3, _super);
  function Text3() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Text3.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign(__assign({}, attrs), { x: 0, y: 0, text: null, fontSize: 12, fontFamily: "sans-serif", fontStyle: "normal", fontWeight: "normal", fontVariant: "normal", textAlign: "start", textBaseline: "bottom" });
  };
  Text3.prototype.isOnlyHitBox = function() {
    return true;
  };
  Text3.prototype.initAttrs = function(attrs) {
    this._assembleFont();
    if (attrs.text) {
      this._setText(attrs.text);
    }
  };
  Text3.prototype._assembleFont = function() {
    var attrs = this.attrs;
    attrs.font = assembleFont(attrs);
  };
  Text3.prototype._setText = function(text) {
    var textArr = null;
    if (is_string_default(text) && text.indexOf("\n") !== -1) {
      textArr = text.split("\n");
    }
    this.set("textArr", textArr);
  };
  Text3.prototype.onAttrChange = function(name, value, originValue) {
    _super.prototype.onAttrChange.call(this, name, value, originValue);
    if (name.startsWith("font")) {
      this._assembleFont();
    }
    if (name === "text") {
      this._setText(value);
    }
  };
  Text3.prototype._getSpaceingY = function() {
    var attrs = this.attrs;
    var lineHeight = attrs.lineHeight;
    var fontSize = attrs.fontSize * 1;
    return lineHeight ? lineHeight - fontSize : fontSize * 0.14;
  };
  Text3.prototype._drawTextArr = function(context, textArr, isFill) {
    var attrs = this.attrs;
    var textBaseline = attrs.textBaseline;
    var x = attrs.x;
    var y = attrs.y;
    var fontSize = attrs.fontSize * 1;
    var spaceingY = this._getSpaceingY();
    var height = getTextHeight(attrs.text, attrs.fontSize, attrs.lineHeight);
    var subY;
    each_default(textArr, function(subText, index) {
      subY = y + index * (spaceingY + fontSize) - height + fontSize;
      if (textBaseline === "middle")
        subY += height - fontSize - (height - fontSize) / 2;
      if (textBaseline === "top")
        subY += height - fontSize;
      if (!is_nil_default(subText)) {
        if (isFill) {
          context.fillText(subText, x, subY);
        } else {
          context.strokeText(subText, x, subY);
        }
      }
    });
  };
  Text3.prototype._drawText = function(context, isFill) {
    var attrs = this.attr();
    var x = attrs.x;
    var y = attrs.y;
    var textArr = this.get("textArr");
    if (textArr) {
      this._drawTextArr(context, textArr, isFill);
    } else {
      var text = attrs.text;
      if (!is_nil_default(text)) {
        if (isFill) {
          context.fillText(text, x, y);
        } else {
          context.strokeText(text, x, y);
        }
      }
    }
  };
  Text3.prototype.strokeAndFill = function(context) {
    var _a3 = this.attrs, lineWidth = _a3.lineWidth, opacity = _a3.opacity, strokeOpacity = _a3.strokeOpacity, fillOpacity = _a3.fillOpacity;
    if (this.isStroke()) {
      if (lineWidth > 0) {
        if (!is_nil_default(strokeOpacity) && strokeOpacity !== 1) {
          context.globalAlpha = opacity;
        }
        this.stroke(context);
      }
    }
    if (this.isFill()) {
      if (!is_nil_default(fillOpacity) && fillOpacity !== 1) {
        context.globalAlpha = fillOpacity;
        this.fill(context);
        context.globalAlpha = opacity;
      } else {
        this.fill(context);
      }
    }
    this.afterDrawPath(context);
  };
  Text3.prototype.fill = function(context) {
    this._drawText(context, true);
  };
  Text3.prototype.stroke = function(context) {
    this._drawText(context, false);
  };
  return Text3;
}(base_default15);
var text_default3 = Text;

// node_modules/@antv/g-canvas/esm/util/hit.js
function invertFromMatrix(v, matrix) {
  if (matrix) {
    var invertMatrix = invert2(matrix);
    return multiplyVec2(invertMatrix, v);
  }
  return v;
}
function getRefXY(element, x, y) {
  var totalMatrix = element.getTotalMatrix();
  if (totalMatrix) {
    var _a3 = invertFromMatrix([x, y, 1], totalMatrix), refX = _a3[0], refY = _a3[1];
    return [refX, refY];
  }
  return [x, y];
}
function preTest(element, x, y) {
  if (element.isCanvas && element.isCanvas()) {
    return true;
  }
  if (!isAllowCapture(element) || element.cfg.isInView === false) {
    return false;
  }
  if (element.cfg.clipShape) {
    var _a3 = getRefXY(element, x, y), refX = _a3[0], refY = _a3[1];
    if (element.isClipped(refX, refY)) {
      return false;
    }
  }
  var bbox = element.cfg.cacheCanvasBBox || element.getCanvasBBox();
  if (!(x >= bbox.minX && x <= bbox.maxX && y >= bbox.minY && y <= bbox.maxY)) {
    return false;
  }
  return true;
}
function getShape(container, x, y) {
  if (!preTest(container, x, y)) {
    return null;
  }
  var shape = null;
  var children = container.getChildren();
  var count = children.length;
  for (var i = count - 1; i >= 0; i--) {
    var child = children[i];
    if (child.isGroup()) {
      shape = getShape(child, x, y);
    } else if (preTest(child, x, y)) {
      var curShape = child;
      var _a3 = getRefXY(child, x, y), refX = _a3[0], refY = _a3[1];
      if (curShape.isInShape(refX, refY)) {
        shape = child;
      }
    }
    if (shape) {
      break;
    }
  }
  return shape;
}

// node_modules/@antv/g-canvas/esm/canvas.js
var Canvas2 = function(_super) {
  __extends(Canvas4, _super);
  function Canvas4() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Canvas4.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    cfg["renderer"] = "canvas";
    cfg["autoDraw"] = true;
    cfg["localRefresh"] = true;
    cfg["refreshElements"] = [];
    cfg["clipView"] = true;
    cfg["quickHit"] = false;
    return cfg;
  };
  Canvas4.prototype.onCanvasChange = function(changeType) {
    if (changeType === "attr" || changeType === "sort" || changeType === "changeSize") {
      this.set("refreshElements", [this]);
      this.draw();
    }
  };
  Canvas4.prototype.getShapeBase = function() {
    return shape_exports;
  };
  Canvas4.prototype.getGroupBase = function() {
    return group_default3;
  };
  Canvas4.prototype.getPixelRatio = function() {
    var pixelRatio = this.get("pixelRatio") || getPixelRatio();
    return pixelRatio >= 1 ? Math.ceil(pixelRatio) : 1;
  };
  Canvas4.prototype.getViewRange = function() {
    return {
      minX: 0,
      minY: 0,
      maxX: this.cfg.width,
      maxY: this.cfg.height
    };
  };
  Canvas4.prototype.createDom = function() {
    var element = document.createElement("canvas");
    var context = element.getContext("2d");
    this.set("context", context);
    return element;
  };
  Canvas4.prototype.setDOMSize = function(width, height) {
    _super.prototype.setDOMSize.call(this, width, height);
    var context = this.get("context");
    var el = this.get("el");
    var pixelRatio = this.getPixelRatio();
    el.width = pixelRatio * width;
    el.height = pixelRatio * height;
    if (pixelRatio > 1) {
      context.scale(pixelRatio, pixelRatio);
    }
  };
  Canvas4.prototype.clear = function() {
    _super.prototype.clear.call(this);
    this._clearFrame();
    var context = this.get("context");
    var element = this.get("el");
    context.clearRect(0, 0, element.width, element.height);
  };
  Canvas4.prototype.getShape = function(x, y) {
    var shape;
    if (this.get("quickHit")) {
      shape = getShape(this, x, y);
    } else {
      shape = _super.prototype.getShape.call(this, x, y, null);
    }
    return shape;
  };
  Canvas4.prototype._getRefreshRegion = function() {
    var elements = this.get("refreshElements");
    var viewRegion = this.getViewRange();
    var region;
    if (elements.length && elements[0] === this) {
      region = viewRegion;
    } else {
      region = getMergedRegion(elements);
      if (region) {
        region.minX = Math.floor(region.minX);
        region.minY = Math.floor(region.minY);
        region.maxX = Math.ceil(region.maxX);
        region.maxY = Math.ceil(region.maxY);
        region.maxY += 1;
        var clipView = this.get("clipView");
        if (clipView) {
          region = mergeView(region, viewRegion);
        }
      }
    }
    return region;
  };
  Canvas4.prototype.refreshElement = function(element) {
    var refreshElements = this.get("refreshElements");
    refreshElements.push(element);
  };
  Canvas4.prototype._clearFrame = function() {
    var drawFrame = this.get("drawFrame");
    if (drawFrame) {
      cancelAnimationFrame(drawFrame);
      this.set("drawFrame", null);
      this.set("refreshElements", []);
    }
  };
  Canvas4.prototype.draw = function() {
    var drawFrame = this.get("drawFrame");
    if (this.get("autoDraw") && drawFrame) {
      return;
    }
    this._startDraw();
  };
  Canvas4.prototype._drawAll = function() {
    var context = this.get("context");
    var element = this.get("el");
    var children = this.getChildren();
    context.clearRect(0, 0, element.width, element.height);
    applyAttrsToContext(context, this);
    drawChildren(context, children);
    this.set("refreshElements", []);
  };
  Canvas4.prototype._drawRegion = function() {
    var context = this.get("context");
    var refreshElements = this.get("refreshElements");
    var children = this.getChildren();
    var region = this._getRefreshRegion();
    if (region) {
      context.clearRect(region.minX, region.minY, region.maxX - region.minX, region.maxY - region.minY);
      context.save();
      context.beginPath();
      context.rect(region.minX, region.minY, region.maxX - region.minX, region.maxY - region.minY);
      context.clip();
      applyAttrsToContext(context, this);
      checkRefresh(this, children, region);
      drawChildren(context, children, region);
      context.restore();
    } else if (refreshElements.length) {
      clearChanged(refreshElements);
    }
    each_default(refreshElements, function(element) {
      if (element.get("hasChanged")) {
        element.set("hasChanged", false);
      }
    });
    this.set("refreshElements", []);
  };
  Canvas4.prototype._startDraw = function() {
    var _this = this;
    var drawFrame = this.get("drawFrame");
    if (!drawFrame) {
      drawFrame = requestAnimationFrame(function() {
        if (_this.get("localRefresh")) {
          _this._drawRegion();
        } else {
          _this._drawAll();
        }
        _this.set("drawFrame", null);
      });
      this.set("drawFrame", drawFrame);
    }
  };
  Canvas4.prototype.skipDraw = function() {
  };
  Canvas4.prototype.removeDom = function() {
    var el = this.get("el");
    el.width = 0;
    el.height = 0;
    el.parentNode.removeChild(el);
  };
  return Canvas4;
}(canvas_default);
var canvas_default2 = Canvas2;

// node_modules/@antv/g-canvas/esm/index.js
var version = "0.5.12";

// node_modules/@antv/g-svg/esm/index.js
var esm_exports3 = {};
__export(esm_exports3, {
  AbstractCanvas: () => canvas_default,
  AbstractGroup: () => group_default2,
  AbstractShape: () => shape_default,
  Base: () => base_default2,
  Canvas: () => canvas_default3,
  Event: () => graph_event_default,
  Group: () => group_default4,
  PathUtil: () => path_exports,
  Shape: () => shape_exports2,
  assembleFont: () => assembleFont,
  getBBoxMethod: () => getMethod,
  getOffScreenContext: () => getOffScreenContext,
  getTextHeight: () => getTextHeight,
  invert: () => invert2,
  isAllowCapture: () => isAllowCapture,
  multiplyVec2: () => multiplyVec2,
  registerBBox: () => register,
  registerEasing: () => registerEasing,
  version: () => version2
});

// node_modules/@antv/g-svg/esm/shape/index.js
var shape_exports2 = {};
__export(shape_exports2, {
  Base: () => base_default16,
  Circle: () => circle_default6,
  Dom: () => dom_default,
  Ellipse: () => ellipse_default4,
  Image: () => image_default3,
  Line: () => line_default8,
  Marker: () => marker_default2,
  Path: () => path_default4,
  Polygon: () => polygon_default4,
  Polyline: () => polyline_default4,
  Rect: () => rect_default3,
  Text: () => text_default4
});

// node_modules/@antv/g-svg/esm/constant.js
var SHAPE_TO_TAGS = {
  rect: "path",
  circle: "circle",
  line: "line",
  path: "path",
  marker: "path",
  text: "text",
  polyline: "polyline",
  polygon: "polygon",
  image: "image",
  ellipse: "ellipse",
  dom: "foreignObject"
};
var SVG_ATTR_MAP = {
  opacity: "opacity",
  fillStyle: "fill",
  fill: "fill",
  fillOpacity: "fill-opacity",
  strokeStyle: "stroke",
  strokeOpacity: "stroke-opacity",
  stroke: "stroke",
  x: "x",
  y: "y",
  r: "r",
  rx: "rx",
  ry: "ry",
  width: "width",
  height: "height",
  x1: "x1",
  x2: "x2",
  y1: "y1",
  y2: "y2",
  lineCap: "stroke-linecap",
  lineJoin: "stroke-linejoin",
  lineWidth: "stroke-width",
  lineDash: "stroke-dasharray",
  lineDashOffset: "stroke-dashoffset",
  miterLimit: "stroke-miterlimit",
  font: "font",
  fontSize: "font-size",
  fontStyle: "font-style",
  fontVariant: "font-variant",
  fontWeight: "font-weight",
  fontFamily: "font-family",
  startArrow: "marker-start",
  endArrow: "marker-end",
  path: "d",
  class: "class",
  id: "id",
  style: "style",
  preserveAspectRatio: "preserveAspectRatio"
};

// node_modules/@antv/g-svg/esm/util/dom.js
function createSVGElement(type) {
  return document.createElementNS("http://www.w3.org/2000/svg", type);
}
function createDom2(shape) {
  var type = SHAPE_TO_TAGS[shape.type];
  var parent = shape.getParent();
  if (!type) {
    throw new Error("the type " + shape.type + " is not supported by svg");
  }
  var element = createSVGElement(type);
  if (shape.get("id")) {
    element.id = shape.get("id");
  }
  shape.set("el", element);
  shape.set("attrs", {});
  if (parent) {
    var parentNode = parent.get("el");
    if (parentNode) {
      parentNode.appendChild(element);
    } else {
      parentNode = parent.createDom();
      parent.set("el", parentNode);
      parentNode.appendChild(element);
    }
  }
  return element;
}
function sortDom(element, sorter) {
  var el = element.get("el");
  var childList = to_array_default(el.children).sort(sorter);
  var fragment = document.createDocumentFragment();
  childList.forEach(function(child) {
    fragment.appendChild(child);
  });
  el.appendChild(fragment);
}
function moveTo(element, targetIndex) {
  var parentNode = element.parentNode;
  var siblings = Array.from(parentNode.childNodes).filter(
    function(node) {
      return node.nodeType === 1 && node.nodeName.toLowerCase() !== "defs";
    }
  );
  var target = siblings[targetIndex];
  var currentIndex = siblings.indexOf(element);
  if (target) {
    if (currentIndex > targetIndex) {
      parentNode.insertBefore(element, target);
    } else if (currentIndex < targetIndex) {
      var targetNext = siblings[targetIndex + 1];
      if (targetNext) {
        parentNode.insertBefore(element, targetNext);
      } else {
        parentNode.appendChild(element);
      }
    }
  } else {
    parentNode.appendChild(element);
  }
}

// node_modules/@antv/g-svg/esm/util/svg.js
function setShadow(model, context) {
  var el = model.cfg.el;
  var attrs = model.attr();
  var cfg = {
    dx: attrs.shadowOffsetX,
    dy: attrs.shadowOffsetY,
    blur: attrs.shadowBlur,
    color: attrs.shadowColor
  };
  if (!cfg.dx && !cfg.dy && !cfg.blur && !cfg.color) {
    el.removeAttribute("filter");
  } else {
    var id = context.find("filter", cfg);
    if (!id) {
      id = context.addShadow(cfg);
    }
    el.setAttribute("filter", "url(#" + id + ")");
  }
}
function setTransform(model) {
  var matrix = model.attr().matrix;
  if (matrix) {
    var el = model.cfg.el;
    var transform5 = [];
    for (var i = 0; i < 9; i += 3) {
      transform5.push(matrix[i] + "," + matrix[i + 1]);
    }
    transform5 = transform5.join(",");
    if (transform5.indexOf("NaN") === -1) {
      el.setAttribute("transform", "matrix(" + transform5 + ")");
    } else {
      console.warn("invalid matrix:", matrix);
    }
  }
}
function setClip(model, context) {
  var clip = model.getClip();
  var el = model.get("el");
  if (!clip) {
    el.removeAttribute("clip-path");
  } else if (clip && !el.hasAttribute("clip-path")) {
    createDom2(clip);
    clip.createPath(context);
    var id = context.addClip(clip);
    el.setAttribute("clip-path", "url(#" + id + ")");
  }
}

// node_modules/@antv/g-svg/esm/util/draw.js
function drawChildren2(context, children) {
  children.forEach(function(child) {
    child.draw(context);
  });
}
function refreshElement2(element, changeType) {
  var canvas = element.get("canvas");
  if (canvas && canvas.get("autoDraw")) {
    var context = canvas.get("context");
    var parent_1 = element.getParent();
    var parentChildren = parent_1 ? parent_1.getChildren() : [canvas];
    var el = element.get("el");
    if (changeType === "remove") {
      var isClipShape = element.get("isClipShape");
      if (isClipShape) {
        var clipPathEl = el && el.parentNode;
        var defsEl = clipPathEl && clipPathEl.parentNode;
        if (clipPathEl && defsEl) {
          defsEl.removeChild(clipPathEl);
        }
      } else if (el && el.parentNode) {
        el.parentNode.removeChild(el);
      }
    } else if (changeType === "show") {
      el.setAttribute("visibility", "visible");
    } else if (changeType === "hide") {
      el.setAttribute("visibility", "hidden");
    } else if (changeType === "zIndex") {
      moveTo(el, parentChildren.indexOf(element));
    } else if (changeType === "sort") {
      var children_1 = element.get("children");
      if (children_1 && children_1.length) {
        sortDom(element, function(a, b) {
          return children_1.indexOf(a) - children_1.indexOf(b) ? 1 : 0;
        });
      }
    } else if (changeType === "clear") {
      if (el) {
        el.innerHTML = "";
      }
    } else if (changeType === "matrix") {
      setTransform(element);
    } else if (changeType === "clip") {
      setClip(element, context);
    } else if (changeType === "attr") {
    } else if (changeType === "add") {
      element.draw(context);
    }
  }
}

// node_modules/@antv/g-svg/esm/group.js
var Group2 = function(_super) {
  __extends(Group3, _super);
  function Group3() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Group3.prototype.isEntityGroup = function() {
    return true;
  };
  Group3.prototype.createDom = function() {
    var element = createSVGElement("g");
    this.set("el", element);
    var parent = this.getParent();
    if (parent) {
      var parentNode = parent.get("el");
      if (parentNode) {
        parentNode.appendChild(element);
      } else {
        parentNode = parent.createDom();
        parent.set("el", parentNode);
        parentNode.appendChild(element);
      }
    }
    return element;
  };
  Group3.prototype.afterAttrsChange = function(targetAttrs) {
    _super.prototype.afterAttrsChange.call(this, targetAttrs);
    var canvas = this.get("canvas");
    if (canvas && canvas.get("autoDraw")) {
      var context = canvas.get("context");
      this.createPath(context, targetAttrs);
    }
  };
  Group3.prototype.onCanvasChange = function(changeType) {
    refreshElement2(this, changeType);
  };
  Group3.prototype.getShapeBase = function() {
    return shape_exports2;
  };
  Group3.prototype.getGroupBase = function() {
    return Group3;
  };
  Group3.prototype.draw = function(context) {
    var children = this.getChildren();
    var el = this.get("el");
    if (this.get("destroyed")) {
      if (el) {
        el.parentNode.removeChild(el);
      }
    } else {
      if (!el) {
        this.createDom();
      }
      setClip(this, context);
      this.createPath(context);
      if (children.length) {
        drawChildren2(context, children);
      }
    }
  };
  Group3.prototype.createPath = function(context, targetAttrs) {
    var attrs = this.attr();
    var el = this.get("el");
    each_default(targetAttrs || attrs, function(value, attr) {
      if (SVG_ATTR_MAP[attr]) {
        el.setAttribute(SVG_ATTR_MAP[attr], value);
      }
    });
    setTransform(this);
  };
  return Group3;
}(group_default2);
var group_default4 = Group2;

// node_modules/@antv/g-svg/esm/shape/base.js
var ShapeBase3 = function(_super) {
  __extends(ShapeBase4, _super);
  function ShapeBase4() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "svg";
    _this.canFill = false;
    _this.canStroke = false;
    return _this;
  }
  ShapeBase4.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign(__assign({}, attrs), { lineWidth: 1, lineAppendWidth: 0, strokeOpacity: 1, fillOpacity: 1 });
  };
  ShapeBase4.prototype.afterAttrsChange = function(targetAttrs) {
    _super.prototype.afterAttrsChange.call(this, targetAttrs);
    var canvas = this.get("canvas");
    if (canvas && canvas.get("autoDraw")) {
      var context = canvas.get("context");
      this.draw(context, targetAttrs);
    }
  };
  ShapeBase4.prototype.getShapeBase = function() {
    return shape_exports2;
  };
  ShapeBase4.prototype.getGroupBase = function() {
    return group_default4;
  };
  ShapeBase4.prototype.onCanvasChange = function(changeType) {
    refreshElement2(this, changeType);
  };
  ShapeBase4.prototype.calculateBBox = function() {
    var el = this.get("el");
    var bbox = null;
    if (el) {
      bbox = el.getBBox();
    } else {
      var bboxMethod = getMethod(this.get("type"));
      if (bboxMethod) {
        bbox = bboxMethod(this);
      }
    }
    if (bbox) {
      var x = bbox.x, y = bbox.y, width = bbox.width, height = bbox.height;
      var lineWidth = this.getHitLineWidth();
      var halfWidth = lineWidth / 2;
      var minX = x - halfWidth;
      var minY = y - halfWidth;
      var maxX = x + width + halfWidth;
      var maxY = y + height + halfWidth;
      return {
        x: minX,
        y: minY,
        minX,
        minY,
        maxX,
        maxY,
        width: width + lineWidth,
        height: height + lineWidth
      };
    }
    return {
      x: 0,
      y: 0,
      minX: 0,
      minY: 0,
      maxX: 0,
      maxY: 0,
      width: 0,
      height: 0
    };
  };
  ShapeBase4.prototype.isFill = function() {
    var _a3 = this.attr(), fill = _a3.fill, fillStyle = _a3.fillStyle;
    return (fill || fillStyle || this.isClipShape()) && this.canFill;
  };
  ShapeBase4.prototype.isStroke = function() {
    var _a3 = this.attr(), stroke = _a3.stroke, strokeStyle = _a3.strokeStyle;
    return (stroke || strokeStyle) && this.canStroke;
  };
  ShapeBase4.prototype.draw = function(context, targetAttrs) {
    var el = this.get("el");
    if (this.get("destroyed")) {
      if (el) {
        el.parentNode.removeChild(el);
      }
    } else {
      if (!el) {
        createDom2(this);
      }
      setClip(this, context);
      this.createPath(context, targetAttrs);
      this.shadow(context, targetAttrs);
      this.strokeAndFill(context, targetAttrs);
      this.transform(targetAttrs);
    }
  };
  ShapeBase4.prototype.createPath = function(context, targetAttrs) {
  };
  ShapeBase4.prototype.strokeAndFill = function(context, targetAttrs) {
    var attrs = targetAttrs || this.attr();
    var fill = attrs.fill, fillStyle = attrs.fillStyle, stroke = attrs.stroke, strokeStyle = attrs.strokeStyle, fillOpacity = attrs.fillOpacity, strokeOpacity = attrs.strokeOpacity, lineWidth = attrs.lineWidth;
    var el = this.get("el");
    if (this.canFill) {
      if (!targetAttrs) {
        this._setColor(context, "fill", fill || fillStyle);
      } else if ("fill" in attrs) {
        this._setColor(context, "fill", fill);
      } else if ("fillStyle" in attrs) {
        this._setColor(context, "fill", fillStyle);
      }
      if (fillOpacity) {
        el.setAttribute(SVG_ATTR_MAP["fillOpacity"], fillOpacity);
      }
    }
    if (this.canStroke && lineWidth > 0) {
      if (!targetAttrs) {
        this._setColor(context, "stroke", stroke || strokeStyle);
      } else if ("stroke" in attrs) {
        this._setColor(context, "stroke", stroke);
      } else if ("strokeStyle" in attrs) {
        this._setColor(context, "stroke", strokeStyle);
      }
      if (strokeOpacity) {
        el.setAttribute(SVG_ATTR_MAP["strokeOpacity"], strokeOpacity);
      }
      if (lineWidth) {
        el.setAttribute(SVG_ATTR_MAP["lineWidth"], lineWidth);
      }
    }
  };
  ShapeBase4.prototype._setColor = function(context, attr, value) {
    var el = this.get("el");
    if (!value) {
      el.setAttribute(SVG_ATTR_MAP[attr], "none");
      return;
    }
    value = value.trim();
    if (/^[r,R,L,l]{1}[\s]*\(/.test(value)) {
      var id = context.find("gradient", value);
      if (!id) {
        id = context.addGradient(value);
      }
      el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id + ")");
    } else if (/^[p,P]{1}[\s]*\(/.test(value)) {
      var id = context.find("pattern", value);
      if (!id) {
        id = context.addPattern(value);
      }
      el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id + ")");
    } else {
      el.setAttribute(SVG_ATTR_MAP[attr], value);
    }
  };
  ShapeBase4.prototype.shadow = function(context, targetAttrs) {
    var attrs = this.attr();
    var _a3 = targetAttrs || attrs, shadowOffsetX = _a3.shadowOffsetX, shadowOffsetY = _a3.shadowOffsetY, shadowBlur = _a3.shadowBlur, shadowColor = _a3.shadowColor;
    if (shadowOffsetX || shadowOffsetY || shadowBlur || shadowColor) {
      setShadow(this, context);
    }
  };
  ShapeBase4.prototype.transform = function(targetAttrs) {
    var attrs = this.attr();
    var matrix = (targetAttrs || attrs).matrix;
    if (matrix) {
      setTransform(this);
    }
  };
  ShapeBase4.prototype.isInShape = function(refX, refY) {
    return this.isPointInPath(refX, refY);
  };
  ShapeBase4.prototype.isPointInPath = function(refX, refY) {
    var el = this.get("el");
    var canvas = this.get("canvas");
    var bbox = canvas.get("el").getBoundingClientRect();
    var clientX = refX + bbox.left;
    var clientY = refY + bbox.top;
    var element = document.elementFromPoint(clientX, clientY);
    if (element && element.isEqualNode(el)) {
      return true;
    }
    return false;
  };
  ShapeBase4.prototype.getHitLineWidth = function() {
    var _a3 = this.attrs, lineWidth = _a3.lineWidth, lineAppendWidth = _a3.lineAppendWidth;
    if (this.isStroke()) {
      return lineWidth + lineAppendWidth;
    }
    return 0;
  };
  return ShapeBase4;
}(shape_default);
var base_default16 = ShapeBase3;

// node_modules/@antv/g-svg/esm/shape/circle.js
var Circle4 = function(_super) {
  __extends(Circle6, _super);
  function Circle6() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "circle";
    _this.canFill = true;
    _this.canStroke = true;
    return _this;
  }
  Circle6.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign(__assign({}, attrs), { x: 0, y: 0, r: 0 });
  };
  Circle6.prototype.createPath = function(context, targetAttrs) {
    var attrs = this.attr();
    var el = this.get("el");
    each_default(targetAttrs || attrs, function(value, attr) {
      if (attr === "x" || attr === "y") {
        el.setAttribute("c" + attr, value);
      } else if (SVG_ATTR_MAP[attr]) {
        el.setAttribute(SVG_ATTR_MAP[attr], value);
      }
    });
  };
  return Circle6;
}(base_default16);
var circle_default6 = Circle4;

// node_modules/@antv/g-svg/esm/shape/dom.js
var Dom = function(_super) {
  __extends(Dom2, _super);
  function Dom2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "dom";
    _this.canFill = false;
    _this.canStroke = false;
    return _this;
  }
  Dom2.prototype.createPath = function(context, targetAttrs) {
    var attrs = this.attr();
    var el = this.get("el");
    each_default(targetAttrs || attrs, function(value, attr) {
      if (SVG_ATTR_MAP[attr]) {
        el.setAttribute(SVG_ATTR_MAP[attr], value);
      }
    });
    if (typeof attrs["html"] === "function") {
      var element = attrs["html"].call(this, attrs);
      if (element instanceof Element || element instanceof HTMLDocument) {
        var children = el.childNodes;
        for (var i = children.length - 1; i >= 0; i--) {
          el.removeChild(children[i]);
        }
        el.appendChild(element);
      } else {
        el.innerHTML = element;
      }
    } else {
      el.innerHTML = attrs["html"];
    }
  };
  return Dom2;
}(base_default16);
var dom_default = Dom;

// node_modules/@antv/g-svg/esm/shape/ellipse.js
var Ellipse2 = function(_super) {
  __extends(Ellipse3, _super);
  function Ellipse3() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "ellipse";
    _this.canFill = true;
    _this.canStroke = true;
    return _this;
  }
  Ellipse3.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign(__assign({}, attrs), { x: 0, y: 0, rx: 0, ry: 0 });
  };
  Ellipse3.prototype.createPath = function(context, targetAttrs) {
    var attrs = this.attr();
    var el = this.get("el");
    each_default(targetAttrs || attrs, function(value, attr) {
      if (attr === "x" || attr === "y") {
        el.setAttribute("c" + attr, value);
      } else if (SVG_ATTR_MAP[attr]) {
        el.setAttribute(SVG_ATTR_MAP[attr], value);
      }
    });
  };
  return Ellipse3;
}(base_default16);
var ellipse_default4 = Ellipse2;

// node_modules/@antv/g-svg/esm/shape/image.js
var Image2 = function(_super) {
  __extends(Image3, _super);
  function Image3() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "image";
    _this.canFill = false;
    _this.canStroke = false;
    return _this;
  }
  Image3.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign(__assign({}, attrs), { x: 0, y: 0, width: 0, height: 0 });
  };
  Image3.prototype.createPath = function(context, targetAttrs) {
    var _this = this;
    var attrs = this.attr();
    var el = this.get("el");
    each_default(targetAttrs || attrs, function(value, attr) {
      if (attr === "img") {
        _this._setImage(attrs.img);
      } else if (SVG_ATTR_MAP[attr]) {
        el.setAttribute(SVG_ATTR_MAP[attr], value);
      }
    });
  };
  Image3.prototype.setAttr = function(name, value) {
    this.attrs[name] = value;
    if (name === "img") {
      this._setImage(value);
    }
  };
  Image3.prototype._setImage = function(img) {
    var attrs = this.attr();
    var el = this.get("el");
    if (is_string_default(img)) {
      el.setAttribute("href", img);
    } else if (img instanceof window.Image) {
      if (!attrs.width) {
        el.setAttribute("width", img.width);
        this.attr("width", img.width);
      }
      if (!attrs.height) {
        el.setAttribute("height", img.height);
        this.attr("height", img.height);
      }
      el.setAttribute("href", img.src);
    } else if (img instanceof HTMLElement && is_string_default(img.nodeName) && img.nodeName.toUpperCase() === "CANVAS") {
      el.setAttribute("href", img.toDataURL());
    } else if (img instanceof ImageData) {
      var canvas = document.createElement("canvas");
      canvas.setAttribute("width", "" + img.width);
      canvas.setAttribute("height", "" + img.height);
      canvas.getContext("2d").putImageData(img, 0, 0);
      if (!attrs.width) {
        el.setAttribute("width", "" + img.width);
        this.attr("width", img.width);
      }
      if (!attrs.height) {
        el.setAttribute("height", "" + img.height);
        this.attr("height", img.height);
      }
      el.setAttribute("href", canvas.toDataURL());
    }
  };
  return Image3;
}(base_default16);
var image_default3 = Image2;

// node_modules/@antv/g-svg/esm/shape/line.js
var Line4 = function(_super) {
  __extends(Line6, _super);
  function Line6() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "line";
    _this.canFill = false;
    _this.canStroke = true;
    return _this;
  }
  Line6.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign(__assign({}, attrs), { x1: 0, y1: 0, x2: 0, y2: 0, startArrow: false, endArrow: false });
  };
  Line6.prototype.createPath = function(context, targetAttrs) {
    var attrs = this.attr();
    var el = this.get("el");
    each_default(targetAttrs || attrs, function(value, attr) {
      if (attr === "startArrow" || attr === "endArrow") {
        if (value) {
          var id = is_object_default(value) ? context.addArrow(attrs, SVG_ATTR_MAP[attr]) : context.getDefaultArrow(attrs, SVG_ATTR_MAP[attr]);
          el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id + ")");
        } else {
          el.removeAttribute(SVG_ATTR_MAP[attr]);
        }
      } else if (SVG_ATTR_MAP[attr]) {
        el.setAttribute(SVG_ATTR_MAP[attr], value);
      }
    });
  };
  Line6.prototype.getTotalLength = function() {
    var _a3 = this.attr(), x1 = _a3.x1, y1 = _a3.y1, x2 = _a3.x2, y2 = _a3.y2;
    return line_default.length(x1, y1, x2, y2);
  };
  Line6.prototype.getPoint = function(ratio) {
    var _a3 = this.attr(), x1 = _a3.x1, y1 = _a3.y1, x2 = _a3.x2, y2 = _a3.y2;
    return line_default.pointAt(x1, y1, x2, y2, ratio);
  };
  return Line6;
}(base_default16);
var line_default8 = Line4;

// node_modules/@antv/g-svg/esm/shape/marker/symbols.js
var Symbols2 = {
  circle: function(x, y, r) {
    return [
      ["M", x, y],
      ["m", -r, 0],
      ["a", r, r, 0, 1, 0, r * 2, 0],
      ["a", r, r, 0, 1, 0, -r * 2, 0]
    ];
  },
  square: function(x, y, r) {
    return [["M", x - r, y - r], ["L", x + r, y - r], ["L", x + r, y + r], ["L", x - r, y + r], ["Z"]];
  },
  diamond: function(x, y, r) {
    return [["M", x - r, y], ["L", x, y - r], ["L", x + r, y], ["L", x, y + r], ["Z"]];
  },
  triangle: function(x, y, r) {
    var diffY = r * Math.sin(1 / 3 * Math.PI);
    return [["M", x - r, y + diffY], ["L", x, y - diffY], ["L", x + r, y + diffY], ["z"]];
  },
  triangleDown: function(x, y, r) {
    var diffY = r * Math.sin(1 / 3 * Math.PI);
    return [["M", x - r, y - diffY], ["L", x + r, y - diffY], ["L", x, y + diffY], ["Z"]];
  }
};
var symbols_default = {
  get: function(type) {
    return Symbols2[type];
  },
  register: function(type, func) {
    Symbols2[type] = func;
  },
  remove: function(type) {
    delete Symbols2[type];
  },
  getAll: function() {
    return Symbols2;
  }
};

// node_modules/@antv/g-svg/esm/shape/marker/index.js
var Marker2 = function(_super) {
  __extends(Marker3, _super);
  function Marker3() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "marker";
    _this.canFill = true;
    _this.canStroke = true;
    return _this;
  }
  Marker3.prototype.createPath = function(context) {
    var el = this.get("el");
    el.setAttribute("d", this._assembleMarker());
  };
  Marker3.prototype._assembleMarker = function() {
    var d = this._getPath();
    if (is_array_default(d)) {
      return d.map(function(path) {
        return path.join(" ");
      }).join("");
    }
    return d;
  };
  Marker3.prototype._getPath = function() {
    var attrs = this.attr();
    var x = attrs.x, y = attrs.y;
    var r = attrs.r || attrs.radius;
    var symbol = attrs.symbol || "circle";
    var method;
    if (is_function_default(symbol)) {
      method = symbol;
    } else {
      method = symbols_default.get(symbol);
    }
    if (!method) {
      console.warn(method + " symbol is not exist.");
      return null;
    }
    return method(x, y, r);
  };
  Marker3.symbolsFactory = symbols_default;
  return Marker3;
}(base_default16);
var marker_default2 = Marker2;

// node_modules/@antv/g-svg/esm/shape/path.js
var Path2 = function(_super) {
  __extends(Path4, _super);
  function Path4() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "path";
    _this.canFill = true;
    _this.canStroke = true;
    return _this;
  }
  Path4.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign(__assign({}, attrs), { startArrow: false, endArrow: false });
  };
  Path4.prototype.createPath = function(context, targetAttrs) {
    var _this = this;
    var attrs = this.attr();
    var el = this.get("el");
    each_default(targetAttrs || attrs, function(value, attr) {
      if (attr === "path" && is_array_default(value)) {
        el.setAttribute("d", _this._formatPath(value));
      } else if (attr === "startArrow" || attr === "endArrow") {
        if (value) {
          var id = is_object_default(value) ? context.addArrow(attrs, SVG_ATTR_MAP[attr]) : context.getDefaultArrow(attrs, SVG_ATTR_MAP[attr]);
          el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id + ")");
        } else {
          el.removeAttribute(SVG_ATTR_MAP[attr]);
        }
      } else if (SVG_ATTR_MAP[attr]) {
        el.setAttribute(SVG_ATTR_MAP[attr], value);
      }
    });
  };
  Path4.prototype._formatPath = function(value) {
    var newValue = value.map(function(path) {
      return path.join(" ");
    }).join("");
    if (~newValue.indexOf("NaN")) {
      return "";
    }
    return newValue;
  };
  Path4.prototype.getTotalLength = function() {
    var el = this.get("el");
    return el ? el.getTotalLength() : null;
  };
  Path4.prototype.getPoint = function(ratio) {
    var el = this.get("el");
    var totalLength = this.getTotalLength();
    if (totalLength === 0) {
      return null;
    }
    var point = el ? el.getPointAtLength(ratio * totalLength) : null;
    return point ? {
      x: point.x,
      y: point.y
    } : null;
  };
  return Path4;
}(base_default16);
var path_default4 = Path2;

// node_modules/@antv/g-svg/esm/shape/polygon.js
var Polygon2 = function(_super) {
  __extends(Polygon4, _super);
  function Polygon4() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "polygon";
    _this.canFill = true;
    _this.canStroke = true;
    return _this;
  }
  Polygon4.prototype.createPath = function(context, targetAttrs) {
    var attrs = this.attr();
    var el = this.get("el");
    each_default(targetAttrs || attrs, function(value, attr) {
      if (attr === "points" && is_array_default(value) && value.length >= 2) {
        el.setAttribute("points", value.map(function(point) {
          return point[0] + "," + point[1];
        }).join(" "));
      } else if (SVG_ATTR_MAP[attr]) {
        el.setAttribute(SVG_ATTR_MAP[attr], value);
      }
    });
  };
  return Polygon4;
}(base_default16);
var polygon_default4 = Polygon2;

// node_modules/@antv/g-svg/esm/shape/polyline.js
var Polyline = function(_super) {
  __extends(Polyline2, _super);
  function Polyline2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "polyline";
    _this.canFill = true;
    _this.canStroke = true;
    return _this;
  }
  Polyline2.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign(__assign({}, attrs), { startArrow: false, endArrow: false });
  };
  Polyline2.prototype.onAttrChange = function(name, value, originValue) {
    _super.prototype.onAttrChange.call(this, name, value, originValue);
    if (["points"].indexOf(name) !== -1) {
      this._resetCache();
    }
  };
  Polyline2.prototype._resetCache = function() {
    this.set("totalLength", null);
    this.set("tCache", null);
  };
  Polyline2.prototype.createPath = function(context, targetAttrs) {
    var attrs = this.attr();
    var el = this.get("el");
    each_default(targetAttrs || attrs, function(value, attr) {
      if (attr === "points" && is_array_default(value) && value.length >= 2) {
        el.setAttribute("points", value.map(function(point) {
          return point[0] + "," + point[1];
        }).join(" "));
      } else if (SVG_ATTR_MAP[attr]) {
        el.setAttribute(SVG_ATTR_MAP[attr], value);
      }
    });
  };
  Polyline2.prototype.getTotalLength = function() {
    var points = this.attr().points;
    var totalLength = this.get("totalLength");
    if (!is_nil_default(totalLength)) {
      return totalLength;
    }
    this.set("totalLength", polyline_default.length(points));
    return this.get("totalLength");
  };
  Polyline2.prototype.getPoint = function(ratio) {
    var points = this.attr().points;
    var tCache = this.get("tCache");
    if (!tCache) {
      this._setTcache();
      tCache = this.get("tCache");
    }
    var subt;
    var index;
    each_default(tCache, function(v, i) {
      if (ratio >= v[0] && ratio <= v[1]) {
        subt = (ratio - v[0]) / (v[1] - v[0]);
        index = i;
      }
    });
    return line_default.pointAt(points[index][0], points[index][1], points[index + 1][0], points[index + 1][1], subt);
  };
  Polyline2.prototype._setTcache = function() {
    var points = this.attr().points;
    if (!points || points.length === 0) {
      return;
    }
    var totalLength = this.getTotalLength();
    if (totalLength <= 0) {
      return;
    }
    var tempLength = 0;
    var tCache = [];
    var segmentT;
    var segmentL;
    each_default(points, function(p, i) {
      if (points[i + 1]) {
        segmentT = [];
        segmentT[0] = tempLength / totalLength;
        segmentL = line_default.length(p[0], p[1], points[i + 1][0], points[i + 1][1]);
        tempLength += segmentL;
        segmentT[1] = tempLength / totalLength;
        tCache.push(segmentT);
      }
    });
    this.set("tCache", tCache);
  };
  Polyline2.prototype.getStartTangent = function() {
    var points = this.attr().points;
    var result = [];
    result.push([points[1][0], points[1][1]]);
    result.push([points[0][0], points[0][1]]);
    return result;
  };
  Polyline2.prototype.getEndTangent = function() {
    var points = this.attr().points;
    var l = points.length - 1;
    var result = [];
    result.push([points[l - 1][0], points[l - 1][1]]);
    result.push([points[l][0], points[l][1]]);
    return result;
  };
  return Polyline2;
}(base_default16);
var polyline_default4 = Polyline;

// node_modules/@antv/g-svg/esm/util/format.js
function parseRadius2(radius) {
  var r1 = 0;
  var r2 = 0;
  var r3 = 0;
  var r4 = 0;
  if (is_array_default(radius)) {
    if (radius.length === 1) {
      r1 = r2 = r3 = r4 = radius[0];
    } else if (radius.length === 2) {
      r1 = r3 = radius[0];
      r2 = r4 = radius[1];
    } else if (radius.length === 3) {
      r1 = radius[0];
      r2 = r4 = radius[1];
      r3 = radius[2];
    } else {
      r1 = radius[0];
      r2 = radius[1];
      r3 = radius[2];
      r4 = radius[3];
    }
  } else {
    r1 = r2 = r3 = r4 = radius;
  }
  return {
    r1,
    r2,
    r3,
    r4
  };
}

// node_modules/@antv/g-svg/esm/shape/rect.js
var Rect2 = function(_super) {
  __extends(Rect4, _super);
  function Rect4() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "rect";
    _this.canFill = true;
    _this.canStroke = true;
    return _this;
  }
  Rect4.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign(__assign({}, attrs), { x: 0, y: 0, width: 0, height: 0, radius: 0 });
  };
  Rect4.prototype.createPath = function(context, targetAttrs) {
    var _this = this;
    var attrs = this.attr();
    var el = this.get("el");
    var completed = false;
    var pathRelatedAttrs = ["x", "y", "width", "height", "radius"];
    each_default(targetAttrs || attrs, function(value, attr) {
      if (pathRelatedAttrs.indexOf(attr) !== -1 && !completed) {
        el.setAttribute("d", _this._assembleRect(attrs));
        completed = true;
      } else if (pathRelatedAttrs.indexOf(attr) === -1 && SVG_ATTR_MAP[attr]) {
        el.setAttribute(SVG_ATTR_MAP[attr], value);
      }
    });
  };
  Rect4.prototype._assembleRect = function(attrs) {
    var x = attrs.x;
    var y = attrs.y;
    var w = attrs.width;
    var h = attrs.height;
    var radius = attrs.radius;
    if (!radius) {
      return "M " + x + "," + y + " l " + w + ",0 l 0," + h + " l" + -w + " 0 z";
    }
    var r = parseRadius2(radius);
    if (is_array_default(radius)) {
      if (radius.length === 1) {
        r.r1 = r.r2 = r.r3 = r.r4 = radius[0];
      } else if (radius.length === 2) {
        r.r1 = r.r3 = radius[0];
        r.r2 = r.r4 = radius[1];
      } else if (radius.length === 3) {
        r.r1 = radius[0];
        r.r2 = r.r4 = radius[1];
        r.r3 = radius[2];
      } else {
        r.r1 = radius[0];
        r.r2 = radius[1];
        r.r3 = radius[2];
        r.r4 = radius[3];
      }
    } else {
      r.r1 = r.r2 = r.r3 = r.r4 = radius;
    }
    var d = [
      ["M " + (x + r.r1) + "," + y],
      ["l " + (w - r.r1 - r.r2) + ",0"],
      ["a " + r.r2 + "," + r.r2 + ",0,0,1," + r.r2 + "," + r.r2],
      ["l 0," + (h - r.r2 - r.r3)],
      ["a " + r.r3 + "," + r.r3 + ",0,0,1," + -r.r3 + "," + r.r3],
      ["l " + (r.r3 + r.r4 - w) + ",0"],
      ["a " + r.r4 + "," + r.r4 + ",0,0,1," + -r.r4 + "," + -r.r4],
      ["l 0," + (r.r4 + r.r1 - h)],
      ["a " + r.r1 + "," + r.r1 + ",0,0,1," + r.r1 + "," + -r.r1],
      ["z"]
    ];
    return d.join(" ");
  };
  return Rect4;
}(base_default16);
var rect_default3 = Rect2;

// node_modules/@antv/g-svg/esm/shape/text.js
var LETTER_SPACING = 0.3;
var BASELINE_MAP = {
  top: "before-edge",
  middle: "central",
  bottom: "after-edge",
  alphabetic: "baseline",
  hanging: "hanging"
};
var BASELINE_MAP_FOR_FIREFOX = {
  top: "text-before-edge",
  middle: "central",
  bottom: "text-after-edge",
  alphabetic: "alphabetic",
  hanging: "hanging"
};
var ANCHOR_MAP = {
  left: "left",
  start: "left",
  center: "middle",
  right: "end",
  end: "end"
};
var Text2 = function(_super) {
  __extends(Text3, _super);
  function Text3() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "text";
    _this.canFill = true;
    _this.canStroke = true;
    return _this;
  }
  Text3.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign(__assign({}, attrs), { x: 0, y: 0, text: null, fontSize: 12, fontFamily: "sans-serif", fontStyle: "normal", fontWeight: "normal", fontVariant: "normal", textAlign: "start", textBaseline: "bottom" });
  };
  Text3.prototype.createPath = function(context, targetAttrs) {
    var _this = this;
    var attrs = this.attr();
    var el = this.get("el");
    this._setFont();
    each_default(targetAttrs || attrs, function(value, attr) {
      if (attr === "text") {
        _this._setText("" + value);
      } else if (attr === "matrix" && value) {
        setTransform(_this);
      } else if (SVG_ATTR_MAP[attr]) {
        el.setAttribute(SVG_ATTR_MAP[attr], value);
      }
    });
    el.setAttribute("paint-order", "stroke");
    el.setAttribute("style", "stroke-linecap:butt; stroke-linejoin:miter;");
  };
  Text3.prototype._setFont = function() {
    var el = this.get("el");
    var _a3 = this.attr(), textBaseline = _a3.textBaseline, textAlign = _a3.textAlign;
    var browser2 = detect();
    if (browser2 && browser2.name === "firefox") {
      el.setAttribute("dominant-baseline", BASELINE_MAP_FOR_FIREFOX[textBaseline] || "alphabetic");
    } else {
      el.setAttribute("alignment-baseline", BASELINE_MAP[textBaseline] || "baseline");
    }
    el.setAttribute("text-anchor", ANCHOR_MAP[textAlign] || "left");
  };
  Text3.prototype._setText = function(text) {
    var el = this.get("el");
    var _a3 = this.attr(), x = _a3.x, _b = _a3.textBaseline, baseline = _b === void 0 ? "bottom" : _b;
    if (!text) {
      el.innerHTML = "";
    } else if (~text.indexOf("\n")) {
      var textArr = text.split("\n");
      var textLen_1 = textArr.length - 1;
      var arr_1 = "";
      each_default(textArr, function(segment, i) {
        if (i === 0) {
          if (baseline === "alphabetic") {
            arr_1 += '<tspan x="' + x + '" dy="' + -textLen_1 + 'em">' + segment + "</tspan>";
          } else if (baseline === "top") {
            arr_1 += '<tspan x="' + x + '" dy="0.9em">' + segment + "</tspan>";
          } else if (baseline === "middle") {
            arr_1 += '<tspan x="' + x + '" dy="' + -(textLen_1 - 1) / 2 + 'em">' + segment + "</tspan>";
          } else if (baseline === "bottom") {
            arr_1 += '<tspan x="' + x + '" dy="-' + (textLen_1 + LETTER_SPACING) + 'em">' + segment + "</tspan>";
          } else if (baseline === "hanging") {
            arr_1 += '<tspan x="' + x + '" dy="' + (-(textLen_1 - 1) - LETTER_SPACING) + 'em">' + segment + "</tspan>";
          }
        } else {
          arr_1 += '<tspan x="' + x + '" dy="1em">' + segment + "</tspan>";
        }
      });
      el.innerHTML = arr_1;
    } else {
      el.innerHTML = text;
    }
  };
  return Text3;
}(base_default16);
var text_default4 = Text2;

// node_modules/@antv/g-svg/esm/defs/gradient.js
var regexLG3 = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
var regexRG3 = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
var regexColorStop3 = /[\d.]+:(#[^\s]+|[^)]+\))/gi;
function addStop2(steps) {
  var arr = steps.match(regexColorStop3);
  if (!arr) {
    return "";
  }
  var stops = "";
  arr.sort(function(a, b) {
    a = a.split(":");
    b = b.split(":");
    return Number(a[0]) - Number(b[0]);
  });
  each_default(arr, function(item) {
    item = item.split(":");
    stops += '<stop offset="' + item[0] + '" stop-color="' + item[1] + '"></stop>';
  });
  return stops;
}
function parseLineGradient2(color2, el) {
  var arr = regexLG3.exec(color2);
  var angle3 = mod_default(to_radian_default(parseFloat(arr[1])), Math.PI * 2);
  var steps = arr[2];
  var start;
  var end;
  if (angle3 >= 0 && angle3 < 0.5 * Math.PI) {
    start = {
      x: 0,
      y: 0
    };
    end = {
      x: 1,
      y: 1
    };
  } else if (0.5 * Math.PI <= angle3 && angle3 < Math.PI) {
    start = {
      x: 1,
      y: 0
    };
    end = {
      x: 0,
      y: 1
    };
  } else if (Math.PI <= angle3 && angle3 < 1.5 * Math.PI) {
    start = {
      x: 1,
      y: 1
    };
    end = {
      x: 0,
      y: 0
    };
  } else {
    start = {
      x: 0,
      y: 1
    };
    end = {
      x: 1,
      y: 0
    };
  }
  var tanTheta = Math.tan(angle3);
  var tanTheta2 = tanTheta * tanTheta;
  var x = (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.x;
  var y = tanTheta * (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.y;
  el.setAttribute("x1", start.x);
  el.setAttribute("y1", start.y);
  el.setAttribute("x2", x);
  el.setAttribute("y2", y);
  el.innerHTML = addStop2(steps);
}
function parseRadialGradient2(color2, self2) {
  var arr = regexRG3.exec(color2);
  var cx = parseFloat(arr[1]);
  var cy = parseFloat(arr[2]);
  var r = parseFloat(arr[3]);
  var steps = arr[4];
  self2.setAttribute("cx", cx);
  self2.setAttribute("cy", cy);
  self2.setAttribute("r", r);
  self2.innerHTML = addStop2(steps);
}
var Gradient = function() {
  function Gradient2(cfg) {
    this.cfg = {};
    var el = null;
    var id = unique_id_default("gradient_");
    if (cfg.toLowerCase()[0] === "l") {
      el = createSVGElement("linearGradient");
      parseLineGradient2(cfg, el);
    } else {
      el = createSVGElement("radialGradient");
      parseRadialGradient2(cfg, el);
    }
    el.setAttribute("id", id);
    this.el = el;
    this.id = id;
    this.cfg = cfg;
    return this;
  }
  Gradient2.prototype.match = function(type, attr) {
    return this.cfg === attr;
  };
  return Gradient2;
}();
var gradient_default = Gradient;

// node_modules/@antv/g-svg/esm/defs/shadow.js
var ATTR_MAP = {
  shadowColor: "color",
  shadowOpacity: "opacity",
  shadowBlur: "blur",
  shadowOffsetX: "dx",
  shadowOffsetY: "dy"
};
var SHADOW_DIMENSION = {
  x: "-40%",
  y: "-40%",
  width: "200%",
  height: "200%"
};
var Shadow = function() {
  function Shadow2(cfg) {
    this.type = "filter";
    this.cfg = {};
    this.type = "filter";
    var el = createSVGElement("filter");
    each_default(SHADOW_DIMENSION, function(v, k) {
      el.setAttribute(k, v);
    });
    this.el = el;
    this.id = unique_id_default("filter_");
    this.el.id = this.id;
    this.cfg = cfg;
    this._parseShadow(cfg, el);
    return this;
  }
  Shadow2.prototype.match = function(type, cfg) {
    if (this.type !== type) {
      return false;
    }
    var flag = true;
    var config = this.cfg;
    each_default(Object.keys(config), function(attr) {
      if (config[attr] !== cfg[attr]) {
        flag = false;
        return false;
      }
    });
    return flag;
  };
  Shadow2.prototype.update = function(name, value) {
    var config = this.cfg;
    config[ATTR_MAP[name]] = value;
    this._parseShadow(config, this.el);
    return this;
  };
  Shadow2.prototype._parseShadow = function(config, el) {
    var child = '<feDropShadow\n      dx="' + (config.dx || 0) + '"\n      dy="' + (config.dy || 0) + '"\n      stdDeviation="' + (config.blur ? config.blur / 10 : 0) + '"\n      flood-color="' + (config.color ? config.color : "#000") + '"\n      flood-opacity="' + (config.opacity ? config.opacity : 1) + '"\n      />';
    el.innerHTML = child;
  };
  return Shadow2;
}();
var shadow_default = Shadow;

// node_modules/@antv/g-svg/esm/defs/arrow.js
var Arrow = function() {
  function Arrow2(attrs, type) {
    this.cfg = {};
    var el = createSVGElement("marker");
    var id = unique_id_default("marker_");
    el.setAttribute("id", id);
    var shape = createSVGElement("path");
    shape.setAttribute("stroke", attrs.stroke || "none");
    shape.setAttribute("fill", attrs.fill || "none");
    el.appendChild(shape);
    el.setAttribute("overflow", "visible");
    el.setAttribute("orient", "auto-start-reverse");
    this.el = el;
    this.child = shape;
    this.id = id;
    var cfg = attrs[type === "marker-start" ? "startArrow" : "endArrow"];
    this.stroke = attrs.stroke || "#000";
    if (cfg === true) {
      this._setDefaultPath(type, shape);
    } else {
      this.cfg = cfg;
      this._setMarker(attrs.lineWidth, shape);
    }
    return this;
  }
  Arrow2.prototype.match = function() {
    return false;
  };
  Arrow2.prototype._setDefaultPath = function(type, el) {
    var parent = this.el;
    el.setAttribute("d", "M0,0 L" + 10 * Math.cos(Math.PI / 6) + ",5 L0,10");
    parent.setAttribute("refX", "" + 10 * Math.cos(Math.PI / 6));
    parent.setAttribute("refY", "" + 5);
  };
  Arrow2.prototype._setMarker = function(r, el) {
    var parent = this.el;
    var path = this.cfg.path;
    var d = this.cfg.d;
    if (is_array_default(path)) {
      path = path.map(function(segment) {
        return segment.join(" ");
      }).join("");
    }
    el.setAttribute("d", path);
    parent.appendChild(el);
    if (d) {
      parent.setAttribute("refX", "" + d / r);
    }
  };
  Arrow2.prototype.update = function(fill) {
    var child = this.child;
    if (child.attr) {
      child.attr("fill", fill);
    } else {
      child.setAttribute("fill", fill);
    }
  };
  return Arrow2;
}();
var arrow_default = Arrow;

// node_modules/@antv/g-svg/esm/defs/clip.js
var Clip = function() {
  function Clip2(cfg) {
    this.type = "clip";
    this.cfg = {};
    var el = createSVGElement("clipPath");
    this.el = el;
    this.id = unique_id_default("clip_");
    el.id = this.id;
    var shapeEl = cfg.cfg.el;
    el.appendChild(shapeEl);
    this.cfg = cfg;
    return this;
  }
  Clip2.prototype.match = function() {
    return false;
  };
  Clip2.prototype.remove = function() {
    var el = this.el;
    el.parentNode.removeChild(el);
  };
  return Clip2;
}();
var clip_default = Clip;

// node_modules/@antv/g-svg/esm/defs/pattern.js
var regexPR2 = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i;
var Pattern = function() {
  function Pattern2(cfg) {
    this.cfg = {};
    var el = createSVGElement("pattern");
    el.setAttribute("patternUnits", "userSpaceOnUse");
    var child = createSVGElement("image");
    el.appendChild(child);
    var id = unique_id_default("pattern_");
    el.id = id;
    this.el = el;
    this.id = id;
    this.cfg = cfg;
    var arr = regexPR2.exec(cfg);
    var source = arr[2];
    child.setAttribute("href", source);
    var img = new Image();
    if (!source.match(/^data:/i)) {
      img.crossOrigin = "Anonymous";
    }
    img.src = source;
    function onload() {
      el.setAttribute("width", "" + img.width);
      el.setAttribute("height", "" + img.height);
    }
    if (img.complete) {
      onload();
    } else {
      img.onload = onload;
      img.src = img.src;
    }
    return this;
  }
  Pattern2.prototype.match = function(type, attr) {
    return this.cfg === attr;
  };
  return Pattern2;
}();
var pattern_default = Pattern;

// node_modules/@antv/g-svg/esm/defs/index.js
var Defs = function() {
  function Defs2(canvas) {
    var el = createSVGElement("defs");
    var id = unique_id_default("defs_");
    el.id = id;
    canvas.appendChild(el);
    this.children = [];
    this.defaultArrow = {};
    this.el = el;
    this.canvas = canvas;
  }
  Defs2.prototype.find = function(type, attr) {
    var children = this.children;
    var result = null;
    for (var i = 0; i < children.length; i++) {
      if (children[i].match(type, attr)) {
        result = children[i].id;
        break;
      }
    }
    return result;
  };
  Defs2.prototype.findById = function(id) {
    var children = this.children;
    var flag = null;
    for (var i = 0; i < children.length; i++) {
      if (children[i].id === id) {
        flag = children[i];
        break;
      }
    }
    return flag;
  };
  Defs2.prototype.add = function(item) {
    this.children.push(item);
    item.canvas = this.canvas;
    item.parent = this;
  };
  Defs2.prototype.getDefaultArrow = function(attrs, name) {
    var stroke = attrs.stroke || attrs.strokeStyle;
    if (this.defaultArrow[stroke]) {
      return this.defaultArrow[stroke].id;
    }
    var arrow = new arrow_default(attrs, name);
    this.defaultArrow[stroke] = arrow;
    this.el.appendChild(arrow.el);
    this.add(arrow);
    return arrow.id;
  };
  Defs2.prototype.addGradient = function(cfg) {
    var gradient2 = new gradient_default(cfg);
    this.el.appendChild(gradient2.el);
    this.add(gradient2);
    return gradient2.id;
  };
  Defs2.prototype.addArrow = function(attrs, name) {
    var arrow = new arrow_default(attrs, name);
    this.el.appendChild(arrow.el);
    this.add(arrow);
    return arrow.id;
  };
  Defs2.prototype.addShadow = function(cfg) {
    var shadow = new shadow_default(cfg);
    this.el.appendChild(shadow.el);
    this.add(shadow);
    return shadow.id;
  };
  Defs2.prototype.addPattern = function(cfg) {
    var pattern = new pattern_default(cfg);
    this.el.appendChild(pattern.el);
    this.add(pattern);
    return pattern.id;
  };
  Defs2.prototype.addClip = function(cfg) {
    var clip = new clip_default(cfg);
    this.el.appendChild(clip.el);
    this.add(clip);
    return clip.id;
  };
  return Defs2;
}();
var defs_default = Defs;

// node_modules/@antv/g-svg/esm/canvas.js
var Canvas3 = function(_super) {
  __extends(Canvas4, _super);
  function Canvas4(cfg) {
    return _super.call(this, __assign(__assign({}, cfg), {
      autoDraw: true,
      renderer: "svg"
    })) || this;
  }
  Canvas4.prototype.getShapeBase = function() {
    return shape_exports2;
  };
  Canvas4.prototype.getGroupBase = function() {
    return group_default4;
  };
  Canvas4.prototype.getShape = function(x, y, ev) {
    var target = ev.target || ev.srcElement;
    if (!SHAPE_TO_TAGS[target.tagName]) {
      var parent_1 = target.parentNode;
      while (parent_1 && !SHAPE_TO_TAGS[parent_1.tagName]) {
        parent_1 = parent_1.parentNode;
      }
      target = parent_1;
    }
    return this.find(function(child) {
      return child.get("el") === target;
    });
  };
  Canvas4.prototype.createDom = function() {
    var element = createSVGElement("svg");
    var context = new defs_default(element);
    element.setAttribute("width", "" + this.get("width"));
    element.setAttribute("height", "" + this.get("height"));
    this.set("context", context);
    return element;
  };
  Canvas4.prototype.onCanvasChange = function(changeType) {
    var context = this.get("context");
    var el = this.get("el");
    if (changeType === "sort") {
      var children_1 = this.get("children");
      if (children_1 && children_1.length) {
        sortDom(this, function(a, b) {
          return children_1.indexOf(a) - children_1.indexOf(b) ? 1 : 0;
        });
      }
    } else if (changeType === "clear") {
      if (el) {
        el.innerHTML = "";
        var defsEl = context.el;
        defsEl.innerHTML = "";
        el.appendChild(defsEl);
      }
    } else if (changeType === "matrix") {
      setTransform(this);
    } else if (changeType === "clip") {
      setClip(this, context);
    } else if (changeType === "changeSize") {
      el.setAttribute("width", "" + this.get("width"));
      el.setAttribute("height", "" + this.get("height"));
    }
  };
  Canvas4.prototype.draw = function() {
    var context = this.get("context");
    var children = this.getChildren();
    setClip(this, context);
    if (children.length) {
      drawChildren2(context, children);
    }
  };
  return Canvas4;
}(canvas_default);
var canvas_default3 = Canvas3;

// node_modules/@antv/g-svg/esm/index.js
var version2 = "0.5.6";

// node_modules/@antv/g2/esm/geometry/path.js
var Path3 = function(_super) {
  __extends(Path4, _super);
  function Path4(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.type = "path";
    _this.shapeType = "line";
    var _a3 = cfg.connectNulls, connectNulls = _a3 === void 0 ? false : _a3, _b = cfg.showSinglePoint, showSinglePoint = _b === void 0 ? true : _b;
    _this.connectNulls = connectNulls;
    _this.showSinglePoint = showSinglePoint;
    return _this;
  }
  Path4.prototype.updateElements = function(mappingDataArray, isUpdate) {
    var e_1, _a3, e_2, _b, e_3, _c;
    if (isUpdate === void 0) {
      isUpdate = false;
    }
    var keyData = /* @__PURE__ */ new Map();
    var keyIndex = /* @__PURE__ */ new Map();
    var keys2 = [];
    var index = 0;
    for (var i = 0; i < mappingDataArray.length; i++) {
      var mappingData = mappingDataArray[i];
      var key = this.getElementId(mappingData);
      keys2.push(key);
      keyData.set(key, mappingData);
      keyIndex.set(key, index);
      index++;
    }
    this.elements = new Array(index);
    var _d = diff(this.lastElementsMap, keys2), added = _d.added, updated = _d.updated, removed = _d.removed;
    try {
      for (var added_1 = __values(added), added_1_1 = added_1.next(); !added_1_1.done; added_1_1 = added_1.next()) {
        var key = added_1_1.value;
        var mappingData = keyData.get(key);
        var shapeFactory = this.getShapeFactory();
        var shapeCfg = this.getShapeInfo(mappingData);
        var i = keyIndex.get(key);
        var element = new element_default2({
          shapeFactory,
          container: this.container,
          offscreenGroup: this.getOffscreenGroup(),
          elementIndex: i
        });
        element.geometry = this;
        element.animate = this.animateOption;
        element.draw(shapeCfg, isUpdate);
        this.elementsMap[key] = element;
        this.elements[i] = element;
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (added_1_1 && !added_1_1.done && (_a3 = added_1.return))
          _a3.call(added_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    try {
      for (var updated_1 = __values(updated), updated_1_1 = updated_1.next(); !updated_1_1.done; updated_1_1 = updated_1.next()) {
        var key = updated_1_1.value;
        var mappingData = keyData.get(key);
        var element = this.lastElementsMap[key];
        var i = keyIndex.get(key);
        var shapeCfg = this.getShapeInfo(mappingData);
        var preShapeCfg = element.getModel();
        if (this.isCoordinateChanged || isModelChange(preShapeCfg, shapeCfg)) {
          element.animate = this.animateOption;
          element.update(shapeCfg);
        }
        this.elementsMap[key] = element;
        this.elements[i] = element;
      }
    } catch (e_2_1) {
      e_2 = { error: e_2_1 };
    } finally {
      try {
        if (updated_1_1 && !updated_1_1.done && (_b = updated_1.return))
          _b.call(updated_1);
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
    try {
      for (var removed_1 = __values(removed), removed_1_1 = removed_1.next(); !removed_1_1.done; removed_1_1 = removed_1.next()) {
        var key = removed_1_1.value;
        var element = this.lastElementsMap[key];
        element.animate = this.animateOption;
        element.destroy();
      }
    } catch (e_3_1) {
      e_3 = { error: e_3_1 };
    } finally {
      try {
        if (removed_1_1 && !removed_1_1.done && (_c = removed_1.return))
          _c.call(removed_1);
      } finally {
        if (e_3)
          throw e_3.error;
      }
    }
  };
  Path4.prototype.getPointsAndData = function(mappingData) {
    var points = [];
    var data = [];
    for (var i = 0, len3 = mappingData.length; i < len3; i++) {
      var obj = mappingData[i];
      points.push({
        x: obj.x,
        y: obj.y
      });
      data.push(obj[FIELD_ORIGIN]);
    }
    return {
      points,
      data
    };
  };
  Path4.prototype.getShapeInfo = function(mappingData) {
    var shapeCfg = this.getDrawCfg(mappingData[0]);
    var _a3 = this.getPointsAndData(mappingData), points = _a3.points, data = _a3.data;
    shapeCfg.mappingData = mappingData;
    shapeCfg.data = data;
    shapeCfg.isStack = !!this.getAdjust("stack");
    shapeCfg.points = points;
    shapeCfg.connectNulls = this.connectNulls;
    shapeCfg.showSinglePoint = this.showSinglePoint;
    return shapeCfg;
  };
  return Path4;
}(base_default13);
var path_default5 = Path3;

// node_modules/@antv/g2/esm/geometry/shape/area/util.js
function getPath2(points, isInCircle, smooth, registeredShape, constraint) {
  var path = [];
  if (points.length) {
    var topLinePoints_1 = [];
    var bottomLinePoints_1 = [];
    for (var i = 0, len3 = points.length; i < len3; i++) {
      var point = points[i];
      topLinePoints_1.push(point[1]);
      bottomLinePoints_1.push(point[0]);
    }
    bottomLinePoints_1 = bottomLinePoints_1.reverse();
    each_default([topLinePoints_1, bottomLinePoints_1], function(pointsData, index) {
      var subPath = [];
      var parsedPoints = registeredShape.parsePoints(pointsData);
      var p1 = parsedPoints[0];
      if (topLinePoints_1.length === 1 && bottomLinePoints_1.length === 1) {
        subPath = index === 0 ? [
          ["M", p1.x - 0.5, p1.y],
          ["L", p1.x + 0.5, p1.y]
        ] : [
          ["L", p1.x + 0.5, p1.y],
          ["L", p1.x - 0.5, p1.y]
        ];
      } else {
        if (isInCircle) {
          parsedPoints.push({ x: p1.x, y: p1.y });
        }
        if (smooth) {
          subPath = getSplinePath(parsedPoints, false, constraint);
        } else {
          subPath = getLinePath2(parsedPoints, false);
        }
        if (index > 0) {
          subPath[0][0] = "L";
        }
      }
      path = path.concat(subPath);
    });
    path.push(["Z"]);
  }
  return path;
}
function getShapeAttrs2(cfg, isStroke, smooth, registeredShape, constraint) {
  var attrs = getStyle2(cfg, isStroke, !isStroke, "lineWidth");
  var connectNulls = cfg.connectNulls, isInCircle = cfg.isInCircle, points = cfg.points, showSinglePoint = cfg.showSinglePoint;
  var pathPoints = getPathPoints(points, connectNulls, showSinglePoint);
  var path = [];
  for (var i = 0, len3 = pathPoints.length; i < len3; i++) {
    var eachPoints = pathPoints[i];
    path = path.concat(getPath2(eachPoints, isInCircle, smooth, registeredShape, constraint));
  }
  attrs.path = path;
  return attrs;
}
function getConstraint(coordinate) {
  var start = coordinate.start, end = coordinate.end;
  return [
    [start.x, end.y],
    [end.x, start.y]
  ];
}

// node_modules/@antv/g2/esm/geometry/shape/area/index.js
var AreaShapeFactory = registerShapeFactory("area", {
  defaultShapeType: "area",
  getDefaultPoints: function(pointInfo) {
    var x = pointInfo.x, y0 = pointInfo.y0;
    var y = is_array_default(pointInfo.y) ? pointInfo.y : [y0, pointInfo.y];
    return y.map(function(yItem) {
      return {
        x,
        y: yItem
      };
    });
  }
});
registerShape("area", "area", {
  draw: function(cfg, container) {
    var attrs = getShapeAttrs2(cfg, false, false, this);
    var shape = container.addShape({
      type: "path",
      attrs,
      name: "area"
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: function(x, y, r) {
        if (r === void 0) {
          r = 5.5;
        }
        return [["M", x - r, y - 4], ["L", x + r, y - 4], ["L", x + r, y + 4], ["L", x - r, y + 4], ["Z"]];
      },
      style: {
        r: 5,
        fill: color2,
        fillOpacity: 1
      }
    };
  }
});

// node_modules/@antv/g2/esm/geometry/area.js
var Area = function(_super) {
  __extends(Area2, _super);
  function Area2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.type = "area";
    _this.shapeType = "area";
    _this.generatePoints = true;
    _this.startOnZero = true;
    var _a3 = cfg.startOnZero, startOnZero = _a3 === void 0 ? true : _a3, _b = cfg.sortable, sortable = _b === void 0 ? false : _b, _c = cfg.showSinglePoint, showSinglePoint = _c === void 0 ? false : _c;
    _this.startOnZero = startOnZero;
    _this.sortable = sortable;
    _this.showSinglePoint = showSinglePoint;
    return _this;
  }
  Area2.prototype.getPointsAndData = function(mappingData) {
    var points = [];
    var data = [];
    for (var i = 0, len3 = mappingData.length; i < len3; i++) {
      var obj = mappingData[i];
      points.push(obj.points);
      data.push(obj[FIELD_ORIGIN]);
    }
    return {
      points,
      data
    };
  };
  Area2.prototype.getYMinValue = function() {
    if (this.startOnZero) {
      return _super.prototype.getYMinValue.call(this);
    }
    var yScale = this.getYScale();
    return yScale.min;
  };
  return Area2;
}(path_default5);
var area_default = Area;

// node_modules/@antv/g2/esm/geometry/shape/edge/index.js
var EdgeShapeFactory = registerShapeFactory("edge", {
  defaultShapeType: "line",
  getDefaultPoints: function(pointInfo) {
    return splitPoints(pointInfo);
  }
});
registerShape("edge", "line", {
  draw: function(cfg, container) {
    var style = getStyle2(cfg, true, false, "lineWidth");
    var path = getLinePath2(this.parsePoints(cfg.points), this.coordinate.isPolar);
    return container.addShape("path", {
      attrs: __assign(__assign({}, style), { path })
    });
  },
  getMarker: function(markerCfg) {
    return {
      symbol: "circle",
      style: {
        r: 4.5,
        fill: markerCfg.color
      }
    };
  }
});

// node_modules/@antv/g2/esm/geometry/edge.js
var Edge = function(_super) {
  __extends(Edge2, _super);
  function Edge2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "edge";
    _this.shapeType = "edge";
    _this.generatePoints = true;
    return _this;
  }
  return Edge2;
}(base_default13);
var edge_default = Edge;

// node_modules/@antv/g2/esm/geometry/heatmap.js
var Heatmap = function(_super) {
  __extends(Heatmap2, _super);
  function Heatmap2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "heatmap";
    _this.paletteCache = {};
    return _this;
  }
  Heatmap2.prototype.updateElements = function(mappingDataArray, isUpdate) {
    if (isUpdate === void 0) {
      isUpdate = false;
    }
    for (var i = 0; i < mappingDataArray.length; i++) {
      var mappingData = mappingDataArray[i];
      var range = this.prepareRange(mappingData);
      var radius = this.prepareSize();
      var blur_1 = get_default(this.styleOption, ["cfg", "shadowBlur"]);
      if (!is_number_default(blur_1)) {
        blur_1 = radius / 2;
      }
      this.prepareGreyScaleBlurredCircle(radius, blur_1);
      this.drawWithRange(mappingData, range, radius, blur_1);
    }
  };
  Heatmap2.prototype.color = function(field, cfg) {
    this.createAttrOption("color", field, typeof cfg !== "function" ? cfg : "");
    return this;
  };
  Heatmap2.prototype.clear = function() {
    _super.prototype.clear.call(this);
    this.clearShadowCanvasCtx();
    this.paletteCache = {};
  };
  Heatmap2.prototype.prepareRange = function(data) {
    var colorAttr = this.getAttribute("color");
    var colorField = colorAttr.getFields()[0];
    var min3 = Infinity;
    var max3 = -Infinity;
    data.forEach(function(row) {
      var value = row[FIELD_ORIGIN][colorField];
      if (value > max3) {
        max3 = value;
      }
      if (value < min3) {
        min3 = value;
      }
    });
    if (min3 === max3) {
      min3 = max3 - 1;
    }
    return [min3, max3];
  };
  Heatmap2.prototype.prepareSize = function() {
    var radius = this.getDefaultValue("size");
    if (!is_number_default(radius)) {
      radius = this.getDefaultSize();
    }
    return radius;
  };
  Heatmap2.prototype.prepareGreyScaleBlurredCircle = function(radius, blur) {
    var grayScaleBlurredCanvas = this.getGrayScaleBlurredCanvas();
    var r2 = radius + blur;
    var ctx3 = grayScaleBlurredCanvas.getContext("2d");
    grayScaleBlurredCanvas.width = grayScaleBlurredCanvas.height = r2 * 2;
    ctx3.clearRect(0, 0, grayScaleBlurredCanvas.width, grayScaleBlurredCanvas.height);
    ctx3.shadowOffsetX = ctx3.shadowOffsetY = r2 * 2;
    ctx3.shadowBlur = blur;
    ctx3.shadowColor = "black";
    ctx3.beginPath();
    ctx3.arc(-r2, -r2, radius, 0, Math.PI * 2, true);
    ctx3.closePath();
    ctx3.fill();
  };
  Heatmap2.prototype.drawWithRange = function(data, range, radius, blur) {
    var e_1, _a3;
    var _b = this.coordinate, start = _b.start, end = _b.end;
    var width = this.coordinate.getWidth();
    var height = this.coordinate.getHeight();
    var colorAttr = this.getAttribute("color");
    var valueField = colorAttr.getFields()[0];
    this.clearShadowCanvasCtx();
    var ctx3 = this.getShadowCanvasCtx();
    if (range) {
      data = data.filter(function(row) {
        return row[FIELD_ORIGIN][valueField] <= range[1] && row[FIELD_ORIGIN][valueField] >= range[0];
      });
    }
    var scale5 = this.scales[valueField];
    try {
      for (var data_1 = __values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
        var obj = data_1_1.value;
        var _c = this.getDrawCfg(obj), x = _c.x, y = _c.y;
        var alpha = scale5.scale(obj[FIELD_ORIGIN][valueField]);
        this.drawGrayScaleBlurredCircle(x - start.x, y - end.y, radius + blur, alpha, ctx3);
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (data_1_1 && !data_1_1.done && (_a3 = data_1.return))
          _a3.call(data_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    var colored = ctx3.getImageData(0, 0, width, height);
    this.clearShadowCanvasCtx();
    this.colorize(colored);
    ctx3.putImageData(colored, 0, 0);
    var imageShape = this.getImageShape();
    imageShape.attr("x", start.x);
    imageShape.attr("y", end.y);
    imageShape.attr("width", width);
    imageShape.attr("height", height);
    imageShape.attr("img", ctx3.canvas);
    imageShape.set("origin", this.getShapeInfo(data));
  };
  Heatmap2.prototype.getDefaultSize = function() {
    var position = this.getAttribute("position");
    var coordinate = this.coordinate;
    return Math.min(coordinate.getWidth() / (position.scales[0].ticks.length * 4), coordinate.getHeight() / (position.scales[1].ticks.length * 4));
  };
  Heatmap2.prototype.clearShadowCanvasCtx = function() {
    var ctx3 = this.getShadowCanvasCtx();
    ctx3.clearRect(0, 0, ctx3.canvas.width, ctx3.canvas.height);
  };
  Heatmap2.prototype.getShadowCanvasCtx = function() {
    var canvas = this.shadowCanvas;
    if (!canvas) {
      canvas = document.createElement("canvas");
      this.shadowCanvas = canvas;
    }
    canvas.width = this.coordinate.getWidth();
    canvas.height = this.coordinate.getHeight();
    return canvas.getContext("2d");
  };
  Heatmap2.prototype.getGrayScaleBlurredCanvas = function() {
    if (!this.grayScaleBlurredCanvas) {
      this.grayScaleBlurredCanvas = document.createElement("canvas");
    }
    return this.grayScaleBlurredCanvas;
  };
  Heatmap2.prototype.drawGrayScaleBlurredCircle = function(x, y, r, alpha, ctx3) {
    var grayScaleBlurredCanvas = this.getGrayScaleBlurredCanvas();
    ctx3.globalAlpha = alpha;
    ctx3.drawImage(grayScaleBlurredCanvas, x - r, y - r);
  };
  Heatmap2.prototype.colorize = function(img) {
    var colorAttr = this.getAttribute("color");
    var pixels = img.data;
    var paletteCache = this.paletteCache;
    for (var i = 3; i < pixels.length; i += 4) {
      var alpha = pixels[i];
      if (is_number_default(alpha)) {
        var palette = paletteCache[alpha] ? paletteCache[alpha] : esm_default2.rgb2arr(colorAttr.gradient(alpha / 256));
        pixels[i - 3] = palette[0];
        pixels[i - 2] = palette[1];
        pixels[i - 1] = palette[2];
        pixels[i] = alpha;
      }
    }
  };
  Heatmap2.prototype.getImageShape = function() {
    var imageShape = this.imageShape;
    if (imageShape) {
      return imageShape;
    }
    var container = this.container;
    imageShape = container.addShape({
      type: "image",
      attrs: {}
    });
    this.imageShape = imageShape;
    return imageShape;
  };
  Heatmap2.prototype.getShapeInfo = function(mappingData) {
    var shapeCfg = this.getDrawCfg(mappingData[0]);
    var data = mappingData.map(function(obj) {
      return obj[FIELD_ORIGIN];
    });
    return __assign(__assign({}, shapeCfg), { mappingData, data });
  };
  return Heatmap2;
}(base_default13);
var heatmap_default = Heatmap;

// node_modules/@antv/g2/esm/geometry/shape/interval/util.js
function getRectPoints(pointInfo) {
  var _a3, _b;
  var x = pointInfo.x, y = pointInfo.y, y0 = pointInfo.y0, size2 = pointInfo.size;
  var yMin;
  var yMax;
  if (is_array_default(y)) {
    _a3 = __read(y, 2), yMin = _a3[0], yMax = _a3[1];
  } else {
    yMin = y0;
    yMax = y;
  }
  var xMin;
  var xMax;
  if (is_array_default(x)) {
    _b = __read(x, 2), xMin = _b[0], xMax = _b[1];
  } else {
    xMin = x - size2 / 2;
    xMax = x + size2 / 2;
  }
  var points = [
    { x: xMin, y: yMin },
    { x: xMin, y: yMax }
  ];
  points.push({ x: xMax, y: yMax }, { x: xMax, y: yMin });
  return points;
}
function getRectPath(points, isClosed) {
  if (isClosed === void 0) {
    isClosed = true;
  }
  var path = [];
  var firstPoint = points[0];
  path.push(["M", firstPoint.x, firstPoint.y]);
  for (var i = 1, len3 = points.length; i < len3; i++) {
    path.push(["L", points[i].x, points[i].y]);
  }
  if (isClosed) {
    path.push(["L", firstPoint.x, firstPoint.y]);
    path.push(["z"]);
  }
  return path;
}
function parseRadius3(radius, minLength) {
  var r1 = 0;
  var r2 = 0;
  var r3 = 0;
  var r4 = 0;
  if (is_array_default(radius)) {
    if (radius.length === 1) {
      r1 = r2 = r3 = r4 = radius[0];
    } else if (radius.length === 2) {
      r1 = r3 = radius[0];
      r2 = r4 = radius[1];
    } else if (radius.length === 3) {
      r1 = radius[0];
      r2 = r4 = radius[1];
      r3 = radius[2];
    } else {
      r1 = radius[0];
      r2 = radius[1];
      r3 = radius[2];
      r4 = radius[3];
    }
  } else {
    r1 = r2 = r3 = r4 = radius;
  }
  if (r1 + r2 > minLength) {
    r1 = r1 ? minLength / (1 + r2 / r1) : 0;
    r2 = minLength - r1;
  }
  if (r3 + r4 > minLength) {
    r3 = r3 ? minLength / (1 + r4 / r3) : 0;
    r4 = minLength - r3;
  }
  return [r1 || 0, r2 || 0, r3 || 0, r4 || 0];
}
function getBackgroundRectPath(cfg, points, coordinate) {
  var path = [];
  if (coordinate.isRect) {
    var p0 = coordinate.isTransposed ? { x: coordinate.start.x, y: points[0].y } : { x: points[0].x, y: coordinate.start.y };
    var p1 = coordinate.isTransposed ? { x: coordinate.end.x, y: points[2].y } : { x: points[3].x, y: coordinate.end.y };
    var radius = get_default(cfg, ["background", "style", "radius"]);
    if (radius) {
      var width = coordinate.isTransposed ? Math.abs(points[0].y - points[2].y) : points[2].x - points[1].x;
      var height = coordinate.isTransposed ? coordinate.getWidth() : coordinate.getHeight();
      var _a3 = __read(parseRadius3(radius, Math.min(width, height)), 4), r1 = _a3[0], r2 = _a3[1], r3 = _a3[2], r4 = _a3[3];
      var isReflectYTransposed_1 = coordinate.isTransposed && coordinate.isReflect("y");
      var bump = isReflectYTransposed_1 ? 0 : 1;
      var opposite = function(r) {
        return isReflectYTransposed_1 ? -r : r;
      };
      path.push(["M", p0.x, p1.y + opposite(r1)]);
      r1 !== 0 && path.push(["A", r1, r1, 0, 0, bump, p0.x + r1, p1.y]);
      path.push(["L", p1.x - r2, p1.y]);
      r2 !== 0 && path.push(["A", r2, r2, 0, 0, bump, p1.x, p1.y + opposite(r2)]);
      path.push(["L", p1.x, p0.y - opposite(r3)]);
      r3 !== 0 && path.push(["A", r3, r3, 0, 0, bump, p1.x - r3, p0.y]);
      path.push(["L", p0.x + r4, p0.y]);
      r4 !== 0 && path.push(["A", r4, r4, 0, 0, bump, p0.x, p0.y - opposite(r4)]);
    } else {
      path.push(["M", p0.x, p0.y]);
      path.push(["L", p1.x, p0.y]);
      path.push(["L", p1.x, p1.y]);
      path.push(["L", p0.x, p1.y]);
      path.push(["L", p0.x, p0.y]);
    }
    path.push(["z"]);
  }
  if (coordinate.isPolar) {
    var center = coordinate.getCenter();
    var _b = getAngle2(cfg, coordinate), startAngle = _b.startAngle, endAngle = _b.endAngle;
    if (coordinate.type !== "theta" && !coordinate.isTransposed) {
      path = getSectorPath(center.x, center.y, coordinate.getRadius(), startAngle, endAngle);
    } else {
      var pow = function(v) {
        return Math.pow(v, 2);
      };
      var r1 = Math.sqrt(pow(center.x - points[0].x) + pow(center.y - points[0].y));
      var r2 = Math.sqrt(pow(center.x - points[2].x) + pow(center.y - points[2].y));
      path = getSectorPath(center.x, center.y, r1, coordinate.startAngle, coordinate.endAngle, r2);
    }
  }
  return path;
}
function getIntervalRectPath(points, lineCap, coor) {
  var width = coor.getWidth();
  var height = coor.getHeight();
  var isRect = coor.type === "rect";
  var path = [];
  var r = (points[2].x - points[1].x) / 2;
  var ry = coor.isTransposed ? r * height / width : r * width / height;
  if (lineCap === "round") {
    if (isRect) {
      path.push(["M", points[0].x, points[0].y + ry]);
      path.push(["L", points[1].x, points[1].y - ry]);
      path.push(["A", r, r, 0, 0, 1, points[2].x, points[2].y - ry]);
      path.push(["L", points[3].x, points[3].y + ry]);
      path.push(["A", r, r, 0, 0, 1, points[0].x, points[0].y + ry]);
    } else {
      path.push(["M", points[0].x, points[0].y]);
      path.push(["L", points[1].x, points[1].y]);
      path.push(["A", r, r, 0, 0, 1, points[2].x, points[2].y]);
      path.push(["L", points[3].x, points[3].y]);
      path.push(["A", r, r, 0, 0, 1, points[0].x, points[0].y]);
    }
    path.push(["z"]);
  } else {
    path = getRectPath(points);
  }
  return path;
}
function getFunnelPath(points, nextPoints, isPyramid) {
  var path = [];
  if (!is_nil_default(nextPoints)) {
    path.push(["M", points[0].x, points[0].y], ["L", points[1].x, points[1].y], ["L", nextPoints[1].x, nextPoints[1].y], ["L", nextPoints[0].x, nextPoints[0].y], ["Z"]);
  } else if (isPyramid) {
    path.push(["M", points[0].x, points[0].y], ["L", points[1].x, points[1].y], ["L", (points[2].x + points[3].x) / 2, (points[2].y + points[3].y) / 2], ["Z"]);
  } else {
    path.push(["M", points[0].x, points[0].y], ["L", points[1].x, points[1].y], ["L", points[2].x, points[2].y], ["L", points[3].x, points[3].y], ["Z"]);
  }
  return path;
}
function swap(p0, p1) {
  return [p1, p0];
}
function getRectWithCornerRadius(points, coordinate, radius) {
  var _a3, _b, _c, _d, _e, _f, _g;
  var _h = __read(__spreadArray([], __read(points), false), 4), p0 = _h[0], p1 = _h[1], p2 = _h[2], p3 = _h[3];
  var _j = __read(typeof radius === "number" ? Array(4).fill(radius) : radius, 4), r1 = _j[0], r2 = _j[1], r3 = _j[2], r4 = _j[3];
  if (coordinate.isTransposed) {
    _a3 = __read(swap(p1, p3), 2), p1 = _a3[0], p3 = _a3[1];
  }
  if (coordinate.isReflect("y")) {
    _b = __read(swap(p0, p1), 2), p0 = _b[0], p1 = _b[1];
    _c = __read(swap(p2, p3), 2), p2 = _c[0], p3 = _c[1];
  }
  if (coordinate.isReflect("x")) {
    _d = __read(swap(p0, p3), 2), p0 = _d[0], p3 = _d[1];
    _e = __read(swap(p1, p2), 2), p1 = _e[0], p2 = _e[1];
  }
  var path = [];
  var abs = function(v) {
    return Math.abs(v);
  };
  _f = __read(parseRadius3([r1, r2, r3, r4], Math.min(abs(p3.x - p0.x), abs(p1.y - p0.y))).map(function(d) {
    return abs(d);
  }), 4), r1 = _f[0], r2 = _f[1], r3 = _f[2], r4 = _f[3];
  if (coordinate.isTransposed) {
    _g = __read([r4, r1, r2, r3], 4), r1 = _g[0], r2 = _g[1], r3 = _g[2], r4 = _g[3];
  }
  if (p0.y < p1.y) {
    path.push(["M", p3.x, p3.y + r3]);
    r3 !== 0 && path.push(["A", r3, r3, 0, 0, 0, p3.x - r3, p3.y]);
    path.push(["L", p0.x + r4, p0.y]);
    r4 !== 0 && path.push(["A", r4, r4, 0, 0, 0, p0.x, p0.y + r4]);
    path.push(["L", p1.x, p1.y - r1]);
    r1 !== 0 && path.push(["A", r1, r1, 0, 0, 0, p1.x + r1, p1.y]);
    path.push(["L", p2.x - r2, p2.y]);
    r2 !== 0 && path.push(["A", r2, r2, 0, 0, 0, p2.x, p2.y - r2]);
    path.push(["L", p3.x, p3.y + r3]);
    path.push(["z"]);
  } else if (p3.x < p0.x) {
    path.push(["M", p2.x + r2, p2.y]);
    r2 !== 0 && path.push(["A", r2, r2, 0, 0, 0, p2.x, p2.y + r2]);
    path.push(["L", p3.x, p3.y - r3]);
    r3 !== 0 && path.push(["A", r3, r3, 0, 0, 0, p3.x + r3, p3.y]);
    path.push(["L", p0.x - r4, p0.y]);
    r4 !== 0 && path.push(["A", r4, r4, 0, 0, 0, p0.x, p0.y - r4]);
    path.push(["L", p1.x, p1.y + r1]);
    r1 !== 0 && path.push(["A", r1, r1, 0, 0, 0, p1.x - r1, p1.y]);
    path.push(["L", p2.x + r2, p2.y]);
    path.push(["z"]);
  } else {
    path.push(["M", p1.x, p1.y + r1]);
    r1 !== 0 && path.push(["A", r1, r1, 0, 0, 1, p1.x + r1, p1.y]);
    path.push(["L", p2.x - r2, p2.y]);
    r2 !== 0 && path.push(["A", r2, r2, 0, 0, 1, p2.x, p2.y + r2]);
    path.push(["L", p3.x, p3.y - r3]);
    r3 !== 0 && path.push(["A", r3, r3, 0, 0, 1, p3.x - r3, p3.y]);
    path.push(["L", p0.x + r4, p0.y]);
    r4 !== 0 && path.push(["A", r4, r4, 0, 0, 1, p0.x, p0.y - r4]);
    path.push(["L", p1.x, p1.y + r1]);
    path.push(["z"]);
  }
  return path;
}

// node_modules/@antv/g2/esm/geometry/shape/interval/index.js
var IntervalShapeFactory = registerShapeFactory("interval", {
  defaultShapeType: "rect",
  getDefaultPoints: function(pointInfo) {
    return getRectPoints(pointInfo);
  }
});
registerShape("interval", "rect", {
  draw: function(cfg, container) {
    var style = getStyle2(cfg, false, true);
    var group2 = container;
    var backgroundCfg = cfg === null || cfg === void 0 ? void 0 : cfg.background;
    if (backgroundCfg) {
      group2 = container.addGroup({
        name: "interval-group"
      });
      var backgroundStyle = getBackgroundRectStyle(cfg);
      var backgroundPath = getBackgroundRectPath(cfg, this.parsePoints(cfg.points), this.coordinate);
      group2.addShape("path", {
        attrs: __assign(__assign({}, backgroundStyle), { path: backgroundPath }),
        zIndex: -1,
        name: BACKGROUND_SHAPE
      });
    }
    var path;
    if (style.radius && this.coordinate.isRect) {
      path = getRectWithCornerRadius(this.parsePoints(cfg.points), this.coordinate, style.radius);
    } else {
      path = this.parsePath(getIntervalRectPath(cfg.points, style.lineCap, this.coordinate));
    }
    var shape = group2.addShape("path", {
      attrs: __assign(__assign({}, style), { path }),
      name: "interval"
    });
    return backgroundCfg ? group2 : shape;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color, isInPolar = markerCfg.isInPolar;
    if (isInPolar) {
      return {
        symbol: "circle",
        style: {
          r: 4.5,
          fill: color2
        }
      };
    }
    return {
      symbol: "square",
      style: {
        r: 4,
        fill: color2
      }
    };
  }
});

// node_modules/@antv/g2/esm/geometry/util/shape-size.js
function findMinDistance(arr, scale5) {
  var count = arr.length;
  var sourceArr = arr;
  if (is_string_default(sourceArr[0])) {
    sourceArr = arr.map(function(v) {
      return scale5.translate(v);
    });
  }
  var distance8 = sourceArr[1] - sourceArr[0];
  for (var i = 2; i < count; i++) {
    var tmp = sourceArr[i] - sourceArr[i - 1];
    if (distance8 > tmp) {
      distance8 = tmp;
    }
  }
  return distance8;
}
function getDodgeCount(dataArray, dodgeBy) {
  if (dodgeBy) {
    var mergeData = flatten_default(dataArray);
    var values2 = values_of_key_default(mergeData, dodgeBy);
    return values2.length;
  }
  return dataArray.length;
}
function getDefaultSize(geometry) {
  var theme = geometry.theme;
  var coordinate = geometry.coordinate;
  var xScale = geometry.getXScale();
  var xValues = xScale.values;
  var dataArray = geometry.beforeMappingData;
  var count = xValues.length;
  var xDimensionLength = getXDimensionLength(geometry.coordinate);
  var intervalPadding = geometry.intervalPadding, dodgePadding = geometry.dodgePadding;
  var maxColumnWidth = geometry.maxColumnWidth || theme.maxColumnWidth;
  var minColumnWidth = geometry.minColumnWidth || theme.minColumnWidth;
  var columnWidthRatio = geometry.columnWidthRatio || theme.columnWidthRatio;
  var multiplePieWidthRatio = geometry.multiplePieWidthRatio || theme.multiplePieWidthRatio;
  var roseWidthRatio = geometry.roseWidthRatio || theme.roseWidthRatio;
  if (xScale.isLinear && xValues.length > 1) {
    xValues.sort();
    var interval2 = findMinDistance(xValues, xScale);
    count = (xScale.max - xScale.min) / interval2;
    if (xValues.length > count) {
      count = xValues.length;
    }
  }
  var range = xScale.range;
  var normalizedSize = 1 / count;
  var wr = 1;
  if (coordinate.isPolar) {
    if (coordinate.isTransposed && count > 1) {
      wr = multiplePieWidthRatio;
    } else {
      wr = roseWidthRatio;
    }
  } else {
    if (xScale.isLinear) {
      normalizedSize *= range[1] - range[0];
    }
    wr = columnWidthRatio;
  }
  if (!is_nil_default(intervalPadding) && intervalPadding >= 0) {
    var normalizedIntervalPadding = intervalPadding / xDimensionLength;
    normalizedSize = (1 - (count - 1) * normalizedIntervalPadding) / count;
  } else {
    normalizedSize *= wr;
  }
  if (geometry.getAdjust("dodge")) {
    var dodgeAdjust = geometry.getAdjust("dodge");
    var dodgeBy = dodgeAdjust.dodgeBy;
    var dodgeCount = getDodgeCount(dataArray, dodgeBy);
    if (!is_nil_default(dodgePadding) && dodgePadding >= 0) {
      var normalizedDodgePadding = dodgePadding / xDimensionLength;
      normalizedSize = (normalizedSize - normalizedDodgePadding * (dodgeCount - 1)) / dodgeCount;
    } else if (!is_nil_default(intervalPadding) && intervalPadding >= 0) {
      normalizedSize *= wr;
      normalizedSize = normalizedSize / dodgeCount;
    } else {
      normalizedSize = normalizedSize / dodgeCount;
    }
    normalizedSize = normalizedSize >= 0 ? normalizedSize : 0;
  }
  if (!is_nil_default(maxColumnWidth) && maxColumnWidth >= 0) {
    var normalizedMaxColumnWidth = maxColumnWidth / xDimensionLength;
    if (normalizedSize > normalizedMaxColumnWidth) {
      normalizedSize = normalizedMaxColumnWidth;
    }
  }
  if (!is_nil_default(minColumnWidth) && minColumnWidth >= 0) {
    var normalizedMinColumnWidth = minColumnWidth / xDimensionLength;
    if (normalizedSize < normalizedMinColumnWidth) {
      normalizedSize = normalizedMinColumnWidth;
    }
  }
  return normalizedSize;
}

// node_modules/@antv/g2/esm/geometry/interval.js
var Interval = function(_super) {
  __extends(Interval2, _super);
  function Interval2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.type = "interval";
    _this.shapeType = "interval";
    _this.generatePoints = true;
    var background = cfg.background;
    _this.background = background;
    return _this;
  }
  Interval2.prototype.createShapePointsCfg = function(obj) {
    var cfg = _super.prototype.createShapePointsCfg.call(this, obj);
    var size2;
    var sizeAttr = this.getAttribute("size");
    if (sizeAttr) {
      size2 = this.getAttributeValues(sizeAttr, obj)[0];
      var coordinate = this.coordinate;
      var coordinateWidth = getXDimensionLength(coordinate);
      size2 = size2 / coordinateWidth;
    } else {
      if (!this.defaultSize) {
        this.defaultSize = getDefaultSize(this);
      }
      size2 = this.defaultSize;
    }
    cfg.size = size2;
    return cfg;
  };
  Interval2.prototype.adjustScale = function() {
    _super.prototype.adjustScale.call(this);
    var yScale = this.getYScale();
    if (this.coordinate.type === "theta") {
      yScale.change({
        nice: false,
        min: 0,
        max: getMaxScale(yScale)
      });
    } else {
      var scaleDefs = this.scaleDefs;
      var field = yScale.field, min3 = yScale.min, max3 = yScale.max, type = yScale.type;
      if (type !== "time") {
        if (min3 > 0 && !get_default(scaleDefs, [field, "min"])) {
          yScale.change({
            min: 0
          });
        }
        if (max3 <= 0 && !get_default(scaleDefs, [field, "max"])) {
          yScale.change({
            max: 0
          });
        }
      }
    }
  };
  Interval2.prototype.getDrawCfg = function(mappingData) {
    var shapeCfg = _super.prototype.getDrawCfg.call(this, mappingData);
    shapeCfg.background = this.background;
    return shapeCfg;
  };
  return Interval2;
}(base_default13);
var interval_default2 = Interval;

// node_modules/@antv/g2/esm/geometry/line.js
var Line5 = function(_super) {
  __extends(Line6, _super);
  function Line6(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.type = "line";
    var _a3 = cfg.sortable, sortable = _a3 === void 0 ? false : _a3;
    _this.sortable = sortable;
    return _this;
  }
  return Line6;
}(path_default5);
var line_default9 = Line5;

// node_modules/@antv/g2/esm/geometry/shape/point/util.js
var SHAPES = ["circle", "square", "bowtie", "diamond", "hexagon", "triangle", "triangle-down"];
var HOLLOW_SHAPES = ["cross", "tick", "plus", "hyphen", "line"];
function drawPoints(shape, cfg, container, shapeName, isStroke) {
  var e_1, _a3;
  var style = getStyle2(cfg, isStroke, !isStroke, "r");
  var points = shape.parsePoints(cfg.points);
  var pointPosition = points[0];
  if (cfg.isStack) {
    pointPosition = points[1];
  } else if (points.length > 1) {
    var group2 = container.addGroup();
    try {
      for (var points_1 = __values(points), points_1_1 = points_1.next(); !points_1_1.done; points_1_1 = points_1.next()) {
        var point = points_1_1.value;
        group2.addShape({
          type: "marker",
          attrs: __assign(__assign(__assign({}, style), { symbol: MarkerSymbols[shapeName] || shapeName }), point)
        });
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (points_1_1 && !points_1_1.done && (_a3 = points_1.return))
          _a3.call(points_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    return group2;
  }
  return container.addShape({
    type: "marker",
    attrs: __assign(__assign(__assign({}, style), { symbol: MarkerSymbols[shapeName] || shapeName }), pointPosition)
  });
}

// node_modules/@antv/g2/esm/geometry/shape/point/index.js
var PointShapeFactory = registerShapeFactory("point", {
  defaultShapeType: "hollow-circle",
  getDefaultPoints: function(pointInfo) {
    return splitPoints(pointInfo);
  }
});
each_default(SHAPES, function(shapeName) {
  registerShape("point", "hollow-".concat(shapeName), {
    draw: function(cfg, container) {
      return drawPoints(this, cfg, container, shapeName, true);
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color;
      return {
        symbol: MarkerSymbols[shapeName] || shapeName,
        style: {
          r: 4.5,
          stroke: color2,
          fill: null
        }
      };
    }
  });
});

// node_modules/@antv/g2/esm/geometry/point.js
var Point = function(_super) {
  __extends(Point2, _super);
  function Point2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "point";
    _this.shapeType = "point";
    _this.generatePoints = true;
    return _this;
  }
  Point2.prototype.getDrawCfg = function(mappingDatum) {
    var shapeCfg = _super.prototype.getDrawCfg.call(this, mappingDatum);
    return __assign(__assign({}, shapeCfg), { isStack: !!this.getAdjust("stack") });
  };
  return Point2;
}(base_default13);
var point_default = Point;

// node_modules/@antv/g2/esm/geometry/shape/polygon/index.js
function getPath3(points) {
  var flag = points[0];
  var i = 1;
  var path = [["M", flag.x, flag.y]];
  while (i < points.length) {
    var c = points[i];
    if (c.x !== points[i - 1].x || c.y !== points[i - 1].y) {
      path.push(["L", c.x, c.y]);
      if (c.x === flag.x && c.y === flag.y && i < points.length - 1) {
        flag = points[i + 1];
        path.push(["Z"]);
        path.push(["M", flag.x, flag.y]);
        i++;
      }
    }
    i++;
  }
  if (!is_equal_default(last(path), flag)) {
    path.push(["L", flag.x, flag.y]);
  }
  path.push(["Z"]);
  return path;
}
var PolygonShapeFactory = registerShapeFactory("polygon", {
  defaultShapeType: "polygon",
  getDefaultPoints: function(pointInfo) {
    var points = [];
    each_default(pointInfo.x, function(subX, index) {
      var subY = pointInfo.y[index];
      points.push({
        x: subX,
        y: subY
      });
    });
    return points;
  }
});
registerShape("polygon", "polygon", {
  draw: function(cfg, container) {
    if (!is_empty_default(cfg.points)) {
      var shapeAttrs = getStyle2(cfg, true, true);
      var path = this.parsePath(getPath3(cfg.points));
      return container.addShape("path", {
        attrs: __assign(__assign({}, shapeAttrs), { path }),
        name: "polygon"
      });
    }
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: "square",
      style: {
        r: 4,
        fill: color2
      }
    };
  }
});

// node_modules/@antv/g2/esm/geometry/polygon.js
var Polygon3 = function(_super) {
  __extends(Polygon4, _super);
  function Polygon4() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "polygon";
    _this.shapeType = "polygon";
    _this.generatePoints = true;
    return _this;
  }
  Polygon4.prototype.createShapePointsCfg = function(obj) {
    var cfg = _super.prototype.createShapePointsCfg.call(this, obj);
    var x = cfg.x;
    var y = cfg.y;
    var temp;
    if (!(is_array_default(x) && is_array_default(y))) {
      var xScale = this.getXScale();
      var yScale = this.getYScale();
      var xCount = xScale.values.length;
      var yCount = yScale.values.length;
      var xOffset = 0.5 * 1 / xCount;
      var yOffset = 0.5 * 1 / yCount;
      if (xScale.isCategory && yScale.isCategory) {
        x = [x - xOffset, x - xOffset, x + xOffset, x + xOffset];
        y = [y - yOffset, y + yOffset, y + yOffset, y - yOffset];
      } else if (is_array_default(x)) {
        temp = x;
        x = [temp[0], temp[0], temp[1], temp[1]];
        y = [y - yOffset / 2, y + yOffset / 2, y + yOffset / 2, y - yOffset / 2];
      } else if (is_array_default(y)) {
        temp = y;
        y = [temp[0], temp[1], temp[1], temp[0]];
        x = [x - xOffset / 2, x - xOffset / 2, x + xOffset / 2, x + xOffset / 2];
      }
      cfg.x = x;
      cfg.y = y;
    }
    return cfg;
  };
  return Polygon4;
}(base_default13);
var polygon_default5 = Polygon3;

// node_modules/@antv/g2/esm/geometry/shape/schema/index.js
var SchemaShapeFactory = registerShapeFactory("schema", {
  defaultShapeType: ""
});

// node_modules/@antv/g2/esm/geometry/schema.js
var Schema = function(_super) {
  __extends(Schema2, _super);
  function Schema2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "schema";
    _this.shapeType = "schema";
    _this.generatePoints = true;
    return _this;
  }
  Schema2.prototype.createShapePointsCfg = function(record) {
    var cfg = _super.prototype.createShapePointsCfg.call(this, record);
    var size2;
    var sizeAttr = this.getAttribute("size");
    if (sizeAttr) {
      size2 = this.getAttributeValues(sizeAttr, record)[0];
      var coordinate = this.coordinate;
      var coordinateWidth = getXDimensionLength(coordinate);
      size2 = size2 / coordinateWidth;
    } else {
      if (!this.defaultSize) {
        this.defaultSize = getDefaultSize(this);
      }
      size2 = this.defaultSize;
    }
    cfg.size = size2;
    return cfg;
  };
  return Schema2;
}(base_default13);
var schema_default = Schema;

// node_modules/@antv/g2/esm/geometry/shape/violin/index.js
function normalizeSize(arr) {
  if (!is_array_default(arr)) {
    return [];
  }
  var maxValue = max_default(arr);
  return map_default(arr, function(num) {
    return num / maxValue;
  });
}
var ViolinShapeFactory = registerShapeFactory("violin", {
  defaultShapeType: "violin",
  getDefaultPoints: function(pointInfo) {
    var radius = pointInfo.size / 2;
    var points = [];
    var sizeArr = normalizeSize(pointInfo._size);
    each_default(pointInfo.y, function(y, index) {
      var offset = sizeArr[index] * radius;
      var isMin = index === 0;
      var isMax = index === pointInfo.y.length - 1;
      points.push({
        isMin,
        isMax,
        x: pointInfo.x - offset,
        y
      });
      points.unshift({
        isMin,
        isMax,
        x: pointInfo.x + offset,
        y
      });
    });
    return points;
  }
});
registerShape("violin", "violin", {
  draw: function(cfg, container) {
    var shapeAttrs = getStyle2(cfg, true, true);
    var path = this.parsePath(getViolinPath(cfg.points));
    return container.addShape("path", {
      attrs: __assign(__assign({}, shapeAttrs), { path }),
      name: "violin"
    });
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: "circle",
      style: {
        r: 4,
        fill: color2
      }
    };
  }
});

// node_modules/@antv/g2/esm/geometry/violin.js
var Violin = function(_super) {
  __extends(Violin2, _super);
  function Violin2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "violin";
    _this.shapeType = "violin";
    _this.generatePoints = true;
    return _this;
  }
  Violin2.prototype.createShapePointsCfg = function(record) {
    var cfg = _super.prototype.createShapePointsCfg.call(this, record);
    var size2;
    var sizeAttr = this.getAttribute("size");
    if (sizeAttr) {
      size2 = this.getAttributeValues(sizeAttr, record)[0];
      var coordinate = this.coordinate;
      var coordinateWidth = getXDimensionLength(coordinate);
      size2 = size2 / coordinateWidth;
    } else {
      if (!this.defaultSize) {
        this.defaultSize = getDefaultSize(this);
      }
      size2 = this.defaultSize;
    }
    cfg.size = size2;
    cfg._size = get_default(record[FIELD_ORIGIN], [this._sizeField]);
    return cfg;
  };
  Violin2.prototype.initAttributes = function() {
    var attributeOption = this.attributeOption;
    var sizeField = attributeOption.size ? attributeOption.size.fields[0] : this._sizeField ? this._sizeField : "size";
    this._sizeField = sizeField;
    delete attributeOption.size;
    _super.prototype.initAttributes.call(this);
  };
  return Violin2;
}(base_default13);
var violin_default = Violin;

// node_modules/@antv/g2/esm/geometry/shape/area/line.js
registerShape("area", "line", {
  draw: function(cfg, container) {
    var attrs = getShapeAttrs2(cfg, true, false, this);
    var shape = container.addShape({
      type: "path",
      attrs,
      name: "area"
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: function(x, y, r) {
        if (r === void 0) {
          r = 5.5;
        }
        return [["M", x - r, y - 4], ["L", x + r, y - 4], ["L", x + r, y + 4], ["L", x - r, y + 4], ["Z"]];
      },
      style: {
        r: 5,
        stroke: color2,
        fill: null
      }
    };
  }
});

// node_modules/@antv/g2/esm/geometry/shape/area/smooth.js
registerShape("area", "smooth", {
  draw: function(cfg, container) {
    var coordinate = this.coordinate;
    var attrs = getShapeAttrs2(cfg, false, true, this, getConstraint(coordinate));
    var shape = container.addShape({
      type: "path",
      attrs,
      name: "area"
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: function(x, y, r) {
        if (r === void 0) {
          r = 5.5;
        }
        return [["M", x - r, y - 4], ["L", x + r, y - 4], ["L", x + r, y + 4], ["L", x - r, y + 4], ["Z"]];
      },
      style: {
        r: 5,
        fill: color2,
        fillOpacity: 1
      }
    };
  }
});

// node_modules/@antv/g2/esm/geometry/shape/area/smooth-line.js
registerShape("area", "smooth-line", {
  draw: function(cfg, container) {
    var coordinate = this.coordinate;
    var attrs = getShapeAttrs2(cfg, true, true, this, getConstraint(coordinate));
    var shape = container.addShape({
      type: "path",
      attrs,
      name: "area"
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: function(x, y, r) {
        if (r === void 0) {
          r = 5.5;
        }
        return [["M", x - r, y - 4], ["L", x + r, y - 4], ["L", x + r, y + 4], ["L", x - r, y + 4], ["Z"]];
      },
      style: {
        r: 5,
        stroke: color2,
        fill: null
      }
    };
  }
});

// node_modules/@antv/g2/esm/geometry/shape/edge/util.js
function getCPath(from, to) {
  return ["C", from.x * 1 / 2 + to.x * 1 / 2, from.y, from.x * 1 / 2 + to.x * 1 / 2, to.y, to.x, to.y];
}
function getQPath(to, center) {
  var points = [];
  points.push({
    x: center.x,
    y: center.y
  });
  points.push(to);
  var sub4 = ["Q"];
  each_default(points, function(point) {
    sub4.push(point.x, point.y);
  });
  return sub4;
}

// node_modules/@antv/g2/esm/geometry/shape/edge/arc.js
function getArcShapePath(from, to, center) {
  var sub4 = getQPath(to, center);
  var path = [["M", from.x, from.y]];
  path.push(sub4);
  return path;
}
function getArcShapeWeightPath(points, center) {
  var arc1 = getQPath(points[1], center);
  var arc2 = getQPath(points[3], center);
  var path = [["M", points[0].x, points[0].y]];
  path.push(arc2);
  path.push(["L", points[3].x, points[3].y]);
  path.push(["L", points[2].x, points[2].y]);
  path.push(arc1);
  path.push(["L", points[1].x, points[1].y]);
  path.push(["L", points[0].x, points[0].y]);
  path.push(["Z"]);
  return path;
}
registerShape("edge", "arc", {
  draw: function(cfg, container) {
    var style = getStyle2(cfg, true, false, "lineWidth");
    var points = cfg.points;
    var type = points.length > 2 ? "weight" : "normal";
    var path;
    if (cfg.isInCircle) {
      var center = { x: 0, y: 1 };
      if (type === "normal") {
        path = getArcShapePath(points[0], points[1], center);
      } else {
        style.fill = style.stroke;
        path = getArcShapeWeightPath(points, center);
      }
      path = this.parsePath(path);
      return container.addShape("path", {
        attrs: __assign(__assign({}, style), { path })
      });
    } else {
      if (type === "normal") {
        points = this.parsePoints(points);
        path = getArcPath((points[1].x + points[0].x) / 2, points[0].y, Math.abs(points[1].x - points[0].x) / 2, Math.PI, Math.PI * 2);
        return container.addShape("path", {
          attrs: __assign(__assign({}, style), { path })
        });
      } else {
        var c1 = getCPath(points[1], points[3]);
        var c2 = getCPath(points[2], points[0]);
        path = [
          ["M", points[0].x, points[0].y],
          ["L", points[1].x, points[1].y],
          c1,
          ["L", points[3].x, points[3].y],
          ["L", points[2].x, points[2].y],
          c2,
          ["Z"]
        ];
        path = this.parsePath(path);
        style.fill = style.stroke;
        return container.addShape("path", {
          attrs: __assign(__assign({}, style), { path })
        });
      }
    }
  },
  getMarker: function(markerCfg) {
    return {
      symbol: "circle",
      style: {
        r: 4.5,
        fill: markerCfg.color
      }
    };
  }
});

// node_modules/@antv/g2/esm/geometry/shape/edge/smooth.js
function getSmoothPath(from, to) {
  var sub4 = getCPath(from, to);
  var path = [["M", from.x, from.y]];
  path.push(sub4);
  return path;
}
registerShape("edge", "smooth", {
  draw: function(cfg, container) {
    var style = getStyle2(cfg, true, false, "lineWidth");
    var points = cfg.points;
    var path = this.parsePath(getSmoothPath(points[0], points[1]));
    return container.addShape("path", {
      attrs: __assign(__assign({}, style), { path })
    });
  },
  getMarker: function(markerCfg) {
    return {
      symbol: "circle",
      style: {
        r: 4.5,
        fill: markerCfg.color
      }
    };
  }
});

// node_modules/@antv/g2/esm/geometry/shape/edge/vhv.js
var CORNER_PERCENT = 1 / 3;
function getVHVPath(from, to) {
  var points = [];
  points.push({
    x: from.x,
    y: from.y * (1 - CORNER_PERCENT) + to.y * CORNER_PERCENT
  });
  points.push({
    x: to.x,
    y: from.y * (1 - CORNER_PERCENT) + to.y * CORNER_PERCENT
  });
  points.push(to);
  var path = [["M", from.x, from.y]];
  each_default(points, function(point) {
    path.push(["L", point.x, point.y]);
  });
  return path;
}
registerShape("edge", "vhv", {
  draw: function(cfg, container) {
    var style = getStyle2(cfg, true, false, "lineWidth");
    var points = cfg.points;
    var path = this.parsePath(getVHVPath(points[0], points[1]));
    return container.addShape("path", {
      attrs: __assign(__assign({}, style), { path })
    });
  },
  getMarker: function(markerCfg) {
    return {
      symbol: "circle",
      style: {
        r: 4.5,
        fill: markerCfg.color
      }
    };
  }
});

// node_modules/@antv/g2/esm/geometry/shape/interval/funnel.js
registerShape("interval", "funnel", {
  getPoints: function(shapePoint) {
    shapePoint.size = shapePoint.size * 2;
    return getRectPoints(shapePoint);
  },
  draw: function(cfg, container) {
    var style = getStyle2(cfg, false, true);
    var path = this.parsePath(getFunnelPath(cfg.points, cfg.nextPoints, false));
    var shape = container.addShape("path", {
      attrs: __assign(__assign({}, style), { path }),
      name: "interval"
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: "square",
      style: {
        r: 4,
        fill: color2
      }
    };
  }
});

// node_modules/@antv/g2/esm/geometry/shape/interval/hollow-rect.js
registerShape("interval", "hollow-rect", {
  draw: function(cfg, container) {
    var style = getStyle2(cfg, true, false);
    var group2 = container;
    var backgroundCfg = cfg === null || cfg === void 0 ? void 0 : cfg.background;
    if (backgroundCfg) {
      group2 = container.addGroup();
      var backgroundStyle = getBackgroundRectStyle(cfg);
      var backgroundPath = getBackgroundRectPath(cfg, this.parsePoints(cfg.points), this.coordinate);
      group2.addShape("path", {
        attrs: __assign(__assign({}, backgroundStyle), { path: backgroundPath }),
        zIndex: -1,
        name: BACKGROUND_SHAPE
      });
    }
    var path = this.parsePath(getRectPath(cfg.points));
    var shape = group2.addShape("path", {
      attrs: __assign(__assign({}, style), { path }),
      name: "interval"
    });
    return backgroundCfg ? group2 : shape;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color, isInPolar = markerCfg.isInPolar;
    if (isInPolar) {
      return {
        symbol: "circle",
        style: {
          r: 4.5,
          stroke: color2,
          fill: null
        }
      };
    }
    return {
      symbol: "square",
      style: {
        r: 4,
        stroke: color2,
        fill: null
      }
    };
  }
});

// node_modules/@antv/g2/esm/geometry/shape/interval/line.js
function getLinePoints(pointInfo) {
  var x = pointInfo.x, y = pointInfo.y, y0 = pointInfo.y0;
  if (is_array_default(y)) {
    return y.map(function(yItem, idx) {
      return {
        x: is_array_default(x) ? x[idx] : x,
        y: yItem
      };
    });
  }
  return [
    { x, y: y0 },
    { x, y }
  ];
}
registerShape("interval", "line", {
  getPoints: function(shapePoint) {
    return getLinePoints(shapePoint);
  },
  draw: function(cfg, container) {
    var style = getStyle2(cfg, true, false, "lineWidth");
    var newStyle = omit(__assign({}, style), ["fill"]);
    var path = this.parsePath(getRectPath(cfg.points, false));
    var shape = container.addShape("path", {
      attrs: __assign(__assign({}, newStyle), { path }),
      name: "interval"
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: function(x, y, r) {
        return [
          ["M", x, y - r],
          ["L", x, y + r]
        ];
      },
      style: {
        r: 5,
        stroke: color2
      }
    };
  }
});

// node_modules/@antv/g2/esm/geometry/shape/interval/pyramid.js
registerShape("interval", "pyramid", {
  getPoints: function(shapePoint) {
    shapePoint.size = shapePoint.size * 2;
    return getRectPoints(shapePoint);
  },
  draw: function(cfg, container) {
    var style = getStyle2(cfg, false, true);
    var path = this.parsePath(getFunnelPath(cfg.points, cfg.nextPoints, true));
    var shape = container.addShape("path", {
      attrs: __assign(__assign({}, style), { path }),
      name: "interval"
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: "square",
      style: {
        r: 4,
        fill: color2
      }
    };
  }
});

// node_modules/@antv/g2/esm/geometry/shape/interval/tick.js
function getTickPoints(pointInfo) {
  var _a3;
  var x = pointInfo.x, y = pointInfo.y, y0 = pointInfo.y0, size2 = pointInfo.size;
  var yMin;
  var yMax;
  if (is_array_default(y)) {
    _a3 = __read(y, 2), yMin = _a3[0], yMax = _a3[1];
  } else {
    yMin = y0;
    yMax = y;
  }
  var xMax = x + size2 / 2;
  var xMin = x - size2 / 2;
  return [
    { x, y: yMin },
    { x, y: yMax },
    { x: xMin, y: yMin },
    { x: xMax, y: yMin },
    { x: xMin, y: yMax },
    { x: xMax, y: yMax }
  ];
}
function getTickPath(points) {
  return [
    ["M", points[0].x, points[0].y],
    ["L", points[1].x, points[1].y],
    ["M", points[2].x, points[2].y],
    ["L", points[3].x, points[3].y],
    ["M", points[4].x, points[4].y],
    ["L", points[5].x, points[5].y]
  ];
}
registerShape("interval", "tick", {
  getPoints: function(shapePoint) {
    return getTickPoints(shapePoint);
  },
  draw: function(cfg, container) {
    var style = getStyle2(cfg, true, false);
    var path = this.parsePath(getTickPath(cfg.points));
    var shape = container.addShape("path", {
      attrs: __assign(__assign({}, style), { path }),
      name: "interval"
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: function(x, y, r) {
        return [
          ["M", x - r / 2, y - r],
          ["L", x + r / 2, y - r],
          ["M", x, y - r],
          ["L", x, y + r],
          ["M", x - r / 2, y + r],
          ["L", x + r / 2, y + r]
        ];
      },
      style: {
        r: 5,
        stroke: color2
      }
    };
  }
});

// node_modules/@antv/g2/esm/geometry/shape/line/step.js
var interpolateCallback = function(point, nextPoint, shapeType) {
  var x = point.x;
  var y = point.y;
  var nextX = nextPoint.x;
  var nextY = nextPoint.y;
  var result;
  switch (shapeType) {
    case "hv":
      result = [{ x: nextX, y }];
      break;
    case "vh":
      result = [{ x, y: nextY }];
      break;
    case "hvh":
      var middleX = (nextX + x) / 2;
      result = [
        { x: middleX, y },
        { x: middleX, y: nextY }
      ];
      break;
    case "vhv":
      var middleY = (y + nextY) / 2;
      result = [
        { x, y: middleY },
        { x: nextX, y: middleY }
      ];
      break;
    default:
      break;
  }
  return result;
};
function getInterpolatePoints(points, shapeType) {
  var result = [];
  each_default(points, function(point, index) {
    var nextPoint = points[index + 1];
    result.push(point);
    if (nextPoint) {
      var interpolatePoint = interpolateCallback(point, nextPoint, shapeType);
      result = result.concat(interpolatePoint);
    }
  });
  return result;
}
function getInterpolatePath(points) {
  return points.map(function(point, index) {
    return index === 0 ? ["M", point.x, point.y] : ["L", point.x, point.y];
  });
}
function getInterpolateShapeAttrs(cfg, shapeType) {
  var points = getPathPoints(cfg.points, cfg.connectNulls, cfg.showSinglePoint);
  var path = [];
  each_default(points, function(eachLinePoints) {
    var interpolatePoints = getInterpolatePoints(eachLinePoints, shapeType);
    path = path.concat(getInterpolatePath(interpolatePoints));
  });
  return __assign(__assign({}, getStyle2(cfg, true, false, "lineWidth")), { path });
}
each_default(["hv", "vh", "hvh", "vhv"], function(shapeType) {
  registerShape("line", shapeType, {
    draw: function(cfg, container) {
      var attrs = getInterpolateShapeAttrs(cfg, shapeType);
      var shape = container.addShape({
        type: "path",
        attrs,
        name: "line"
      });
      return shape;
    },
    getMarker: function(markerCfg) {
      return getLineMarker(markerCfg, shapeType);
    }
  });
});

// node_modules/@antv/g2/esm/geometry/shape/point/hollow.js
each_default(HOLLOW_SHAPES, function(shapeName) {
  registerShape("point", shapeName, {
    draw: function(cfg, container) {
      return drawPoints(this, cfg, container, shapeName, true);
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color;
      return {
        symbol: MarkerSymbols[shapeName],
        style: {
          r: 4.5,
          stroke: color2,
          fill: null
        }
      };
    }
  });
});

// node_modules/@antv/g2/esm/geometry/shape/point/image.js
registerShape("point", "image", {
  draw: function(cfg, container) {
    var e_1, _a3;
    var size2 = getStyle2(cfg, false, false, "r").r;
    var points = this.parsePoints(cfg.points);
    var pointPosition = points[0];
    if (cfg.isStack) {
      pointPosition = points[1];
    } else if (points.length > 1) {
      var group2 = container.addGroup();
      try {
        for (var points_1 = __values(points), points_1_1 = points_1.next(); !points_1_1.done; points_1_1 = points_1.next()) {
          var point = points_1_1.value;
          group2.addShape("image", {
            attrs: {
              x: point.x - size2 / 2,
              y: point.y - size2,
              width: size2,
              height: size2,
              img: cfg.shape[1]
            }
          });
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (points_1_1 && !points_1_1.done && (_a3 = points_1.return))
            _a3.call(points_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return group2;
    }
    return container.addShape("image", {
      attrs: {
        x: pointPosition.x - size2 / 2,
        y: pointPosition.y - size2,
        width: size2,
        height: size2,
        img: cfg.shape[1]
      }
    });
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: "circle",
      style: {
        r: 4.5,
        fill: color2
      }
    };
  }
});

// node_modules/@antv/g2/esm/geometry/shape/point/solid.js
each_default(SHAPES, function(shapeName) {
  registerShape("point", shapeName, {
    draw: function(cfg, container) {
      return drawPoints(this, cfg, container, shapeName, false);
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color;
      return {
        symbol: MarkerSymbols[shapeName] || shapeName,
        style: {
          r: 4.5,
          fill: color2
        }
      };
    }
  });
});

// node_modules/@antv/g2/esm/geometry/shape/schema/box.js
function parseValue(value) {
  var array = !is_array_default(value) ? [value] : value;
  var min3 = array[0];
  var max3 = array[array.length - 1];
  var min1 = array.length > 1 ? array[1] : min3;
  var max1 = array.length > 3 ? array[3] : max3;
  var median = array.length > 2 ? array[2] : min1;
  return {
    min: min3,
    max: max3,
    min1,
    max1,
    median
  };
}
function getBoxPoints(x, y, size2) {
  var halfSize = size2 / 2;
  var pointsArray;
  if (is_array_default(y)) {
    var _a3 = parseValue(y), min3 = _a3.min, max3 = _a3.max, median = _a3.median, min1 = _a3.min1, max1 = _a3.max1;
    var minX = x - halfSize;
    var maxX = x + halfSize;
    pointsArray = [
      [minX, max3],
      [maxX, max3],
      [x, max3],
      [x, max1],
      [minX, min1],
      [minX, max1],
      [maxX, max1],
      [maxX, min1],
      [x, min1],
      [x, min3],
      [minX, min3],
      [maxX, min3],
      [minX, median],
      [maxX, median]
    ];
  } else {
    y = is_nil_default(y) ? 0.5 : y;
    var _b = parseValue(x), min3 = _b.min, max3 = _b.max, median = _b.median, min1 = _b.min1, max1 = _b.max1;
    var minY = y - halfSize;
    var maxY = y + halfSize;
    pointsArray = [
      [min3, minY],
      [min3, maxY],
      [min3, y],
      [min1, y],
      [min1, minY],
      [min1, maxY],
      [max1, maxY],
      [max1, minY],
      [max1, y],
      [max3, y],
      [max3, minY],
      [max3, maxY],
      [median, minY],
      [median, maxY]
    ];
  }
  return pointsArray.map(function(arr) {
    return {
      x: arr[0],
      y: arr[1]
    };
  });
}
function getBoxPath(points) {
  return [
    ["M", points[0].x, points[0].y],
    ["L", points[1].x, points[1].y],
    ["M", points[2].x, points[2].y],
    ["L", points[3].x, points[3].y],
    ["M", points[4].x, points[4].y],
    ["L", points[5].x, points[5].y],
    ["L", points[6].x, points[6].y],
    ["L", points[7].x, points[7].y],
    ["L", points[4].x, points[4].y],
    ["Z"],
    ["M", points[8].x, points[8].y],
    ["L", points[9].x, points[9].y],
    ["M", points[10].x, points[10].y],
    ["L", points[11].x, points[11].y],
    ["M", points[12].x, points[12].y],
    ["L", points[13].x, points[13].y]
  ];
}
registerShape("schema", "box", {
  getPoints: function(shapePoint) {
    var x = shapePoint.x, y = shapePoint.y, size2 = shapePoint.size;
    return getBoxPoints(x, y, size2);
  },
  draw: function(cfg, container) {
    var style = getStyle2(cfg, true, false);
    var path = this.parsePath(getBoxPath(cfg.points));
    var shape = container.addShape("path", {
      attrs: __assign(__assign({}, style), { path, name: "schema" })
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: function(x, y, r) {
        var yValues = [y - 6, y - 3, y, y + 3, y + 6];
        var points = getBoxPoints(x, yValues, r);
        return [
          ["M", points[0].x + 1, points[0].y],
          ["L", points[1].x - 1, points[1].y],
          ["M", points[2].x, points[2].y],
          ["L", points[3].x, points[3].y],
          ["M", points[4].x, points[4].y],
          ["L", points[5].x, points[5].y],
          ["L", points[6].x, points[6].y],
          ["L", points[7].x, points[7].y],
          ["L", points[4].x, points[4].y],
          ["Z"],
          ["M", points[8].x, points[8].y],
          ["L", points[9].x, points[9].y],
          ["M", points[10].x + 1, points[10].y],
          ["L", points[11].x - 1, points[11].y],
          ["M", points[12].x, points[12].y],
          ["L", points[13].x, points[13].y]
        ];
      },
      style: {
        r: 6,
        lineWidth: 1,
        stroke: color2
      }
    };
  }
});

// node_modules/@antv/g2/esm/geometry/shape/schema/candle.js
function getCandleYValues(value) {
  var array = !is_array_default(value) ? [value] : value;
  var sorted = array.sort(function(a, b) {
    return b - a;
  });
  return padEnd(sorted, 4, sorted[sorted.length - 1]);
}
function getCandlePoints(x, y, size2) {
  var yValues = getCandleYValues(y);
  return [
    { x, y: yValues[0] },
    { x, y: yValues[1] },
    { x: x - size2 / 2, y: yValues[2] },
    { x: x - size2 / 2, y: yValues[1] },
    { x: x + size2 / 2, y: yValues[1] },
    { x: x + size2 / 2, y: yValues[2] },
    { x, y: yValues[2] },
    { x, y: yValues[3] }
  ];
}
function getCandlePath(points) {
  return [
    ["M", points[0].x, points[0].y],
    ["L", points[1].x, points[1].y],
    ["M", points[2].x, points[2].y],
    ["L", points[3].x, points[3].y],
    ["L", points[4].x, points[4].y],
    ["L", points[5].x, points[5].y],
    ["Z"],
    ["M", points[6].x, points[6].y],
    ["L", points[7].x, points[7].y]
  ];
}
registerShape("schema", "candle", {
  getPoints: function(shapePoint) {
    var x = shapePoint.x, y = shapePoint.y, size2 = shapePoint.size;
    return getCandlePoints(x, y, size2);
  },
  draw: function(cfg, container) {
    var style = getStyle2(cfg, true, true);
    var path = this.parsePath(getCandlePath(cfg.points));
    var shape = container.addShape("path", {
      attrs: __assign(__assign({}, style), { path, name: "schema" })
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: function(x, y, r) {
        var yValues = [y + 7.5, y + 3, y - 3, y - 7.5];
        var points = getCandlePoints(x, yValues, r);
        return [
          ["M", points[0].x, points[0].y],
          ["L", points[1].x, points[1].y],
          ["M", points[2].x, points[2].y],
          ["L", points[3].x, points[3].y],
          ["L", points[4].x, points[4].y],
          ["L", points[5].x, points[5].y],
          ["Z"],
          ["M", points[6].x, points[6].y],
          ["L", points[7].x, points[7].y]
        ];
      },
      style: {
        lineWidth: 1,
        stroke: color2,
        fill: color2,
        r: 6
      }
    };
  }
});

// node_modules/@antv/g2/esm/geometry/shape/polygon/square.js
function getRectAttrs(points, size2) {
  var width = Math.abs(points[0].x - points[2].x);
  var height = Math.abs(points[0].y - points[2].y);
  var len3 = Math.min(width, height);
  if (size2) {
    len3 = clamp_default(size2, 0, Math.min(width, height));
  }
  len3 = len3 / 2;
  var centerX = (points[0].x + points[2].x) / 2;
  var centerY = (points[0].y + points[2].y) / 2;
  return {
    x: centerX - len3,
    y: centerY - len3,
    width: len3 * 2,
    height: len3 * 2
  };
}
registerShape("polygon", "square", {
  draw: function(cfg, container) {
    if (!is_empty_default(cfg.points)) {
      var shapeAttrs = getStyle2(cfg, true, true);
      var points = this.parsePoints(cfg.points);
      return container.addShape("rect", {
        attrs: __assign(__assign({}, shapeAttrs), getRectAttrs(points, cfg.size)),
        name: "polygon"
      });
    }
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: "square",
      style: {
        r: 4,
        fill: color2
      }
    };
  }
});

// node_modules/@antv/g2/esm/geometry/shape/violin/smooth.js
registerShape("violin", "smooth", {
  draw: function(cfg, container) {
    var attrs = getStyle2(cfg, true, true);
    var path = this.parsePath(getSmoothViolinPath(cfg.points));
    return container.addShape("path", {
      attrs: __assign(__assign({}, attrs), { path })
    });
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: "circle",
      style: {
        stroke: null,
        r: 4,
        fill: color2
      }
    };
  }
});

// node_modules/@antv/g2/esm/geometry/shape/violin/hollow.js
registerShape("violin", "hollow", {
  draw: function(cfg, container) {
    var attrs = getStyle2(cfg, true, false);
    var path = this.parsePath(getViolinPath(cfg.points));
    return container.addShape("path", {
      attrs: __assign(__assign({}, attrs), { path })
    });
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: "circle",
      style: {
        r: 4,
        fill: null,
        stroke: color2
      }
    };
  }
});
registerShape("violin", "hollow-smooth", {
  draw: function(cfg, container) {
    var attrs = getStyle2(cfg, true, false);
    var path = this.parsePath(getSmoothViolinPath(cfg.points));
    return container.addShape("path", {
      attrs: __assign(__assign({}, attrs), { path })
    });
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: "circle",
      style: {
        r: 4,
        fill: null,
        stroke: color2
      }
    };
  }
});

// node_modules/@antv/g2/esm/geometry/label/interval.js
var IntervalLabel = function(_super) {
  __extends(IntervalLabel2, _super);
  function IntervalLabel2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  IntervalLabel2.prototype.getLabelValueDir = function(mappingData) {
    var dim = "y";
    var points = mappingData.points;
    return points[0][dim] <= points[2][dim] ? 1 : -1;
  };
  IntervalLabel2.prototype.getLabelOffsetPoint = function(labelCfg, index, total, position) {
    var _a3;
    var point = _super.prototype.getLabelOffsetPoint.call(this, labelCfg, index, total);
    var coordinate = this.getCoordinate();
    var transposed = coordinate.isTransposed;
    var dim = transposed ? "x" : "y";
    var dir = this.getLabelValueDir(labelCfg.mappingData);
    point = __assign(__assign({}, point), (_a3 = {}, _a3[dim] = point[dim] * dir, _a3));
    if (coordinate.isReflect("x")) {
      point = __assign(__assign({}, point), { x: point.x * -1 });
    }
    if (coordinate.isReflect("y")) {
      point = __assign(__assign({}, point), { y: point.y * -1 });
    }
    return point;
  };
  IntervalLabel2.prototype.getThemedLabelCfg = function(labelCfg) {
    var geometry = this.geometry;
    var defaultLabelCfg = this.getDefaultLabelCfg();
    var theme = geometry.theme;
    return deep_mix_default({}, defaultLabelCfg, theme.labels, labelCfg.position === "middle" ? { offset: 0 } : {}, labelCfg);
  };
  IntervalLabel2.prototype.setLabelPosition = function(labelPointCfg, mappingData, index, position) {
    var coordinate = this.getCoordinate();
    var transposed = coordinate.isTransposed;
    var shapePoints = mappingData.points;
    var point0 = coordinate.convert(shapePoints[0]);
    var point2 = coordinate.convert(shapePoints[2]);
    var dir = this.getLabelValueDir(mappingData);
    var top;
    var right;
    var bottom;
    var left;
    var shape = is_array_default(mappingData.shape) ? mappingData.shape[0] : mappingData.shape;
    if (shape === "funnel" || shape === "pyramid") {
      var nextPoints = get_default(mappingData, "nextPoints");
      var points = get_default(mappingData, "points");
      if (nextPoints) {
        var p0 = coordinate.convert(points[0]);
        var p1 = coordinate.convert(points[1]);
        var nextP0 = coordinate.convert(nextPoints[0]);
        var nextP1 = coordinate.convert(nextPoints[1]);
        if (transposed) {
          top = Math.min(nextP0.y, p0.y);
          bottom = Math.max(nextP0.y, p0.y);
          right = (p1.x + nextP1.x) / 2;
          left = (p0.x + nextP0.x) / 2;
        } else {
          top = Math.min((p1.y + nextP1.y) / 2, (p0.y + nextP0.y) / 2);
          bottom = Math.max((p1.y + nextP1.y) / 2, (p0.y + nextP0.y) / 2);
          right = nextP1.x;
          left = p0.x;
        }
      } else {
        top = Math.min(point2.y, point0.y);
        bottom = Math.max(point2.y, point0.y);
        right = point2.x;
        left = point0.x;
      }
    } else {
      top = Math.min(point2.y, point0.y);
      bottom = Math.max(point2.y, point0.y);
      right = point2.x;
      left = point0.x;
    }
    switch (position) {
      case "right":
        labelPointCfg.x = right;
        labelPointCfg.y = (top + bottom) / 2;
        labelPointCfg.textAlign = get_default(labelPointCfg, "textAlign", dir > 0 ? "left" : "right");
        break;
      case "left":
        labelPointCfg.x = left;
        labelPointCfg.y = (top + bottom) / 2;
        labelPointCfg.textAlign = get_default(labelPointCfg, "textAlign", dir > 0 ? "left" : "right");
        break;
      case "bottom":
        if (transposed) {
          labelPointCfg.x = (right + left) / 2;
        }
        labelPointCfg.y = bottom;
        labelPointCfg.textAlign = get_default(labelPointCfg, "textAlign", "center");
        labelPointCfg.textBaseline = get_default(labelPointCfg, "textBaseline", dir > 0 ? "bottom" : "top");
        break;
      case "middle":
        if (transposed) {
          labelPointCfg.x = (right + left) / 2;
        }
        labelPointCfg.y = (top + bottom) / 2;
        labelPointCfg.textAlign = get_default(labelPointCfg, "textAlign", "center");
        labelPointCfg.textBaseline = get_default(labelPointCfg, "textBaseline", "middle");
        break;
      case "top":
        if (transposed) {
          labelPointCfg.x = (right + left) / 2;
        }
        labelPointCfg.y = top;
        labelPointCfg.textAlign = get_default(labelPointCfg, "textAlign", "center");
        labelPointCfg.textBaseline = get_default(labelPointCfg, "textBaseline", dir > 0 ? "bottom" : "top");
        break;
      default:
        break;
    }
  };
  return IntervalLabel2;
}(base_default14);
var interval_default3 = IntervalLabel;

// node_modules/@antv/g2/esm/geometry/label/polar.js
var HALF_PI = Math.PI / 2;
var PolarLabel = function(_super) {
  __extends(PolarLabel2, _super);
  function PolarLabel2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  PolarLabel2.prototype.getLabelOffset = function(offset) {
    var coordinate = this.getCoordinate();
    var actualOffset = 0;
    if (is_number_default(offset)) {
      actualOffset = offset;
    } else if (is_string_default(offset) && offset.indexOf("%") !== -1) {
      var r = coordinate.getRadius();
      if (coordinate.innerRadius > 0) {
        r = r * (1 - coordinate.innerRadius);
      }
      actualOffset = parseFloat(offset) * 0.01 * r;
    }
    return actualOffset;
  };
  PolarLabel2.prototype.getLabelItems = function(mapppingArray) {
    var items = _super.prototype.getLabelItems.call(this, mapppingArray);
    var yScale = this.geometry.getYScale();
    return map_default(items, function(item) {
      if (item && yScale) {
        var percent = yScale.scale(get_default(item.data, yScale.field));
        return __assign(__assign({}, item), { percent });
      }
      return item;
    });
  };
  PolarLabel2.prototype.getLabelAlign = function(point) {
    var coordinate = this.getCoordinate();
    var align;
    if (point.labelEmit) {
      align = point.angle <= Math.PI / 2 && point.angle >= -Math.PI / 2 ? "left" : "right";
    } else if (!coordinate.isTransposed) {
      align = "center";
    } else {
      var center = coordinate.getCenter();
      var offset = point.offset;
      if (Math.abs(point.x - center.x) < 1) {
        align = "center";
      } else if (point.angle > Math.PI || point.angle <= 0) {
        align = offset > 0 ? "left" : "right";
      } else {
        align = offset > 0 ? "right" : "left";
      }
    }
    return align;
  };
  PolarLabel2.prototype.getLabelPoint = function(labelCfg, mappingData, index) {
    var factor = 1;
    var arcPoint;
    var content = labelCfg.content[index];
    if (this.isToMiddle(mappingData)) {
      arcPoint = this.getMiddlePoint(mappingData.points);
    } else {
      if (labelCfg.content.length === 1 && index === 0) {
        index = 1;
      } else if (index === 0) {
        factor = -1;
      }
      arcPoint = this.getArcPoint(mappingData, index);
    }
    var offset = labelCfg.offset * factor;
    var middleAngle = this.getPointAngle(arcPoint);
    var isLabelEmit = labelCfg.labelEmit;
    var labelPositionCfg = this.getCirclePoint(middleAngle, offset, arcPoint, isLabelEmit);
    if (labelPositionCfg.r === 0) {
      labelPositionCfg.content = "";
    } else {
      labelPositionCfg.content = content;
      labelPositionCfg.angle = middleAngle;
      labelPositionCfg.color = mappingData.color;
    }
    labelPositionCfg.rotate = labelCfg.autoRotate ? this.getLabelRotate(middleAngle, offset, isLabelEmit) : labelCfg.rotate;
    labelPositionCfg.start = {
      x: arcPoint.x,
      y: arcPoint.y
    };
    return labelPositionCfg;
  };
  PolarLabel2.prototype.getArcPoint = function(mappingData, index) {
    if (index === void 0) {
      index = 0;
    }
    if (!is_array_default(mappingData.x) && !is_array_default(mappingData.y)) {
      return {
        x: mappingData.x,
        y: mappingData.y
      };
    }
    return {
      x: is_array_default(mappingData.x) ? mappingData.x[index] : mappingData.x,
      y: is_array_default(mappingData.y) ? mappingData.y[index] : mappingData.y
    };
  };
  PolarLabel2.prototype.getPointAngle = function(point) {
    return getAngleByPoint(this.getCoordinate(), point);
  };
  PolarLabel2.prototype.getCirclePoint = function(angle3, offset, point, isLabelEmit) {
    var coordinate = this.getCoordinate();
    var center = coordinate.getCenter();
    var r = getDistanceToCenter(coordinate, point);
    if (r === 0) {
      return __assign(__assign({}, center), { r });
    }
    var labelAngle = angle3;
    if (coordinate.isTransposed && r > offset && !isLabelEmit) {
      var appendAngle = Math.asin(offset / (2 * r));
      labelAngle = angle3 + appendAngle * 2;
    } else {
      r = r + offset;
    }
    return {
      x: center.x + r * Math.cos(labelAngle),
      y: center.y + r * Math.sin(labelAngle),
      r
    };
  };
  PolarLabel2.prototype.getLabelRotate = function(angle3, offset, isLabelEmit) {
    var rotate5 = angle3 + HALF_PI;
    if (isLabelEmit) {
      rotate5 -= HALF_PI;
    }
    if (rotate5) {
      if (rotate5 > HALF_PI) {
        rotate5 = rotate5 - Math.PI;
      } else if (rotate5 < -HALF_PI) {
        rotate5 = rotate5 + Math.PI;
      }
    }
    return rotate5;
  };
  PolarLabel2.prototype.getMiddlePoint = function(points) {
    var coordinate = this.getCoordinate();
    var count = points.length;
    var middlePoint = {
      x: 0,
      y: 0
    };
    each_default(points, function(point) {
      middlePoint.x += point.x;
      middlePoint.y += point.y;
    });
    middlePoint.x /= count;
    middlePoint.y /= count;
    middlePoint = coordinate.convert(middlePoint);
    return middlePoint;
  };
  PolarLabel2.prototype.isToMiddle = function(mappingData) {
    return mappingData.x.length > 2;
  };
  return PolarLabel2;
}(base_default14);
var polar_default2 = PolarLabel;

// node_modules/@antv/g2/esm/geometry/label/pie.js
var PieLabel = function(_super) {
  __extends(PieLabel2, _super);
  function PieLabel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.defaultLayout = "distribute";
    return _this;
  }
  PieLabel2.prototype.getDefaultLabelCfg = function(offset, position) {
    var cfg = _super.prototype.getDefaultLabelCfg.call(this, offset, position);
    return deep_mix_default({}, cfg, get_default(this.geometry.theme, "pieLabels", {}));
  };
  PieLabel2.prototype.getLabelOffset = function(offset) {
    return _super.prototype.getLabelOffset.call(this, offset) || 0;
  };
  PieLabel2.prototype.getLabelRotate = function(angle3, offset, isLabelLimit) {
    var rotate5;
    if (offset < 0) {
      rotate5 = angle3;
      if (rotate5 > Math.PI / 2) {
        rotate5 = rotate5 - Math.PI;
      }
      if (rotate5 < -Math.PI / 2) {
        rotate5 = rotate5 + Math.PI;
      }
    }
    return rotate5;
  };
  PieLabel2.prototype.getLabelAlign = function(point) {
    var coordinate = this.getCoordinate();
    var center = coordinate.getCenter();
    var align;
    if (point.angle <= Math.PI / 2 && point.x >= center.x) {
      align = "left";
    } else {
      align = "right";
    }
    if (point.offset <= 0) {
      if (align === "right") {
        align = "left";
      } else {
        align = "right";
      }
    }
    return align;
  };
  PieLabel2.prototype.getArcPoint = function(point) {
    return point;
  };
  PieLabel2.prototype.getPointAngle = function(point) {
    var coordinate = this.getCoordinate();
    var startPoint = {
      x: is_array_default(point.x) ? point.x[0] : point.x,
      y: point.y[0]
    };
    var endPoint = {
      x: is_array_default(point.x) ? point.x[1] : point.x,
      y: point.y[1]
    };
    var angle3;
    var startAngle = getAngleByPoint(coordinate, startPoint);
    if (point.points && point.points[0].y === point.points[1].y) {
      angle3 = startAngle;
    } else {
      var endAngle = getAngleByPoint(coordinate, endPoint);
      if (startAngle >= endAngle) {
        endAngle = endAngle + Math.PI * 2;
      }
      angle3 = startAngle + (endAngle - startAngle) / 2;
    }
    return angle3;
  };
  PieLabel2.prototype.getCirclePoint = function(angle3, offset) {
    var coordinate = this.getCoordinate();
    var center = coordinate.getCenter();
    var r = coordinate.getRadius() + offset;
    return __assign(__assign({}, polarToCartesian(center.x, center.y, r, angle3)), { angle: angle3, r });
  };
  return PieLabel2;
}(polar_default2);
var pie_default = PieLabel;

// node_modules/@antv/g2/esm/geometry/label/layout/pie/distribute.js
var MARGIN = 4;
function antiCollision(labelShapes, labels, lineHeight, plotRange, center, isRight) {
  var e_1, _a3;
  var overlapping = true;
  var start = plotRange.start;
  var end = plotRange.end;
  var startY = Math.min(start.y, end.y);
  var totalHeight = Math.abs(start.y - end.y);
  var i;
  var maxY = 0;
  var minY = Number.MIN_VALUE;
  var boxes = labels.map(function(label) {
    if (label.y > maxY) {
      maxY = label.y;
    }
    if (label.y < minY) {
      minY = label.y;
    }
    return {
      size: lineHeight,
      targets: [label.y - startY]
    };
  });
  minY -= startY;
  if (maxY - startY > totalHeight) {
    totalHeight = maxY - startY;
  }
  while (overlapping) {
    boxes.forEach(function(box3) {
      var target = (Math.min.apply(minY, box3.targets) + Math.max.apply(minY, box3.targets)) / 2;
      box3.pos = Math.min(Math.max(minY, target - box3.size / 2), totalHeight - box3.size);
    });
    overlapping = false;
    i = boxes.length;
    while (i--) {
      if (i > 0) {
        var previousBox = boxes[i - 1];
        var box2 = boxes[i];
        if (previousBox.pos + previousBox.size > box2.pos) {
          previousBox.size += box2.size;
          previousBox.targets = previousBox.targets.concat(box2.targets);
          if (previousBox.pos + previousBox.size > totalHeight) {
            previousBox.pos = totalHeight - previousBox.size;
          }
          boxes.splice(i, 1);
          overlapping = true;
        }
      }
    }
  }
  i = 0;
  boxes.forEach(function(b) {
    var posInCompositeBox = startY + lineHeight / 2;
    b.targets.forEach(function() {
      labels[i].y = b.pos + posInCompositeBox;
      posInCompositeBox += lineHeight;
      i++;
    });
  });
  var labelsMap = {};
  try {
    for (var labelShapes_1 = __values(labelShapes), labelShapes_1_1 = labelShapes_1.next(); !labelShapes_1_1.done; labelShapes_1_1 = labelShapes_1.next()) {
      var labelShape = labelShapes_1_1.value;
      labelsMap[labelShape.get("id")] = labelShape;
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (labelShapes_1_1 && !labelShapes_1_1.done && (_a3 = labelShapes_1.return))
        _a3.call(labelShapes_1);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  labels.forEach(function(label) {
    var rPow2 = label.r * label.r;
    var dyPow2 = Math.pow(Math.abs(label.y - center.y), 2);
    if (rPow2 < dyPow2) {
      label.x = center.x;
    } else {
      var dx = Math.sqrt(rPow2 - dyPow2);
      if (!isRight) {
        label.x = center.x - dx;
      } else {
        label.x = center.x + dx;
      }
    }
    var labelShape2 = labelsMap[label.id];
    labelShape2.attr("x", label.x);
    labelShape2.attr("y", label.y);
    var textShape = find_default(labelShape2.getChildren(), function(ele) {
      return ele.get("type") === "text";
    });
    if (textShape) {
      textShape.attr("y", label.y);
      textShape.attr("x", label.x);
    }
  });
}
function distribute(items, labels, shapes, region) {
  if (!items.length || !labels.length) {
    return;
  }
  var offset = items[0] ? items[0].offset : 0;
  var coordinate = labels[0].get("coordinate");
  var radius = coordinate.getRadius();
  var center = coordinate.getCenter();
  if (offset > 0) {
    var lineHeight_1 = 14;
    var totalR = radius + offset;
    var totalHeight_1 = totalR * 2 + lineHeight_1 * 2;
    var plotRange_1 = {
      start: coordinate.start,
      end: coordinate.end
    };
    var halves_1 = [
      [],
      []
    ];
    items.forEach(function(labelItem) {
      if (!labelItem) {
        return;
      }
      if (labelItem.textAlign === "right") {
        halves_1[0].push(labelItem);
      } else {
        halves_1[1].push(labelItem);
      }
    });
    halves_1.forEach(function(half, index) {
      var maxLabelsCountForOneSide = totalHeight_1 / lineHeight_1;
      if (half.length > maxLabelsCountForOneSide) {
        half.sort(function(a, b) {
          return b["..percent"] - a["..percent"];
        });
        half.splice(maxLabelsCountForOneSide, half.length - maxLabelsCountForOneSide);
      }
      half.sort(function(a, b) {
        return a.y - b.y;
      });
      antiCollision(labels, half, lineHeight_1, plotRange_1, center, index);
    });
  }
  each_default(items, function(item) {
    if (item && item.labelLine) {
      var distance8 = item.offset;
      var angle3 = item.angle;
      var startPoint = polarToCartesian(center.x, center.y, radius, angle3);
      var innerPoint = polarToCartesian(center.x, center.y, radius + distance8 / 2, angle3);
      var itemX = item.x + get_default(item, "offsetX", 0);
      var itemY = item.y + get_default(item, "offsetY", 0);
      var endPoint = {
        x: itemX - Math.cos(angle3) * MARGIN,
        y: itemY - Math.sin(angle3) * MARGIN
      };
      if (!is_object_default(item.labelLine)) {
        item.labelLine = {};
      }
      item.labelLine.path = [
        "M ".concat(startPoint.x),
        "".concat(startPoint.y, " Q").concat(innerPoint.x),
        "".concat(innerPoint.y, " ").concat(endPoint.x),
        endPoint.y
      ].join(",");
    }
  });
}

// node_modules/@antv/g2/esm/geometry/label/layout/pie/util.js
function antiCollision2(items, labelHeight, plotRange) {
  var labels = items.filter(function(item) {
    return !item.invisible;
  });
  labels.sort(function(a, b) {
    return a.y - b.y;
  });
  var overlapping = true;
  var startY = plotRange.minY;
  var endY = plotRange.maxY;
  var totalHeight = Math.abs(startY - endY);
  var i;
  var maxY = 0;
  var minY = Number.MIN_VALUE;
  var boxes = labels.map(function(label) {
    if (label.y > maxY) {
      maxY = label.y;
    }
    if (label.y < minY) {
      minY = label.y;
    }
    return {
      content: label.content,
      size: labelHeight,
      targets: [label.y - startY],
      pos: null
    };
  });
  minY -= startY;
  if (maxY - startY > totalHeight) {
    totalHeight = maxY - startY;
  }
  while (overlapping) {
    boxes.forEach(function(box3) {
      var target = (Math.min.apply(minY, box3.targets) + Math.max.apply(minY, box3.targets)) / 2;
      box3.pos = Math.min(Math.max(minY, target - box3.size / 2), totalHeight - box3.size);
      box3.pos = Math.max(0, box3.pos);
    });
    overlapping = false;
    i = boxes.length;
    while (i--) {
      if (i > 0) {
        var previousBox = boxes[i - 1];
        var box2 = boxes[i];
        if (previousBox.pos + previousBox.size > box2.pos) {
          previousBox.size += box2.size;
          previousBox.targets = previousBox.targets.concat(box2.targets);
          if (previousBox.pos + previousBox.size > totalHeight) {
            previousBox.pos = totalHeight - previousBox.size;
          }
          boxes.splice(i, 1);
          overlapping = true;
        }
      }
    }
  }
  i = 0;
  boxes.forEach(function(b) {
    var posInCompositeBox = startY + labelHeight / 2;
    b.targets.forEach(function() {
      labels[i].y = b.pos + posInCompositeBox;
      posInCompositeBox += labelHeight;
      i++;
    });
  });
}

// node_modules/@antv/g2/esm/geometry/label/layout/pie/outer.js
var MARGIN2 = 4;
function drawLabelline(item, coordinate) {
  var center = coordinate.getCenter();
  var radius = coordinate.getRadius();
  if (item && item.labelLine) {
    var angle3 = item.angle, labelOffset = item.offset;
    var startPoint = polarToCartesian(center.x, center.y, radius, angle3);
    var itemX = item.x + get_default(item, "offsetX", 0) * (Math.cos(angle3) > 0 ? 1 : -1);
    var itemY = item.y + get_default(item, "offsetY", 0) * (Math.sin(angle3) > 0 ? 1 : -1);
    var endPoint = {
      x: itemX - Math.cos(angle3) * MARGIN2,
      y: itemY - Math.sin(angle3) * MARGIN2
    };
    var smoothConnector = item.labelLine.smooth;
    var path = [];
    var dx = endPoint.x - center.x;
    var dy = endPoint.y - center.y;
    var endAngle = Math.atan(dy / dx);
    if (dx < 0) {
      endAngle += Math.PI;
    }
    if (smoothConnector === false) {
      if (!is_object_default(item.labelLine)) {
        item.labelLine = {};
      }
      var sweepFlag = 0;
      if (angle3 < 0 && angle3 > -Math.PI / 2 || angle3 > Math.PI * 1.5) {
        if (endPoint.y > startPoint.y) {
          sweepFlag = 1;
        }
      }
      if (angle3 >= 0 && angle3 < Math.PI / 2) {
        if (endPoint.y > startPoint.y) {
          sweepFlag = 1;
        }
      }
      if (angle3 >= Math.PI / 2 && angle3 < Math.PI) {
        if (startPoint.y > endPoint.y) {
          sweepFlag = 1;
        }
      }
      if (angle3 < -Math.PI / 2 || angle3 >= Math.PI && angle3 < Math.PI * 1.5) {
        if (startPoint.y > endPoint.y) {
          sweepFlag = 1;
        }
      }
      var distance8 = labelOffset / 2 > 4 ? 4 : Math.max(labelOffset / 2 - 1, 0);
      var breakPoint = polarToCartesian(center.x, center.y, radius + distance8, angle3);
      var breakPoint3 = polarToCartesian(center.x, center.y, radius + labelOffset / 2, endAngle);
      var largeArcFlag = 0;
      path.push("M ".concat(startPoint.x, " ").concat(startPoint.y));
      path.push("L ".concat(breakPoint.x, " ").concat(breakPoint.y));
      path.push("A ".concat(center.x, " ").concat(center.y, " 0 ").concat(largeArcFlag, " ").concat(sweepFlag, " ").concat(breakPoint3.x, " ").concat(breakPoint3.y));
      path.push("L ".concat(endPoint.x, " ").concat(endPoint.y));
    } else {
      var breakPoint = polarToCartesian(center.x, center.y, radius + (labelOffset / 2 > 4 ? 4 : Math.max(labelOffset / 2 - 1, 0)), angle3);
      var xSign = startPoint.x < center.x ? 1 : -1;
      path.push("M ".concat(endPoint.x, " ").concat(endPoint.y));
      var slope1 = (startPoint.y - center.y) / (startPoint.x - center.x);
      var slope2 = (endPoint.y - center.y) / (endPoint.x - center.x);
      if (Math.abs(slope1 - slope2) > Math.pow(Math.E, -16)) {
        path.push.apply(path, [
          "C",
          endPoint.x + xSign * 4,
          endPoint.y,
          2 * breakPoint.x - startPoint.x,
          2 * breakPoint.y - startPoint.y,
          startPoint.x,
          startPoint.y
        ]);
      }
      path.push("L ".concat(startPoint.x, " ").concat(startPoint.y));
    }
    item.labelLine.path = path.join(" ");
  }
}
function pieOuterLabelLayout(originalItems, labels, shapes, region) {
  var e_1, _a3;
  var items = filter_default(originalItems, function(item) {
    return !is_nil_default(item);
  });
  var coordinate = labels[0] && labels[0].get("coordinate");
  if (!coordinate) {
    return;
  }
  var center = coordinate.getCenter();
  var radius = coordinate.getRadius();
  var labelsMap = {};
  try {
    for (var labels_1 = __values(labels), labels_1_1 = labels_1.next(); !labels_1_1.done; labels_1_1 = labels_1.next()) {
      var labelShape = labels_1_1.value;
      labelsMap[labelShape.get("id")] = labelShape;
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (labels_1_1 && !labels_1_1.done && (_a3 = labels_1.return))
        _a3.call(labels_1);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  var labelHeight = get_default(items[0], "labelHeight", 14);
  var labelOffset = get_default(items[0], "offset", 0);
  if (labelOffset <= 0) {
    return;
  }
  var LEFT_HALF_KEY = "left";
  var RIGHT_HALF_KEY = "right";
  var separateLabels = group_by_default(items, function(item) {
    return item.x < center.x ? LEFT_HALF_KEY : RIGHT_HALF_KEY;
  });
  var start = coordinate.start, end = coordinate.end;
  var totalHeight = Math.min((radius + labelOffset + labelHeight) * 2, coordinate.getHeight());
  var totalR = totalHeight / 2;
  var labelsContainerRange = {
    minX: start.x,
    maxX: end.x,
    minY: center.y - totalR,
    maxY: center.y + totalR
  };
  each_default(separateLabels, function(half, key) {
    var maxLabelsCountForOneSide = Math.floor(totalHeight / labelHeight);
    if (half.length > maxLabelsCountForOneSide) {
      half.sort(function(a, b) {
        return b.percent - a.percent;
      });
      each_default(half, function(labelItem, idx) {
        if (idx + 1 > maxLabelsCountForOneSide) {
          labelsMap[labelItem.id].set("visible", false);
          labelItem.invisible = true;
        }
      });
    }
    antiCollision2(half, labelHeight, labelsContainerRange);
  });
  each_default(separateLabels, function(half, key) {
    each_default(half, function(item) {
      var isRight = key === RIGHT_HALF_KEY;
      var labelShape2 = labelsMap[item.id];
      var content = labelShape2.getChildByIndex(0);
      if (content) {
        var r = radius + labelOffset;
        var dy = item.y - center.y;
        var rPow2 = Math.pow(r, 2);
        var dyPow2 = Math.pow(dy, 2);
        var dxPow2 = rPow2 - dyPow2 > 0 ? rPow2 - dyPow2 : 0;
        var dx = Math.sqrt(dxPow2);
        var dx_offset = Math.abs(Math.cos(item.angle) * r);
        if (!isRight) {
          item.x = center.x - Math.max(dx, dx_offset);
        } else {
          item.x = center.x + Math.max(dx, dx_offset);
        }
      }
      if (content) {
        content.attr("y", item.y);
        content.attr("x", item.x);
      }
      drawLabelline(item, coordinate);
    });
  });
}

// node_modules/@antv/g2/esm/geometry/label/layout/pie/spider.js
var INFLECTION_OFFSET = 4;
var LABEL_OFFSET_X = 4;
var LABEL_TEXT_LINE_OFFSET = 4;
function drawLabelline2(item, coordinate, inRight) {
  var center = coordinate.getCenter();
  var radius = coordinate.getRadius();
  var startPoint = {
    x: item.x - (inRight ? LABEL_TEXT_LINE_OFFSET : -LABEL_TEXT_LINE_OFFSET),
    y: item.y
  };
  var inflectionPoint = polarToCartesian(center.x, center.y, radius + INFLECTION_OFFSET, item.angle);
  var p1 = { x: startPoint.x, y: startPoint.y };
  var p2 = { x: inflectionPoint.x, y: inflectionPoint.y };
  var endPoint = polarToCartesian(center.x, center.y, radius, item.angle);
  var path = "";
  if (startPoint.y !== inflectionPoint.y) {
    var offset = inRight ? 4 : -4;
    p1.y = startPoint.y;
    if (item.angle < 0 && item.angle >= -Math.PI / 2) {
      p1.x = Math.max(inflectionPoint.x, startPoint.x - offset);
      if (startPoint.y < inflectionPoint.y) {
        p2.y = p1.y;
      } else {
        p2.y = inflectionPoint.y;
        p2.x = Math.max(p2.x, p1.x - offset);
      }
    }
    if (item.angle > 0 && item.angle < Math.PI / 2) {
      p1.x = Math.max(inflectionPoint.x, startPoint.x - offset);
      if (startPoint.y > inflectionPoint.y) {
        p2.y = p1.y;
      } else {
        p2.y = inflectionPoint.y;
        p2.x = Math.max(p2.x, p1.x - offset);
      }
    }
    if (item.angle > Math.PI / 2) {
      p1.x = Math.min(inflectionPoint.x, startPoint.x - offset);
      if (startPoint.y > inflectionPoint.y) {
        p2.y = p1.y;
      } else {
        p2.y = inflectionPoint.y;
        p2.x = Math.min(p2.x, p1.x - offset);
      }
    }
    if (item.angle < -Math.PI / 2) {
      p1.x = Math.min(inflectionPoint.x, startPoint.x - offset);
      if (startPoint.y < inflectionPoint.y) {
        p2.y = p1.y;
      } else {
        p2.y = inflectionPoint.y;
        p2.x = Math.min(p2.x, p1.x - offset);
      }
    }
  }
  path = [
    "M ".concat(startPoint.x, ",").concat(startPoint.y),
    "L ".concat(p1.x, ",").concat(p1.y),
    "L ".concat(p2.x, ",").concat(p2.y),
    "L ".concat(inflectionPoint.x, ",").concat(inflectionPoint.y),
    "L ".concat(endPoint.x, ",").concat(endPoint.y)
  ].join(" ");
  item.labelLine = deep_mix_default({}, item.labelLine, { path });
}
function pieSpiderLabelLayout(items, labels, shapes, region) {
  var e_1, _a3;
  var coordinate = labels[0] && labels[0].get("coordinate");
  if (!coordinate) {
    return;
  }
  var center = coordinate.getCenter();
  var radius = coordinate.getRadius();
  var labelsMap = {};
  try {
    for (var labels_1 = __values(labels), labels_1_1 = labels_1.next(); !labels_1_1.done; labels_1_1 = labels_1.next()) {
      var labelShape = labels_1_1.value;
      labelsMap[labelShape.get("id")] = labelShape;
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (labels_1_1 && !labels_1_1.done && (_a3 = labels_1.return))
        _a3.call(labels_1);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  var labelHeight = get_default(items[0], "labelHeight", 14);
  var labelOffset = Math.max(get_default(items[0], "offset", 0), INFLECTION_OFFSET);
  each_default(items, function(item) {
    if (!item)
      return;
    var label = get_default(labelsMap, [item.id]);
    if (!label)
      return;
    var inRight = item.x > center.x || item.x === center.x && item.y > center.y;
    var offsetX = !is_nil_default(item.offsetX) ? item.offsetX : LABEL_OFFSET_X;
    var inflectionPoint = polarToCartesian(center.x, center.y, radius + INFLECTION_OFFSET, item.angle);
    var totalOffset = labelOffset + offsetX;
    item.x = center.x + (inRight ? 1 : -1) * (radius + totalOffset);
    item.y = inflectionPoint.y;
  });
  var start = coordinate.start, end = coordinate.end;
  var LEFT_HALF_KEY = "left";
  var RIGHT_HALF_KEY = "right";
  var separateLabels = group_by_default(items, function(item) {
    return item.x < center.x ? LEFT_HALF_KEY : RIGHT_HALF_KEY;
  });
  var totalHeight = (radius + labelOffset) * 2 + labelHeight;
  each_default(separateLabels, function(half) {
    var halfHeight = half.length * labelHeight;
    if (halfHeight > totalHeight) {
      totalHeight = Math.min(halfHeight, Math.abs(start.y - end.y));
    }
  });
  var labelsContainerRange = {
    minX: start.x,
    maxX: end.x,
    minY: center.y - totalHeight / 2,
    maxY: center.y + totalHeight / 2
  };
  each_default(separateLabels, function(half, key) {
    var maxLabelsCountForOneSide = totalHeight / labelHeight;
    if (half.length > maxLabelsCountForOneSide) {
      half.sort(function(a, b) {
        return b.percent - a.percent;
      });
      each_default(half, function(labelItem, idx) {
        if (idx > maxLabelsCountForOneSide) {
          labelsMap[labelItem.id].set("visible", false);
          labelItem.invisible = true;
        }
      });
    }
    antiCollision2(half, labelHeight, labelsContainerRange);
  });
  var startY = labelsContainerRange.minY;
  var endY = labelsContainerRange.maxY;
  each_default(separateLabels, function(half, key) {
    var inRight = key === RIGHT_HALF_KEY;
    each_default(half, function(item) {
      var label = get_default(labelsMap, item && [item.id]);
      if (!label) {
        return;
      }
      if (item.y < startY || item.y > endY) {
        label.set("visible", false);
        return;
      }
      var labelContent = label.getChildByIndex(0);
      var box2 = labelContent.getCanvasBBox();
      var originalPos = { x: inRight ? box2.x : box2.maxX, y: box2.y + box2.height / 2 };
      translate2(labelContent, item.x - originalPos.x, item.y - originalPos.y);
      if (item.labelLine) {
        drawLabelline2(item, coordinate, inRight);
      }
    });
  });
}

// node_modules/@antv/g2/esm/geometry/label/layout/limit-in-canvas.js
function limitInCanvas(items, labels, shapes, region) {
  each_default(labels, function(label) {
    var regionMinX = region.minX, regionMinY = region.minY, regionMaxX = region.maxX, regionMaxY = region.maxY;
    var _a3 = label.getCanvasBBox(), minX = _a3.minX, minY = _a3.minY, maxX = _a3.maxX, maxY = _a3.maxY, x = _a3.x, y = _a3.y, width = _a3.width, height = _a3.height;
    var finalX = x;
    var finalY = y;
    if (minX < regionMinX || maxX < regionMinX) {
      finalX = regionMinX;
    }
    if (minY < regionMinY || maxY < regionMinY) {
      finalY = regionMinY;
    }
    if (minX > regionMaxX) {
      finalX = regionMaxX - width;
    } else if (maxX > regionMaxX) {
      finalX = finalX - (maxX - regionMaxX);
    }
    if (minY > regionMaxY) {
      finalY = regionMaxY - height;
    } else if (maxY > regionMaxY) {
      finalY = finalY - (maxY - regionMaxY);
    }
    if (finalX !== x || finalY !== y) {
      translate2(label, finalX - x, finalY - y);
    }
  });
}

// node_modules/@antv/g2/esm/geometry/label/layout/limit-in-shape.js
function limitInShape(items, labels, shapes, region) {
  each_default(labels, function(label, index) {
    var labelBBox = label.getCanvasBBox();
    var shapeBBox = shapes[index].getBBox();
    if (labelBBox.minX < shapeBBox.minX || labelBBox.minY < shapeBBox.minY || labelBBox.maxX > shapeBBox.maxX || labelBBox.maxY > shapeBBox.maxY) {
      label.remove(true);
    }
  });
}

// node_modules/@antv/g2/esm/geometry/label/layout/overlap.js
var MAX_TIMES = 100;
var Greedy = function() {
  function Greedy2(cfg) {
    if (cfg === void 0) {
      cfg = {};
    }
    this.bitmap = {};
    var _a3 = cfg.xGap, xGap = _a3 === void 0 ? 1 : _a3, _b = cfg.yGap, yGap = _b === void 0 ? 8 : _b;
    this.xGap = xGap;
    this.yGap = yGap;
  }
  Greedy2.prototype.hasGap = function(bbox) {
    var hasGap = true;
    var bitmap = this.bitmap;
    var minX = Math.round(bbox.minX);
    var maxX = Math.round(bbox.maxX);
    var minY = Math.round(bbox.minY);
    var maxY = Math.round(bbox.maxY);
    for (var i = minX; i <= maxX; i += 1) {
      if (!bitmap[i]) {
        bitmap[i] = {};
        continue;
      }
      if (i === minX || i === maxX) {
        for (var j = minY; j <= maxY; j++) {
          if (bitmap[i][j]) {
            hasGap = false;
            break;
          }
        }
      } else {
        if (bitmap[i][minY] || bitmap[i][maxY]) {
          hasGap = false;
          break;
        }
      }
    }
    return hasGap;
  };
  Greedy2.prototype.fillGap = function(bbox) {
    var bitmap = this.bitmap;
    var minX = Math.round(bbox.minX);
    var maxX = Math.round(bbox.maxX);
    var minY = Math.round(bbox.minY);
    var maxY = Math.round(bbox.maxY);
    for (var i = minX; i <= maxX; i += 1) {
      if (!bitmap[i]) {
        bitmap[i] = {};
      }
    }
    for (var i = minX; i <= maxX; i += this.xGap) {
      for (var j = minY; j <= maxY; j += this.yGap) {
        bitmap[i][j] = true;
      }
      bitmap[i][maxY] = true;
    }
    if (this.yGap !== 1) {
      for (var i = minY; i <= maxY; i += 1) {
        bitmap[minX][i] = true;
        bitmap[maxX][i] = true;
      }
    }
    if (this.xGap !== 1) {
      for (var i = minX; i <= maxX; i += 1) {
        bitmap[i][minY] = true;
        bitmap[i][maxY] = true;
      }
    }
  };
  Greedy2.prototype.destroy = function() {
    this.bitmap = {};
  };
  return Greedy2;
}();
function spiralFill(label, greedy, maxTimes) {
  if (maxTimes === void 0) {
    maxTimes = MAX_TIMES;
  }
  var dt = -1;
  var _a3 = label.attr(), x = _a3.x, y = _a3.y;
  var bbox = label.getCanvasBBox();
  var maxDelta = Math.sqrt(bbox.width * bbox.width + bbox.height * bbox.height);
  var dxdy;
  var t = -dt;
  var dx = 0;
  var dy = 0;
  var f = function(param) {
    var nt = param * 0.1;
    return [nt * Math.cos(nt), nt * Math.sin(nt)];
  };
  if (greedy.hasGap(bbox)) {
    greedy.fillGap(bbox);
    return true;
  }
  var canFill = false;
  var times = 0;
  var accessedCache = {};
  while (Math.min(Math.abs(dx), Math.abs(dy)) < maxDelta && times < maxTimes) {
    dxdy = f(t += dt);
    dx = ~~dxdy[0];
    dy = ~~dxdy[1];
    if (!dx && !dy || accessedCache["".concat(dx, "-").concat(dy)]) {
      continue;
    }
    label.attr({ x: x + dx, y: y + dy });
    if (dx + dy < 0) {
      label.attr("textAlign", "right");
    }
    times++;
    if (greedy.hasGap(label.getCanvasBBox())) {
      greedy.fillGap(label.getCanvasBBox());
      canFill = true;
      accessedCache["".concat(dx, "-").concat(dy)] = true;
      break;
    }
  }
  return canFill;
}
function adjustLabelPosition(label, x, y, index) {
  var _a3 = label.getCanvasBBox(), width = _a3.width, height = _a3.height;
  var attrs = {
    x,
    y,
    textAlign: "center"
  };
  switch (index) {
    case 0:
      attrs.y -= height + 1;
      attrs.x += 1;
      attrs.textAlign = "left";
      break;
    case 1:
      attrs.y -= height + 1;
      attrs.x -= 1;
      attrs.textAlign = "right";
      break;
    case 2:
      attrs.y += height + 1;
      attrs.x -= 1;
      attrs.textAlign = "right";
      break;
    case 3:
      attrs.y += height + 1;
      attrs.x += 1;
      attrs.textAlign = "left";
      break;
    case 5:
      attrs.y -= height * 2 + 2;
      break;
    case 6:
      attrs.y += height * 2 + 2;
      break;
    case 7:
      attrs.x += width + 1;
      attrs.textAlign = "left";
      break;
    case 8:
      attrs.x -= width + 1;
      attrs.textAlign = "right";
      break;
    default:
      break;
  }
  label.attr(attrs);
  return label.getCanvasBBox();
}
function fixedOverlap(items, labels, shapes, region) {
  var greedy = new Greedy();
  each_default(labels, function(label) {
    var labelShape = label.find(function(shape) {
      return shape.get("type") === "text";
    });
    if (!spiralFill(labelShape, greedy)) {
      label.remove(true);
    }
  });
  greedy.destroy();
}
function overlap(items, labels, shapes, region) {
  var greedy = new Greedy();
  each_default(labels, function(label) {
    var labelShape = label.find(function(shape) {
      return shape.get("type") === "text";
    });
    var _a3 = labelShape.attr(), x = _a3.x, y = _a3.y;
    var canFill = false;
    for (var i = 0; i <= 8; i++) {
      var bbox = adjustLabelPosition(labelShape, x, y, i);
      if (greedy.hasGap(bbox)) {
        greedy.fillGap(bbox);
        canFill = true;
        break;
      }
    }
    if (!canFill) {
      label.remove(true);
    }
  });
  greedy.destroy();
}

// node_modules/@antv/g2/esm/util/collision-detect.js
function dot5(a, b) {
  return (a[0] || 0) * (b[0] || 0) + (a[1] || 0) * (b[1] || 0) + (a[2] || 0) * (b[2] || 0);
}
function getAxes(points) {
  if (points.length > 4) {
    return [];
  }
  var vector = function(start, end) {
    return [end.x - start.x, end.y - start.y];
  };
  var AB = vector(points[0], points[1]);
  var BC = vector(points[1], points[2]);
  return [AB, BC];
}
function rotateAtPoint(point, deg, origin) {
  if (deg === void 0) {
    deg = 0;
  }
  if (origin === void 0) {
    origin = { x: 0, y: 0 };
  }
  var x = point.x, y = point.y;
  return {
    x: (x - origin.x) * Math.cos(-deg) + (y - origin.y) * Math.sin(-deg) + origin.x,
    y: (origin.x - x) * Math.sin(-deg) + (y - origin.y) * Math.cos(-deg) + origin.y
  };
}
function getRectPoints2(box2) {
  var points = [
    { x: box2.x, y: box2.y },
    { x: box2.x + box2.width, y: box2.y },
    { x: box2.x + box2.width, y: box2.y + box2.height },
    { x: box2.x, y: box2.y + box2.height }
  ];
  var rotation = box2.rotation;
  if (rotation) {
    return [
      rotateAtPoint(points[0], rotation, points[0]),
      rotateAtPoint(points[1], rotation, points[0]),
      rotateAtPoint(points[2], rotation, points[0]),
      rotateAtPoint(points[3], rotation, points[0])
    ];
  }
  return points;
}
function getProjection(points, axis) {
  if (points.length > 4) {
    return { min: 0, max: 0 };
  }
  var scalars = [];
  points.forEach(function(point) {
    scalars.push(dot5([point.x, point.y], axis));
  });
  return { min: Math.min.apply(Math, __spreadArray([], __read(scalars), false)), max: Math.max.apply(Math, __spreadArray([], __read(scalars), false)) };
}
function isProjectionOverlap(projection1, projection2) {
  return projection1.max > projection2.min && projection1.min < projection2.max;
}
function isValidNumber(d) {
  return typeof d === "number" && !Number.isNaN(d) && d !== Infinity && d !== -Infinity;
}
function isValidBox(box2) {
  return ["x", "y", "width", "height"].every(function(attr) {
    return isValidNumber(box2[attr]);
  });
}
function isIntersectRect(box1, box2, margin) {
  if (margin === void 0) {
    margin = 0;
  }
  return !(box2.x > box1.x + box1.width + margin || box2.x + box2.width < box1.x - margin || box2.y > box1.y + box1.height + margin || box2.y + box2.height < box1.y - margin);
}
function intersect2(box1, box2, margin) {
  if (margin === void 0) {
    margin = 0;
  }
  if (!isValidBox(box1) || !isValidBox(box2))
    return false;
  if (!box1.rotation && !box2.rotation) {
    return isIntersectRect(box1, box2, margin);
  }
  var rect1Points = getRectPoints2(box1);
  var rect2Points = getRectPoints2(box2);
  var axes = getAxes(rect1Points).concat(getAxes(rect2Points));
  for (var i = 0; i < axes.length; i++) {
    var axis = axes[i];
    var projection1 = getProjection(rect1Points, axis);
    var projection2 = getProjection(rect2Points, axis);
    if (!isProjectionOverlap(projection1, projection2)) {
      return false;
    }
  }
  return true;
}

// node_modules/@antv/g2/esm/geometry/label/util/createWorker.js
var MyWorker = function() {
  function MyWorker2(url) {
    var _this = this;
    this.queue = [];
    this.worker = new Worker(url);
    this.worker.onmessage = function(e) {
      var _a3;
      (_a3 = _this.queue.shift()) === null || _a3 === void 0 ? void 0 : _a3.resolve(e);
    };
    this.worker.onmessageerror = function(e) {
      var _a3;
      console.warn("[AntV G2] Web worker is not available");
      (_a3 = _this.queue.shift()) === null || _a3 === void 0 ? void 0 : _a3.reject(e);
    };
  }
  MyWorker2.prototype.post = function(params, onError) {
    var _this = this;
    return new Promise(function(resolve, reject) {
      _this.queue.push({ resolve, reject });
      try {
        _this.worker.postMessage(params);
      } catch (e) {
        console.warn("[AntV G2] Web worker is not available");
        is_function_default(onError) && onError();
      }
    });
  };
  MyWorker2.prototype.destroy = function() {
    this.worker.terminate();
  };
  return MyWorker2;
}();
function createWorker(f) {
  if (typeof window === "undefined")
    return;
  var blob;
  try {
    blob = new Blob([f.toString()], { type: "application/javascript" });
  } catch (e) {
    blob = new window.BlobBuilder();
    blob.append(f.toString());
    blob = blob.getBlob();
  }
  return new MyWorker(URL.createObjectURL(blob));
}

// node_modules/@antv/g2/esm/geometry/label/layout/worker/hide-overlap.js
var onmessage = function(e) {
  function generateUtils() {
    function dot6(a, b) {
      return (a[0] || 0) * (b[0] || 0) + (a[1] || 0) * (b[1] || 0) + (a[2] || 0) * (b[2] || 0);
    }
    function getAxes2(points) {
      if (points.length > 4) {
        return [];
      }
      var vector = function(start, end) {
        return [end.x - start.x, end.y - start.y];
      };
      var AB = vector(points[0], points[1]);
      var BC = vector(points[1], points[2]);
      return [AB, BC];
    }
    function rotateAtPoint2(point, deg, origin) {
      if (deg === void 0) {
        deg = 0;
      }
      if (origin === void 0) {
        origin = { x: 0, y: 0 };
      }
      var x = point.x, y = point.y;
      return {
        x: (x - origin.x) * Math.cos(-deg) + (y - origin.y) * Math.sin(-deg) + origin.x,
        y: (origin.x - x) * Math.sin(-deg) + (y - origin.y) * Math.cos(-deg) + origin.y
      };
    }
    function getRectPoints3(box2) {
      var points = [
        { x: box2.x, y: box2.y },
        { x: box2.x + box2.width, y: box2.y },
        { x: box2.x + box2.width, y: box2.y + box2.height },
        { x: box2.x, y: box2.y + box2.height }
      ];
      var rotation = box2.rotation;
      if (rotation) {
        return [
          rotateAtPoint2(points[0], rotation, points[0]),
          rotateAtPoint2(points[1], rotation, points[0]),
          rotateAtPoint2(points[2], rotation, points[0]),
          rotateAtPoint2(points[3], rotation, points[0])
        ];
      }
      return points;
    }
    function getProjection2(points, axis) {
      if (points.length > 4) {
        return { min: 0, max: 0 };
      }
      var scalars = [];
      points.forEach(function(point) {
        scalars.push(dot6([point.x, point.y], axis));
      });
      return { min: Math.min.apply(null, scalars), max: Math.max.apply(null, scalars) };
    }
    function isProjectionOverlap2(projection1, projection2) {
      return projection1.max > projection2.min && projection1.min < projection2.max;
    }
    function isValidNumber2(d) {
      return typeof d === "number" && !Number.isNaN(d) && d !== Infinity && d !== -Infinity;
    }
    function isValidBox2(box2) {
      return ["x", "y", "width", "height"].every(function(attr) {
        return isValidNumber2(box2[attr]);
      });
    }
    function isIntersectRect2(box1, box2, margin) {
      if (margin === void 0) {
        margin = 0;
      }
      return !(box2.x > box1.x + box1.width + margin || box2.x + box2.width < box1.x - margin || box2.y > box1.y + box1.height + margin || box2.y + box2.height < box1.y - margin);
    }
    function intersect4(box1, box2, margin) {
      if (margin === void 0) {
        margin = 0;
      }
      if (!isValidBox2(box1) || !isValidBox2(box2))
        return false;
      if (!box1.rotation && !box2.rotation) {
        return isIntersectRect2(box1, box2, margin);
      }
      var rect1Points = getRectPoints3(box1);
      var rect2Points = getRectPoints3(box2);
      var axes = getAxes2(rect1Points).concat(getAxes2(rect2Points));
      for (var i = 0; i < axes.length; i++) {
        var axis = axes[i];
        var projection1 = getProjection2(rect1Points, axis);
        var projection2 = getProjection2(rect2Points, axis);
        if (!isProjectionOverlap2(projection1, projection2))
          return false;
      }
      return true;
    }
    return { intersect: intersect4 };
  }
  var intersect3 = generateUtils().intersect;
  function hideOverlap2(items2) {
    var boxes = items2.slice();
    for (var i = 0; i < boxes.length; i++) {
      var box1 = boxes[i];
      if (box1.visible) {
        for (var j = i + 1; j < boxes.length; j++) {
          var box2 = boxes[j];
          if (box1 !== box2 && box2.visible) {
            if (intersect3(box1, box2)) {
              box2.visible = false;
            }
          }
        }
      }
    }
    return boxes;
  }
  var methods = {
    "hide-overlap": hideOverlap2
  };
  try {
    var eventData = JSON.parse(e.data);
    if (!eventData || !eventData.type || !methods[eventData.type])
      return;
    var type = eventData.type, items = eventData.items;
    var result = methods[type](items);
    self.postMessage(result);
  } catch (e3) {
    throw e3;
  }
};
var code = "\n   self.onmessage = ".concat(onmessage.toString(), "\n");

// node_modules/@antv/g2/esm/geometry/label/layout/hide-overlap.js
var layout = function(items) {
  var boxes = items.slice();
  for (var i = 0; i < boxes.length; i++) {
    var box1 = boxes[i];
    if (box1.visible) {
      for (var j = i + 1; j < boxes.length; j++) {
        var box2 = boxes[j];
        if (box1 !== box2 && box2.visible) {
          if (intersect2(box1, box2)) {
            box2.visible = false;
          }
        }
      }
    }
  }
  return boxes;
};
var cache2 = /* @__PURE__ */ new Map();
var worker = createWorker(code);
function hideOverlap(labelItems, labels, shapes, region) {
  return __awaiter(this, void 0, void 0, function() {
    var boxes, memoKey, cb, params, res, e_1;
    return __generator(this, function(_a3) {
      switch (_a3.label) {
        case 0:
          boxes = labels.map(function(d, idx) {
            return __assign(__assign({}, getLabelBackgroundInfo(d, labelItems[idx], get_default(labelItems[idx], "background.padding"))), { visible: true });
          });
          memoKey = JSON.stringify(boxes);
          cb = function(items) {
            cache2.set(memoKey, items);
            each_default(items, function(_a4, idx) {
              var visible = _a4.visible;
              var labelShape = labels[idx];
              if (visible) {
                labelShape === null || labelShape === void 0 ? void 0 : labelShape.show();
              } else {
                labelShape === null || labelShape === void 0 ? void 0 : labelShape.hide();
              }
            });
            return items;
          };
          if (!cache2.get(memoKey))
            return [3, 1];
          cb(cache2.get(memoKey));
          return [3, 7];
        case 1:
          if (!worker)
            return [3, 6];
          _a3.label = 2;
        case 2:
          _a3.trys.push([2, 4, , 5]);
          params = JSON.stringify({ type: "hide-overlap", items: boxes });
          return [4, worker.post(params, function() {
            return cb(layout(boxes));
          })];
        case 3:
          res = _a3.sent();
          cb(Array.isArray(res.data) ? res.data : []);
          return [3, 5];
        case 4:
          e_1 = _a3.sent();
          console.error(e_1);
          cb(layout(boxes));
          return [3, 5];
        case 5:
          return [3, 7];
        case 6:
          cb(layout(boxes));
          _a3.label = 7;
        case 7:
          return [2];
      }
    });
  });
}

// node_modules/@antv/g2/esm/util/color.js
var preset = {
  "#5B8FF9": true
};
var isContrastColorWhite = function(color2) {
  var rgb2 = esm_default2.toRGB(color2).toUpperCase();
  if (preset[rgb2]) {
    return preset[rgb2];
  }
  var _a3 = __read(esm_default2.rgb2arr(rgb2), 3), r = _a3[0], g = _a3[1], b = _a3[2];
  var isDark = (r * 299 + g * 587 + b * 114) / 1e3 < 128;
  return isDark;
};

// node_modules/@antv/g2/esm/geometry/label/layout/adjust-color.js
function adjustColor(items, labels, shapes) {
  if (shapes.length === 0) {
    return;
  }
  var element = shapes[0].get("element");
  var theme = element.geometry.theme;
  var _a3 = theme.labels || {}, fillColorLight = _a3.fillColorLight, fillColorDark = _a3.fillColorDark;
  shapes.forEach(function(shape, index) {
    var label = labels[index];
    var textShape = label.find(function(el) {
      return el.get("type") === "text";
    });
    var shapeBBox = BBox.fromObject(shape.getBBox());
    var textBBox = BBox.fromObject(textShape.getCanvasBBox());
    var overflow = !shapeBBox.contains(textBBox);
    var bgColor = shape.attr("fill");
    var fillWhite = isContrastColorWhite(bgColor);
    if (!overflow) {
      if (fillWhite) {
        if (fillColorLight) {
          textShape.attr("fill", fillColorLight);
        }
      } else {
        if (fillColorDark) {
          textShape.attr("fill", fillColorDark);
        }
      }
    } else {
      textShape.attr(theme.overflowLabels.style);
    }
  });
}

// node_modules/@antv/g2/esm/geometry/label/layout/interval/adjust-position.js
function shouldInShapeSingle(geometry, label, shape) {
  var coordinate = geometry.coordinate;
  var textShape = findLabelTextShape(label);
  var textBBox = BBox.fromObject(textShape.getCanvasBBox());
  var shapeBBox = BBox.fromObject(shape.getBBox());
  return coordinate.isTransposed ? shapeBBox.height >= textBBox.height : shapeBBox.width >= textBBox.width;
}
function shouldInShape(geometry, labels, shapes) {
  var isStack = !!geometry.getAdjust("stack");
  return isStack || labels.every(function(label, index) {
    var shape = shapes[index];
    return shouldInShapeSingle(geometry, label, shape);
  });
}
function moveInShape(geometry, label, shape) {
  var coordinate = geometry.coordinate;
  var shapeBBox = BBox.fromObject(shape.getBBox());
  var textShape = findLabelTextShape(label);
  if (coordinate.isTransposed) {
    textShape.attr({
      x: shapeBBox.minX + shapeBBox.width / 2,
      textAlign: "center"
    });
  } else {
    textShape.attr({
      y: shapeBBox.minY + shapeBBox.height / 2,
      textBaseline: "middle"
    });
  }
}
function intervalAdjustPosition(items, labels, shapes) {
  var _a3;
  if (shapes.length === 0) {
    return;
  }
  var element = (_a3 = shapes[0]) === null || _a3 === void 0 ? void 0 : _a3.get("element");
  var geometry = element === null || element === void 0 ? void 0 : element.geometry;
  if (!geometry || geometry.type !== "interval") {
    return;
  }
  var inShape = shouldInShape(geometry, labels, shapes);
  if (inShape) {
    shapes.forEach(function(shape, index) {
      var label = labels[index];
      moveInShape(geometry, label, shape);
    });
  }
}

// node_modules/@antv/g2/esm/geometry/label/layout/interval/hide-overlap.js
function filterLabel(labels) {
  var MAX_CNT = 500;
  var filteredLabels = [];
  var pages = Math.max(Math.floor(labels.length / MAX_CNT), 1);
  each_default(labels, function(label, idx) {
    if (idx % pages === 0) {
      filteredLabels.push(label);
    } else {
      label.set("visible", false);
    }
  });
  return filteredLabels;
}
function intervalHideOverlap(items, labels, shapes) {
  var _a3;
  if (shapes.length === 0) {
    return;
  }
  var element = (_a3 = shapes[0]) === null || _a3 === void 0 ? void 0 : _a3.get("element");
  var geometry = element === null || element === void 0 ? void 0 : element.geometry;
  if (!geometry || geometry.type !== "interval") {
    return;
  }
  var filteredLabels = filterLabel(labels);
  var _b = __read(geometry.getXYFields(), 1), xField = _b[0];
  var dones = [];
  var todo = [];
  var groupedLabels = group_by_default(filteredLabels, function(label) {
    return label.get("data")[xField];
  });
  var xValues = uniq(map_default(filteredLabels, function(label) {
    return label.get("data")[xField];
  }));
  var xValue;
  filteredLabels.forEach(function(label) {
    label.set("visible", true);
  });
  var addCurrentGroup = function(curItems) {
    if (curItems) {
      if (curItems.length) {
        todo.push(curItems.pop());
      }
      todo.push.apply(todo, __spreadArray([], __read(curItems), false));
    }
  };
  if (size(xValues) > 0) {
    xValue = xValues.shift();
    addCurrentGroup(groupedLabels[xValue]);
  }
  if (size(xValues) > 0) {
    xValue = xValues.pop();
    addCurrentGroup(groupedLabels[xValue]);
  }
  each_default(xValues.reverse(), function(val) {
    addCurrentGroup(groupedLabels[val]);
  });
  while (todo.length > 0) {
    var cur = todo.shift();
    if (cur.get("visible")) {
      if (checkShapeOverlap(cur, dones)) {
        cur.set("visible", false);
      } else {
        dones.push(cur);
      }
    }
  }
}

// node_modules/@antv/g2/esm/geometry/label/layout/point/adjust-position.js
function sortLabels(geometry, labels) {
  var yField = geometry.getXYFields()[1];
  var result = [];
  var sortedLabels = labels.sort(function(left, right) {
    return left.get("data")[yField] - left.get("data")[yField];
  });
  if (sortedLabels.length > 0) {
    result.push(sortedLabels.shift());
  }
  if (sortedLabels.length > 0) {
    result.push(sortedLabels.pop());
  }
  result.push.apply(result, __spreadArray([], __read(sortedLabels), false));
  return result;
}
function hasSome(dones, current, compare) {
  return dones.some(function(done) {
    return compare(done, current);
  });
}
function getOverlapArea2(a, b, margin) {
  if (margin === void 0) {
    margin = 0;
  }
  var xOverlap = Math.max(0, Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin));
  var yOverlap = Math.max(0, Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin));
  return xOverlap * yOverlap;
}
function checkShapeOverlap2(dones, current) {
  return hasSome(dones, current, function(left, right) {
    var leftText = findLabelTextShape(left);
    var rightText = findLabelTextShape(right);
    return getOverlapArea2(leftText.getCanvasBBox(), rightText.getCanvasBBox(), 2) > 0;
  });
}
function pointAdjustPosition(items, labels, shapes, region, cfg) {
  var _a3, _b;
  if (shapes.length === 0) {
    return;
  }
  var element = (_a3 = shapes[0]) === null || _a3 === void 0 ? void 0 : _a3.get("element");
  var geometry = element === null || element === void 0 ? void 0 : element.geometry;
  if (!geometry || geometry.type !== "point") {
    return;
  }
  var _c = __read(geometry.getXYFields(), 2), xField = _c[0], yField = _c[1];
  var groupedLabels = group_by_default(labels, function(label) {
    return label.get("data")[xField];
  });
  var dones = [];
  var offset = cfg && cfg.offset || ((_b = items[0]) === null || _b === void 0 ? void 0 : _b.offset) || 12;
  map_default(keys_default(groupedLabels).reverse(), function(xValue) {
    var sortedCollections = sortLabels(geometry, groupedLabels[xValue]);
    while (sortedCollections.length) {
      var current = sortedCollections.shift();
      var textShape = findLabelTextShape(current);
      if (hasSome(dones, current, function(left, right) {
        return left.get("data")[xField] === right.get("data")[xField] && left.get("data")[yField] === right.get("data")[yField];
      })) {
        textShape.set("visible", false);
        continue;
      }
      var upFail = checkShapeOverlap2(dones, current);
      var downFail = false;
      if (upFail) {
        textShape.attr("y", textShape.attr("y") + 2 * offset);
        downFail = checkShapeOverlap2(dones, current);
      }
      if (downFail) {
        textShape.set("visible", false);
        continue;
      }
      dones.push(current);
    }
  });
}

// node_modules/@antv/g2/esm/geometry/label/layout/path/adjust-position.js
function sortLabels2(geometry, labels) {
  var yField = geometry.getXYFields()[1];
  var result = [];
  var sortedLabels = labels.sort(function(left, right) {
    return left.get("data")[yField] - left.get("data")[yField];
  });
  if (sortedLabels.length > 0) {
    result.push(sortedLabels.shift());
  }
  if (sortedLabels.length > 0) {
    result.push(sortedLabels.pop());
  }
  result.push.apply(result, __spreadArray([], __read(sortedLabels), false));
  return result;
}
function hasSome2(dones, current, compare) {
  return dones.some(function(done) {
    return compare(done, current);
  });
}
function getOverlapArea3(a, b, margin) {
  if (margin === void 0) {
    margin = 0;
  }
  var xOverlap = Math.max(0, Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin));
  var yOverlap = Math.max(0, Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin));
  return xOverlap * yOverlap;
}
function checkShapeOverlap3(dones, current) {
  return hasSome2(dones, current, function(left, right) {
    var leftText = findLabelTextShape(left);
    var rightText = findLabelTextShape(right);
    return getOverlapArea3(leftText.getCanvasBBox(), rightText.getCanvasBBox(), 2) > 0;
  });
}
function pathAdjustPosition(items, labels, shapes, region, cfg) {
  var _a3, _b;
  if (shapes.length === 0) {
    return;
  }
  var element = (_a3 = shapes[0]) === null || _a3 === void 0 ? void 0 : _a3.get("element");
  var geometry = element === null || element === void 0 ? void 0 : element.geometry;
  if (!geometry || ["path", "line", "area"].indexOf(geometry.type) < 0) {
    return;
  }
  var _c = __read(geometry.getXYFields(), 2), xField = _c[0], yField = _c[1];
  var groupedLabels = group_by_default(labels, function(label) {
    return label.get("data")[xField];
  });
  var dones = [];
  var offset = cfg && cfg.offset || ((_b = items[0]) === null || _b === void 0 ? void 0 : _b.offset) || 12;
  map_default(keys_default(groupedLabels).reverse(), function(xValue) {
    var sortedCollections = sortLabels2(geometry, groupedLabels[xValue]);
    while (sortedCollections.length) {
      var current = sortedCollections.shift();
      var textShape = findLabelTextShape(current);
      if (hasSome2(dones, current, function(left, right) {
        return left.get("data")[xField] === right.get("data")[xField] && left.get("data")[yField] === right.get("data")[yField];
      })) {
        textShape.set("visible", false);
        continue;
      }
      var upFail = checkShapeOverlap3(dones, current);
      var downFail = false;
      if (upFail) {
        textShape.attr("y", textShape.attr("y") + 2 * offset);
        downFail = checkShapeOverlap3(dones, current);
      }
      if (downFail) {
        textShape.set("visible", false);
        continue;
      }
      dones.push(current);
    }
  });
}

// node_modules/@antv/g2/esm/util/context.js
var ctx2;
function getCanvasContext() {
  if (!ctx2) {
    ctx2 = document.createElement("canvas").getContext("2d");
  }
  return ctx2;
}

// node_modules/@antv/g2/esm/util/text.js
var measureTextWidth = memoize_default(function(text, font) {
  if (font === void 0) {
    font = {};
  }
  var fontSize = font.fontSize, fontFamily = font.fontFamily, fontWeight = font.fontWeight, fontStyle = font.fontStyle, fontVariant = font.fontVariant;
  var ctx3 = getCanvasContext();
  ctx3.font = [fontStyle, fontVariant, fontWeight, "".concat(fontSize, "px"), fontFamily].join(" ");
  return ctx3.measureText(is_string_default(text) ? text : "").width;
}, function(text, font) {
  if (font === void 0) {
    font = {};
  }
  return __spreadArray([text], __read(values_default(font)), false).join("");
});
var getEllipsisText = function(text, maxWidth, font) {
  var STEP = 16;
  var DOT_WIDTH = measureTextWidth("...", font);
  var leftText;
  if (!is_string_default(text)) {
    leftText = to_string_default(text);
  } else {
    leftText = text;
  }
  var leftWidth = maxWidth;
  var r = [];
  var currentText;
  var currentWidth;
  if (measureTextWidth(text, font) <= maxWidth) {
    return text;
  }
  while (true) {
    currentText = leftText.substr(0, STEP);
    currentWidth = measureTextWidth(currentText, font);
    if (currentWidth + DOT_WIDTH > leftWidth) {
      if (currentWidth > leftWidth) {
        break;
      }
    }
    r.push(currentText);
    leftWidth -= currentWidth;
    leftText = leftText.substr(STEP);
    if (!leftText) {
      return r.join("");
    }
  }
  while (true) {
    currentText = leftText.substr(0, 1);
    currentWidth = measureTextWidth(currentText, font);
    if (currentWidth + DOT_WIDTH > leftWidth) {
      break;
    }
    r.push(currentText);
    leftWidth -= currentWidth;
    leftText = leftText.substr(1);
    if (!leftText) {
      return r.join("");
    }
  }
  return "".concat(r.join(""), "...");
};

// node_modules/@antv/g2/esm/geometry/label/layout/limit-in-plot.js
function limitInPlot(items, labels, shapes, region, cfg) {
  if (labels.length <= 0) {
    return;
  }
  var direction2 = (cfg === null || cfg === void 0 ? void 0 : cfg.direction) || ["top", "right", "bottom", "left"];
  var action = (cfg === null || cfg === void 0 ? void 0 : cfg.action) || "translate";
  var margin = (cfg === null || cfg === void 0 ? void 0 : cfg.margin) || 0;
  var coordinate = labels[0].get("coordinate");
  if (!coordinate) {
    return;
  }
  var _a3 = getCoordinateBBox(coordinate, margin), regionMinX = _a3.minX, regionMinY = _a3.minY, regionMaxX = _a3.maxX, regionMaxY = _a3.maxY;
  each_default(labels, function(label) {
    var _a4 = label.getCanvasBBox(), minX = _a4.minX, minY = _a4.minY, maxX = _a4.maxX, maxY = _a4.maxY, x = _a4.x, y = _a4.y, width = _a4.width, height = _a4.height;
    var finalX = x;
    var finalY = y;
    if (direction2.indexOf("left") >= 0 && (minX < regionMinX || maxX < regionMinX)) {
      finalX = regionMinX;
    }
    if (direction2.indexOf("top") >= 0 && (minY < regionMinY || maxY < regionMinY)) {
      finalY = regionMinY;
    }
    if (direction2.indexOf("right") >= 0) {
      if (minX > regionMaxX) {
        finalX = regionMaxX - width;
      } else if (maxX > regionMaxX) {
        finalX = finalX - (maxX - regionMaxX);
      }
    }
    if (direction2.indexOf("bottom") >= 0) {
      if (minY > regionMaxY) {
        finalY = regionMaxY - height;
      } else if (maxY > regionMaxY) {
        finalY = finalY - (maxY - regionMaxY);
      }
    }
    if (finalX !== x || finalY !== y) {
      var translateX_1 = finalX - x;
      if (action === "translate") {
        translate2(label, translateX_1, finalY - y);
      } else if (action === "ellipsis") {
        var textShapes = label.findAll(function(shape) {
          return shape.get("type") === "text";
        });
        textShapes.forEach(function(textShape) {
          var style = pick_default(textShape.attr(), ["fontSize", "fontFamily", "fontWeight", "fontStyle", "fontVariant"]);
          var textBox = textShape.getCanvasBBox();
          var text = getEllipsisText(textShape.attr("text"), textBox.width - Math.abs(translateX_1), style);
          textShape.attr("text", text);
        });
      } else {
        label.hide();
      }
    }
  });
}

// node_modules/@antv/g2/esm/animate/animation/fade.js
function fadeIn(shape, animateCfg, cfg) {
  var endState = {
    fillOpacity: is_nil_default(shape.attr("fillOpacity")) ? 1 : shape.attr("fillOpacity"),
    strokeOpacity: is_nil_default(shape.attr("strokeOpacity")) ? 1 : shape.attr("strokeOpacity"),
    opacity: is_nil_default(shape.attr("opacity")) ? 1 : shape.attr("opacity")
  };
  shape.attr({
    fillOpacity: 0,
    strokeOpacity: 0,
    opacity: 0
  });
  shape.animate(endState, animateCfg);
}
function fadeOut(shape, animateCfg, cfg) {
  var endState = {
    fillOpacity: 0,
    strokeOpacity: 0,
    opacity: 0
  };
  var easing = animateCfg.easing, duration = animateCfg.duration, delay = animateCfg.delay;
  shape.animate(endState, duration, easing, function() {
    shape.remove(true);
  }, delay);
}

// node_modules/@antv/g2/esm/animate/animation/util.js
function transformShape(shape, vector, direct) {
  var scaledMatrix;
  var _a3 = __read(vector, 2), x = _a3[0], y = _a3[1];
  shape.applyToMatrix([x, y, 1]);
  if (direct === "x") {
    shape.setMatrix(ext_exports.transform(shape.getMatrix(), [
      ["t", -x, -y],
      ["s", 0.01, 1],
      ["t", x, y]
    ]));
    scaledMatrix = ext_exports.transform(shape.getMatrix(), [
      ["t", -x, -y],
      ["s", 100, 1],
      ["t", x, y]
    ]);
  } else if (direct === "y") {
    shape.setMatrix(ext_exports.transform(shape.getMatrix(), [
      ["t", -x, -y],
      ["s", 1, 0.01],
      ["t", x, y]
    ]));
    scaledMatrix = ext_exports.transform(shape.getMatrix(), [
      ["t", -x, -y],
      ["s", 1, 100],
      ["t", x, y]
    ]);
  } else if (direct === "xy") {
    shape.setMatrix(ext_exports.transform(shape.getMatrix(), [
      ["t", -x, -y],
      ["s", 0.01, 0.01],
      ["t", x, y]
    ]));
    scaledMatrix = ext_exports.transform(shape.getMatrix(), [
      ["t", -x, -y],
      ["s", 100, 100],
      ["t", x, y]
    ]);
  }
  return scaledMatrix;
}
function doScaleAnimate(element, animateCfg, coordinate, yMinPoint, type) {
  var start = coordinate.start, end = coordinate.end;
  var width = coordinate.getWidth();
  var height = coordinate.getHeight();
  var x;
  var y;
  if (type === "y") {
    x = start.x + width / 2;
    y = yMinPoint.y < start.y ? yMinPoint.y : start.y;
  } else if (type === "x") {
    x = yMinPoint.x > start.x ? yMinPoint.x : start.x;
    y = start.y + height / 2;
  } else if (type === "xy") {
    if (coordinate.isPolar) {
      x = coordinate.getCenter().x;
      y = coordinate.getCenter().y;
    } else {
      x = (start.x + end.x) / 2;
      y = (start.y + end.y) / 2;
    }
  }
  var endMatrix = transformShape(element, [x, y], type);
  element.animate({
    matrix: endMatrix
  }, animateCfg);
}

// node_modules/@antv/g2/esm/animate/animation/grow-in.js
function growInX(element, animateCfg, cfg) {
  var coordinate = cfg.coordinate, minYPoint = cfg.minYPoint;
  doScaleAnimate(element, animateCfg, coordinate, minYPoint, "x");
}
function growInY(element, animateCfg, cfg) {
  var coordinate = cfg.coordinate, minYPoint = cfg.minYPoint;
  doScaleAnimate(element, animateCfg, coordinate, minYPoint, "y");
}
function growInXY(element, animateCfg, cfg) {
  var coordinate = cfg.coordinate, minYPoint = cfg.minYPoint;
  doScaleAnimate(element, animateCfg, coordinate, minYPoint, "xy");
}

// node_modules/@antv/g2/esm/animate/animation/path-in.js
function pathIn(element, animateCfg, cfg) {
  var length5 = element.getTotalLength();
  element.attr("lineDash", [length5]);
  element.animate(function(ratio) {
    return {
      lineDashOffset: (1 - ratio) * length5
    };
  }, animateCfg);
}

// node_modules/@antv/g2/esm/animate/animation/position-update.js
function positionUpdate(shape, animateCfg, cfg) {
  var toAttrs = cfg.toAttrs;
  var x = toAttrs.x;
  var y = toAttrs.y;
  delete toAttrs.x;
  delete toAttrs.y;
  shape.attr(toAttrs);
  shape.animate({
    x,
    y
  }, animateCfg);
}

// node_modules/@antv/g2/esm/animate/animation/scale-in.js
function scaleInX(shape, animateCfg, cfg) {
  var box2 = shape.getBBox();
  var mappingData = shape.get("origin").mappingData;
  var points = mappingData.points;
  var x = points[0].y - points[1].y > 0 ? box2.maxX : box2.minX;
  var y = (box2.minY + box2.maxY) / 2;
  shape.applyToMatrix([x, y, 1]);
  var matrix = ext_exports.transform(shape.getMatrix(), [
    ["t", -x, -y],
    ["s", 0.01, 1],
    ["t", x, y]
  ]);
  shape.setMatrix(matrix);
  shape.animate({
    matrix: ext_exports.transform(shape.getMatrix(), [
      ["t", -x, -y],
      ["s", 100, 1],
      ["t", x, y]
    ])
  }, animateCfg);
}
function scaleInY(shape, animateCfg, cfg) {
  var box2 = shape.getBBox();
  var mappingData = shape.get("origin").mappingData;
  var x = (box2.minX + box2.maxX) / 2;
  var points = mappingData.points;
  var y = points[0].y - points[1].y <= 0 ? box2.maxY : box2.minY;
  shape.applyToMatrix([x, y, 1]);
  var matrix = ext_exports.transform(shape.getMatrix(), [
    ["t", -x, -y],
    ["s", 1, 0.01],
    ["t", x, y]
  ]);
  shape.setMatrix(matrix);
  shape.animate({
    matrix: ext_exports.transform(shape.getMatrix(), [
      ["t", -x, -y],
      ["s", 1, 100],
      ["t", x, y]
    ])
  }, animateCfg);
}

// node_modules/@antv/g2/esm/animate/animation/sector-path-update.js
function getAngle3(startPoint, arcPath) {
  var _a3;
  var _b = getArcParams2(startPoint, arcPath), startAngle = _b.startAngle, endAngle = _b.endAngle;
  if (!isNumberEqual(startAngle, -Math.PI * 0.5) && startAngle < -Math.PI * 0.5) {
    startAngle += Math.PI * 2;
  }
  if (!isNumberEqual(endAngle, -Math.PI * 0.5) && endAngle < -Math.PI * 0.5) {
    endAngle += Math.PI * 2;
  }
  if (arcPath[5] === 0) {
    _a3 = __read([endAngle, startAngle], 2), startAngle = _a3[0], endAngle = _a3[1];
  }
  if (isNumberEqual(startAngle, Math.PI * 1.5)) {
    startAngle = Math.PI * -0.5;
  }
  if (isNumberEqual(endAngle, Math.PI * -0.5) && !isNumberEqual(startAngle, endAngle)) {
    endAngle = Math.PI * 1.5;
  }
  return {
    startAngle,
    endAngle
  };
}
function getArcStartPoint(path) {
  var startPoint;
  if (path[0] === "M" || path[0] === "L") {
    startPoint = [path[1], path[2]];
  } else if (path[0] === "a" || path[0] === "A" || path[0] === "C") {
    startPoint = [path[path.length - 2], path[path.length - 1]];
  }
  return startPoint;
}
function getArcInfo(path) {
  var _a3;
  var startAngle;
  var endAngle;
  var arcPaths = path.filter(function(command) {
    return command[0] === "A" || command[0] === "a";
  });
  if (arcPaths.length === 0) {
    return {
      startAngle: 0,
      endAngle: 0,
      radius: 0,
      innerRadius: 0
    };
  }
  var firstArcPathCommand = arcPaths[0];
  var lastArcPathCommand = arcPaths.length > 1 ? arcPaths[1] : arcPaths[0];
  var firstIndex = path.indexOf(firstArcPathCommand);
  var lastIndex = path.indexOf(lastArcPathCommand);
  var firstStartPoint = getArcStartPoint(path[firstIndex - 1]);
  var lastStartPoint = getArcStartPoint(path[lastIndex - 1]);
  var _b = getAngle3(firstStartPoint, firstArcPathCommand), firstStartAngle = _b.startAngle, firstEndAngle = _b.endAngle;
  var _c = getAngle3(lastStartPoint, lastArcPathCommand), lastStartAngle = _c.startAngle, lastEndAngle = _c.endAngle;
  if (isNumberEqual(firstStartAngle, lastStartAngle) && isNumberEqual(firstEndAngle, lastEndAngle)) {
    startAngle = firstStartAngle;
    endAngle = firstEndAngle;
  } else {
    startAngle = Math.min(firstStartAngle, lastStartAngle);
    endAngle = Math.max(firstEndAngle, lastEndAngle);
  }
  var radius = firstArcPathCommand[1];
  var innerRadius = arcPaths[arcPaths.length - 1][1];
  if (radius < innerRadius) {
    _a3 = __read([innerRadius, radius], 2), radius = _a3[0], innerRadius = _a3[1];
  } else if (radius === innerRadius) {
    innerRadius = 0;
  }
  return {
    startAngle,
    endAngle,
    radius,
    innerRadius
  };
}
function sectorPathUpdate(shape, animateCfg, cfg) {
  var toAttrs = cfg.toAttrs, coordinate = cfg.coordinate;
  var path = toAttrs.path || [];
  var pathCommands = path.map(function(command) {
    return command[0];
  });
  if (path.length < 1)
    return;
  var _a3 = getArcInfo(path), curStartAngle = _a3.startAngle, curEndAngle = _a3.endAngle, radius = _a3.radius, innerRadius = _a3.innerRadius;
  var _b = getArcInfo(shape.attr("path")), preStartAngle = _b.startAngle, preEndAngle = _b.endAngle;
  var center = coordinate.getCenter();
  var diffStartAngle = curStartAngle - preStartAngle;
  var diffEndAngle = curEndAngle - preEndAngle;
  if (diffStartAngle === 0 && diffEndAngle === 0) {
    shape.attr("path", path);
    return;
  }
  shape.animate(function(ratio) {
    var onFrameStartAngle = preStartAngle + ratio * diffStartAngle;
    var onFrameEndAngle = preEndAngle + ratio * diffEndAngle;
    return __assign(__assign({}, toAttrs), { path: is_equal_default(pathCommands, ["M", "A", "A", "Z"]) ? getArcPath(center.x, center.y, radius, onFrameStartAngle, onFrameEndAngle) : getSectorPath(center.x, center.y, radius, onFrameStartAngle, onFrameEndAngle, innerRadius) });
  }, __assign(__assign({}, animateCfg), { callback: function() {
    shape.attr("path", path);
  } }));
}

// node_modules/@antv/g2/esm/animate/animation/wave-in.js
function waveIn(element, animateCfg, cfg) {
  var _a3 = getCoordinateClipCfg(cfg.coordinate, 20), type = _a3.type, startState = _a3.startState, endState = _a3.endState;
  var clipShape = element.setClip({
    type,
    attrs: startState
  });
  if (cfg.toAttrs) {
    element.attr(cfg.toAttrs);
  }
  clipShape.animate(endState, __assign(__assign({}, animateCfg), { callback: function() {
    if (element && !element.get("destroyed")) {
      element.set("clipShape", null);
    }
    clipShape.remove(true);
  } }));
}

// node_modules/@antv/g2/esm/animate/animation/zoom.js
function doShapeZoom(shape, animateCfg, type) {
  if (shape.isGroup()) {
    each_default(shape.getChildren(), function(child) {
      doShapeZoom(child, animateCfg, type);
    });
  } else {
    var bbox = shape.getBBox();
    var x = (bbox.minX + bbox.maxX) / 2;
    var y = (bbox.minY + bbox.maxY) / 2;
    shape.applyToMatrix([x, y, 1]);
    if (type === "zoomIn") {
      var matrix = ext_exports.transform(shape.getMatrix(), [
        ["t", -x, -y],
        ["s", 0.01, 0.01],
        ["t", x, y]
      ]);
      shape.setMatrix(matrix);
      shape.animate({
        matrix: ext_exports.transform(shape.getMatrix(), [
          ["t", -x, -y],
          ["s", 100, 100],
          ["t", x, y]
        ])
      }, animateCfg);
    } else {
      shape.animate({
        matrix: ext_exports.transform(shape.getMatrix(), [
          ["t", -x, -y],
          ["s", 0.01, 0.01],
          ["t", x, y]
        ])
      }, __assign(__assign({}, animateCfg), { callback: function() {
        shape.remove(true);
      } }));
    }
  }
}
function zoomIn(shape, animateCfg, cfg) {
  doShapeZoom(shape, animateCfg, "zoomIn");
}
function zoomOut(shape, animateCfg, cfg) {
  doShapeZoom(shape, animateCfg, "zoomOut");
}

// node_modules/@antv/g2/esm/util/facet.js
function getFactTitleConfig(direction2) {
  if ([DIRECTION.TOP, DIRECTION.BOTTOM].includes(direction2)) {
    return {
      offsetX: 0,
      offsetY: direction2 === DIRECTION.TOP ? -8 : 8,
      style: {
        textAlign: "center",
        textBaseline: direction2 === DIRECTION.TOP ? "bottom" : "top"
      }
    };
  }
  if ([DIRECTION.LEFT, DIRECTION.RIGHT].includes(direction2)) {
    return {
      offsetX: direction2 === DIRECTION.LEFT ? -8 : 8,
      offsetY: 0,
      style: {
        textAlign: direction2 === DIRECTION.LEFT ? "right" : "left",
        textBaseline: "middle",
        rotate: Math.PI / 2
      }
    };
  }
  return {};
}
function getAnglePoint(center, r, angle3) {
  return {
    x: center.x + r * Math.cos(angle3),
    y: center.y + r * Math.sin(angle3)
  };
}

// node_modules/@antv/g2/esm/facet/circle.js
var Circle5 = function(_super) {
  __extends(Circle6, _super);
  function Circle6() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Circle6.prototype.getDefaultCfg = function() {
    return deep_mix_default({}, _super.prototype.getDefaultCfg.call(this), {
      type: "circle",
      showTitle: true,
      title: _super.prototype.getDefaultTitleCfg.call(this)
    });
  };
  Circle6.prototype.render = function() {
    _super.prototype.render.call(this);
    if (this.cfg.showTitle) {
      this.renderTitle();
    }
  };
  Circle6.prototype.getRegion = function(count, index) {
    var r = 1 / 2;
    var center = { x: 0.5, y: 0.5 };
    var avgAngle = Math.PI * 2 / count;
    var angle3 = -1 * Math.PI / 2 + avgAngle * index;
    var facetR = r / (1 + 1 / Math.sin(avgAngle / 2));
    var middle = getAnglePoint(center, r - facetR, angle3);
    var startAngle = Math.PI * 5 / 4;
    var endAngle = Math.PI * 1 / 4;
    return {
      start: getAnglePoint(middle, facetR, startAngle),
      end: getAnglePoint(middle, facetR, endAngle)
    };
  };
  Circle6.prototype.afterEachView = function(view, facet) {
    this.processAxis(view, facet);
  };
  Circle6.prototype.beforeEachView = function(view, facet) {
  };
  Circle6.prototype.generateFacets = function(data) {
    var _this = this;
    var _a3 = this.cfg, fields = _a3.fields, type = _a3.type;
    var _b = __read(fields, 1), field = _b[0];
    if (!field) {
      throw new Error("No `fields` specified!");
    }
    var values2 = this.getFieldValues(data, field);
    var count = values2.length;
    var rst = [];
    values2.forEach(function(value, index) {
      var conditions = [{ field, value, values: values2 }];
      var facetData = filter_default(data, _this.getFacetDataFilter(conditions));
      var facet = {
        type,
        data: facetData,
        region: _this.getRegion(count, index),
        columnValue: value,
        columnField: field,
        columnIndex: index,
        columnValuesLength: count,
        rowValue: null,
        rowField: null,
        rowIndex: 0,
        rowValuesLength: 1
      };
      rst.push(facet);
    });
    return rst;
  };
  Circle6.prototype.getXAxisOption = function(x, axes, option, facet) {
    return option;
  };
  Circle6.prototype.getYAxisOption = function(y, axes, option, facet) {
    return option;
  };
  Circle6.prototype.renderTitle = function() {
    var _this = this;
    each_default(this.facets, function(facet) {
      var columnValue = facet.columnValue, view = facet.view;
      var formatter = get_default(_this.cfg.title, "formatter");
      var config = deep_mix_default({
        position: ["50%", "0%"],
        content: formatter ? formatter(columnValue) : columnValue
      }, getFactTitleConfig(DIRECTION.TOP), _this.cfg.title);
      view.annotation().text(config);
    });
  };
  return Circle6;
}(Facet);
var circle_default7 = Circle5;

// node_modules/@antv/g2/esm/facet/list.js
var List = function(_super) {
  __extends(List2, _super);
  function List2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  List2.prototype.getDefaultCfg = function() {
    return deep_mix_default({}, _super.prototype.getDefaultCfg.call(this), {
      type: "list",
      cols: null,
      showTitle: true,
      title: _super.prototype.getDefaultTitleCfg.call(this)
    });
  };
  List2.prototype.render = function() {
    _super.prototype.render.call(this);
    if (this.cfg.showTitle) {
      this.renderTitle();
    }
  };
  List2.prototype.afterEachView = function(view, facet) {
    this.processAxis(view, facet);
  };
  List2.prototype.beforeEachView = function(view, facet) {
  };
  List2.prototype.generateFacets = function(data) {
    var _this = this;
    var fields = this.cfg.fields;
    var cols = this.cfg.cols;
    var _a3 = __read(fields, 1), columnField = _a3[0];
    if (!columnField) {
      throw new Error("No `fields` specified!");
    }
    var colValues = this.getFieldValues(data, columnField);
    var count = colValues.length;
    cols = cols || count;
    var rows = this.getPageCount(count, cols);
    var rst = [];
    colValues.forEach(function(val, index) {
      var _a4 = _this.getRowCol(index, cols), row = _a4.row, col = _a4.col;
      var conditions = [{ field: columnField, value: val, values: colValues }];
      var facetData = filter_default(data, _this.getFacetDataFilter(conditions));
      var facet = {
        type: _this.cfg.type,
        data: facetData,
        region: _this.getRegion(rows, cols, col, row),
        columnValue: val,
        rowValue: val,
        columnField,
        rowField: null,
        columnIndex: col,
        rowIndex: row,
        columnValuesLength: cols,
        rowValuesLength: rows,
        total: count
      };
      rst.push(facet);
    });
    return rst;
  };
  List2.prototype.getXAxisOption = function(x, axes, option, facet) {
    if (facet.rowIndex !== facet.rowValuesLength - 1 && facet.columnValuesLength * facet.rowIndex + facet.columnIndex + 1 + facet.columnValuesLength <= facet.total) {
      return __assign(__assign({}, option), { label: null, title: null });
    }
    return option;
  };
  List2.prototype.getYAxisOption = function(y, axes, option, facet) {
    if (facet.columnIndex !== 0) {
      return __assign(__assign({}, option), { title: null, label: null });
    }
    return option;
  };
  List2.prototype.renderTitle = function() {
    var _this = this;
    each_default(this.facets, function(facet) {
      var columnValue = facet.columnValue, view = facet.view;
      var formatter = get_default(_this.cfg.title, "formatter");
      var config = deep_mix_default({
        position: ["50%", "0%"],
        content: formatter ? formatter(columnValue) : columnValue
      }, getFactTitleConfig(DIRECTION.TOP), _this.cfg.title);
      view.annotation().text(config);
    });
  };
  List2.prototype.getPageCount = function(total, pageSize) {
    return Math.floor((total + pageSize - 1) / pageSize);
  };
  List2.prototype.getRowCol = function(index, pageSize) {
    var row = Math.floor(index / pageSize);
    var col = index % pageSize;
    return { row, col };
  };
  return List2;
}(Facet);
var list_default = List;

// node_modules/@antv/g2/esm/facet/matrix.js
var Matrix = function(_super) {
  __extends(Matrix2, _super);
  function Matrix2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Matrix2.prototype.getDefaultCfg = function() {
    return deep_mix_default({}, _super.prototype.getDefaultCfg.call(this), {
      type: "matrix",
      showTitle: false,
      columnTitle: __assign({}, _super.prototype.getDefaultTitleCfg.call(this)),
      rowTitle: __assign({}, _super.prototype.getDefaultTitleCfg.call(this))
    });
  };
  Matrix2.prototype.render = function() {
    _super.prototype.render.call(this);
    if (this.cfg.showTitle) {
      this.renderTitle();
    }
  };
  Matrix2.prototype.afterEachView = function(view, facet) {
    this.processAxis(view, facet);
  };
  Matrix2.prototype.beforeEachView = function(view, facet) {
  };
  Matrix2.prototype.generateFacets = function(data) {
    var _a3 = this.cfg, fields = _a3.fields, type = _a3.type;
    var rowValuesLength = fields.length;
    var columnValuesLength = rowValuesLength;
    var rst = [];
    for (var i = 0; i < columnValuesLength; i++) {
      var columnField = fields[i];
      for (var j = 0; j < rowValuesLength; j++) {
        var rowField = fields[j];
        var facet = {
          type,
          data,
          region: this.getRegion(rowValuesLength, columnValuesLength, i, j),
          columnValue: columnField,
          rowValue: rowField,
          columnField,
          rowField,
          columnIndex: i,
          rowIndex: j,
          columnValuesLength,
          rowValuesLength
        };
        rst.push(facet);
      }
    }
    return rst;
  };
  Matrix2.prototype.getXAxisOption = function(x, axes, option, facet) {
    if (facet.rowIndex !== facet.rowValuesLength - 1) {
      return __assign(__assign({}, option), { label: null, title: null });
    }
    return option;
  };
  Matrix2.prototype.getYAxisOption = function(y, axes, option, facet) {
    if (facet.columnIndex !== 0) {
      return __assign(__assign({}, option), { title: null, label: null });
    }
    return option;
  };
  Matrix2.prototype.renderTitle = function() {
    var _this = this;
    each_default(this.facets, function(facet, facetIndex) {
      var columnIndex = facet.columnIndex, rowIndex = facet.rowIndex, columnValuesLength = facet.columnValuesLength, rowValuesLength = facet.rowValuesLength, columnValue = facet.columnValue, rowValue = facet.rowValue, view = facet.view;
      if (rowIndex === 0) {
        var formatter = get_default(_this.cfg.columnTitle, "formatter");
        var config = deep_mix_default({
          position: ["50%", "0%"],
          content: formatter ? formatter(columnValue) : columnValue
        }, getFactTitleConfig(DIRECTION.TOP), _this.cfg.columnTitle);
        view.annotation().text(config);
      }
      if (columnIndex === columnValuesLength - 1) {
        var formatter = get_default(_this.cfg.rowTitle, "formatter");
        var config = deep_mix_default({
          position: ["100%", "50%"],
          content: formatter ? formatter(rowValue) : rowValue
        }, getFactTitleConfig(DIRECTION.RIGHT), _this.cfg.rowTitle);
        view.annotation().text(config);
      }
    });
  };
  return Matrix2;
}(Facet);
var matrix_default = Matrix;

// node_modules/@antv/g2/esm/facet/mirror.js
var Mirror = function(_super) {
  __extends(Mirror2, _super);
  function Mirror2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Mirror2.prototype.getDefaultCfg = function() {
    return deep_mix_default({}, _super.prototype.getDefaultCfg.call(this), {
      type: "mirror",
      showTitle: true,
      title: _super.prototype.getDefaultTitleCfg.call(this),
      transpose: false
    });
  };
  Mirror2.prototype.render = function() {
    _super.prototype.render.call(this);
    if (this.cfg.showTitle) {
      this.renderTitle();
    }
  };
  Mirror2.prototype.beforeEachView = function(view, facet) {
    if (this.cfg.transpose) {
      if (facet.columnIndex % 2 === 0) {
        view.coordinate().transpose().reflect("x");
      } else {
        view.coordinate().transpose();
      }
    } else {
      if (facet.rowIndex % 2 !== 0) {
        view.coordinate().reflect("y");
      }
    }
  };
  Mirror2.prototype.afterEachView = function(view, facet) {
    this.processAxis(view, facet);
  };
  Mirror2.prototype.generateFacets = function(data) {
    var _this = this;
    var _a3 = __read(this.cfg.fields, 1), f = _a3[0];
    var rst = [];
    var columnValuesLength = 1;
    var rowValuesLength = 1;
    var columnValues = [""];
    var rowValues = [""];
    var columnField;
    var rowField;
    if (this.cfg.transpose) {
      columnField = f;
      columnValues = this.getFieldValues(data, columnField).slice(0, 2);
      columnValuesLength = columnValues.length;
    } else {
      rowField = f;
      rowValues = this.getFieldValues(data, rowField).slice(0, 2);
      rowValuesLength = rowValues.length;
    }
    columnValues.forEach(function(xVal, xIndex) {
      rowValues.forEach(function(yVal, yIndex) {
        var conditions = [
          { field: columnField, value: xVal, values: columnValues },
          { field: rowField, value: yVal, values: rowValues }
        ];
        var facetData = filter_default(data, _this.getFacetDataFilter(conditions));
        var facet = {
          type: _this.cfg.type,
          data: facetData,
          region: _this.getRegion(rowValuesLength, columnValuesLength, xIndex, yIndex),
          columnValue: xVal,
          rowValue: yVal,
          columnField,
          rowField,
          columnIndex: xIndex,
          rowIndex: yIndex,
          columnValuesLength,
          rowValuesLength
        };
        rst.push(facet);
      });
    });
    return rst;
  };
  Mirror2.prototype.getXAxisOption = function(x, axes, option, facet) {
    if (facet.columnIndex === 1 || facet.rowIndex === 1) {
      return __assign(__assign({}, option), { label: null, title: null });
    }
    return option;
  };
  Mirror2.prototype.getYAxisOption = function(y, axes, option, facet) {
    return option;
  };
  Mirror2.prototype.renderTitle = function() {
    var _this = this;
    each_default(this.facets, function(facet, facetIndex) {
      var columnValue = facet.columnValue, rowValue = facet.rowValue, view = facet.view;
      var formatter = get_default(_this.cfg.title, "formatter");
      if (_this.cfg.transpose) {
        var config = deep_mix_default({
          position: ["50%", "0%"],
          content: formatter ? formatter(columnValue) : columnValue
        }, getFactTitleConfig(DIRECTION.TOP), _this.cfg.title);
        view.annotation().text(config);
      } else {
        var config = deep_mix_default({
          position: ["100%", "50%"],
          content: formatter ? formatter(rowValue) : rowValue
        }, getFactTitleConfig(DIRECTION.RIGHT), _this.cfg.title);
        view.annotation().text(config);
      }
    });
  };
  return Mirror2;
}(Facet);
var mirror_default = Mirror;

// node_modules/@antv/g2/esm/facet/rect.js
var Rect3 = function(_super) {
  __extends(Rect4, _super);
  function Rect4() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Rect4.prototype.afterEachView = function(view, facet) {
    this.processAxis(view, facet);
  };
  Rect4.prototype.beforeEachView = function(view, facet) {
  };
  Rect4.prototype.getDefaultCfg = function() {
    return deep_mix_default({}, _super.prototype.getDefaultCfg.call(this), {
      type: "rect",
      columnTitle: __assign({}, _super.prototype.getDefaultTitleCfg.call(this)),
      rowTitle: __assign({}, _super.prototype.getDefaultTitleCfg.call(this))
    });
  };
  Rect4.prototype.render = function() {
    _super.prototype.render.call(this);
    if (this.cfg.showTitle) {
      this.renderTitle();
    }
  };
  Rect4.prototype.generateFacets = function(data) {
    var _this = this;
    var _a3 = __read(this.cfg.fields, 2), columnField = _a3[0], rowField = _a3[1];
    var rst = [];
    var columnValuesLength = 1;
    var rowValuesLength = 1;
    var columnValues = [""];
    var rowValues = [""];
    if (columnField) {
      columnValues = this.getFieldValues(data, columnField);
      columnValuesLength = columnValues.length;
    }
    if (rowField) {
      rowValues = this.getFieldValues(data, rowField);
      rowValuesLength = rowValues.length;
    }
    columnValues.forEach(function(xVal, xIndex) {
      rowValues.forEach(function(yVal, yIndex) {
        var conditions = [
          { field: columnField, value: xVal, values: columnValues },
          { field: rowField, value: yVal, values: rowValues }
        ];
        var facetData = filter_default(data, _this.getFacetDataFilter(conditions));
        var facet = {
          type: _this.cfg.type,
          data: facetData,
          region: _this.getRegion(rowValuesLength, columnValuesLength, xIndex, yIndex),
          columnValue: xVal,
          rowValue: yVal,
          columnField,
          rowField,
          columnIndex: xIndex,
          rowIndex: yIndex,
          columnValuesLength,
          rowValuesLength
        };
        rst.push(facet);
      });
    });
    return rst;
  };
  Rect4.prototype.renderTitle = function() {
    var _this = this;
    each_default(this.facets, function(facet, facetIndex) {
      var columnIndex = facet.columnIndex, rowIndex = facet.rowIndex, columnValuesLength = facet.columnValuesLength, columnValue = facet.columnValue, rowValue = facet.rowValue, view = facet.view;
      if (rowIndex === 0) {
        var formatter = get_default(_this.cfg.columnTitle, "formatter");
        var config = deep_mix_default({
          position: ["50%", "0%"],
          content: formatter ? formatter(columnValue) : columnValue
        }, getFactTitleConfig(DIRECTION.TOP), _this.cfg.columnTitle);
        view.annotation().text(config);
      }
      if (columnIndex === columnValuesLength - 1) {
        var formatter = get_default(_this.cfg.rowTitle, "formatter");
        var config = deep_mix_default({
          position: ["100%", "50%"],
          content: formatter ? formatter(rowValue) : rowValue
        }, getFactTitleConfig(DIRECTION.RIGHT), _this.cfg.rowTitle);
        view.annotation().text(config);
      }
    });
  };
  Rect4.prototype.getXAxisOption = function(x, axes, option, facet) {
    if (facet.rowIndex !== facet.rowValuesLength - 1) {
      return __assign(__assign({}, option), { title: null, label: null });
    } else if (facet.columnIndex !== Math.floor((facet.columnValuesLength - 1) / 2)) {
      return __assign(__assign({}, option), { title: null });
    }
    return option;
  };
  Rect4.prototype.getYAxisOption = function(y, axes, option, facet) {
    if (facet.columnIndex !== 0) {
      return __assign(__assign({}, option), { title: null, label: null });
    } else if (facet.rowIndex !== Math.floor((facet.rowValuesLength - 1) / 2)) {
      return __assign(__assign({}, option), { title: null });
    }
    return option;
  };
  return Rect4;
}(Facet);
var rect_default4 = Rect3;

// node_modules/@antv/g2/esm/facet/tree.js
var Tree = function(_super) {
  __extends(Tree2, _super);
  function Tree2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.afterChartRender = function() {
      if (_this.facets && _this.cfg.line) {
        _this.container.clear();
        _this.drawLines(_this.facets);
      }
    };
    return _this;
  }
  Tree2.prototype.afterEachView = function(view, facet) {
    this.processAxis(view, facet);
  };
  Tree2.prototype.beforeEachView = function(view, facet) {
  };
  Tree2.prototype.init = function() {
    _super.prototype.init.call(this);
    this.view.on(VIEW_LIFE_CIRCLE.AFTER_RENDER, this.afterChartRender);
  };
  Tree2.prototype.getDefaultCfg = function() {
    return deep_mix_default({}, _super.prototype.getDefaultCfg.call(this), {
      type: "tree",
      line: {
        style: {
          lineWidth: 1,
          stroke: "#ddd"
        },
        smooth: false
      },
      showTitle: true,
      title: _super.prototype.getDefaultTitleCfg.call(this)
    });
  };
  Tree2.prototype.generateFacets = function(data) {
    var fields = this.cfg.fields;
    if (!fields.length) {
      throw new Error("Please specify for the fields for rootFacet!");
    }
    var rst = [];
    var rootFacet = {
      type: this.cfg.type,
      data,
      region: null,
      rowValuesLength: this.getRows(),
      columnValuesLength: 1,
      rowIndex: 0,
      columnIndex: 0,
      rowField: "",
      columnField: "",
      rowValue: "",
      columnValue: ""
    };
    rst.push(rootFacet);
    rootFacet.children = this.getChildFacets(data, 1, rst);
    this.setRegion(rst);
    return rst;
  };
  Tree2.prototype.setRegion = function(facets) {
    var _this = this;
    this.forceColIndex(facets);
    facets.forEach(function(facet) {
      facet.region = _this.getRegion(facet.rowValuesLength, facet.columnValuesLength, facet.columnIndex, facet.rowIndex);
    });
  };
  Tree2.prototype.getRegion = function(rows, cols, xIndex, yIndex) {
    var xWidth = 1 / cols;
    var yWidth = 1 / rows;
    var start = {
      x: xWidth * xIndex,
      y: yWidth * yIndex
    };
    var end = {
      x: start.x + xWidth,
      y: start.y + yWidth * 2 / 3
    };
    return {
      start,
      end
    };
  };
  Tree2.prototype.forceColIndex = function(facets) {
    var e_1, _a3;
    var _this = this;
    var leafs = [];
    var index = 0;
    facets.forEach(function(facet2) {
      if (_this.isLeaf(facet2)) {
        leafs.push(facet2);
        facet2.columnIndex = index;
        index++;
      }
    });
    leafs.forEach(function(facet2) {
      facet2.columnValuesLength = leafs.length;
    });
    var maxLevel = this.cfg.fields.length;
    for (var i = maxLevel - 1; i >= 0; i--) {
      var levelFacets = this.getFacetsByLevel(facets, i);
      try {
        for (var levelFacets_1 = (e_1 = void 0, __values(levelFacets)), levelFacets_1_1 = levelFacets_1.next(); !levelFacets_1_1.done; levelFacets_1_1 = levelFacets_1.next()) {
          var facet = levelFacets_1_1.value;
          if (!this.isLeaf(facet)) {
            facet.originColIndex = facet.columnIndex;
            facet.columnIndex = this.getRegionIndex(facet.children);
            facet.columnValuesLength = leafs.length;
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (levelFacets_1_1 && !levelFacets_1_1.done && (_a3 = levelFacets_1.return))
            _a3.call(levelFacets_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    }
  };
  Tree2.prototype.getFacetsByLevel = function(facets, level) {
    var rst = [];
    facets.forEach(function(facet) {
      if (facet.rowIndex === level) {
        rst.push(facet);
      }
    });
    return rst;
  };
  Tree2.prototype.getRegionIndex = function(children) {
    var first = children[0];
    var last2 = children[children.length - 1];
    return (last2.columnIndex - first.columnIndex) / 2 + first.columnIndex;
  };
  Tree2.prototype.isLeaf = function(facet) {
    return !facet.children || !facet.children.length;
  };
  Tree2.prototype.getRows = function() {
    return this.cfg.fields.length + 1;
  };
  Tree2.prototype.getChildFacets = function(data, level, arr) {
    var _this = this;
    var fields = this.cfg.fields;
    var length5 = fields.length;
    if (length5 < level) {
      return;
    }
    var rst = [];
    var field = fields[level - 1];
    var values2 = this.getFieldValues(data, field);
    values2.forEach(function(value, index) {
      var conditions = [{ field, value, values: values2 }];
      var subData = data.filter(_this.getFacetDataFilter(conditions));
      if (subData.length) {
        var facet = {
          type: _this.cfg.type,
          data: subData,
          region: null,
          columnValue: value,
          rowValue: "",
          columnField: field,
          rowField: "",
          columnIndex: index,
          rowValuesLength: _this.getRows(),
          columnValuesLength: 1,
          rowIndex: level,
          children: _this.getChildFacets(subData, level + 1, arr)
        };
        rst.push(facet);
        arr.push(facet);
      }
    });
    return rst;
  };
  Tree2.prototype.render = function() {
    _super.prototype.render.call(this);
    if (this.cfg.showTitle) {
      this.renderTitle();
    }
  };
  Tree2.prototype.renderTitle = function() {
    var _this = this;
    each_default(this.facets, function(facet) {
      var columnValue = facet.columnValue, view = facet.view;
      var formatter = get_default(_this.cfg.title, "formatter");
      var config = deep_mix_default({
        position: ["50%", "0%"],
        content: formatter ? formatter(columnValue) : columnValue
      }, getFactTitleConfig(DIRECTION.TOP), _this.cfg.title);
      view.annotation().text(config);
    });
  };
  Tree2.prototype.drawLines = function(facets) {
    var _this = this;
    facets.forEach(function(facet) {
      if (!_this.isLeaf(facet)) {
        var children = facet.children;
        _this.addFacetLines(facet, children);
      }
    });
  };
  Tree2.prototype.addFacetLines = function(facet, children) {
    var _this = this;
    var view = facet.view;
    var region = view.coordinateBBox;
    var start = {
      x: region.x + region.width / 2,
      y: region.y + region.height
    };
    children.forEach(function(subFacet) {
      var subRegion = subFacet.view.coordinateBBox;
      var end = {
        x: subRegion.bl.x + (subRegion.tr.x - subRegion.bl.x) / 2,
        y: subRegion.tr.y
      };
      var middle1 = {
        x: start.x,
        y: start.y + (end.y - start.y) / 2
      };
      var middle2 = {
        x: end.x,
        y: middle1.y
      };
      _this.drawLine([start, middle1, middle2, end]);
    });
  };
  Tree2.prototype.getPath = function(points) {
    var path = [];
    var smooth = this.cfg.line.smooth;
    if (smooth) {
      path.push(["M", points[0].x, points[0].y]);
      path.push(["C", points[1].x, points[1].y, points[2].x, points[2].y, points[3].x, points[3].y]);
    } else {
      points.forEach(function(point, index) {
        if (index === 0) {
          path.push(["M", point.x, point.y]);
        } else {
          path.push(["L", point.x, point.y]);
        }
      });
    }
    return path;
  };
  Tree2.prototype.drawLine = function(points) {
    var path = this.getPath(points);
    var line = this.cfg.line.style;
    this.container.addShape("path", {
      attrs: mix({
        path
      }, line)
    });
  };
  Tree2.prototype.getXAxisOption = function(x, axes, option, facet) {
    if (facet.rowIndex !== facet.rowValuesLength - 1) {
      return __assign(__assign({}, option), { title: null, label: null });
    }
    return option;
  };
  Tree2.prototype.getYAxisOption = function(y, axes, option, facet) {
    if (facet.originColIndex !== 0 && facet.columnIndex !== 0) {
      return __assign(__assign({}, option), { title: null, label: null });
    }
    return option;
  };
  return Tree2;
}(Facet);
var tree_default = Tree;

// node_modules/@antv/g2/esm/util/stat.js
function getMedian(array) {
  var arr = __spreadArray([], __read(array), false);
  arr.sort(function(a, b) {
    return a - b;
  });
  var len3 = arr.length;
  if (len3 === 0) {
    return 0;
  }
  if (len3 % 2 === 1) {
    return arr[(len3 - 1) / 2];
  }
  return (arr[len3 / 2] + arr[len3 / 2 - 1]) / 2;
}
function getMean(array) {
  var sum = reduce_default(array, function(r, num) {
    return r += isNaN(num) || !is_number_default(num) ? 0 : num;
  }, 0);
  return array.length === 0 ? 0 : sum / array.length;
}

// node_modules/@antv/g2/esm/util/annotation.js
function getNormalizedValue(val, scale5) {
  if (!scale5) {
    return null;
  }
  var scaled;
  switch (val) {
    case "start":
      return 0;
    case "center":
      return 0.5;
    case "end":
      return 1;
    case "median": {
      scaled = scale5.isCategory ? getMedian(scale5.values.map(function(_, idx) {
        return idx;
      })) : getMedian(scale5.values);
      break;
    }
    case "mean": {
      scaled = scale5.isCategory ? (scale5.values.length - 1) / 2 : getMean(scale5.values);
      break;
    }
    case "min":
      scaled = scale5.isCategory ? 0 : scale5[val];
      break;
    case "max":
      scaled = scale5.isCategory ? scale5.values.length - 1 : scale5[val];
      break;
    default:
      scaled = val;
      break;
  }
  return scale5.scale(scaled);
}

// node_modules/@antv/g2/esm/chart/controller/annotation.js
var ANNOTATIONS_AFTER_RENDER = ["regionFilter", "shape"];
var Annotation = function(_super) {
  __extends(Annotation2, _super);
  function Annotation2(view) {
    var _this = _super.call(this, view) || this;
    _this.cache = /* @__PURE__ */ new Map();
    _this.foregroundContainer = _this.view.getLayer(LAYER.FORE).addGroup();
    _this.backgroundContainer = _this.view.getLayer(LAYER.BG).addGroup();
    _this.option = [];
    return _this;
  }
  Object.defineProperty(Annotation2.prototype, "name", {
    get: function() {
      return "annotation";
    },
    enumerable: false,
    configurable: true
  });
  Annotation2.prototype.init = function() {
  };
  Annotation2.prototype.layout = function() {
    this.update();
  };
  Annotation2.prototype.render = function() {
  };
  Annotation2.prototype.update = function() {
    var _this = this;
    this.onAfterRender(function() {
      var updated = /* @__PURE__ */ new Map();
      each_default(_this.option, function(option) {
        if (contains_default(ANNOTATIONS_AFTER_RENDER, option.type)) {
          var co = _this.updateOrCreate(option);
          if (co) {
            updated.set(_this.getCacheKey(option), co);
          }
        }
      });
      _this.cache = _this.syncCache(updated);
    });
    var updateCache = /* @__PURE__ */ new Map();
    each_default(this.option, function(option) {
      if (!contains_default(ANNOTATIONS_AFTER_RENDER, option.type)) {
        var co = _this.updateOrCreate(option);
        if (co) {
          updateCache.set(_this.getCacheKey(option), co);
        }
      }
    });
    this.cache = this.syncCache(updateCache);
  };
  Annotation2.prototype.clear = function(includeOption) {
    if (includeOption === void 0) {
      includeOption = false;
    }
    _super.prototype.clear.call(this);
    this.clearComponents();
    this.foregroundContainer.clear();
    this.backgroundContainer.clear();
    if (includeOption) {
      this.option = [];
    }
  };
  Annotation2.prototype.destroy = function() {
    this.clear(true);
    this.foregroundContainer.remove(true);
    this.backgroundContainer.remove(true);
  };
  Annotation2.prototype.getComponents = function() {
    var co = [];
    this.cache.forEach(function(value) {
      co.push(value);
    });
    return co;
  };
  Annotation2.prototype.clearComponents = function() {
    this.getComponents().forEach(function(co) {
      co.component.destroy();
    });
    this.cache.clear();
  };
  Annotation2.prototype.onAfterRender = function(doWhat) {
    var done = false;
    if (this.view.getOptions().animate) {
      this.view.geometries.forEach(function(g) {
        if (g.animateOption) {
          g.once(GEOMETRY_LIFE_CIRCLE.AFTER_DRAW_ANIMATE, function() {
            doWhat();
          });
          done = true;
        }
      });
    }
    if (!done) {
      this.view.getRootView().once(VIEW_LIFE_CIRCLE.AFTER_RENDER, function() {
        doWhat();
      });
    }
  };
  Annotation2.prototype.createAnnotation = function(option) {
    var type = option.type;
    var Ctor = annotation_exports[upper_first_default(type)];
    if (Ctor) {
      var theme = this.getAnnotationTheme(type);
      var cfg = this.getAnnotationCfg(type, option, theme);
      if (!cfg) {
        return null;
      }
      var annotation = new Ctor(cfg);
      return {
        component: annotation,
        layer: this.isTop(cfg) ? LAYER.FORE : LAYER.BG,
        direction: DIRECTION.NONE,
        type: COMPONENT_TYPE.ANNOTATION,
        extra: option
      };
    }
  };
  Annotation2.prototype.annotation = function(option) {
    this.option.push(option);
  };
  Annotation2.prototype.arc = function(option) {
    this.annotation(__assign({ type: "arc" }, option));
    return this;
  };
  Annotation2.prototype.image = function(option) {
    this.annotation(__assign({ type: "image" }, option));
    return this;
  };
  Annotation2.prototype.line = function(option) {
    this.annotation(__assign({ type: "line" }, option));
    return this;
  };
  Annotation2.prototype.region = function(option) {
    this.annotation(__assign({ type: "region" }, option));
    return this;
  };
  Annotation2.prototype.text = function(option) {
    this.annotation(__assign({ type: "text" }, option));
    return this;
  };
  Annotation2.prototype.dataMarker = function(option) {
    this.annotation(__assign({ type: "dataMarker" }, option));
    return this;
  };
  Annotation2.prototype.dataRegion = function(option) {
    this.annotation(__assign({ type: "dataRegion" }, option));
  };
  Annotation2.prototype.regionFilter = function(option) {
    this.annotation(__assign({ type: "regionFilter" }, option));
  };
  Annotation2.prototype.shape = function(option) {
    this.annotation(__assign({ type: "shape" }, option));
  };
  Annotation2.prototype.html = function(option) {
    this.annotation(__assign({ type: "html" }, option));
  };
  Annotation2.prototype.parsePosition = function(p) {
    var e_1, _a3;
    var xScale = this.view.getXScale();
    var yScales = this.view.getScalesByDim("y");
    var position = is_function_default(p) ? p.call(null, xScale, yScales) : p;
    var x = 0;
    var y = 0;
    if (is_array_default(position)) {
      var _b = __read(position, 2), xPos = _b[0], yPos = _b[1];
      if (is_string_default(xPos) && xPos.indexOf("%") !== -1 && !isNaN(xPos.slice(0, -1))) {
        return this.parsePercentPosition(position);
      }
      x = getNormalizedValue(xPos, xScale);
      y = getNormalizedValue(yPos, Object.values(yScales)[0]);
    } else if (!is_nil_default(position)) {
      try {
        for (var _c = __values(keys_default(position)), _d = _c.next(); !_d.done; _d = _c.next()) {
          var key = _d.value;
          var value = position[key];
          if (key === xScale.field) {
            x = getNormalizedValue(value, xScale);
          }
          if (yScales[key]) {
            y = getNormalizedValue(value, yScales[key]);
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_d && !_d.done && (_a3 = _c.return))
            _a3.call(_c);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    }
    if (isNaN(x) || isNaN(y)) {
      return null;
    }
    return this.view.getCoordinate().convert({ x, y });
  };
  Annotation2.prototype.getRegionPoints = function(start, end) {
    var _this = this;
    var xScale = this.view.getXScale();
    var yScales = this.view.getScalesByDim("y");
    var yScale = Object.values(yScales)[0];
    var xField = xScale.field;
    var viewData = this.view.getData();
    var startXValue = is_array_default(start) ? start[0] : start[xField];
    var endXValue = is_array_default(end) ? end[0] : end[xField];
    var arr = [];
    var startIndex;
    each_default(viewData, function(item, idx) {
      if (item[xField] === startXValue) {
        startIndex = idx;
      }
      if (idx >= startIndex) {
        var point = _this.parsePosition([item[xField], item[yScale.field]]);
        if (point) {
          arr.push(point);
        }
      }
      if (item[xField] === endXValue) {
        return false;
      }
    });
    return arr;
  };
  Annotation2.prototype.parsePercentPosition = function(position) {
    var xPercent = parseFloat(position[0]) / 100;
    var yPercent = parseFloat(position[1]) / 100;
    var coordinate = this.view.getCoordinate();
    var start = coordinate.start, end = coordinate.end;
    var topLeft = {
      x: Math.min(start.x, end.x),
      y: Math.min(start.y, end.y)
    };
    var x = coordinate.getWidth() * xPercent + topLeft.x;
    var y = coordinate.getHeight() * yPercent + topLeft.y;
    return { x, y };
  };
  Annotation2.prototype.getCoordinateBBox = function() {
    var coordinate = this.view.getCoordinate();
    var start = coordinate.start, end = coordinate.end;
    var width = coordinate.getWidth();
    var height = coordinate.getHeight();
    var topLeft = {
      x: Math.min(start.x, end.x),
      y: Math.min(start.y, end.y)
    };
    return {
      x: topLeft.x,
      y: topLeft.y,
      minX: topLeft.x,
      minY: topLeft.y,
      maxX: topLeft.x + width,
      maxY: topLeft.y + height,
      width,
      height
    };
  };
  Annotation2.prototype.getAnnotationCfg = function(type, option, theme) {
    var _this = this;
    var coordinate = this.view.getCoordinate();
    var canvas = this.view.getCanvas();
    var o = {};
    if (is_nil_default(option)) {
      return null;
    }
    var start = option.start, end = option.end, position = option.position;
    var sp = this.parsePosition(start);
    var ep = this.parsePosition(end);
    var textPoint = this.parsePosition(position);
    if (["arc", "image", "line", "region", "regionFilter"].includes(type) && (!sp || !ep)) {
      return null;
    } else if (["text", "dataMarker", "html"].includes(type) && !textPoint) {
      return null;
    }
    if (type === "arc") {
      var _a3 = option, start_1 = _a3.start, end_1 = _a3.end, rest = __rest(_a3, ["start", "end"]);
      var startAngle = getAngleByPoint(coordinate, sp);
      var endAngle = getAngleByPoint(coordinate, ep);
      if (startAngle > endAngle) {
        endAngle = Math.PI * 2 + endAngle;
      }
      o = __assign(__assign({}, rest), { center: coordinate.getCenter(), radius: getDistanceToCenter(coordinate, sp), startAngle, endAngle });
    } else if (type === "image") {
      var _b = option, start_2 = _b.start, end_2 = _b.end, rest = __rest(_b, ["start", "end"]);
      o = __assign(__assign({}, rest), { start: sp, end: ep, src: option.src });
    } else if (type === "line") {
      var _c = option, start_3 = _c.start, end_3 = _c.end, rest = __rest(_c, ["start", "end"]);
      o = __assign(__assign({}, rest), { start: sp, end: ep, text: get_default(option, "text", null) });
    } else if (type === "region") {
      var _d = option, start_4 = _d.start, end_4 = _d.end, rest = __rest(_d, ["start", "end"]);
      o = __assign(__assign({}, rest), { start: sp, end: ep });
    } else if (type === "text") {
      var filteredData = this.view.getData();
      var _e = option, position_1 = _e.position, content = _e.content, rest = __rest(_e, ["position", "content"]);
      var textContent = content;
      if (is_function_default(content)) {
        textContent = content(filteredData);
      }
      o = __assign(__assign(__assign({}, textPoint), rest), { content: textContent });
    } else if (type === "dataMarker") {
      var _f = option, position_2 = _f.position, point = _f.point, line = _f.line, text = _f.text, autoAdjust = _f.autoAdjust, direction2 = _f.direction, rest = __rest(_f, ["position", "point", "line", "text", "autoAdjust", "direction"]);
      o = __assign(__assign(__assign({}, rest), textPoint), { coordinateBBox: this.getCoordinateBBox(), point, line, text, autoAdjust, direction: direction2 });
    } else if (type === "dataRegion") {
      var _g = option, start_5 = _g.start, end_5 = _g.end, region = _g.region, text = _g.text, lineLength = _g.lineLength, rest = __rest(_g, ["start", "end", "region", "text", "lineLength"]);
      o = __assign(__assign({}, rest), { points: this.getRegionPoints(start_5, end_5), region, text, lineLength });
    } else if (type === "regionFilter") {
      var _h = option, start_6 = _h.start, end_6 = _h.end, apply_1 = _h.apply, color2 = _h.color, rest = __rest(_h, ["start", "end", "apply", "color"]);
      var geometries = this.view.geometries;
      var shapes_1 = [];
      var addShapes_1 = function(item) {
        if (!item) {
          return;
        }
        if (item.isGroup()) {
          item.getChildren().forEach(function(child) {
            return addShapes_1(child);
          });
        } else {
          shapes_1.push(item);
        }
      };
      each_default(geometries, function(geom) {
        if (apply_1) {
          if (contains_default(apply_1, geom.type)) {
            each_default(geom.elements, function(elem) {
              addShapes_1(elem.shape);
            });
          }
        } else {
          each_default(geom.elements, function(elem) {
            addShapes_1(elem.shape);
          });
        }
      });
      o = __assign(__assign({}, rest), { color: color2, shapes: shapes_1, start: sp, end: ep });
    } else if (type === "shape") {
      var _j = option, render_1 = _j.render, restOptions = __rest(_j, ["render"]);
      var wrappedRender = function(container) {
        if (is_function_default(option.render)) {
          return render_1(container, _this.view, { parsePosition: _this.parsePosition.bind(_this) });
        }
      };
      o = __assign(__assign({}, restOptions), { render: wrappedRender });
    } else if (type === "html") {
      var _k = option, html_1 = _k.html, position_3 = _k.position, restOptions = __rest(_k, ["html", "position"]);
      var wrappedHtml = function(container) {
        if (is_function_default(html_1)) {
          return html_1(container, _this.view);
        }
        return html_1;
      };
      o = __assign(__assign(__assign({}, restOptions), textPoint), {
        parent: canvas.get("el").parentNode,
        html: wrappedHtml
      });
    }
    var cfg = deep_mix_default({}, theme, __assign(__assign({}, o), { top: option.top, style: option.style, offsetX: option.offsetX, offsetY: option.offsetY }));
    if (type !== "html") {
      cfg.container = this.getComponentContainer(cfg);
    }
    cfg.animate = this.view.getOptions().animate && cfg.animate && get_default(option, "animate", cfg.animate);
    cfg.animateOption = deep_mix_default({}, DEFAULT_ANIMATE_CFG, cfg.animateOption, option.animateOption);
    return cfg;
  };
  Annotation2.prototype.isTop = function(option) {
    return get_default(option, "top", true);
  };
  Annotation2.prototype.getComponentContainer = function(option) {
    return this.isTop(option) ? this.foregroundContainer : this.backgroundContainer;
  };
  Annotation2.prototype.getAnnotationTheme = function(type) {
    return get_default(this.view.getTheme(), ["components", "annotation", type], {});
  };
  Annotation2.prototype.updateOrCreate = function(option) {
    var co = this.cache.get(this.getCacheKey(option));
    if (co) {
      var type = option.type;
      var theme = this.getAnnotationTheme(type);
      var cfg = this.getAnnotationCfg(type, option, theme);
      if (cfg) {
        omit(cfg, ["container"]);
      }
      co.component.update(__assign(__assign({}, cfg || {}), { visible: !!cfg }));
      if (contains_default(ANNOTATIONS_AFTER_RENDER, option.type)) {
        co.component.render();
      }
    } else {
      co = this.createAnnotation(option);
      if (co) {
        co.component.init();
        if (contains_default(ANNOTATIONS_AFTER_RENDER, option.type)) {
          co.component.render();
        }
      }
    }
    return co;
  };
  Annotation2.prototype.syncCache = function(updated) {
    var _this = this;
    var newCache = new Map(this.cache);
    updated.forEach(function(co, key) {
      newCache.set(key, co);
    });
    newCache.forEach(function(co, key) {
      if (!find_default(_this.option, function(option) {
        return key === _this.getCacheKey(option);
      })) {
        co.component.destroy();
        newCache.delete(key);
      }
    });
    return newCache;
  };
  Annotation2.prototype.getCacheKey = function(option) {
    return option;
  };
  return Annotation2;
}(Controller);
var annotation_default = Annotation;

// node_modules/@antv/g2/esm/util/grid.js
function getGridThemeCfg(theme, direction2) {
  var axisTheme = deep_mix_default({}, get_default(theme, ["components", "axis", "common"]), get_default(theme, ["components", "axis", direction2]));
  return get_default(axisTheme, ["grid"], {});
}
function getLineGridItems(coordinate, scale5, dim, alignTick) {
  var items = [];
  var ticks = scale5.getTicks();
  if (coordinate.isPolar) {
    ticks.push({
      value: 1,
      text: "",
      tickValue: ""
    });
  }
  ticks.reduce(function(preTick, currentTick, currentIndex) {
    var currentValue = currentTick.value;
    if (alignTick) {
      items.push({
        points: [
          coordinate.convert(dim === "y" ? { x: 0, y: currentValue } : { x: currentValue, y: 0 }),
          coordinate.convert(dim === "y" ? { x: 1, y: currentValue } : { x: currentValue, y: 1 })
        ]
      });
    } else {
      if (currentIndex) {
        var preValue = preTick.value;
        var middleValue = (preValue + currentValue) / 2;
        items.push({
          points: [
            coordinate.convert(dim === "y" ? { x: 0, y: middleValue } : { x: middleValue, y: 0 }),
            coordinate.convert(dim === "y" ? { x: 1, y: middleValue } : { x: middleValue, y: 1 })
          ]
        });
      }
    }
    return currentTick;
  }, ticks[0]);
  return items;
}
function getCircleGridItems(coordinate, xScale, yScale, alignTick, dim) {
  var count = xScale.values.length;
  var items = [];
  var ticks = yScale.getTicks();
  ticks.reduce(function(preTick, currentTick) {
    var preValue = preTick ? preTick.value : currentTick.value;
    var currentValue = currentTick.value;
    var middleValue = (preValue + currentValue) / 2;
    if (dim === "x") {
      items.push({
        points: [
          coordinate.convert({
            x: alignTick ? currentValue : middleValue,
            y: 0
          }),
          coordinate.convert({
            x: alignTick ? currentValue : middleValue,
            y: 1
          })
        ]
      });
    } else {
      items.push({
        points: map_default(Array(count + 1), function(__, idx) {
          return coordinate.convert({
            x: idx / count,
            y: alignTick ? currentValue : middleValue
          });
        })
      });
    }
    return currentTick;
  }, ticks[0]);
  return items;
}
function showGrid(axisTheme, axisOption) {
  var userGrid = get_default(axisOption, "grid");
  if (userGrid === null) {
    return false;
  }
  var themeGrid = get_default(axisTheme, "grid");
  return !(userGrid === void 0 && themeGrid === null);
}

// node_modules/@antv/g2/esm/chart/controller/axis.js
var OMIT_CFG = ["container"];
var AXIS_DEFAULT_ANIMATE_CFG = __assign(__assign({}, DEFAULT_ANIMATE_CFG), { appear: null });
var Axis = function(_super) {
  __extends(Axis2, _super);
  function Axis2(view) {
    var _this = _super.call(this, view) || this;
    _this.cache = /* @__PURE__ */ new Map();
    _this.gridContainer = _this.view.getLayer(LAYER.BG).addGroup();
    _this.gridForeContainer = _this.view.getLayer(LAYER.FORE).addGroup();
    _this.axisContainer = _this.view.getLayer(LAYER.BG).addGroup();
    _this.axisForeContainer = _this.view.getLayer(LAYER.FORE).addGroup();
    return _this;
  }
  Object.defineProperty(Axis2.prototype, "name", {
    get: function() {
      return "axis";
    },
    enumerable: false,
    configurable: true
  });
  Axis2.prototype.init = function() {
  };
  Axis2.prototype.render = function() {
    this.update();
  };
  Axis2.prototype.layout = function() {
    var _this = this;
    var coordinate = this.view.getCoordinate();
    each_default(this.getComponents(), function(co) {
      var component = co.component, direction2 = co.direction, type = co.type, extra = co.extra;
      var dim = extra.dim, scale5 = extra.scale, alignTick = extra.alignTick;
      var updated;
      if (type === COMPONENT_TYPE.AXIS) {
        if (coordinate.isPolar) {
          if (dim === "x") {
            updated = coordinate.isTransposed ? getAxisRegion(coordinate, direction2) : getCircleAxisCenterRadius(coordinate);
          } else if (dim === "y") {
            updated = coordinate.isTransposed ? getCircleAxisCenterRadius(coordinate) : getAxisRegion(coordinate, direction2);
          }
        } else {
          updated = getAxisRegion(coordinate, direction2);
        }
      } else if (type === COMPONENT_TYPE.GRID) {
        if (coordinate.isPolar) {
          var items = void 0;
          if (coordinate.isTransposed) {
            items = dim === "x" ? getCircleGridItems(coordinate, _this.view.getYScales()[0], scale5, alignTick, dim) : getLineGridItems(coordinate, scale5, dim, alignTick);
          } else {
            items = dim === "x" ? getLineGridItems(coordinate, scale5, dim, alignTick) : getCircleGridItems(coordinate, _this.view.getXScale(), scale5, alignTick, dim);
          }
          updated = {
            items,
            center: _this.view.getCoordinate().getCenter()
          };
        } else {
          updated = { items: getLineGridItems(coordinate, scale5, dim, alignTick) };
        }
      }
      component.update(updated);
    });
  };
  Axis2.prototype.update = function() {
    this.option = this.view.getOptions().axes;
    var updatedCache = /* @__PURE__ */ new Map();
    this.updateXAxes(updatedCache);
    this.updateYAxes(updatedCache);
    var newCache = /* @__PURE__ */ new Map();
    this.cache.forEach(function(co, key) {
      if (updatedCache.has(key)) {
        newCache.set(key, co);
      } else {
        co.component.destroy();
      }
    });
    this.cache = newCache;
  };
  Axis2.prototype.clear = function() {
    _super.prototype.clear.call(this);
    this.cache.clear();
    this.gridContainer.clear();
    this.gridForeContainer.clear();
    this.axisContainer.clear();
    this.axisForeContainer.clear();
  };
  Axis2.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    this.gridContainer.remove(true);
    this.gridForeContainer.remove(true);
    this.axisContainer.remove(true);
    this.axisForeContainer.remove(true);
  };
  Axis2.prototype.getComponents = function() {
    var co = [];
    this.cache.forEach(function(value) {
      co.push(value);
    });
    return co;
  };
  Axis2.prototype.updateXAxes = function(updatedCache) {
    var scale5 = this.view.getXScale();
    if (!scale5 || scale5.isIdentity) {
      return;
    }
    var xAxisOption = getAxisOption(this.option, scale5.field);
    if (xAxisOption === false) {
      return;
    }
    var direction2 = getAxisDirection(xAxisOption, DIRECTION.BOTTOM);
    var layer = LAYER.BG;
    var dim = "x";
    var coordinate = this.view.getCoordinate();
    var axisId = this.getId("axis", scale5.field);
    var gridId = this.getId("grid", scale5.field);
    if (coordinate.isRect) {
      var axis = this.cache.get(axisId);
      if (axis) {
        var cfg = this.getLineAxisCfg(scale5, xAxisOption, direction2);
        omit(cfg, OMIT_CFG);
        axis.component.update(cfg);
        updatedCache.set(axisId, axis);
      } else {
        axis = this.createLineAxis(scale5, xAxisOption, layer, direction2, dim);
        this.cache.set(axisId, axis);
        updatedCache.set(axisId, axis);
      }
      var grid = this.cache.get(gridId);
      if (grid) {
        var cfg = this.getLineGridCfg(scale5, xAxisOption, direction2, dim);
        omit(cfg, OMIT_CFG);
        grid.component.update(cfg);
        updatedCache.set(gridId, grid);
      } else {
        grid = this.createLineGrid(scale5, xAxisOption, layer, direction2, dim);
        if (grid) {
          this.cache.set(gridId, grid);
          updatedCache.set(gridId, grid);
        }
      }
    } else if (coordinate.isPolar) {
      var axis = this.cache.get(axisId);
      if (axis) {
        var cfg = coordinate.isTransposed ? this.getLineAxisCfg(scale5, xAxisOption, DIRECTION.RADIUS) : this.getCircleAxisCfg(scale5, xAxisOption, direction2);
        omit(cfg, OMIT_CFG);
        axis.component.update(cfg);
        updatedCache.set(axisId, axis);
      } else {
        if (coordinate.isTransposed) {
          if (is_undefined_default(xAxisOption)) {
            return;
          } else {
            axis = this.createLineAxis(scale5, xAxisOption, layer, DIRECTION.RADIUS, dim);
          }
        } else {
          axis = this.createCircleAxis(scale5, xAxisOption, layer, direction2, dim);
        }
        this.cache.set(axisId, axis);
        updatedCache.set(axisId, axis);
      }
      var grid = this.cache.get(gridId);
      if (grid) {
        var cfg = coordinate.isTransposed ? this.getCircleGridCfg(scale5, xAxisOption, DIRECTION.RADIUS, dim) : this.getLineGridCfg(scale5, xAxisOption, DIRECTION.CIRCLE, dim);
        omit(cfg, OMIT_CFG);
        grid.component.update(cfg);
        updatedCache.set(gridId, grid);
      } else {
        if (coordinate.isTransposed) {
          if (is_undefined_default(xAxisOption)) {
            return;
          } else {
            grid = this.createCircleGrid(scale5, xAxisOption, layer, DIRECTION.RADIUS, dim);
          }
        } else {
          grid = this.createLineGrid(scale5, xAxisOption, layer, DIRECTION.CIRCLE, dim);
        }
        if (grid) {
          this.cache.set(gridId, grid);
          updatedCache.set(gridId, grid);
        }
      }
    } else {
    }
  };
  Axis2.prototype.updateYAxes = function(updatedCache) {
    var _this = this;
    var yScales = this.view.getYScales();
    each_default(yScales, function(scale5, idx) {
      if (!scale5 || scale5.isIdentity) {
        return;
      }
      var field = scale5.field;
      var yAxisOption = getAxisOption(_this.option, field);
      if (yAxisOption !== false) {
        var layer = LAYER.BG;
        var dim = "y";
        var axisId = _this.getId("axis", field);
        var gridId = _this.getId("grid", field);
        var coordinate = _this.view.getCoordinate();
        if (coordinate.isRect) {
          var direction2 = getAxisDirection(yAxisOption, idx === 0 ? DIRECTION.LEFT : DIRECTION.RIGHT);
          var axis = _this.cache.get(axisId);
          if (axis) {
            var cfg = _this.getLineAxisCfg(scale5, yAxisOption, direction2);
            omit(cfg, OMIT_CFG);
            axis.component.update(cfg);
            updatedCache.set(axisId, axis);
          } else {
            axis = _this.createLineAxis(scale5, yAxisOption, layer, direction2, dim);
            _this.cache.set(axisId, axis);
            updatedCache.set(axisId, axis);
          }
          var grid = _this.cache.get(gridId);
          if (grid) {
            var cfg = _this.getLineGridCfg(scale5, yAxisOption, direction2, dim);
            omit(cfg, OMIT_CFG);
            grid.component.update(cfg);
            updatedCache.set(gridId, grid);
          } else {
            grid = _this.createLineGrid(scale5, yAxisOption, layer, direction2, dim);
            if (grid) {
              _this.cache.set(gridId, grid);
              updatedCache.set(gridId, grid);
            }
          }
        } else if (coordinate.isPolar) {
          var axis = _this.cache.get(axisId);
          if (axis) {
            var cfg = coordinate.isTransposed ? _this.getCircleAxisCfg(scale5, yAxisOption, DIRECTION.CIRCLE) : _this.getLineAxisCfg(scale5, yAxisOption, DIRECTION.RADIUS);
            omit(cfg, OMIT_CFG);
            axis.component.update(cfg);
            updatedCache.set(axisId, axis);
          } else {
            if (coordinate.isTransposed) {
              if (is_undefined_default(yAxisOption)) {
                return;
              } else {
                axis = _this.createCircleAxis(scale5, yAxisOption, layer, DIRECTION.CIRCLE, dim);
              }
            } else {
              axis = _this.createLineAxis(scale5, yAxisOption, layer, DIRECTION.RADIUS, dim);
            }
            _this.cache.set(axisId, axis);
            updatedCache.set(axisId, axis);
          }
          var grid = _this.cache.get(gridId);
          if (grid) {
            var cfg = coordinate.isTransposed ? _this.getLineGridCfg(scale5, yAxisOption, DIRECTION.CIRCLE, dim) : _this.getCircleGridCfg(scale5, yAxisOption, DIRECTION.RADIUS, dim);
            omit(cfg, OMIT_CFG);
            grid.component.update(cfg);
            updatedCache.set(gridId, grid);
          } else {
            if (coordinate.isTransposed) {
              if (is_undefined_default(yAxisOption)) {
                return;
              } else {
                grid = _this.createLineGrid(scale5, yAxisOption, layer, DIRECTION.CIRCLE, dim);
              }
            } else {
              grid = _this.createCircleGrid(scale5, yAxisOption, layer, DIRECTION.RADIUS, dim);
            }
            if (grid) {
              _this.cache.set(gridId, grid);
              updatedCache.set(gridId, grid);
            }
          }
        } else {
        }
      }
    });
  };
  Axis2.prototype.createLineAxis = function(scale5, option, layer, direction2, dim) {
    var axis = {
      component: new LineAxis(this.getLineAxisCfg(scale5, option, direction2)),
      layer,
      direction: direction2 === DIRECTION.RADIUS ? DIRECTION.NONE : direction2,
      type: COMPONENT_TYPE.AXIS,
      extra: { dim, scale: scale5 }
    };
    axis.component.set("field", scale5.field);
    axis.component.init();
    return axis;
  };
  Axis2.prototype.createLineGrid = function(scale5, option, layer, direction2, dim) {
    var cfg = this.getLineGridCfg(scale5, option, direction2, dim);
    if (cfg) {
      var grid = {
        component: new LineGrid(cfg),
        layer,
        direction: DIRECTION.NONE,
        type: COMPONENT_TYPE.GRID,
        extra: {
          dim,
          scale: scale5,
          alignTick: get_default(cfg, "alignTick", true)
        }
      };
      grid.component.init();
      return grid;
    }
  };
  Axis2.prototype.createCircleAxis = function(scale5, option, layer, direction2, dim) {
    var axis = {
      component: new CircleAxis(this.getCircleAxisCfg(scale5, option, direction2)),
      layer,
      direction: direction2,
      type: COMPONENT_TYPE.AXIS,
      extra: { dim, scale: scale5 }
    };
    axis.component.set("field", scale5.field);
    axis.component.init();
    return axis;
  };
  Axis2.prototype.createCircleGrid = function(scale5, option, layer, direction2, dim) {
    var cfg = this.getCircleGridCfg(scale5, option, direction2, dim);
    if (cfg) {
      var grid = {
        component: new CircleGrid(cfg),
        layer,
        direction: DIRECTION.NONE,
        type: COMPONENT_TYPE.GRID,
        extra: {
          dim,
          scale: scale5,
          alignTick: get_default(cfg, "alignTick", true)
        }
      };
      grid.component.init();
      return grid;
    }
  };
  Axis2.prototype.getLineAxisCfg = function(scale5, axisOption, direction2) {
    var container = get_default(axisOption, ["top"]) ? this.axisForeContainer : this.axisContainer;
    var coordinate = this.view.getCoordinate();
    var region = getAxisRegion(coordinate, direction2);
    var titleText = getAxisTitleText(scale5, axisOption);
    var axisThemeCfg = getAxisThemeCfg(this.view.getTheme(), direction2);
    var optionWithTitle = get_default(axisOption, ["title"]) ? deep_mix_default({ title: { style: { text: titleText } } }, { title: getAxisTitleOptions(this.view.getTheme(), direction2, axisOption.title) }, axisOption) : axisOption;
    var cfg = deep_mix_default(__assign(__assign({ container }, region), { ticks: scale5.getTicks().map(function(tick) {
      return { id: "".concat(tick.tickValue), name: tick.text, value: tick.value };
    }), verticalFactor: coordinate.isPolar ? getAxisFactorByRegion(region, coordinate.getCenter()) * -1 : getAxisFactorByRegion(region, coordinate.getCenter()), theme: axisThemeCfg }), axisThemeCfg, optionWithTitle);
    var _a3 = this.getAnimateCfg(cfg), animate = _a3.animate, animateOption = _a3.animateOption;
    cfg.animateOption = animateOption;
    cfg.animate = animate;
    var isAxisVertical = isVertical(region);
    var verticalLimitLength = get_default(cfg, "verticalLimitLength", isAxisVertical ? 1 / 3 : 1 / 2);
    if (verticalLimitLength <= 1) {
      var canvasWidth = this.view.getCanvas().get("width");
      var canvasHeight = this.view.getCanvas().get("height");
      cfg.verticalLimitLength = verticalLimitLength * (isAxisVertical ? canvasWidth : canvasHeight);
    }
    return cfg;
  };
  Axis2.prototype.getLineGridCfg = function(scale5, axisOption, direction2, dim) {
    if (!showGrid(getAxisThemeCfg(this.view.getTheme(), direction2), axisOption)) {
      return void 0;
    }
    var gridThemeCfg = getGridThemeCfg(this.view.getTheme(), direction2);
    var gridCfg = deep_mix_default({
      container: get_default(axisOption, ["top"]) ? this.gridForeContainer : this.gridContainer
    }, gridThemeCfg, get_default(axisOption, "grid"), this.getAnimateCfg(axisOption));
    gridCfg.items = getLineGridItems(this.view.getCoordinate(), scale5, dim, get_default(gridCfg, "alignTick", true));
    return gridCfg;
  };
  Axis2.prototype.getCircleAxisCfg = function(scale5, axisOption, direction2) {
    var container = get_default(axisOption, ["top"]) ? this.axisForeContainer : this.axisContainer;
    var coordinate = this.view.getCoordinate();
    var ticks = scale5.getTicks().map(function(tick) {
      return { id: "".concat(tick.tickValue), name: tick.text, value: tick.value };
    });
    if (!scale5.isCategory && Math.abs(coordinate.endAngle - coordinate.startAngle) === Math.PI * 2) {
      ticks.pop();
    }
    var titleText = getAxisTitleText(scale5, axisOption);
    var axisThemeCfg = getAxisThemeCfg(this.view.getTheme(), DIRECTION.CIRCLE);
    var optionWithTitle = get_default(axisOption, ["title"]) ? deep_mix_default({ title: { style: { text: titleText } } }, { title: getAxisTitleOptions(this.view.getTheme(), direction2, axisOption.title) }, axisOption) : axisOption;
    var cfg = deep_mix_default(__assign(__assign({ container }, getCircleAxisCenterRadius(this.view.getCoordinate())), { ticks, verticalFactor: 1, theme: axisThemeCfg }), axisThemeCfg, optionWithTitle);
    var _a3 = this.getAnimateCfg(cfg), animate = _a3.animate, animateOption = _a3.animateOption;
    cfg.animate = animate;
    cfg.animateOption = animateOption;
    return cfg;
  };
  Axis2.prototype.getCircleGridCfg = function(scale5, axisOption, direction2, dim) {
    if (!showGrid(getAxisThemeCfg(this.view.getTheme(), direction2), axisOption)) {
      return void 0;
    }
    var gridThemeCfg = getGridThemeCfg(this.view.getTheme(), DIRECTION.RADIUS);
    var gridCfg = deep_mix_default({
      container: get_default(axisOption, ["top"]) ? this.gridForeContainer : this.gridContainer,
      center: this.view.getCoordinate().getCenter()
    }, gridThemeCfg, get_default(axisOption, "grid"), this.getAnimateCfg(axisOption));
    var alignTick = get_default(gridCfg, "alignTick", true);
    var verticalScale = dim === "x" ? this.view.getYScales()[0] : this.view.getXScale();
    gridCfg.items = getCircleGridItems(this.view.getCoordinate(), verticalScale, scale5, alignTick, dim);
    return gridCfg;
  };
  Axis2.prototype.getId = function(name, key) {
    var coordinate = this.view.getCoordinate();
    return "".concat(name, "-").concat(key, "-").concat(coordinate.type);
  };
  Axis2.prototype.getAnimateCfg = function(cfg) {
    return {
      animate: this.view.getOptions().animate && get_default(cfg, "animate"),
      animateOption: cfg && cfg.animateOption ? deep_mix_default({}, AXIS_DEFAULT_ANIMATE_CFG, cfg.animateOption) : AXIS_DEFAULT_ANIMATE_CFG
    };
  };
  return Axis2;
}(Controller);
var axis_default = Axis;

// node_modules/@antv/g2/esm/util/direction.js
function directionToPosition(parentBBox, bbox, direction2) {
  if (direction2 === DIRECTION.TOP) {
    return [parentBBox.minX + parentBBox.width / 2 - bbox.width / 2, parentBBox.minY];
  }
  if (direction2 === DIRECTION.BOTTOM) {
    return [parentBBox.minX + parentBBox.width / 2 - bbox.width / 2, parentBBox.maxY - bbox.height];
  }
  if (direction2 === DIRECTION.LEFT) {
    return [parentBBox.minX, parentBBox.minY + parentBBox.height / 2 - bbox.height / 2];
  }
  if (direction2 === DIRECTION.RIGHT) {
    return [parentBBox.maxX - bbox.width, parentBBox.minY + parentBBox.height / 2 - bbox.height / 2];
  }
  if (direction2 === DIRECTION.TOP_LEFT || direction2 === DIRECTION.LEFT_TOP) {
    return [parentBBox.tl.x, parentBBox.tl.y];
  }
  if (direction2 === DIRECTION.TOP_RIGHT || direction2 === DIRECTION.RIGHT_TOP) {
    return [parentBBox.tr.x - bbox.width, parentBBox.tr.y];
  }
  if (direction2 === DIRECTION.BOTTOM_LEFT || direction2 === DIRECTION.LEFT_BOTTOM) {
    return [parentBBox.bl.x, parentBBox.bl.y - bbox.height];
  }
  if (direction2 === DIRECTION.BOTTOM_RIGHT || direction2 === DIRECTION.RIGHT_BOTTOM) {
    return [parentBBox.br.x - bbox.width, parentBBox.br.y - bbox.height];
  }
  return [0, 0];
}

// node_modules/@antv/g2/esm/chart/controller/legend.js
function getLegendOption(legends, field) {
  if (is_boolean_default(legends)) {
    return legends === false ? false : {};
  }
  return get_default(legends, [field], legends);
}
function getDirection(legendOption) {
  return get_default(legendOption, "position", DIRECTION.BOTTOM);
}
var Legend = function(_super) {
  __extends(Legend2, _super);
  function Legend2(view) {
    var _this = _super.call(this, view) || this;
    _this.container = _this.view.getLayer(LAYER.FORE).addGroup();
    return _this;
  }
  Object.defineProperty(Legend2.prototype, "name", {
    get: function() {
      return "legend";
    },
    enumerable: false,
    configurable: true
  });
  Legend2.prototype.init = function() {
  };
  Legend2.prototype.render = function() {
    this.update();
  };
  Legend2.prototype.layout = function() {
    var _this = this;
    this.layoutBBox = this.view.viewBBox;
    each_default(this.components, function(co) {
      var component = co.component, direction2 = co.direction;
      var layout2 = getLegendLayout(direction2);
      var maxWidthRatio = component.get("maxWidthRatio");
      var maxHeightRatio = component.get("maxHeightRatio");
      var maxSize = _this.getCategoryLegendSizeCfg(layout2, maxWidthRatio, maxHeightRatio);
      var maxWidth = component.get("maxWidth");
      var maxHeight = component.get("maxHeight");
      component.update({
        maxWidth: Math.min(maxSize.maxWidth, maxWidth || 0),
        maxHeight: Math.min(maxSize.maxHeight, maxHeight || 0)
      });
      var padding = component.get("padding");
      var bboxObject = component.getLayoutBBox();
      var bbox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height).expand(padding);
      var _a3 = __read(directionToPosition(_this.view.viewBBox, bbox, direction2), 2), x1 = _a3[0], y1 = _a3[1];
      var _b = __read(directionToPosition(_this.layoutBBox, bbox, direction2), 2), x2 = _b[0], y2 = _b[1];
      var x = 0;
      var y = 0;
      if (direction2.startsWith("top") || direction2.startsWith("bottom")) {
        x = x1;
        y = y2;
      } else {
        x = x2;
        y = y1;
      }
      component.setLocation({ x: x + padding[3], y: y + padding[0] });
      _this.layoutBBox = _this.layoutBBox.cut(bbox, direction2);
    });
  };
  Legend2.prototype.update = function() {
    var _this = this;
    this.option = this.view.getOptions().legends;
    var updated = {};
    var eachLegend = function(geometry, attr, scale5) {
      var id2 = _this.getId(scale5.field);
      var existCo2 = _this.getComponentById(id2);
      if (existCo2) {
        var cfg = void 0;
        var legendOption = getLegendOption(_this.option, scale5.field);
        if (legendOption !== false) {
          if (get_default(legendOption, "custom")) {
            cfg = _this.getCategoryCfg(geometry, attr, scale5, legendOption, true);
          } else {
            if (scale5.isLinear) {
              cfg = _this.getContinuousCfg(geometry, attr, scale5, legendOption);
            } else if (scale5.isCategory) {
              cfg = _this.getCategoryCfg(geometry, attr, scale5, legendOption);
            }
          }
        }
        if (cfg) {
          omit(cfg, ["container"]);
          existCo2.direction = getDirection(legendOption);
          existCo2.component.update(cfg);
          updated[id2] = true;
        }
      } else {
        var legend = _this.createFieldLegend(geometry, attr, scale5);
        if (legend) {
          legend.component.init();
          _this.components.push(legend);
          updated[id2] = true;
        }
      }
    };
    if (get_default(this.option, "custom")) {
      var id = "global-custom";
      var existCo = this.getComponentById(id);
      if (existCo) {
        var customCfg = this.getCategoryCfg(void 0, void 0, void 0, this.option, true);
        omit(customCfg, ["container"]);
        existCo.component.update(customCfg);
        updated[id] = true;
      } else {
        var component = this.createCustomLegend(void 0, void 0, void 0, this.option);
        if (component) {
          component.init();
          var layer = LAYER.FORE;
          var direction2 = getDirection(this.option);
          this.components.push({
            id,
            component,
            layer,
            direction: direction2,
            type: COMPONENT_TYPE.LEGEND,
            extra: void 0
          });
          updated[id] = true;
        }
      }
    } else {
      this.loopLegends(eachLegend);
    }
    var components = [];
    each_default(this.getComponents(), function(co) {
      if (updated[co.id]) {
        components.push(co);
      } else {
        co.component.destroy();
      }
    });
    this.components = components;
  };
  Legend2.prototype.clear = function() {
    _super.prototype.clear.call(this);
    this.container.clear();
  };
  Legend2.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    this.container.remove(true);
  };
  Legend2.prototype.getGeometries = function(view) {
    var _this = this;
    var geometries = view.geometries;
    each_default(view.views, function(v) {
      geometries = geometries.concat(_this.getGeometries(v));
    });
    return geometries;
  };
  Legend2.prototype.loopLegends = function(doEach) {
    var isRootView = this.view.getRootView() === this.view;
    if (!isRootView) {
      return;
    }
    var geometries = this.getGeometries(this.view);
    var looped = {};
    each_default(geometries, function(geometry) {
      var attributes = geometry.getGroupAttributes();
      each_default(attributes, function(attr) {
        var scale5 = attr.getScale(attr.type);
        if (!scale5 || scale5.type === "identity" || looped[scale5.field]) {
          return;
        }
        doEach(geometry, attr, scale5);
        looped[scale5.field] = true;
      });
    });
  };
  Legend2.prototype.createFieldLegend = function(geometry, attr, scale5) {
    var component;
    var legendOption = getLegendOption(this.option, scale5.field);
    var layer = LAYER.FORE;
    var direction2 = getDirection(legendOption);
    if (legendOption !== false) {
      if (get_default(legendOption, "custom")) {
        component = this.createCustomLegend(geometry, attr, scale5, legendOption);
      } else {
        if (scale5.isLinear) {
          component = this.createContinuousLegend(geometry, attr, scale5, legendOption);
        } else if (scale5.isCategory) {
          component = this.createCategoryLegend(geometry, attr, scale5, legendOption);
        }
      }
    }
    if (component) {
      component.set("field", scale5.field);
      return {
        id: this.getId(scale5.field),
        component,
        layer,
        direction: direction2,
        type: COMPONENT_TYPE.LEGEND,
        extra: { scale: scale5 }
      };
    }
  };
  Legend2.prototype.createCustomLegend = function(geometry, attr, scale5, legendOption) {
    var cfg = this.getCategoryCfg(geometry, attr, scale5, legendOption, true);
    return new CategoryLegend(cfg);
  };
  Legend2.prototype.createContinuousLegend = function(geometry, attr, scale5, legendOption) {
    var cfg = this.getContinuousCfg(geometry, attr, scale5, omit(legendOption, ["value"]));
    return new ContinuousLegend(cfg);
  };
  Legend2.prototype.createCategoryLegend = function(geometry, attr, scale5, legendOption) {
    var cfg = this.getCategoryCfg(geometry, attr, scale5, legendOption);
    return new CategoryLegend(cfg);
  };
  Legend2.prototype.getContinuousCfg = function(geometry, attr, scale5, legendOption) {
    var ticks = scale5.getTicks();
    var containMin = find_default(ticks, function(tick) {
      return tick.value === 0;
    });
    var containMax = find_default(ticks, function(tick) {
      return tick.value === 1;
    });
    var items = ticks.map(function(tick) {
      var value = tick.value, tickValue = tick.tickValue;
      var attrValue = attr.mapping(scale5.invert(value)).join("");
      return {
        value: tickValue,
        attrValue,
        color: attrValue,
        scaleValue: value
      };
    });
    if (!containMin) {
      items.push({
        value: scale5.min,
        attrValue: attr.mapping(scale5.invert(0)).join(""),
        color: attr.mapping(scale5.invert(0)).join(""),
        scaleValue: 0
      });
    }
    if (!containMax) {
      items.push({
        value: scale5.max,
        attrValue: attr.mapping(scale5.invert(1)).join(""),
        color: attr.mapping(scale5.invert(1)).join(""),
        scaleValue: 1
      });
    }
    items.sort(function(a, b) {
      return a.value - b.value;
    });
    var attrLegendCfg = {
      min: head(items).value,
      max: last(items).value,
      colors: [],
      rail: {
        type: attr.type
      },
      track: {}
    };
    if (attr.type === "size") {
      attrLegendCfg.track = {
        style: {
          fill: attr.type === "size" ? this.view.getTheme().defaultColor : void 0
        }
      };
    }
    if (attr.type === "color") {
      attrLegendCfg.colors = items.map(function(item) {
        return item.attrValue;
      });
    }
    var container = this.container;
    var direction2 = getDirection(legendOption);
    var layout2 = getLegendLayout(direction2);
    var title = get_default(legendOption, "title");
    if (title) {
      title = deep_mix_default({
        text: getName(scale5)
      }, title);
    }
    attrLegendCfg.container = container;
    attrLegendCfg.layout = layout2;
    attrLegendCfg.title = title;
    attrLegendCfg.animateOption = DEFAULT_ANIMATE_CFG;
    return this.mergeLegendCfg(attrLegendCfg, legendOption, "continuous");
  };
  Legend2.prototype.getCategoryCfg = function(geometry, attr, scale5, legendOption, custom10) {
    var container = this.container;
    var direction2 = get_default(legendOption, "position", DIRECTION.BOTTOM);
    var legendTheme = getLegendThemeCfg(this.view.getTheme(), direction2);
    var themeMarker = get_default(legendTheme, ["marker"]);
    var userMarker = get_default(legendOption, "marker");
    var layout2 = getLegendLayout(direction2);
    var themePageNavigator = get_default(legendTheme, ["pageNavigator"]);
    var userPageNavigator = get_default(legendOption, "pageNavigator");
    var items = custom10 ? getCustomLegendItems(themeMarker, userMarker, legendOption.items) : getLegendItems(this.view, geometry, attr, themeMarker, userMarker);
    var title = get_default(legendOption, "title");
    if (title) {
      title = deep_mix_default({
        text: scale5 ? getName(scale5) : ""
      }, title);
    }
    var maxWidthRatio = get_default(legendOption, "maxWidthRatio");
    var maxHeightRatio = get_default(legendOption, "maxHeightRatio");
    var baseCfg = this.getCategoryLegendSizeCfg(layout2, maxWidthRatio, maxHeightRatio);
    baseCfg.container = container;
    baseCfg.layout = layout2;
    baseCfg.items = items;
    baseCfg.title = title;
    baseCfg.animateOption = DEFAULT_ANIMATE_CFG;
    baseCfg.pageNavigator = deep_mix_default({}, themePageNavigator, userPageNavigator);
    var categoryCfg = this.mergeLegendCfg(baseCfg, legendOption, direction2);
    if (categoryCfg.reversed) {
      categoryCfg.items.reverse();
    }
    var maxItemWidth = get_default(categoryCfg, "maxItemWidth");
    if (maxItemWidth && maxItemWidth <= 1) {
      categoryCfg.maxItemWidth = this.view.viewBBox.width * maxItemWidth;
    }
    return categoryCfg;
  };
  Legend2.prototype.mergeLegendCfg = function(baseCfg, legendOption, direction2) {
    var position = direction2.split("-")[0];
    var themeObject = getLegendThemeCfg(this.view.getTheme(), position);
    return deep_mix_default({}, themeObject, baseCfg, legendOption);
  };
  Legend2.prototype.getId = function(key) {
    return "".concat(this.name, "-").concat(key);
  };
  Legend2.prototype.getComponentById = function(id) {
    return find_default(this.components, function(co) {
      return co.id === id;
    });
  };
  Legend2.prototype.getCategoryLegendSizeCfg = function(layout2, maxWidthRatio, maxHeightRatio) {
    if (maxWidthRatio === void 0) {
      maxWidthRatio = COMPONENT_MAX_VIEW_PERCENTAGE;
    }
    if (maxHeightRatio === void 0) {
      maxHeightRatio = COMPONENT_MAX_VIEW_PERCENTAGE;
    }
    var _a3 = this.view.viewBBox, vw = _a3.width, vh = _a3.height;
    return layout2 === "vertical" ? {
      maxWidth: vw * maxWidthRatio,
      maxHeight: vh
    } : {
      maxWidth: vw,
      maxHeight: vh * maxHeightRatio
    };
  };
  return Legend2;
}(Controller);
var legend_default = Legend;

// node_modules/@antv/g2/esm/chart/controller/slider.js
var Slider2 = function(_super) {
  __extends(Slider3, _super);
  function Slider3(view) {
    var _this = _super.call(this, view) || this;
    _this.onChangeFn = noop_default;
    _this.resetMeasure = function() {
      _this.clear();
    };
    _this.onValueChange = function(v) {
      var _a3 = __read(v, 2), min3 = _a3[0], max3 = _a3[1];
      _this.start = min3;
      _this.end = max3;
      _this.changeViewData(min3, max3);
    };
    _this.container = _this.view.getLayer(LAYER.FORE).addGroup();
    _this.onChangeFn = throttle_default(_this.onValueChange, 20, {
      leading: true
    });
    _this.width = 0;
    _this.view.on(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, _this.resetMeasure);
    _this.view.on(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE, _this.resetMeasure);
    return _this;
  }
  Object.defineProperty(Slider3.prototype, "name", {
    get: function() {
      return "slider";
    },
    enumerable: false,
    configurable: true
  });
  Slider3.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    this.view.off(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, this.resetMeasure);
    this.view.off(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE, this.resetMeasure);
  };
  Slider3.prototype.init = function() {
  };
  Slider3.prototype.render = function() {
    this.option = this.view.getOptions().slider;
    var _a3 = this.getSliderCfg(), start = _a3.start, end = _a3.end;
    if (is_nil_default(this.start)) {
      this.start = start;
      this.end = end;
    }
    var viewData = this.view.getOptions().data;
    if (this.option && !is_empty_default(viewData)) {
      if (this.slider) {
        this.slider = this.updateSlider();
      } else {
        this.slider = this.createSlider();
        this.slider.component.on("sliderchange", this.onChangeFn);
      }
    } else {
      if (this.slider) {
        this.slider.component.destroy();
        this.slider = void 0;
      } else {
      }
    }
  };
  Slider3.prototype.layout = function() {
    var _this = this;
    if (this.option && !this.width) {
      this.measureSlider();
      setTimeout(function() {
        if (!_this.view.destroyed) {
          _this.changeViewData(_this.start, _this.end);
        }
      }, 0);
    }
    if (this.slider) {
      var width = this.view.coordinateBBox.width;
      var padding = this.slider.component.get("padding");
      var _a3 = __read(padding, 4), paddingTop = _a3[0], paddingRight = _a3[1], paddingBottom = _a3[2], paddingLeft = _a3[3];
      var bboxObject = this.slider.component.getLayoutBBox();
      var bbox = new BBox(bboxObject.x, bboxObject.y, Math.min(bboxObject.width, width), bboxObject.height).expand(padding);
      var _b = this.getMinMaxText(this.start, this.end), minText = _b.minText, maxText = _b.maxText;
      var _c = __read(directionToPosition(this.view.viewBBox, bbox, DIRECTION.BOTTOM), 2), x1 = _c[0], y1 = _c[1];
      var _d = __read(directionToPosition(this.view.coordinateBBox, bbox, DIRECTION.BOTTOM), 2), x2 = _d[0], y2 = _d[1];
      this.slider.component.update(__assign(__assign({}, this.getSliderCfg()), { x: x2 + paddingLeft, y: y1 + paddingTop, width: this.width, start: this.start, end: this.end, minText, maxText }));
      this.view.viewBBox = this.view.viewBBox.cut(bbox, DIRECTION.BOTTOM);
    }
  };
  Slider3.prototype.update = function() {
    this.render();
  };
  Slider3.prototype.createSlider = function() {
    var cfg = this.getSliderCfg();
    var component = new Slider(__assign({ container: this.container }, cfg));
    component.init();
    return {
      component,
      layer: LAYER.FORE,
      direction: DIRECTION.BOTTOM,
      type: COMPONENT_TYPE.SLIDER
    };
  };
  Slider3.prototype.updateSlider = function() {
    var cfg = this.getSliderCfg();
    if (this.width) {
      var _a3 = this.getMinMaxText(this.start, this.end), minText = _a3.minText, maxText = _a3.maxText;
      cfg = __assign(__assign({}, cfg), { width: this.width, start: this.start, end: this.end, minText, maxText });
    }
    this.slider.component.update(cfg);
    return this.slider;
  };
  Slider3.prototype.measureSlider = function() {
    var width = this.getSliderCfg().width;
    this.width = width;
  };
  Slider3.prototype.getSliderCfg = function() {
    var cfg = {
      height: 16,
      start: 0,
      end: 1,
      minText: "",
      maxText: "",
      x: 0,
      y: 0,
      width: this.view.coordinateBBox.width
    };
    if (is_object_default(this.option)) {
      var trendCfg = __assign({ data: this.getData() }, get_default(this.option, "trendCfg", {}));
      cfg = deep_mix_default({}, cfg, this.getThemeOptions(), this.option);
      cfg = __assign(__assign({}, cfg), { trendCfg });
    }
    cfg.start = clamp_default(Math.min(is_nil_default(cfg.start) ? 0 : cfg.start, is_nil_default(cfg.end) ? 1 : cfg.end), 0, 1);
    cfg.end = clamp_default(Math.max(is_nil_default(cfg.start) ? 0 : cfg.start, is_nil_default(cfg.end) ? 1 : cfg.end), 0, 1);
    return cfg;
  };
  Slider3.prototype.getData = function() {
    var data = this.view.getOptions().data;
    var _a3 = __read(this.view.getYScales(), 1), yScale = _a3[0];
    var groupScales = this.view.getGroupScales();
    if (groupScales.length) {
      var _b = groupScales[0], field_1 = _b.field, ticks_1 = _b.ticks;
      return data.reduce(function(pre, cur) {
        if (cur[field_1] === ticks_1[0]) {
          pre.push(cur[yScale.field]);
        }
        return pre;
      }, []);
    }
    return data.map(function(datum) {
      return datum[yScale.field] || 0;
    });
  };
  Slider3.prototype.getThemeOptions = function() {
    var theme = this.view.getTheme();
    return get_default(theme, ["components", "slider", "common"], {});
  };
  Slider3.prototype.getMinMaxText = function(min3, max3) {
    var data = this.view.getOptions().data;
    var xScale = this.view.getXScale();
    var isHorizontal = true;
    var values2 = values_of_key_default(data, xScale.field);
    if (xScale.isLinear) {
      values2 = values2.sort();
    }
    var xValues = isHorizontal ? values2 : values2.reverse();
    var dataSize = size(data);
    if (!xScale || !dataSize) {
      return {};
    }
    var xTickCount = size(xValues);
    var minIndex = Math.round(min3 * (xTickCount - 1));
    var maxIndex = Math.round(max3 * (xTickCount - 1));
    var minText = get_default(xValues, [minIndex]);
    var maxText = get_default(xValues, [maxIndex]);
    var formatter = this.getSliderCfg().formatter;
    if (formatter) {
      minText = formatter(minText, data[minIndex], minIndex);
      maxText = formatter(maxText, data[maxIndex], maxIndex);
    }
    return {
      minText,
      maxText
    };
  };
  Slider3.prototype.changeViewData = function(min3, max3) {
    var data = this.view.getOptions().data;
    var xScale = this.view.getXScale();
    var dataSize = size(data);
    if (!xScale || !dataSize) {
      return;
    }
    var isHorizontal = true;
    var values2 = values_of_key_default(data, xScale.field);
    var xScaleValues = this.view.getXScale().isLinear ? values2.sort(function(a, b) {
      return Number(a) - Number(b);
    }) : values2;
    var xValues = isHorizontal ? xScaleValues : xScaleValues.reverse();
    var xTickCount = size(xValues);
    var minIndex = Math.round(min3 * (xTickCount - 1));
    var maxIndex = Math.round(max3 * (xTickCount - 1));
    this.view.filter(xScale.field, function(value, datum) {
      var idx = xValues.indexOf(value);
      return idx > -1 ? isBetween2(idx, minIndex, maxIndex) : true;
    });
    this.view.render(true);
  };
  Slider3.prototype.getComponents = function() {
    return this.slider ? [this.slider] : [];
  };
  Slider3.prototype.clear = function() {
    if (this.slider) {
      this.slider.component.destroy();
      this.slider = void 0;
    }
    this.width = 0;
    this.start = void 0;
    this.end = void 0;
  };
  return Slider3;
}(Controller);
var slider_default = Slider2;

// node_modules/@antv/g2/esm/chart/controller/scrollbar.js
var DEFAULT_PADDING = 0;
var DEFAULT_SIZE = 8;
var DEFAULT_CATEGORY_SIZE = 32;
var MIN_THUMB_LENGTH = 20;
var Scrollbar2 = function(_super) {
  __extends(Scrollbar3, _super);
  function Scrollbar3(view) {
    var _this = _super.call(this, view) || this;
    _this.onChangeFn = noop_default;
    _this.resetMeasure = function() {
      _this.clear();
    };
    _this.onValueChange = function(_a3) {
      var ratio = _a3.ratio;
      var animate = _this.getValidScrollbarCfg().animate;
      _this.ratio = clamp_default(ratio, 0, 1);
      var originalAnimate = _this.view.getOptions().animate;
      if (!animate) {
        _this.view.animate(false);
      }
      _this.changeViewData(_this.getScrollRange(), true);
      _this.view.animate(originalAnimate);
    };
    _this.container = _this.view.getLayer(LAYER.FORE).addGroup();
    _this.onChangeFn = throttle_default(_this.onValueChange, 20, {
      leading: true
    });
    _this.trackLen = 0;
    _this.thumbLen = 0;
    _this.ratio = 0;
    _this.view.on(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, _this.resetMeasure);
    _this.view.on(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE, _this.resetMeasure);
    return _this;
  }
  Object.defineProperty(Scrollbar3.prototype, "name", {
    get: function() {
      return "scrollbar";
    },
    enumerable: false,
    configurable: true
  });
  Scrollbar3.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    this.view.off(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, this.resetMeasure);
    this.view.off(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE, this.resetMeasure);
  };
  Scrollbar3.prototype.init = function() {
  };
  Scrollbar3.prototype.render = function() {
    this.option = this.view.getOptions().scrollbar;
    if (this.option) {
      if (this.scrollbar) {
        this.scrollbar = this.updateScrollbar();
      } else {
        this.scrollbar = this.createScrollbar();
        this.scrollbar.component.on("scrollchange", this.onChangeFn);
      }
    } else {
      if (this.scrollbar) {
        this.scrollbar.component.destroy();
        this.scrollbar = void 0;
      }
    }
  };
  Scrollbar3.prototype.layout = function() {
    var _this = this;
    if (this.option && !this.trackLen) {
      this.measureScrollbar();
      setTimeout(function() {
        if (!_this.view.destroyed) {
          _this.changeViewData(_this.getScrollRange(), true);
        }
      });
    }
    if (this.scrollbar) {
      var width = this.view.coordinateBBox.width;
      var padding = this.scrollbar.component.get("padding");
      var bboxObject = this.scrollbar.component.getLayoutBBox();
      var bbox = new BBox(bboxObject.x, bboxObject.y, Math.min(bboxObject.width, width), bboxObject.height).expand(padding);
      var cfg = this.getScrollbarComponentCfg();
      var x = void 0;
      var y = void 0;
      if (cfg.isHorizontal) {
        var _a3 = __read(directionToPosition(this.view.viewBBox, bbox, DIRECTION.BOTTOM), 2), x1 = _a3[0], y1 = _a3[1];
        var _b = __read(directionToPosition(this.view.coordinateBBox, bbox, DIRECTION.BOTTOM), 2), x2 = _b[0], y2 = _b[1];
        x = x2;
        y = y1;
      } else {
        var _c = __read(directionToPosition(this.view.viewBBox, bbox, DIRECTION.RIGHT), 2), x1 = _c[0], y1 = _c[1];
        var _d = __read(directionToPosition(this.view.viewBBox, bbox, DIRECTION.RIGHT), 2), x2 = _d[0], y2 = _d[1];
        x = x2;
        y = y1;
      }
      x += padding[3];
      y += padding[0];
      if (this.trackLen) {
        this.scrollbar.component.update(__assign(__assign({}, cfg), { x, y, trackLen: this.trackLen, thumbLen: this.thumbLen, thumbOffset: (this.trackLen - this.thumbLen) * this.ratio }));
      } else {
        this.scrollbar.component.update(__assign(__assign({}, cfg), { x, y }));
      }
      this.view.viewBBox = this.view.viewBBox.cut(bbox, cfg.isHorizontal ? DIRECTION.BOTTOM : DIRECTION.RIGHT);
    }
  };
  Scrollbar3.prototype.update = function() {
    this.render();
  };
  Scrollbar3.prototype.getComponents = function() {
    return this.scrollbar ? [this.scrollbar] : [];
  };
  Scrollbar3.prototype.clear = function() {
    if (this.scrollbar) {
      this.scrollbar.component.destroy();
      this.scrollbar = void 0;
    }
    this.trackLen = 0;
    this.thumbLen = 0;
    this.ratio = 0;
    this.cnt = 0;
    this.step = 0;
    this.data = void 0;
    this.xScaleCfg = void 0;
    this.yScalesCfg = [];
  };
  Scrollbar3.prototype.setValue = function(ratio) {
    this.onValueChange({ ratio });
  };
  Scrollbar3.prototype.getValue = function() {
    return this.ratio;
  };
  Scrollbar3.prototype.getThemeOptions = function() {
    var theme = this.view.getTheme();
    return get_default(theme, ["components", "scrollbar", "common"], {});
  };
  Scrollbar3.prototype.getScrollbarTheme = function(style) {
    var theme = get_default(this.view.getTheme(), ["components", "scrollbar"]);
    var _a3 = style || {}, thumbHighlightColor = _a3.thumbHighlightColor, restStyles = __rest(_a3, ["thumbHighlightColor"]);
    return {
      default: deep_mix_default({}, get_default(theme, ["default", "style"], {}), restStyles),
      hover: deep_mix_default({}, get_default(theme, ["hover", "style"], {}), { thumbColor: thumbHighlightColor })
    };
  };
  Scrollbar3.prototype.measureScrollbar = function() {
    var xScale = this.view.getXScale();
    var yScales = this.view.getYScales().slice();
    this.data = this.getScrollbarData();
    this.step = this.getStep();
    this.cnt = this.getCnt();
    var _a3 = this.getScrollbarComponentCfg(), trackLen = _a3.trackLen, thumbLen = _a3.thumbLen;
    this.trackLen = trackLen;
    this.thumbLen = thumbLen;
    this.xScaleCfg = {
      field: xScale.field,
      values: xScale.values || []
    };
    this.yScalesCfg = yScales;
  };
  Scrollbar3.prototype.getScrollRange = function() {
    var startIdx = Math.floor((this.cnt - this.step) * clamp_default(this.ratio, 0, 1));
    var endIdx = Math.min(startIdx + this.step - 1, this.cnt - 1);
    return [startIdx, endIdx];
  };
  Scrollbar3.prototype.changeViewData = function(_a3, render) {
    var _this = this;
    var _b = __read(_a3, 2), startIdx = _b[0], endIdx = _b[1];
    var type = this.getValidScrollbarCfg().type;
    var isHorizontal = type !== "vertical";
    var values2 = values_of_key_default(this.data, this.xScaleCfg.field);
    var xScaleValues = this.view.getXScale().isLinear ? values2.sort(function(a, b) {
      return Number(a) - Number(b);
    }) : values2;
    var xValues = isHorizontal ? xScaleValues : xScaleValues.reverse();
    this.yScalesCfg.forEach(function(cfg) {
      _this.view.scale(cfg.field, {
        formatter: cfg.formatter,
        type: cfg.type,
        min: cfg.min,
        max: cfg.max,
        tickMethod: cfg.tickMethod
      });
    });
    this.view.filter(this.xScaleCfg.field, function(val) {
      var idx = xValues.indexOf(val);
      return idx > -1 ? isBetween2(idx, startIdx, endIdx) : true;
    });
    this.view.render(true);
  };
  Scrollbar3.prototype.createScrollbar = function() {
    var type = this.getValidScrollbarCfg().type;
    var isHorizontal = type !== "vertical";
    var component = new Scrollbar(__assign(__assign({ container: this.container }, this.getScrollbarComponentCfg()), { x: 0, y: 0 }));
    component.init();
    return {
      component,
      layer: LAYER.FORE,
      direction: isHorizontal ? DIRECTION.BOTTOM : DIRECTION.RIGHT,
      type: COMPONENT_TYPE.SCROLLBAR
    };
  };
  Scrollbar3.prototype.updateScrollbar = function() {
    var config = this.getScrollbarComponentCfg();
    var realConfig = this.trackLen ? __assign(__assign({}, config), { trackLen: this.trackLen, thumbLen: this.thumbLen, thumbOffset: (this.trackLen - this.thumbLen) * this.ratio }) : __assign({}, config);
    this.scrollbar.component.update(realConfig);
    return this.scrollbar;
  };
  Scrollbar3.prototype.getStep = function() {
    if (this.step) {
      return this.step;
    }
    var coordinateBBox = this.view.coordinateBBox;
    var _a3 = this.getValidScrollbarCfg(), type = _a3.type, categorySize = _a3.categorySize;
    var isHorizontal = type !== "vertical";
    return Math.floor((isHorizontal ? coordinateBBox.width : coordinateBBox.height) / categorySize);
  };
  Scrollbar3.prototype.getCnt = function() {
    if (this.cnt) {
      return this.cnt;
    }
    var xScale = this.view.getXScale();
    var data = this.getScrollbarData();
    var values2 = values_of_key_default(data, xScale.field);
    return size(values2);
  };
  Scrollbar3.prototype.getScrollbarComponentCfg = function() {
    var _a3 = this.view, coordinateBBox = _a3.coordinateBBox, viewBBox = _a3.viewBBox;
    var _b = this.getValidScrollbarCfg(), type = _b.type, padding = _b.padding, width = _b.width, height = _b.height, style = _b.style;
    var isHorizontal = type !== "vertical";
    var _c = __read(padding, 4), paddingTop = _c[0], paddingRight = _c[1], paddingBottom = _c[2], paddingLeft = _c[3];
    var position = isHorizontal ? {
      x: coordinateBBox.minX + paddingLeft,
      y: viewBBox.maxY - height - paddingBottom
    } : {
      x: viewBBox.maxX - width - paddingRight,
      y: coordinateBBox.minY + paddingTop
    };
    var step = this.getStep();
    var cnt = this.getCnt();
    var trackLen = isHorizontal ? coordinateBBox.width - paddingLeft - paddingRight : coordinateBBox.height - paddingTop - paddingBottom;
    var thumbLen = Math.max(trackLen * clamp_default(step / cnt, 0, 1), MIN_THUMB_LENGTH);
    return __assign(__assign({}, this.getThemeOptions()), { x: position.x, y: position.y, size: isHorizontal ? height : width, isHorizontal, trackLen, thumbLen, thumbOffset: 0, theme: this.getScrollbarTheme(style) });
  };
  Scrollbar3.prototype.getValidScrollbarCfg = function() {
    var cfg = {
      type: "horizontal",
      categorySize: DEFAULT_CATEGORY_SIZE,
      width: DEFAULT_SIZE,
      height: DEFAULT_SIZE,
      padding: [0, 0, 0, 0],
      animate: true,
      style: {}
    };
    if (is_object_default(this.option)) {
      cfg = __assign(__assign({}, cfg), this.option);
    }
    if (!is_object_default(this.option) || !this.option.padding) {
      cfg.padding = cfg.type === "horizontal" ? [DEFAULT_PADDING, 0, DEFAULT_PADDING, 0] : [0, DEFAULT_PADDING, 0, DEFAULT_PADDING];
    }
    return cfg;
  };
  Scrollbar3.prototype.getScrollbarData = function() {
    var coordinate = this.view.getCoordinate();
    var cfg = this.getValidScrollbarCfg();
    var data = this.view.getOptions().data || [];
    if (coordinate.isReflect("y") && cfg.type === "vertical") {
      data = __spreadArray([], __read(data), false).reverse();
    }
    return data;
  };
  return Scrollbar3;
}(Controller);
var scrollbar_default = Scrollbar2;

// node_modules/@antv/g2/esm/interaction/action/active-region.js
var DEFAULT_REGION_PATH_STYLE = {
  fill: "#CCD6EC",
  opacity: 0.3
};
function getItemsOfView(view, point, tooltipCfg) {
  var e_1, _a3, e_2, _b, e_3, _c;
  var items = findItemsFromViewRecurisive(view, point, tooltipCfg);
  if (items.length) {
    items = flatten_default(items);
    try {
      for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
        var itemArr = items_1_1.value;
        try {
          for (var itemArr_1 = (e_2 = void 0, __values(itemArr)), itemArr_1_1 = itemArr_1.next(); !itemArr_1_1.done; itemArr_1_1 = itemArr_1.next()) {
            var item = itemArr_1_1.value;
            var _d = item.mappingData, x = _d.x, y = _d.y;
            item.x = is_array_default(x) ? x[x.length - 1] : x;
            item.y = is_array_default(y) ? y[y.length - 1] : y;
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (itemArr_1_1 && !itemArr_1_1.done && (_b = itemArr_1.return))
              _b.call(itemArr_1);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (items_1_1 && !items_1_1.done && (_a3 = items_1.return))
          _a3.call(items_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    var shared = tooltipCfg.shared;
    if (shared === false && items.length > 1) {
      var snapItem = items[0];
      var min3 = Math.abs(point.y - snapItem[0].y);
      try {
        for (var items_2 = __values(items), items_2_1 = items_2.next(); !items_2_1.done; items_2_1 = items_2.next()) {
          var aItem = items_2_1.value;
          var yDistance = Math.abs(point.y - aItem[0].y);
          if (yDistance <= min3) {
            snapItem = aItem;
            min3 = yDistance;
          }
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          if (items_2_1 && !items_2_1.done && (_c = items_2.return))
            _c.call(items_2);
        } finally {
          if (e_3)
            throw e_3.error;
        }
      }
      items = [snapItem];
    }
    return uniq(flatten_default(items));
  }
  return [];
}
var ActiveRegion = function(_super) {
  __extends(ActiveRegion2, _super);
  function ActiveRegion2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ActiveRegion2.prototype.show = function(args) {
    var view = this.context.view;
    var ev = this.context.event;
    var tooltipCfg = view.getController("tooltip").getTooltipCfg();
    var tooltipItems = getItemsOfView(view, {
      x: ev.x,
      y: ev.y
    }, tooltipCfg);
    if (is_equal_default(tooltipItems, this.items)) {
      return;
    }
    this.items = tooltipItems;
    if (tooltipItems.length) {
      var xField_1 = view.getXScale().field;
      var xValue_1 = tooltipItems[0].data[xField_1];
      var elements_1 = [];
      var geometries = view.geometries;
      each_default(geometries, function(geometry) {
        if (geometry.type === "interval" || geometry.type === "schema") {
          var result = geometry.getElementsBy(function(ele) {
            var eleData = ele.getData();
            return eleData[xField_1] === xValue_1;
          });
          elements_1 = elements_1.concat(result);
        }
      });
      if (elements_1.length) {
        var coordinate_1 = view.getCoordinate();
        var firstBBox_1 = elements_1[0].shape.getCanvasBBox();
        var lastBBox_1 = elements_1[0].shape.getCanvasBBox();
        var groupBBox_1 = firstBBox_1;
        each_default(elements_1, function(ele) {
          var bbox = ele.shape.getCanvasBBox();
          if (coordinate_1.isTransposed) {
            if (bbox.minY < firstBBox_1.minY) {
              firstBBox_1 = bbox;
            }
            if (bbox.maxY > lastBBox_1.maxY) {
              lastBBox_1 = bbox;
            }
          } else {
            if (bbox.minX < firstBBox_1.minX) {
              firstBBox_1 = bbox;
            }
            if (bbox.maxX > lastBBox_1.maxX) {
              lastBBox_1 = bbox;
            }
          }
          groupBBox_1.x = Math.min(bbox.minX, groupBBox_1.minX);
          groupBBox_1.y = Math.min(bbox.minY, groupBBox_1.minY);
          groupBBox_1.width = Math.max(bbox.maxX, groupBBox_1.maxX) - groupBBox_1.x;
          groupBBox_1.height = Math.max(bbox.maxY, groupBBox_1.maxY) - groupBBox_1.y;
        });
        var backgroundGroup = view.backgroundGroup, coordinateBBox = view.coordinateBBox;
        var path = void 0;
        if (coordinate_1.isRect) {
          var xScale = view.getXScale();
          var _a3 = args || {}, appendRatio = _a3.appendRatio, appendWidth = _a3.appendWidth;
          if (is_nil_default(appendWidth)) {
            appendRatio = is_nil_default(appendRatio) ? xScale.isLinear ? 0 : 0.25 : appendRatio;
            appendWidth = coordinate_1.isTransposed ? appendRatio * lastBBox_1.height : appendRatio * firstBBox_1.width;
          }
          var minX = void 0;
          var minY = void 0;
          var width = void 0;
          var height = void 0;
          if (coordinate_1.isTransposed) {
            minX = coordinateBBox.minX;
            minY = Math.min(lastBBox_1.minY, firstBBox_1.minY) - appendWidth;
            width = coordinateBBox.width;
            height = groupBBox_1.height + appendWidth * 2;
          } else {
            minX = Math.min(firstBBox_1.minX, lastBBox_1.minX) - appendWidth;
            minY = coordinateBBox.minY;
            width = groupBBox_1.width + appendWidth * 2;
            height = coordinateBBox.height;
          }
          path = [
            ["M", minX, minY],
            ["L", minX + width, minY],
            ["L", minX + width, minY + height],
            ["L", minX, minY + height],
            ["Z"]
          ];
        } else {
          var firstElement = head(elements_1);
          var lastElement = last(elements_1);
          var startAngle = getAngle2(firstElement.getModel(), coordinate_1).startAngle;
          var endAngle = getAngle2(lastElement.getModel(), coordinate_1).endAngle;
          var center = coordinate_1.getCenter();
          var radius = coordinate_1.getRadius();
          var innterRadius = coordinate_1.innerRadius * radius;
          path = getSectorPath(center.x, center.y, radius, startAngle, endAngle, innterRadius);
        }
        if (this.regionPath) {
          this.regionPath.attr("path", path);
          this.regionPath.show();
        } else {
          var style = get_default(args, "style", DEFAULT_REGION_PATH_STYLE);
          this.regionPath = backgroundGroup.addShape({
            type: "path",
            name: "active-region",
            capture: false,
            attrs: __assign(__assign({}, style), { path })
          });
        }
      }
    }
  };
  ActiveRegion2.prototype.hide = function() {
    if (this.regionPath) {
      this.regionPath.hide();
    }
    this.items = null;
  };
  ActiveRegion2.prototype.destroy = function() {
    this.hide();
    if (this.regionPath) {
      this.regionPath.remove(true);
    }
    _super.prototype.destroy.call(this);
  };
  return ActiveRegion2;
}(base_default12);
var active_region_default = ActiveRegion;

// node_modules/@antv/g2/esm/interaction/action/component/tooltip/geometry.js
var TooltipAction = function(_super) {
  __extends(TooltipAction2, _super);
  function TooltipAction2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.timeStamp = 0;
    return _this;
  }
  TooltipAction2.prototype.show = function() {
    var context = this.context;
    var ev = context.event;
    var view = context.view;
    var isTooltipLocked = view.isTooltipLocked();
    if (isTooltipLocked) {
      return;
    }
    var lastTimeStamp = this.timeStamp;
    var timeStamp = +new Date();
    var showDelay = get_default(context.view.getOptions(), "tooltip.showDelay", 16);
    if (timeStamp - lastTimeStamp > showDelay) {
      var preLoc = this.location;
      var curLoc = { x: ev.x, y: ev.y };
      if (!preLoc || !is_equal_default(preLoc, curLoc)) {
        this.showTooltip(view, curLoc);
      }
      this.timeStamp = timeStamp;
      this.location = curLoc;
    }
  };
  TooltipAction2.prototype.hide = function() {
    var view = this.context.view;
    var tooltip = view.getController("tooltip");
    var _a3 = this.context.event, clientX = _a3.clientX, clientY = _a3.clientY;
    if (tooltip.isCursorEntered({ x: clientX, y: clientY })) {
      return;
    }
    if (view.isTooltipLocked()) {
      return;
    }
    this.hideTooltip(view);
    this.location = null;
  };
  TooltipAction2.prototype.showTooltip = function(view, point) {
    view.showTooltip(point);
  };
  TooltipAction2.prototype.hideTooltip = function(view) {
    view.hideTooltip();
  };
  return TooltipAction2;
}(base_default12);
var geometry_default = TooltipAction;

// node_modules/@antv/g2/esm/interaction/action/component/tooltip/sibling.js
var SiblingTooltip = function(_super) {
  __extends(SiblingTooltip2, _super);
  function SiblingTooltip2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  SiblingTooltip2.prototype.showTooltip = function(view, point) {
    var siblings = getSilbings(view);
    each_default(siblings, function(sibling) {
      var siblingPoint = getSiblingPoint(view, sibling, point);
      sibling.showTooltip(siblingPoint);
    });
  };
  SiblingTooltip2.prototype.hideTooltip = function(view) {
    var siblings = getSilbings(view);
    each_default(siblings, function(sibling) {
      sibling.hideTooltip();
    });
  };
  return SiblingTooltip2;
}(geometry_default);
var sibling_default = SiblingTooltip;

// node_modules/@antv/g2/esm/interaction/action/component/tooltip/ellipsis-text.js
var EllipsisText = function(_super) {
  __extends(EllipsisText2, _super);
  function EllipsisText2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.timeStamp = 0;
    return _this;
  }
  EllipsisText2.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    this.tooltip && this.tooltip.destroy();
  };
  EllipsisText2.prototype.show = function() {
    var context = this.context;
    var ev = context.event;
    var lastTimeStamp = this.timeStamp;
    var timeStamp = +new Date();
    if (timeStamp - lastTimeStamp > 16) {
      var preLoc = this.location;
      var curLoc = { x: ev.x, y: ev.y };
      if (!preLoc || !is_equal_default(preLoc, curLoc)) {
        this.showTooltip(curLoc);
      }
      this.timeStamp = timeStamp;
      this.location = curLoc;
    }
  };
  EllipsisText2.prototype.hide = function() {
    this.hideTooltip();
    this.location = null;
  };
  EllipsisText2.prototype.showTooltip = function(curLoc) {
    var context = this.context;
    var ev = context.event;
    var target = ev.target;
    if (target && target.get("tip")) {
      if (!this.tooltip) {
        this.renderTooltip();
      }
      var tipContent = target.get("tip");
      this.tooltip.update(__assign({ title: tipContent }, curLoc));
      this.tooltip.show();
    }
  };
  EllipsisText2.prototype.hideTooltip = function() {
    this.tooltip && this.tooltip.hide();
  };
  EllipsisText2.prototype.renderTooltip = function() {
    var _a3;
    var view = this.context.view;
    var canvas = view.canvas;
    var region = {
      start: { x: 0, y: 0 },
      end: { x: canvas.get("width"), y: canvas.get("height") }
    };
    var theme = view.getTheme();
    var tooltipStyles = get_default(theme, ["components", "tooltip", "domStyles"], {});
    var tooltip = new HtmlTooltip({
      parent: canvas.get("el").parentNode,
      region,
      visible: false,
      crosshairs: null,
      domStyles: __assign({}, deep_mix_default({}, tooltipStyles, (_a3 = {}, _a3[css_const_exports2.CONTAINER_CLASS] = { "max-width": "50%" }, _a3[css_const_exports2.TITLE_CLASS] = { "word-break": "break-all" }, _a3)))
    });
    tooltip.init();
    tooltip.setCapture(false);
    this.tooltip = tooltip;
  };
  return EllipsisText2;
}(base_default12);
var ellipsis_text_default = EllipsisText;

// node_modules/@antv/g2/esm/interaction/action/element/state-base.js
var StateBase = function(_super) {
  __extends(StateBase2, _super);
  function StateBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = "";
    return _this;
  }
  StateBase2.prototype.hasState = function(element) {
    return element.hasState(this.stateName);
  };
  StateBase2.prototype.setElementState = function(element, enable) {
    element.setState(this.stateName, enable);
  };
  StateBase2.prototype.setState = function() {
    this.setStateEnable(true);
  };
  StateBase2.prototype.clear = function() {
    var view = this.context.view;
    this.clearViewState(view);
  };
  StateBase2.prototype.clearViewState = function(view) {
    var _this = this;
    var elements = getElementsByState(view, this.stateName);
    each_default(elements, function(el) {
      _this.setElementState(el, false);
    });
  };
  return StateBase2;
}(base_default12);
var state_base_default = StateBase;

// node_modules/@antv/g2/esm/interaction/action/element/state.js
function getItem(shape) {
  return get_default(shape.get("delegateObject"), "item");
}
var ElementState = function(_super) {
  __extends(ElementState2, _super);
  function ElementState2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.ignoreListItemStates = ["unchecked"];
    return _this;
  }
  ElementState2.prototype.isItemIgnore = function(item, list) {
    var states = this.ignoreListItemStates;
    var filtered = states.filter(function(state) {
      return list.hasState(item, state);
    });
    return !!filtered.length;
  };
  ElementState2.prototype.setStateByComponent = function(component, item, enable) {
    var view = this.context.view;
    var field = component.get("field");
    var elements = getElements(view);
    this.setElementsStateByItem(elements, field, item, enable);
  };
  ElementState2.prototype.setStateByElement = function(element, enable) {
    this.setElementState(element, enable);
  };
  ElementState2.prototype.isMathItem = function(element, field, item) {
    var view = this.context.view;
    var scale5 = getScaleByField(view, field);
    var value = getElementValue(element, field);
    return !is_nil_default(value) && item.name === scale5.getText(value);
  };
  ElementState2.prototype.setElementsStateByItem = function(elements, field, item, enable) {
    var _this = this;
    each_default(elements, function(el) {
      if (_this.isMathItem(el, field, item)) {
        el.setState(_this.stateName, enable);
      }
    });
  };
  ElementState2.prototype.setStateEnable = function(enable) {
    var element = getCurrentElement(this.context);
    if (element) {
      if (isElementChange(this.context)) {
        this.setStateByElement(element, enable);
      }
    } else {
      var delegateObject = getDelegationObject(this.context);
      if (isList(delegateObject)) {
        var item = delegateObject.item, component = delegateObject.component;
        if (item && component && !this.isItemIgnore(item, component)) {
          var event_1 = this.context.event.gEvent;
          if (event_1 && event_1.fromShape && event_1.toShape && getItem(event_1.fromShape) === getItem(event_1.toShape)) {
            return;
          }
          this.setStateByComponent(component, item, enable);
        }
      }
    }
  };
  ElementState2.prototype.toggle = function() {
    var element = getCurrentElement(this.context);
    if (element) {
      var hasState = element.hasState(this.stateName);
      this.setElementState(element, !hasState);
    }
  };
  ElementState2.prototype.reset = function() {
    this.setStateEnable(false);
  };
  return ElementState2;
}(state_base_default);
var state_default = ElementState;

// node_modules/@antv/g2/esm/interaction/action/element/active.js
var ElementActive = function(_super) {
  __extends(ElementActive2, _super);
  function ElementActive2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = "active";
    return _this;
  }
  ElementActive2.prototype.active = function() {
    this.setState();
  };
  return ElementActive2;
}(state_default);
var active_default = ElementActive;

// node_modules/@antv/g2/esm/interaction/action/element/link-by-color.js
var LinkByColor = function(_super) {
  __extends(LinkByColor2, _super);
  function LinkByColor2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.cache = {};
    return _this;
  }
  LinkByColor2.prototype.getColorScale = function(view, element) {
    var colorAttr = element.geometry.getAttribute("color");
    if (!colorAttr) {
      return null;
    }
    var scale5 = view.getScaleByField(colorAttr.getFields()[0]);
    return scale5;
  };
  LinkByColor2.prototype.getLinkPath = function(element, nextElement) {
    var view = this.context.view;
    var isTransposed = view.getCoordinate().isTransposed;
    var bbox = element.shape.getCanvasBBox();
    var nextBBox = nextElement.shape.getCanvasBBox();
    var path = isTransposed ? [
      ["M", bbox.minX, bbox.minY],
      ["L", nextBBox.minX, nextBBox.maxY],
      ["L", nextBBox.maxX, nextBBox.maxY],
      ["L", bbox.maxX, bbox.minY],
      ["Z"]
    ] : [
      ["M", bbox.maxX, bbox.minY],
      ["L", nextBBox.minX, nextBBox.minY],
      ["L", nextBBox.minX, nextBBox.maxY],
      ["L", bbox.maxX, bbox.maxY],
      ["Z"]
    ];
    return path;
  };
  LinkByColor2.prototype.addLinkShape = function(group2, element, nextElement, activeStyle) {
    var style = {
      opacity: 0.4,
      fill: element.shape.attr("fill")
    };
    group2.addShape({
      type: "path",
      attrs: __assign(__assign({}, deep_mix_default({}, style, is_function_default(activeStyle) ? activeStyle(style, element) : activeStyle)), { path: this.getLinkPath(element, nextElement) })
    });
  };
  LinkByColor2.prototype.linkByElement = function(element, activeStyle) {
    var _this = this;
    var view = this.context.view;
    var scale5 = this.getColorScale(view, element);
    if (!scale5) {
      return;
    }
    var value = getElementValue(element, scale5.field);
    if (!this.cache[value]) {
      var elements_1 = getElementsByField(view, scale5.field, value);
      var linkGroup = this.linkGroup;
      var group_1 = linkGroup.addGroup();
      this.cache[value] = group_1;
      var count_1 = elements_1.length;
      each_default(elements_1, function(el, index) {
        if (index < count_1 - 1) {
          var nextEl = elements_1[index + 1];
          _this.addLinkShape(group_1, el, nextEl, activeStyle);
        }
      });
    }
  };
  LinkByColor2.prototype.removeLink = function(element) {
    var scale5 = this.getColorScale(this.context.view, element);
    if (!scale5) {
      return;
    }
    var value = getElementValue(element, scale5.field);
    if (this.cache[value]) {
      this.cache[value].remove();
      this.cache[value] = null;
    }
  };
  LinkByColor2.prototype.link = function(args) {
    var context = this.context;
    if (!this.linkGroup) {
      this.linkGroup = context.view.foregroundGroup.addGroup({
        id: "link-by-color-group",
        capture: false
      });
    }
    var element = getCurrentElement(context);
    if (element) {
      this.linkByElement(element, args === null || args === void 0 ? void 0 : args.style);
    }
  };
  LinkByColor2.prototype.unlink = function() {
    var element = getCurrentElement(this.context);
    if (element) {
      this.removeLink(element);
    }
  };
  LinkByColor2.prototype.clear = function() {
    if (this.linkGroup) {
      this.linkGroup.clear();
    }
    this.cache = {};
  };
  LinkByColor2.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    if (this.linkGroup) {
      this.linkGroup.remove();
    }
  };
  return LinkByColor2;
}(base_default12);
var link_by_color_default = LinkByColor;

// node_modules/@antv/g2/esm/interaction/action/element/range-state.js
var ElementRangeState = function(_super) {
  __extends(ElementRangeState2, _super);
  function ElementRangeState2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.startPoint = null;
    _this.endPoint = null;
    _this.isStarted = false;
    _this.effectSiblings = false;
    _this.effectByRecord = false;
    return _this;
  }
  ElementRangeState2.prototype.getCurrentPoint = function() {
    var event = this.context.event;
    return {
      x: event.x,
      y: event.y
    };
  };
  ElementRangeState2.prototype.start = function() {
    this.clear();
    this.startPoint = this.getCurrentPoint();
    this.isStarted = true;
  };
  ElementRangeState2.prototype.getIntersectElements = function() {
    var elements = null;
    if (isMask(this.context)) {
      elements = getMaskedElements(this.context, 10);
    } else {
      var startPoint = this.startPoint;
      var endPoint = this.isStarted ? this.getCurrentPoint() : this.endPoint;
      if (!startPoint || !endPoint) {
        return;
      }
      var box2 = {
        minX: Math.min(startPoint.x, endPoint.x),
        minY: Math.min(startPoint.y, endPoint.y),
        maxX: Math.max(startPoint.x, endPoint.x),
        maxY: Math.max(startPoint.y, endPoint.y)
      };
      var view = this.context.view;
      elements = getIntersectElements(view, box2);
    }
    return elements;
  };
  ElementRangeState2.prototype.setStateEnable = function(enable) {
    if (this.effectSiblings && !this.effectByRecord) {
      this.setSiblingsState(enable);
    } else {
      var allElements = getElements(this.context.view);
      var elements = this.getIntersectElements();
      if (elements && elements.length) {
        if (this.effectByRecord) {
          this.setSiblingsStateByRecord(elements, enable);
        } else {
          this.setElementsState(elements, enable, allElements);
        }
      } else {
        this.clear();
      }
    }
  };
  ElementRangeState2.prototype.setSiblingsStateByRecord = function(elements, enable) {
    var _this = this;
    var view = this.context.view;
    var siblings = getSilbings(view);
    var records = elements.map(function(el) {
      return el.getModel().data;
    });
    var xFiled = view.getXScale().field;
    var yField = view.getYScales()[0].field;
    each_default(siblings, function(sibling) {
      var allElements = getElements(sibling);
      var effectElements = allElements.filter(function(el) {
        var record = el.getModel().data;
        return isInRecords(records, record, xFiled, yField);
      });
      _this.setElementsState(effectElements, enable, allElements);
    });
  };
  ElementRangeState2.prototype.setSiblingsState = function(enable) {
    var _this = this;
    var view = this.context.view;
    var siblings = getSilbings(view);
    if (isMask(this.context)) {
      each_default(siblings, function(sibling) {
        var allElements = getElements(sibling);
        var effectElements = getSiblingMaskElements(_this.context, sibling, 10);
        if (effectElements && effectElements.length) {
          _this.setElementsState(effectElements, enable, allElements);
        } else {
          _this.clearViewState(sibling);
        }
      });
    }
  };
  ElementRangeState2.prototype.setElementsState = function(elements, enable, allElements) {
    var _this = this;
    each_default(allElements, function(el) {
      if (!elements.includes(el)) {
        _this.setElementState(el, false);
      } else {
        _this.setElementState(el, enable);
      }
    });
  };
  ElementRangeState2.prototype.end = function() {
    this.isStarted = false;
    this.endPoint = this.getCurrentPoint();
  };
  ElementRangeState2.prototype.clear = function() {
    var _this = this;
    var view = this.context.view;
    if (this.effectSiblings) {
      var siblings = getSilbings(view);
      each_default(siblings, function(sibling) {
        _this.clearViewState(sibling);
      });
    } else {
      this.clearViewState(view);
    }
  };
  return ElementRangeState2;
}(state_base_default);
var range_state_default = ElementRangeState;

// node_modules/@antv/g2/esm/interaction/action/element/range-active.js
var ElementRangeActive = function(_super) {
  __extends(ElementRangeActive2, _super);
  function ElementRangeActive2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = "active";
    return _this;
  }
  ElementRangeActive2.prototype.active = function() {
    this.setState();
  };
  return ElementRangeActive2;
}(range_state_default);
var range_active_default = ElementRangeActive;

// node_modules/@antv/g2/esm/interaction/action/element/single-state.js
var ElementSingleState = function(_super) {
  __extends(ElementSingleState2, _super);
  function ElementSingleState2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ElementSingleState2.prototype.setStateEnable = function(enable) {
    var element = getCurrentElement(this.context);
    if (element) {
      if (!isElementChange(this.context)) {
        return;
      }
      if (enable) {
        this.clear();
        this.setElementState(element, true);
      } else if (this.hasState(element)) {
        this.setElementState(element, false);
      }
    }
  };
  ElementSingleState2.prototype.toggle = function() {
    var element = getCurrentElement(this.context);
    if (element) {
      var hasState = this.hasState(element);
      if (!hasState) {
        this.clear();
      }
      this.setElementState(element, !hasState);
    }
  };
  ElementSingleState2.prototype.reset = function() {
    this.setStateEnable(false);
  };
  return ElementSingleState2;
}(state_base_default);
var single_state_default = ElementSingleState;

// node_modules/@antv/g2/esm/interaction/action/element/single-active.js
var ElementSingleActive = function(_super) {
  __extends(ElementSingleActive2, _super);
  function ElementSingleActive2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = "active";
    return _this;
  }
  ElementSingleActive2.prototype.active = function() {
    this.setState();
  };
  return ElementSingleActive2;
}(single_state_default);
var single_active_default = ElementSingleActive;

// node_modules/@antv/g2/esm/interaction/action/element/highlight-util.js
var STATUS_UNACTIVE = "inactive";
var STATUS_ACTIVE = "active";
function clearHighlight(view) {
  var elements = getElements(view);
  each_default(elements, function(el) {
    if (el.hasState(STATUS_ACTIVE)) {
      el.setState(STATUS_ACTIVE, false);
    }
    if (el.hasState(STATUS_UNACTIVE)) {
      el.setState(STATUS_UNACTIVE, false);
    }
  });
}
function setHighlightBy(elements, callback, enable) {
  each_default(elements, function(el) {
    if (callback(el)) {
      if (el.hasState(STATUS_UNACTIVE)) {
        el.setState(STATUS_UNACTIVE, false);
      }
      el.setState(STATUS_ACTIVE, enable);
    } else {
      if (el.hasState(STATUS_ACTIVE)) {
        el.setState(STATUS_ACTIVE, false);
      }
      el.setState(STATUS_UNACTIVE, enable);
    }
  });
}

// node_modules/@antv/g2/esm/interaction/action/element/highlight.js
var STATUS_UNACTIVE2 = ELEMENT_STATE.INACTIVE;
var STATUS_ACTIVE2 = ELEMENT_STATE.ACTIVE;
var ElementHighlight = function(_super) {
  __extends(ElementHighlight2, _super);
  function ElementHighlight2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = STATUS_ACTIVE2;
    return _this;
  }
  ElementHighlight2.prototype.setElementsStateByItem = function(elements, field, item, enable) {
    var _this = this;
    var callback = function(el) {
      return _this.isMathItem(el, field, item);
    };
    this.setHighlightBy(elements, callback, enable);
  };
  ElementHighlight2.prototype.setElementHighlight = function(el, callback) {
    if (callback(el)) {
      if (el.hasState(STATUS_UNACTIVE2)) {
        el.setState(STATUS_UNACTIVE2, false);
      }
      el.setState(STATUS_ACTIVE2, true);
    } else if (!el.hasState(STATUS_ACTIVE2)) {
      el.setState(STATUS_UNACTIVE2, true);
    }
  };
  ElementHighlight2.prototype.setHighlightBy = function(elements, callback, enable) {
    var _this = this;
    if (enable) {
      each_default(elements, function(el) {
        _this.setElementHighlight(el, callback);
      });
    } else {
      var activeElements = getElementsByState(this.context.view, STATUS_ACTIVE2);
      var allCancel_1 = true;
      each_default(activeElements, function(el) {
        if (!callback(el)) {
          allCancel_1 = false;
          return false;
        }
      });
      if (allCancel_1) {
        this.clear();
      } else {
        each_default(elements, function(el) {
          if (callback(el)) {
            if (el.hasState(STATUS_ACTIVE2)) {
              el.setState(STATUS_ACTIVE2, false);
            }
            el.setState(STATUS_UNACTIVE2, true);
          }
        });
      }
    }
  };
  ElementHighlight2.prototype.setElementState = function(element, enable) {
    var view = this.context.view;
    var elements = getElements(view);
    this.setHighlightBy(elements, function(el) {
      return element === el;
    }, enable);
  };
  ElementHighlight2.prototype.highlight = function() {
    this.setState();
  };
  ElementHighlight2.prototype.clear = function() {
    var view = this.context.view;
    clearHighlight(view);
  };
  return ElementHighlight2;
}(state_default);
var highlight_default = ElementHighlight;

// node_modules/@antv/g2/esm/interaction/action/element/highlight-by-color.js
var HighlightColor = function(_super) {
  __extends(HighlightColor2, _super);
  function HighlightColor2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  HighlightColor2.prototype.setStateByElement = function(element, enable) {
    var view = this.context.view;
    var colorAttr = element.geometry.getAttribute("color");
    if (!colorAttr) {
      return;
    }
    var scale5 = view.getScaleByField(colorAttr.getFields()[0]);
    var value = getElementValue(element, scale5.field);
    var elements = getElements(view);
    var highlightElements = elements.filter(function(el) {
      return getElementValue(el, scale5.field) === value;
    });
    this.setHighlightBy(elements, function(el) {
      return highlightElements.includes(el);
    }, enable);
  };
  return HighlightColor2;
}(highlight_default);
var highlight_by_color_default = HighlightColor;

// node_modules/@antv/g2/esm/interaction/action/element/highlight-by-x.js
var HighlightX = function(_super) {
  __extends(HighlightX2, _super);
  function HighlightX2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  HighlightX2.prototype.setElementHighlight = function(el, callback) {
    if (callback(el)) {
      if (el.hasState(STATUS_UNACTIVE2)) {
        el.setState(STATUS_UNACTIVE2, false);
      }
      el.setState(STATUS_ACTIVE2, true);
    } else {
      el.setState(STATUS_UNACTIVE2, true);
      if (el.hasState(STATUS_ACTIVE2)) {
        el.setState(STATUS_ACTIVE2, false);
      }
    }
  };
  HighlightX2.prototype.setStateByElement = function(element, enable) {
    var view = this.context.view;
    var scale5 = view.getXScale();
    var value = getElementValue(element, scale5.field);
    var elements = getElements(view);
    var highlightElements = elements.filter(function(el) {
      return getElementValue(el, scale5.field) === value;
    });
    this.setHighlightBy(elements, function(el) {
      return highlightElements.includes(el);
    }, enable);
  };
  HighlightX2.prototype.toggle = function() {
    var element = getCurrentElement(this.context);
    if (element) {
      var hasState = element.hasState(this.stateName);
      this.setStateByElement(element, !hasState);
    }
  };
  return HighlightX2;
}(highlight_default);
var highlight_by_x_default = HighlightX;

// node_modules/@antv/g2/esm/interaction/action/element/range-highlight.js
var EVENTS2;
(function(EVENTS4) {
  EVENTS4["BEFORE_HIGHLIGHT"] = "element-range-highlight:beforehighlight";
  EVENTS4["AFTER_HIGHLIGHT"] = "element-range-highlight:afterhighlight";
  EVENTS4["BEFORE_CLEAR"] = "element-range-highlight:beforeclear";
  EVENTS4["AFTER_CLEAR"] = "element-range-highlight:afterclear";
})(EVENTS2 || (EVENTS2 = {}));
var ElementRangeHighlight = function(_super) {
  __extends(ElementRangeHighlight2, _super);
  function ElementRangeHighlight2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = "active";
    return _this;
  }
  ElementRangeHighlight2.prototype.clearViewState = function(view) {
    clearHighlight(view);
  };
  ElementRangeHighlight2.prototype.highlight = function() {
    var _a3 = this.context, view = _a3.view, event = _a3.event;
    var elements = this.getIntersectElements();
    var payload = { view, event, highlightElements: elements };
    view.emit(EVENTS2.BEFORE_HIGHLIGHT, event_default.fromData(view, EVENTS2.BEFORE_HIGHLIGHT, payload));
    this.setState();
    view.emit(EVENTS2.AFTER_HIGHLIGHT, event_default.fromData(view, EVENTS2.AFTER_HIGHLIGHT, payload));
  };
  ElementRangeHighlight2.prototype.clear = function() {
    var view = this.context.view;
    view.emit(EVENTS2.BEFORE_CLEAR, event_default.fromData(view, EVENTS2.BEFORE_CLEAR, {}));
    _super.prototype.clear.call(this);
    view.emit(EVENTS2.AFTER_CLEAR, event_default.fromData(view, EVENTS2.AFTER_CLEAR, {}));
  };
  ElementRangeHighlight2.prototype.setElementsState = function(elements, enable, allElements) {
    setHighlightBy(allElements, function(el) {
      return elements.indexOf(el) >= 0;
    }, enable);
  };
  return ElementRangeHighlight2;
}(range_state_default);
var range_highlight_default = ElementRangeHighlight;

// node_modules/@antv/g2/esm/interaction/action/element/single-highlight.js
var ElementSingleHighlight = function(_super) {
  __extends(ElementSingleHighlight2, _super);
  function ElementSingleHighlight2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = "active";
    return _this;
  }
  ElementSingleHighlight2.prototype.highlight = function() {
    this.setState();
  };
  ElementSingleHighlight2.prototype.setElementState = function(element, enable) {
    var view = this.context.view;
    var elements = getElements(view);
    setHighlightBy(elements, function(el) {
      return element === el;
    }, enable);
  };
  ElementSingleHighlight2.prototype.clear = function() {
    var view = this.context.view;
    clearHighlight(view);
  };
  return ElementSingleHighlight2;
}(single_state_default);
var single_highlight_default = ElementSingleHighlight;

// node_modules/@antv/g2/esm/interaction/action/element/range-selected.js
var ElementRangeSelected = function(_super) {
  __extends(ElementRangeSelected2, _super);
  function ElementRangeSelected2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = "selected";
    return _this;
  }
  ElementRangeSelected2.prototype.selected = function() {
    this.setState();
  };
  return ElementRangeSelected2;
}(range_state_default);
var range_selected_default = ElementRangeSelected;

// node_modules/@antv/g2/esm/interaction/action/element/selected.js
var ElementMultipleSelected = function(_super) {
  __extends(ElementMultipleSelected2, _super);
  function ElementMultipleSelected2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = "selected";
    return _this;
  }
  ElementMultipleSelected2.prototype.selected = function() {
    this.setState();
  };
  return ElementMultipleSelected2;
}(state_default);
var selected_default = ElementMultipleSelected;

// node_modules/@antv/g2/esm/interaction/action/element/single-selected.js
var ElementSingleSelected = function(_super) {
  __extends(ElementSingleSelected2, _super);
  function ElementSingleSelected2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = "selected";
    return _this;
  }
  ElementSingleSelected2.prototype.selected = function() {
    this.setState();
  };
  return ElementSingleSelected2;
}(single_state_default);
var single_selected_default = ElementSingleSelected;

// node_modules/@antv/g2/esm/interaction/action/component/list-state.js
var ListState = function(_super) {
  __extends(ListState2, _super);
  function ListState2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = "";
    _this.ignoreItemStates = [];
    return _this;
  }
  ListState2.prototype.getTriggerListInfo = function() {
    var delegateObject = getDelegationObject(this.context);
    var info = null;
    if (isList(delegateObject)) {
      info = {
        item: delegateObject.item,
        list: delegateObject.component
      };
    }
    return info;
  };
  ListState2.prototype.getAllowComponents = function() {
    var _this = this;
    var view = this.context.view;
    var components = getComponents(view);
    var rst = [];
    each_default(components, function(component) {
      if (component.isList() && _this.allowSetStateByElement(component)) {
        rst.push(component);
      }
    });
    return rst;
  };
  ListState2.prototype.hasState = function(list, item) {
    return list.hasState(item, this.stateName);
  };
  ListState2.prototype.clearAllComponentsState = function() {
    var _this = this;
    var components = this.getAllowComponents();
    each_default(components, function(component) {
      component.clearItemsState(_this.stateName);
    });
  };
  ListState2.prototype.allowSetStateByElement = function(component) {
    var field = component.get("field");
    if (!field) {
      return false;
    }
    if (this.cfg && this.cfg.componentNames) {
      var name_1 = component.get("name");
      if (this.cfg.componentNames.indexOf(name_1) === -1) {
        return false;
      }
    }
    var view = this.context.view;
    var scale5 = getScaleByField(view, field);
    return scale5 && scale5.isCategory;
  };
  ListState2.prototype.allowSetStateByItem = function(item, list) {
    var ignoreStates = this.ignoreItemStates;
    if (ignoreStates.length) {
      var filterStates = ignoreStates.filter(function(state) {
        return list.hasState(item, state);
      });
      return filterStates.length === 0;
    }
    return true;
  };
  ListState2.prototype.setStateByElement = function(component, element, enable) {
    var field = component.get("field");
    var view = this.context.view;
    var scale5 = getScaleByField(view, field);
    var value = getElementValue(element, field);
    var text = scale5.getText(value);
    this.setItemsState(component, text, enable);
  };
  ListState2.prototype.setStateEnable = function(enable) {
    var _this = this;
    var element = getCurrentElement(this.context);
    if (element) {
      var components = this.getAllowComponents();
      each_default(components, function(component2) {
        _this.setStateByElement(component2, element, enable);
      });
    } else {
      var delegateObject = getDelegationObject(this.context);
      if (isList(delegateObject)) {
        var item = delegateObject.item, component = delegateObject.component;
        if (this.allowSetStateByElement(component) && this.allowSetStateByItem(item, component)) {
          this.setItemState(component, item, enable);
        }
      }
    }
  };
  ListState2.prototype.setItemsState = function(list, name, enable) {
    var _this = this;
    var items = list.getItems();
    each_default(items, function(item) {
      if (item.name === name) {
        _this.setItemState(list, item, enable);
      }
    });
  };
  ListState2.prototype.setItemState = function(list, item, enable) {
    list.setItemState(item, this.stateName, enable);
  };
  ListState2.prototype.setState = function() {
    this.setStateEnable(true);
  };
  ListState2.prototype.reset = function() {
    this.setStateEnable(false);
  };
  ListState2.prototype.toggle = function() {
    var triggerInfo = this.getTriggerListInfo();
    if (triggerInfo && triggerInfo.item) {
      var list = triggerInfo.list, item = triggerInfo.item;
      var enable = this.hasState(list, item);
      this.setItemState(list, item, !enable);
    }
  };
  ListState2.prototype.clear = function() {
    var triggerInfo = this.getTriggerListInfo();
    if (triggerInfo) {
      triggerInfo.list.clearItemsState(this.stateName);
    } else {
      this.clearAllComponentsState();
    }
  };
  return ListState2;
}(base_default12);
var list_state_default = ListState;

// node_modules/@antv/g2/esm/interaction/action/component/list-active.js
var ListActive = function(_super) {
  __extends(ListActive2, _super);
  function ListActive2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = "active";
    return _this;
  }
  ListActive2.prototype.active = function() {
    this.setState();
  };
  return ListActive2;
}(list_state_default);
var list_active_default = ListActive;

// node_modules/@antv/g2/esm/interaction/action/component/list-highlight-util.js
var STATUS_UNACTIVE3 = "inactive";
var STATUS_ACTIVE3 = "active";
function clearList(list) {
  var items = list.getItems();
  each_default(items, function(item) {
    if (list.hasState(item, STATUS_ACTIVE3)) {
      list.setItemState(item, STATUS_ACTIVE3, false);
    }
    if (list.hasState(item, STATUS_UNACTIVE3)) {
      list.setItemState(item, STATUS_UNACTIVE3, false);
    }
  });
}

// node_modules/@antv/g2/esm/interaction/action/component/list-highlight.js
var STATUS_UNACTIVE4 = "inactive";
var STATUS_ACTIVE4 = "active";
var ListHighlight = function(_super) {
  __extends(ListHighlight2, _super);
  function ListHighlight2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = STATUS_ACTIVE4;
    _this.ignoreItemStates = ["unchecked"];
    return _this;
  }
  ListHighlight2.prototype.setItemsState = function(list, name, enable) {
    this.setHighlightBy(list, function(item) {
      return item.name === name;
    }, enable);
  };
  ListHighlight2.prototype.setItemState = function(list, item, enable) {
    var items = list.getItems();
    this.setHighlightBy(list, function(el) {
      return el === item;
    }, enable);
  };
  ListHighlight2.prototype.setHighlightBy = function(list, callback, enable) {
    var items = list.getItems();
    if (enable) {
      each_default(items, function(item) {
        if (callback(item)) {
          if (list.hasState(item, STATUS_UNACTIVE4)) {
            list.setItemState(item, STATUS_UNACTIVE4, false);
          }
          list.setItemState(item, STATUS_ACTIVE4, true);
        } else if (!list.hasState(item, STATUS_ACTIVE4)) {
          list.setItemState(item, STATUS_UNACTIVE4, true);
        }
      });
    } else {
      var activeItems = list.getItemsByState(STATUS_ACTIVE4);
      var allCancel_1 = true;
      each_default(activeItems, function(item) {
        if (!callback(item)) {
          allCancel_1 = false;
          return false;
        }
      });
      if (allCancel_1) {
        this.clear();
      } else {
        each_default(items, function(item) {
          if (callback(item)) {
            if (list.hasState(item, STATUS_ACTIVE4)) {
              list.setItemState(item, STATUS_ACTIVE4, false);
            }
            list.setItemState(item, STATUS_UNACTIVE4, true);
          }
        });
      }
    }
  };
  ListHighlight2.prototype.highlight = function() {
    this.setState();
  };
  ListHighlight2.prototype.clear = function() {
    var triggerInfo = this.getTriggerListInfo();
    if (triggerInfo) {
      clearList(triggerInfo.list);
    } else {
      var components = this.getAllowComponents();
      each_default(components, function(component) {
        component.clearItemsState(STATUS_ACTIVE4);
        component.clearItemsState(STATUS_UNACTIVE4);
      });
    }
  };
  return ListHighlight2;
}(list_state_default);
var list_highlight_default = ListHighlight;

// node_modules/@antv/g2/esm/interaction/action/component/list-selected.js
var ListSelected = function(_super) {
  __extends(ListSelected2, _super);
  function ListSelected2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = "selected";
    return _this;
  }
  ListSelected2.prototype.selected = function() {
    this.setState();
  };
  return ListSelected2;
}(list_state_default);
var list_selected_default = ListSelected;

// node_modules/@antv/g2/esm/interaction/action/component/list-unchecked.js
var ListUnchecked = function(_super) {
  __extends(ListUnchecked2, _super);
  function ListUnchecked2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = "unchecked";
    return _this;
  }
  ListUnchecked2.prototype.unchecked = function() {
    this.setState();
  };
  return ListUnchecked2;
}(list_state_default);
var list_unchecked_default = ListUnchecked;

// node_modules/@antv/g2/esm/interaction/action/component/list-checked.js
var STATUS_UNCHECKED = "unchecked";
var STATUS_CHECKED = "checked";
var ListChecked = function(_super) {
  __extends(ListChecked2, _super);
  function ListChecked2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = STATUS_CHECKED;
    return _this;
  }
  ListChecked2.prototype.setItemState = function(list, item, enable) {
    this.setCheckedBy(list, function(el) {
      return el === item;
    }, enable);
  };
  ListChecked2.prototype.setCheckedBy = function(list, callback, enable) {
    var items = list.getItems();
    if (enable) {
      each_default(items, function(item) {
        if (callback(item)) {
          if (list.hasState(item, STATUS_UNCHECKED)) {
            list.setItemState(item, STATUS_UNCHECKED, false);
          }
          list.setItemState(item, STATUS_CHECKED, true);
        } else if (!list.hasState(item, STATUS_CHECKED)) {
          list.setItemState(item, STATUS_UNCHECKED, true);
        }
      });
    }
  };
  ListChecked2.prototype.toggle = function() {
    var triggerInfo = this.getTriggerListInfo();
    if (triggerInfo && triggerInfo.item) {
      var list_1 = triggerInfo.list, item = triggerInfo.item;
      var allChecked = !some_default(list_1.getItems(), function(t) {
        return list_1.hasState(t, STATUS_UNCHECKED);
      });
      if (allChecked || list_1.hasState(item, STATUS_UNCHECKED)) {
        this.setItemState(list_1, item, true);
      } else {
        this.reset();
      }
    }
  };
  ListChecked2.prototype.checked = function() {
    this.setState();
  };
  ListChecked2.prototype.reset = function() {
    var components = this.getAllowComponents();
    each_default(components, function(component) {
      component.clearItemsState(STATUS_CHECKED);
      component.clearItemsState(STATUS_UNCHECKED);
    });
  };
  return ListChecked2;
}(list_state_default);
var list_checked_default = ListChecked;

// node_modules/@antv/g2/esm/interaction/action/component/list-focus.js
var STATUS_UNCHECKED2 = "unchecked";
var ListFocus = function(_super) {
  __extends(ListFocus2, _super);
  function ListFocus2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ListFocus2.prototype.toggle = function() {
    var e_1, _a3, e_2, _b, e_3, _c, e_4, _d;
    var triggerInfo = this.getTriggerListInfo();
    if (triggerInfo === null || triggerInfo === void 0 ? void 0 : triggerInfo.item) {
      var list_1 = triggerInfo.list, clickedItem = triggerInfo.item;
      var items = list_1.getItems();
      var checkedItems = items.filter(function(t) {
        return !list_1.hasState(t, STATUS_UNCHECKED2);
      });
      var uncheckedItems = items.filter(function(t) {
        return list_1.hasState(t, STATUS_UNCHECKED2);
      });
      var checkedItem = checkedItems[0];
      if (items.length === checkedItems.length) {
        try {
          for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
            var item = items_1_1.value;
            list_1.setItemState(item, STATUS_UNCHECKED2, item.id !== clickedItem.id);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (items_1_1 && !items_1_1.done && (_a3 = items_1.return))
              _a3.call(items_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      } else if (items.length - uncheckedItems.length === 1) {
        if (checkedItem.id === clickedItem.id) {
          try {
            for (var items_2 = __values(items), items_2_1 = items_2.next(); !items_2_1.done; items_2_1 = items_2.next()) {
              var item = items_2_1.value;
              list_1.setItemState(item, STATUS_UNCHECKED2, false);
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (items_2_1 && !items_2_1.done && (_b = items_2.return))
                _b.call(items_2);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
        } else {
          try {
            for (var items_3 = __values(items), items_3_1 = items_3.next(); !items_3_1.done; items_3_1 = items_3.next()) {
              var item = items_3_1.value;
              list_1.setItemState(item, STATUS_UNCHECKED2, item.id !== clickedItem.id);
            }
          } catch (e_3_1) {
            e_3 = { error: e_3_1 };
          } finally {
            try {
              if (items_3_1 && !items_3_1.done && (_c = items_3.return))
                _c.call(items_3);
            } finally {
              if (e_3)
                throw e_3.error;
            }
          }
        }
      } else {
        try {
          for (var items_4 = __values(items), items_4_1 = items_4.next(); !items_4_1.done; items_4_1 = items_4.next()) {
            var item = items_4_1.value;
            list_1.setItemState(item, STATUS_UNCHECKED2, item.id !== clickedItem.id);
          }
        } catch (e_4_1) {
          e_4 = { error: e_4_1 };
        } finally {
          try {
            if (items_4_1 && !items_4_1.done && (_d = items_4.return))
              _d.call(items_4);
          } finally {
            if (e_4)
              throw e_4.error;
          }
        }
      }
    }
  };
  return ListFocus2;
}(list_state_default);
var list_focus_default = ListFocus;

// node_modules/@antv/g2/esm/interaction/action/component/list-radio.js
var STATUS_SHOW = "showRadio";
var TIP_ID = "legend-radio-tip";
var ListRadio = function(_super) {
  __extends(ListRadio2, _super);
  function ListRadio2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.timeStamp = 0;
    return _this;
  }
  ListRadio2.prototype.show = function() {
    var triggerInfo = this.getTriggerListInfo();
    if (triggerInfo === null || triggerInfo === void 0 ? void 0 : triggerInfo.item) {
      var list = triggerInfo.list, item = triggerInfo.item;
      list.setItemState(item, STATUS_SHOW, true);
    }
  };
  ListRadio2.prototype.hide = function() {
    var triggerInfo = this.getTriggerListInfo();
    if (triggerInfo === null || triggerInfo === void 0 ? void 0 : triggerInfo.item) {
      var list = triggerInfo.list, item = triggerInfo.item;
      list.setItemState(item, STATUS_SHOW, false);
    }
  };
  ListRadio2.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    this.tooltip && this.tooltip.destroy();
  };
  ListRadio2.prototype.showTip = function() {
    var context = this.context;
    var ev = context.event;
    var lastTimeStamp = this.timeStamp;
    var timeStamp = +new Date();
    var target = this.context.event.target;
    if (timeStamp - lastTimeStamp > 16 && target.get("name") === "legend-item-radio") {
      var preLoc = this.location;
      var curLoc = { x: ev.x, y: ev.y };
      this.timeStamp = timeStamp;
      this.location = curLoc;
      if (!preLoc || !is_equal_default(preLoc, curLoc)) {
        this.showTooltip(curLoc);
      }
    }
  };
  ListRadio2.prototype.hideTip = function() {
    this.hideTooltip();
    this.location = null;
  };
  ListRadio2.prototype.showTooltip = function(curLoc) {
    var context = this.context;
    var ev = context.event;
    var target = ev.target;
    if (target && target.get("tip")) {
      if (!this.tooltip) {
        this.renderTooltip();
      }
      var _a3 = context.view.getCanvas().get("el").getBoundingClientRect(), offsetX = _a3.x, offsetY = _a3.y;
      this.tooltip.update(__assign(__assign({ title: target.get("tip") }, curLoc), { x: curLoc.x + offsetX, y: curLoc.y + offsetY }));
      this.tooltip.show();
    }
  };
  ListRadio2.prototype.hideTooltip = function() {
    this.tooltip && this.tooltip.hide();
  };
  ListRadio2.prototype.renderTooltip = function() {
    var _a3;
    var tooltipStyles = (_a3 = {}, _a3[css_const_exports2.CONTAINER_CLASS] = {
      padding: "6px 8px",
      transform: "translate(-50%, -80%)",
      background: "rgba(0,0,0,0.75)",
      color: "#fff",
      "border-radius": "2px",
      "z-index": 100
    }, _a3[css_const_exports2.TITLE_CLASS] = {
      "font-size": "12px",
      "line-height": "14px",
      "margin-bottom": 0,
      "word-break": "break-all"
    }, _a3);
    if (document.getElementById(TIP_ID)) {
      document.body.removeChild(document.getElementById(TIP_ID));
    }
    var tooltip = new HtmlTooltip({
      parent: document.body,
      region: null,
      visible: false,
      crosshairs: null,
      domStyles: tooltipStyles,
      containerId: TIP_ID
    });
    tooltip.init();
    tooltip.setCapture(false);
    this.tooltip = tooltip;
  };
  return ListRadio2;
}(list_state_default);
var list_radio_default = ListRadio;

// node_modules/@antv/g2/esm/interaction/action/mask/base.js
var MaskBase = function(_super) {
  __extends(MaskBase2, _super);
  function MaskBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.maskShape = null;
    _this.points = [];
    _this.starting = false;
    _this.moving = false;
    _this.preMovePoint = null;
    _this.shapeType = "path";
    return _this;
  }
  MaskBase2.prototype.getCurrentPoint = function() {
    var event = this.context.event;
    return {
      x: event.x,
      y: event.y
    };
  };
  MaskBase2.prototype.emitEvent = function(type) {
    var eventName = "mask:".concat(type);
    var view = this.context.view;
    var event = this.context.event;
    view.emit(eventName, {
      target: this.maskShape,
      shape: this.maskShape,
      points: this.points,
      x: event.x,
      y: event.y
    });
  };
  MaskBase2.prototype.createMask = function() {
    var view = this.context.view;
    var maskAttrs = this.getMaskAttrs();
    var maskShape = view.foregroundGroup.addShape({
      type: this.shapeType,
      name: "mask",
      draggable: true,
      attrs: __assign({ fill: "#C5D4EB", opacity: 0.3 }, maskAttrs)
    });
    return maskShape;
  };
  MaskBase2.prototype.getMaskPath = function() {
    return [];
  };
  MaskBase2.prototype.show = function() {
    if (this.maskShape) {
      this.maskShape.show();
      this.emitEvent("show");
    }
  };
  MaskBase2.prototype.start = function(arg) {
    this.starting = true;
    this.moving = false;
    this.points = [this.getCurrentPoint()];
    if (!this.maskShape) {
      this.maskShape = this.createMask();
      this.maskShape.set("capture", false);
    }
    this.updateMask(arg === null || arg === void 0 ? void 0 : arg.maskStyle);
    this.emitEvent("start");
  };
  MaskBase2.prototype.moveStart = function() {
    this.moving = true;
    this.preMovePoint = this.getCurrentPoint();
  };
  MaskBase2.prototype.move = function() {
    if (!this.moving || !this.maskShape) {
      return;
    }
    var currentPoint = this.getCurrentPoint();
    var preMovePoint = this.preMovePoint;
    var dx = currentPoint.x - preMovePoint.x;
    var dy = currentPoint.y - preMovePoint.y;
    var points = this.points;
    each_default(points, function(point) {
      point.x += dx;
      point.y += dy;
    });
    this.updateMask();
    this.emitEvent("change");
    this.preMovePoint = currentPoint;
  };
  MaskBase2.prototype.updateMask = function(maskStyle) {
    var attrs = deep_mix_default({}, this.getMaskAttrs(), maskStyle);
    this.maskShape.attr(attrs);
  };
  MaskBase2.prototype.moveEnd = function() {
    this.moving = false;
    this.preMovePoint = null;
  };
  MaskBase2.prototype.end = function() {
    this.starting = false;
    this.emitEvent("end");
    if (this.maskShape) {
      this.maskShape.set("capture", true);
    }
  };
  MaskBase2.prototype.hide = function() {
    if (this.maskShape) {
      this.maskShape.hide();
      this.emitEvent("hide");
    }
  };
  MaskBase2.prototype.resize = function() {
    if (this.starting && this.maskShape) {
      this.points.push(this.getCurrentPoint());
      this.updateMask();
      this.emitEvent("change");
    }
  };
  MaskBase2.prototype.destroy = function() {
    this.points = [];
    if (this.maskShape) {
      this.maskShape.remove();
    }
    this.maskShape = null;
    this.preMovePoint = null;
    _super.prototype.destroy.call(this);
  };
  return MaskBase2;
}(base_default12);
var base_default17 = MaskBase;

// node_modules/@antv/g2/esm/interaction/action/mask/circle.js
var CircleMask = function(_super) {
  __extends(CircleMask2, _super);
  function CircleMask2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.shapeType = "circle";
    return _this;
  }
  CircleMask2.prototype.getMaskAttrs = function() {
    var points = this.points;
    var currentPoint = last(this.points);
    var r = 0;
    var x = 0;
    var y = 0;
    if (points.length) {
      var first = points[0];
      r = distance6(first, currentPoint) / 2;
      x = (currentPoint.x + first.x) / 2;
      y = (currentPoint.y + first.y) / 2;
    }
    return {
      x,
      y,
      r
    };
  };
  return CircleMask2;
}(base_default17);
var circle_default8 = CircleMask;

// node_modules/@antv/g2/esm/interaction/action/mask/rect.js
var RectMask = function(_super) {
  __extends(RectMask2, _super);
  function RectMask2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.shapeType = "rect";
    return _this;
  }
  RectMask2.prototype.getRegion = function() {
    var points = this.points;
    return {
      start: head(points),
      end: last(points)
    };
  };
  RectMask2.prototype.getMaskAttrs = function() {
    var _a3 = this.getRegion(), start = _a3.start, end = _a3.end;
    var x = Math.min(start.x, end.x);
    var y = Math.min(start.y, end.y);
    var width = Math.abs(end.x - start.x);
    var height = Math.abs(end.y - start.y);
    return {
      x,
      y,
      width,
      height
    };
  };
  return RectMask2;
}(base_default17);
var rect_default5 = RectMask;

// node_modules/@antv/g2/esm/interaction/action/mask/dim-rect.js
function clampPoint(point) {
  point.x = clamp_default(point.x, 0, 1);
  point.y = clamp_default(point.y, 0, 1);
}
var DimRect = function(_super) {
  __extends(DimRect2, _super);
  function DimRect2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.dim = "x";
    _this.inPlot = true;
    return _this;
  }
  DimRect2.prototype.getRegion = function() {
    var start = null;
    var end = null;
    var points = this.points;
    var dim = this.dim;
    var coord = this.context.view.getCoordinate();
    var normalStart = coord.invert(head(points));
    var normalEnd = coord.invert(last(points));
    if (this.inPlot) {
      clampPoint(normalStart);
      clampPoint(normalEnd);
    }
    if (dim === "x") {
      start = coord.convert({
        x: normalStart.x,
        y: 0
      });
      end = coord.convert({
        x: normalEnd.x,
        y: 1
      });
    } else {
      start = coord.convert({
        x: 0,
        y: normalStart.y
      });
      end = coord.convert({
        x: 1,
        y: normalEnd.y
      });
    }
    return {
      start,
      end
    };
  };
  return DimRect2;
}(rect_default5);
var dim_rect_default = DimRect;

// node_modules/@antv/g2/esm/interaction/action/mask/path.js
var PathMask = function(_super) {
  __extends(PathMask2, _super);
  function PathMask2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  PathMask2.prototype.getMaskPath = function() {
    var points = this.points;
    var path = [];
    if (points.length) {
      each_default(points, function(point, index) {
        if (index === 0) {
          path.push(["M", point.x, point.y]);
        } else {
          path.push(["L", point.x, point.y]);
        }
      });
      path.push(["L", points[0].x, points[0].y]);
    }
    return path;
  };
  PathMask2.prototype.getMaskAttrs = function() {
    return {
      path: this.getMaskPath()
    };
  };
  PathMask2.prototype.addPoint = function() {
    this.resize();
  };
  return PathMask2;
}(base_default17);
var path_default6 = PathMask;

// node_modules/@antv/g2/esm/interaction/action/mask/smooth-path.js
var SmoothPathMask = function(_super) {
  __extends(SmoothPathMask2, _super);
  function SmoothPathMask2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  SmoothPathMask2.prototype.getMaskPath = function() {
    var points = this.points;
    return getSpline(points, true);
  };
  return SmoothPathMask2;
}(path_default6);
var smooth_path_default = SmoothPathMask;

// node_modules/@antv/g2/esm/interaction/action/cursor.js
var CursorAction = function(_super) {
  __extends(CursorAction2, _super);
  function CursorAction2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  CursorAction2.prototype.setCursor = function(cursor) {
    var view = this.context.view;
    view.getCanvas().setCursor(cursor);
  };
  CursorAction2.prototype.default = function() {
    this.setCursor("default");
  };
  CursorAction2.prototype.pointer = function() {
    this.setCursor("pointer");
  };
  CursorAction2.prototype.move = function() {
    this.setCursor("move");
  };
  CursorAction2.prototype.crosshair = function() {
    this.setCursor("crosshair");
  };
  CursorAction2.prototype.wait = function() {
    this.setCursor("wait");
  };
  CursorAction2.prototype.help = function() {
    this.setCursor("help");
  };
  CursorAction2.prototype.text = function() {
    this.setCursor("text");
  };
  CursorAction2.prototype.eResize = function() {
    this.setCursor("e-resize");
  };
  CursorAction2.prototype.wResize = function() {
    this.setCursor("w-resize");
  };
  CursorAction2.prototype.nResize = function() {
    this.setCursor("n-resize");
  };
  CursorAction2.prototype.sResize = function() {
    this.setCursor("s-resize");
  };
  CursorAction2.prototype.neResize = function() {
    this.setCursor("ne-resize");
  };
  CursorAction2.prototype.nwResize = function() {
    this.setCursor("nw-resize");
  };
  CursorAction2.prototype.seResize = function() {
    this.setCursor("se-resize");
  };
  CursorAction2.prototype.swResize = function() {
    this.setCursor("sw-resize");
  };
  CursorAction2.prototype.nsResize = function() {
    this.setCursor("ns-resize");
  };
  CursorAction2.prototype.ewResize = function() {
    this.setCursor("ew-resize");
  };
  CursorAction2.prototype.zoomIn = function() {
    this.setCursor("zoom-in");
  };
  CursorAction2.prototype.zoomOut = function() {
    this.setCursor("zoom-out");
  };
  return CursorAction2;
}(base_default12);
var cursor_default = CursorAction;

// node_modules/@antv/g2/esm/interaction/action/data/filter.js
var DataFilter = function(_super) {
  __extends(DataFilter2, _super);
  function DataFilter2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  DataFilter2.prototype.filterView = function(view, field, filter2) {
    var _this = this;
    if (view.getScaleByField(field)) {
      view.filter(field, filter2);
    }
    if (view.views && view.views.length) {
      each_default(view.views, function(subView) {
        _this.filterView(subView, field, filter2);
      });
    }
  };
  DataFilter2.prototype.filter = function() {
    var delegateObject = getDelegationObject(this.context);
    if (delegateObject) {
      var view = this.context.view;
      var component = delegateObject.component;
      var field = component.get("field");
      if (isList(delegateObject)) {
        if (field) {
          var unCheckedItems = component.getItemsByState("unchecked");
          var scale_1 = getScaleByField(view, field);
          var names_1 = unCheckedItems.map(function(item) {
            return item.name;
          });
          if (names_1.length) {
            this.filterView(view, field, function(value) {
              var text = scale_1.getText(value);
              return !names_1.includes(text);
            });
          } else {
            this.filterView(view, field, null);
          }
          view.render(true);
        }
      } else if (isSlider(delegateObject)) {
        var range = component.getValue();
        var _a3 = __read(range, 2), min_1 = _a3[0], max_1 = _a3[1];
        this.filterView(view, field, function(value) {
          return value >= min_1 && value <= max_1;
        });
        view.render(true);
      }
    }
  };
  return DataFilter2;
}(base_default12);
var filter_default2 = DataFilter;

// node_modules/@antv/g2/esm/interaction/action/data/range-filter.js
function getFilter(scale5, dim, point1, point2) {
  var min3 = Math.min(point1[dim], point2[dim]);
  var max3 = Math.max(point1[dim], point2[dim]);
  var _a3 = __read(scale5.range, 2), rangeMin = _a3[0], rangeMax = _a3[1];
  if (min3 < rangeMin) {
    min3 = rangeMin;
  }
  if (max3 > rangeMax) {
    max3 = rangeMax;
  }
  if (min3 === rangeMax && max3 === rangeMax) {
    return null;
  }
  var minValue = scale5.invert(min3);
  var maxValue = scale5.invert(max3);
  if (scale5.isCategory) {
    var minIndex = scale5.values.indexOf(minValue);
    var maxIndex = scale5.values.indexOf(maxValue);
    var arr_1 = scale5.values.slice(minIndex, maxIndex + 1);
    return function(value) {
      return arr_1.includes(value);
    };
  } else {
    return function(value) {
      return value >= minValue && value <= maxValue;
    };
  }
}
var EVENTS3;
(function(EVENTS4) {
  EVENTS4["FILTER"] = "brush-filter-processing";
  EVENTS4["RESET"] = "brush-filter-reset";
  EVENTS4["BEFORE_FILTER"] = "brush-filter:beforefilter";
  EVENTS4["AFTER_FILTER"] = "brush-filter:afterfilter";
  EVENTS4["BEFORE_RESET"] = "brush-filter:beforereset";
  EVENTS4["AFTER_RESET"] = "brush-filter:afterreset";
})(EVENTS3 || (EVENTS3 = {}));
var RangeFilter = function(_super) {
  __extends(RangeFilter2, _super);
  function RangeFilter2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.dims = ["x", "y"];
    _this.startPoint = null;
    _this.isStarted = false;
    return _this;
  }
  RangeFilter2.prototype.hasDim = function(dim) {
    return this.dims.includes(dim);
  };
  RangeFilter2.prototype.start = function() {
    var context = this.context;
    this.isStarted = true;
    this.startPoint = context.getCurrentPoint();
  };
  RangeFilter2.prototype.filter = function() {
    var startPoint;
    var currentPoint;
    if (isMask(this.context)) {
      var maskShape = this.context.event.target;
      var bbox = maskShape.getCanvasBBox();
      startPoint = { x: bbox.x, y: bbox.y };
      currentPoint = { x: bbox.maxX, y: bbox.maxY };
    } else {
      if (!this.isStarted) {
        return;
      }
      startPoint = this.startPoint;
      currentPoint = this.context.getCurrentPoint();
    }
    if (Math.abs(startPoint.x - currentPoint.x) < 5 || Math.abs(startPoint.x - currentPoint.y) < 5) {
      return;
    }
    var _a3 = this.context, view = _a3.view, event = _a3.event;
    var payload = { view, event, dims: this.dims };
    view.emit(EVENTS3.BEFORE_FILTER, event_default.fromData(view, EVENTS3.BEFORE_FILTER, payload));
    var coord = view.getCoordinate();
    var normalCurrent = coord.invert(currentPoint);
    var normalStart = coord.invert(startPoint);
    if (this.hasDim("x")) {
      var xScale = view.getXScale();
      var filter2 = getFilter(xScale, "x", normalCurrent, normalStart);
      this.filterView(view, xScale.field, filter2);
    }
    if (this.hasDim("y")) {
      var yScale = view.getYScales()[0];
      var filter2 = getFilter(yScale, "y", normalCurrent, normalStart);
      this.filterView(view, yScale.field, filter2);
    }
    this.reRender(view, { source: EVENTS3.FILTER });
    view.emit(EVENTS3.AFTER_FILTER, event_default.fromData(view, EVENTS3.AFTER_FILTER, payload));
  };
  RangeFilter2.prototype.end = function() {
    this.isStarted = false;
  };
  RangeFilter2.prototype.reset = function() {
    var view = this.context.view;
    view.emit(EVENTS3.BEFORE_RESET, event_default.fromData(view, EVENTS3.BEFORE_RESET, {}));
    this.isStarted = false;
    if (this.hasDim("x")) {
      var xScale = view.getXScale();
      this.filterView(view, xScale.field, null);
    }
    if (this.hasDim("y")) {
      var yScale = view.getYScales()[0];
      this.filterView(view, yScale.field, null);
    }
    this.reRender(view, { source: EVENTS3.RESET });
    view.emit(EVENTS3.AFTER_RESET, event_default.fromData(view, EVENTS3.AFTER_RESET, {}));
  };
  RangeFilter2.prototype.filterView = function(view, field, filter2) {
    view.filter(field, filter2);
  };
  RangeFilter2.prototype.reRender = function(view, payload) {
    view.render(true, payload);
  };
  return RangeFilter2;
}(base_default12);
var range_filter_default = RangeFilter;

// node_modules/@antv/g2/esm/interaction/action/data/sibling-filter.js
var SiblingFilter = function(_super) {
  __extends(SiblingFilter3, _super);
  function SiblingFilter3() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  SiblingFilter3.prototype.filterView = function(view, field, filter2) {
    var siblings = getSilbings(view);
    each_default(siblings, function(sibling) {
      sibling.filter(field, filter2);
    });
  };
  SiblingFilter3.prototype.reRender = function(view) {
    var siblings = getSilbings(view);
    each_default(siblings, function(sibling) {
      sibling.render(true);
    });
  };
  return SiblingFilter3;
}(range_filter_default);
var sibling_filter_default = SiblingFilter;

// node_modules/@antv/g2/esm/interaction/action/element/filter.js
var ElementFilter = function(_super) {
  __extends(ElementFilter2, _super);
  function ElementFilter2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ElementFilter2.prototype.filter = function() {
    var delegateObject = getDelegationObject(this.context);
    var view = this.context.view;
    var elements = getElements(view);
    if (isMask(this.context)) {
      var maskElements_1 = getMaskedElements(this.context, 10);
      if (maskElements_1) {
        each_default(elements, function(el) {
          if (maskElements_1.includes(el)) {
            el.show();
          } else {
            el.hide();
          }
        });
      }
    } else if (delegateObject) {
      var component = delegateObject.component;
      var field_1 = component.get("field");
      if (isList(delegateObject)) {
        if (field_1) {
          var unCheckedItems = component.getItemsByState("unchecked");
          var scale_1 = getScaleByField(view, field_1);
          var names_1 = unCheckedItems.map(function(item) {
            return item.name;
          });
          each_default(elements, function(el) {
            var value = getElementValue(el, field_1);
            var text = scale_1.getText(value);
            if (names_1.indexOf(text) >= 0) {
              el.hide();
            } else {
              el.show();
            }
          });
        }
      } else if (isSlider(delegateObject)) {
        var range = component.getValue();
        var _a3 = __read(range, 2), min_1 = _a3[0], max_1 = _a3[1];
        each_default(elements, function(el) {
          var value = getElementValue(el, field_1);
          if (value >= min_1 && value <= max_1) {
            el.show();
          } else {
            el.hide();
          }
        });
      }
    }
  };
  ElementFilter2.prototype.clear = function() {
    var elements = getElements(this.context.view);
    each_default(elements, function(el) {
      el.show();
    });
  };
  ElementFilter2.prototype.reset = function() {
    this.clear();
  };
  return ElementFilter2;
}(base_default12);
var filter_default3 = ElementFilter;

// node_modules/@antv/g2/esm/interaction/action/element/sibling-filter.js
var SiblingFilter2 = function(_super) {
  __extends(SiblingFilter3, _super);
  function SiblingFilter3() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.byRecord = false;
    return _this;
  }
  SiblingFilter3.prototype.filter = function() {
    if (isMask(this.context)) {
      if (this.byRecord) {
        this.filterByRecord();
      } else {
        this.filterByBBox();
      }
    }
  };
  SiblingFilter3.prototype.filterByRecord = function() {
    var view = this.context.view;
    var maskElements = getMaskedElements(this.context, 10);
    if (!maskElements) {
      return;
    }
    var xFiled = view.getXScale().field;
    var yField = view.getYScales()[0].field;
    var records = maskElements.map(function(el) {
      return el.getModel().data;
    });
    var siblings = getSilbings(view);
    each_default(siblings, function(sibling) {
      var elements = getElements(sibling);
      each_default(elements, function(el) {
        var record = el.getModel().data;
        if (isInRecords(records, record, xFiled, yField)) {
          el.show();
        } else {
          el.hide();
        }
      });
    });
  };
  SiblingFilter3.prototype.filterByBBox = function() {
    var _this = this;
    var view = this.context.view;
    var siblings = getSilbings(view);
    each_default(siblings, function(sibling) {
      var maskElements = getSiblingMaskElements(_this.context, sibling, 10);
      var elements = getElements(sibling);
      if (maskElements) {
        each_default(elements, function(el) {
          if (maskElements.includes(el)) {
            el.show();
          } else {
            el.hide();
          }
        });
      }
    });
  };
  SiblingFilter3.prototype.reset = function() {
    var siblings = getSilbings(this.context.view);
    each_default(siblings, function(sibling) {
      var elements = getElements(sibling);
      each_default(elements, function(el) {
        el.show();
      });
    });
  };
  return SiblingFilter3;
}(base_default12);
var sibling_filter_default2 = SiblingFilter2;

// node_modules/@antv/g2/esm/interaction/action/view/button.js
var PADDING_RIGHT = 10;
var PADDING_TOP = 5;
var ButtonAction = function(_super) {
  __extends(ButtonAction2, _super);
  function ButtonAction2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.buttonGroup = null;
    _this.buttonCfg = {
      name: "button",
      text: "button",
      textStyle: {
        x: 0,
        y: 0,
        fontSize: 12,
        fill: "#333333",
        cursor: "pointer"
      },
      padding: [8, 10],
      style: {
        fill: "#f7f7f7",
        stroke: "#cccccc",
        cursor: "pointer"
      },
      activeStyle: {
        fill: "#e6e6e6"
      }
    };
    return _this;
  }
  ButtonAction2.prototype.getButtonCfg = function() {
    return deep_mix_default(this.buttonCfg, this.cfg);
  };
  ButtonAction2.prototype.drawButton = function() {
    var config = this.getButtonCfg();
    var group2 = this.context.view.foregroundGroup.addGroup({
      name: config.name
    });
    var textShape = group2.addShape({
      type: "text",
      name: "button-text",
      attrs: __assign({ text: config.text }, config.textStyle)
    });
    var textBBox = textShape.getBBox();
    var padding = parsePadding(config.padding);
    var buttonShape = group2.addShape({
      type: "rect",
      name: "button-rect",
      attrs: __assign({ x: textBBox.x - padding[3], y: textBBox.y - padding[0], width: textBBox.width + padding[1] + padding[3], height: textBBox.height + padding[0] + padding[2] }, config.style)
    });
    buttonShape.toBack();
    group2.on("mouseenter", function() {
      buttonShape.attr(config.activeStyle);
    });
    group2.on("mouseleave", function() {
      buttonShape.attr(config.style);
    });
    this.buttonGroup = group2;
  };
  ButtonAction2.prototype.resetPosition = function() {
    var view = this.context.view;
    var coord = view.getCoordinate();
    var point = coord.convert({ x: 1, y: 1 });
    var buttonGroup = this.buttonGroup;
    var bbox = buttonGroup.getBBox();
    var matrix = ext_exports.transform(null, [
      ["t", point.x - bbox.width - PADDING_RIGHT, point.y + bbox.height + PADDING_TOP]
    ]);
    buttonGroup.setMatrix(matrix);
  };
  ButtonAction2.prototype.show = function() {
    if (!this.buttonGroup) {
      this.drawButton();
    }
    this.resetPosition();
    this.buttonGroup.show();
  };
  ButtonAction2.prototype.hide = function() {
    if (this.buttonGroup) {
      this.buttonGroup.hide();
    }
  };
  ButtonAction2.prototype.destroy = function() {
    var buttonGroup = this.buttonGroup;
    if (buttonGroup) {
      buttonGroup.remove();
    }
    _super.prototype.destroy.call(this);
  };
  return ButtonAction2;
}(base_default12);
var button_default = ButtonAction;

// node_modules/@antv/g2/esm/interaction/action/view/drag.js
var DISTANCE = 4;
var Drag = function(_super) {
  __extends(Drag2, _super);
  function Drag2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.starting = false;
    _this.dragStart = false;
    return _this;
  }
  Drag2.prototype.start = function() {
    this.starting = true;
    this.startPoint = this.context.getCurrentPoint();
  };
  Drag2.prototype.drag = function() {
    if (!this.startPoint) {
      return;
    }
    var current = this.context.getCurrentPoint();
    var view = this.context.view;
    var event = this.context.event;
    if (!this.dragStart) {
      if (distance6(current, this.startPoint) > DISTANCE) {
        view.emit("dragstart", {
          target: event.target,
          x: event.x,
          y: event.y
        });
        this.dragStart = true;
      }
    } else {
      view.emit("drag", {
        target: event.target,
        x: event.x,
        y: event.y
      });
    }
  };
  Drag2.prototype.end = function() {
    if (this.dragStart) {
      var view = this.context.view;
      var event_1 = this.context.event;
      view.emit("dragend", {
        target: event_1.target,
        x: event_1.x,
        y: event_1.y
      });
    }
    this.starting = false;
    this.dragStart = false;
  };
  return Drag2;
}(base_default12);
var drag_default = Drag;

// node_modules/@antv/g2/esm/interaction/action/view/move.js
var MIN_DISTANCE = 5;
var Move = function(_super) {
  __extends(Move2, _super);
  function Move2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.starting = false;
    _this.isMoving = false;
    _this.startPoint = null;
    _this.startMatrix = null;
    return _this;
  }
  Move2.prototype.start = function() {
    this.starting = true;
    this.startPoint = this.context.getCurrentPoint();
    this.startMatrix = this.context.view.middleGroup.getMatrix();
  };
  Move2.prototype.move = function() {
    if (!this.starting) {
      return;
    }
    var startPoint = this.startPoint;
    var currentPoint = this.context.getCurrentPoint();
    var d = distance6(startPoint, currentPoint);
    if (d > MIN_DISTANCE && !this.isMoving) {
      this.isMoving = true;
    }
    if (this.isMoving) {
      var view = this.context.view;
      var matrix = ext_exports.transform(this.startMatrix, [
        ["t", currentPoint.x - startPoint.x, currentPoint.y - startPoint.y]
      ]);
      view.backgroundGroup.setMatrix(matrix);
      view.foregroundGroup.setMatrix(matrix);
      view.middleGroup.setMatrix(matrix);
    }
  };
  Move2.prototype.end = function() {
    if (this.isMoving) {
      this.isMoving = false;
    }
    this.startMatrix = null;
    this.starting = false;
    this.startPoint = null;
  };
  Move2.prototype.reset = function() {
    this.starting = false;
    this.startPoint = null;
    this.isMoving = false;
    var view = this.context.view;
    view.backgroundGroup.resetMatrix();
    view.foregroundGroup.resetMatrix();
    view.middleGroup.resetMatrix();
    this.isMoving = false;
  };
  return Move2;
}(base_default12);
var move_default = Move;

// node_modules/@antv/g2/esm/interaction/action/view/scale-transform.js
var DIM_X = "x";
var DIM_Y = "y";
var ScaleTranslate = function(_super) {
  __extends(ScaleTranslate4, _super);
  function ScaleTranslate4() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.dims = [DIM_X, DIM_Y];
    _this.cfgFields = ["dims"];
    _this.cacheScaleDefs = {};
    return _this;
  }
  ScaleTranslate4.prototype.hasDim = function(dim) {
    return this.dims.includes(dim);
  };
  ScaleTranslate4.prototype.getScale = function(dim) {
    var view = this.context.view;
    if (dim === "x") {
      return view.getXScale();
    } else {
      return view.getYScales()[0];
    }
  };
  ScaleTranslate4.prototype.resetDim = function(dim) {
    var view = this.context.view;
    if (this.hasDim(dim) && this.cacheScaleDefs[dim]) {
      var scale5 = this.getScale(dim);
      view.scale(scale5.field, this.cacheScaleDefs[dim]);
      this.cacheScaleDefs[dim] = null;
    }
  };
  ScaleTranslate4.prototype.reset = function() {
    this.resetDim(DIM_X);
    this.resetDim(DIM_Y);
    var view = this.context.view;
    view.render(true);
  };
  return ScaleTranslate4;
}(base_default12);
var scale_transform_default = ScaleTranslate;

// node_modules/@antv/g2/esm/interaction/action/view/scale-translate.js
var ScaleTranslate2 = function(_super) {
  __extends(ScaleTranslate4, _super);
  function ScaleTranslate4() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.startPoint = null;
    _this.starting = false;
    _this.startCache = {};
    return _this;
  }
  ScaleTranslate4.prototype.start = function() {
    var _this = this;
    this.startPoint = this.context.getCurrentPoint();
    this.starting = true;
    var dims = this.dims;
    each_default(dims, function(dim) {
      var scale5 = _this.getScale(dim);
      var min3 = scale5.min, max3 = scale5.max, values2 = scale5.values;
      _this.startCache[dim] = { min: min3, max: max3, values: values2 };
    });
  };
  ScaleTranslate4.prototype.end = function() {
    this.startPoint = null;
    this.starting = false;
    this.startCache = {};
  };
  ScaleTranslate4.prototype.translate = function() {
    var _this = this;
    if (!this.starting) {
      return;
    }
    var startPoint = this.startPoint;
    var coord = this.context.view.getCoordinate();
    var currentPoint = this.context.getCurrentPoint();
    var normalStart = coord.invert(startPoint);
    var noramlCurrent = coord.invert(currentPoint);
    var dx = noramlCurrent.x - normalStart.x;
    var dy = noramlCurrent.y - normalStart.y;
    var view = this.context.view;
    var dims = this.dims;
    each_default(dims, function(dim) {
      _this.translateDim(dim, { x: dx * -1, y: dy * -1 });
    });
    view.render(true);
  };
  ScaleTranslate4.prototype.translateDim = function(dim, normalPoint) {
    if (this.hasDim(dim)) {
      var scale5 = this.getScale(dim);
      if (scale5.isLinear) {
        this.translateLinear(dim, scale5, normalPoint);
      }
    }
  };
  ScaleTranslate4.prototype.translateLinear = function(dim, scale5, normalPoint) {
    var view = this.context.view;
    var _a3 = this.startCache[dim], min3 = _a3.min, max3 = _a3.max;
    var range = max3 - min3;
    var d = normalPoint[dim] * range;
    if (!this.cacheScaleDefs[dim]) {
      this.cacheScaleDefs[dim] = {
        nice: scale5.nice,
        min: min3,
        max: max3
      };
    }
    view.scale(scale5.field, {
      nice: false,
      min: min3 + d,
      max: max3 + d
    });
  };
  ScaleTranslate4.prototype.reset = function() {
    _super.prototype.reset.call(this);
    this.startPoint = null;
    this.starting = false;
  };
  return ScaleTranslate4;
}(scale_transform_default);
var scale_translate_default = ScaleTranslate2;

// node_modules/@antv/g2/esm/interaction/action/view/scale-zoom.js
var ScaleTranslate3 = function(_super) {
  __extends(ScaleTranslate4, _super);
  function ScaleTranslate4() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.zoomRatio = 0.05;
    return _this;
  }
  ScaleTranslate4.prototype.zoomIn = function() {
    this.zoom(this.zoomRatio);
  };
  ScaleTranslate4.prototype.zoom = function(scale5) {
    var _this = this;
    var dims = this.dims;
    each_default(dims, function(dim) {
      _this.zoomDim(dim, scale5);
    });
    this.context.view.render(true);
  };
  ScaleTranslate4.prototype.zoomOut = function() {
    this.zoom(-1 * this.zoomRatio);
  };
  ScaleTranslate4.prototype.zoomDim = function(dim, dRatio) {
    if (this.hasDim(dim)) {
      var scale5 = this.getScale(dim);
      if (scale5.isLinear) {
        this.zoomLinear(dim, scale5, dRatio);
      }
    }
  };
  ScaleTranslate4.prototype.zoomLinear = function(dim, scale5, dRatio) {
    var view = this.context.view;
    if (!this.cacheScaleDefs[dim]) {
      this.cacheScaleDefs[dim] = {
        nice: scale5.nice,
        min: scale5.min,
        max: scale5.max
      };
    }
    var scaleDef = this.cacheScaleDefs[dim];
    var range = scaleDef.max - scaleDef.min;
    var min3 = scale5.min, max3 = scale5.max;
    var d = dRatio * range;
    var toMin = min3 - d;
    var toMax = max3 + d;
    var curRange = toMax - toMin;
    var scaled = curRange / range;
    if (toMax > toMin && scaled < 100 && scaled > 0.01) {
      view.scale(scale5.field, {
        nice: false,
        min: min3 - d,
        max: max3 + d
      });
    }
  };
  return ScaleTranslate4;
}(scale_transform_default);
var scale_zoom_default = ScaleTranslate3;

// node_modules/@antv/g2/esm/interaction/action/view/mousewheel-scroll.js
function isWheelDown(event) {
  var wheelEvent = event.gEvent.originalEvent;
  return wheelEvent.deltaY > 0;
}
var DEFAULT_WHEELDELTA = 1;
var MousewheelScroll = function(_super) {
  __extends(MousewheelScroll2, _super);
  function MousewheelScroll2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MousewheelScroll2.prototype.scroll = function(arg) {
    var _a3 = this.context, view = _a3.view, event = _a3.event;
    if (!view.getOptions().scrollbar) {
      return;
    }
    var wheelDelta = (arg === null || arg === void 0 ? void 0 : arg.wheelDelta) || DEFAULT_WHEELDELTA;
    var scrollbarController = view.getController("scrollbar");
    var xScale = view.getXScale();
    var data = view.getOptions().data;
    var dataSize = size(values_of_key_default(data, xScale.field));
    var step = size(xScale.values);
    var currentRatio = scrollbarController.getValue();
    var currentStart = Math.floor((dataSize - step) * currentRatio);
    var nextStart = currentStart + (isWheelDown(event) ? wheelDelta : -wheelDelta);
    var correction = wheelDelta / (dataSize - step) / 1e4;
    var nextRatio = clamp_default(nextStart / (dataSize - step) + correction, 0, 1);
    scrollbarController.setValue(nextRatio);
  };
  return MousewheelScroll2;
}(base_default12);
var mousewheel_scroll_default = MousewheelScroll;

// node_modules/@antv/g2/esm/interaction/action/component/axis/axis-description.js
var AXIS_DESCRIPTION_TOOLTIP = "aixs-description-tooltip";
var AxisDescription = function(_super) {
  __extends(AxisDescription2, _super);
  function AxisDescription2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AxisDescription2.prototype.show = function() {
    var context = this.context;
    var axis = getDelegationObject(context).axis;
    var _a3 = axis.cfg.title, description = _a3.description, text = _a3.text, descriptionTooltipStyle = _a3.descriptionTooltipStyle;
    var _b = context.event, x = _b.x, y = _b.y;
    if (!this.tooltip) {
      this.renderTooltip();
    }
    this.tooltip.update({
      title: text || "",
      customContent: function() {
        return '\n          <div class="'.concat(css_const_exports2.CONTAINER_CLASS, '" style={').concat(descriptionTooltipStyle, '}>\n            <div class="').concat(css_const_exports2.TITLE_CLASS, '">\n              \u5B57\u6BB5\u8BF4\u660E\uFF1A').concat(description, "\n            </div>\n          </div>\n        ");
      },
      x,
      y
    });
    this.tooltip.show();
  };
  AxisDescription2.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    this.tooltip && this.tooltip.destroy();
  };
  AxisDescription2.prototype.hide = function() {
    this.tooltip && this.tooltip.hide();
  };
  AxisDescription2.prototype.renderTooltip = function() {
    var _a3;
    var view = this.context.view;
    var canvas = view.canvas;
    var region = {
      start: { x: 0, y: 0 },
      end: { x: canvas.get("width"), y: canvas.get("height") }
    };
    var tooltip = new HtmlTooltip({
      parent: canvas.get("el").parentNode,
      region,
      visible: false,
      containerId: AXIS_DESCRIPTION_TOOLTIP,
      domStyles: __assign({}, deep_mix_default({}, (_a3 = {}, _a3[css_const_exports2.CONTAINER_CLASS] = {
        "max-width": "50%",
        padding: "10px",
        "line-height": "15px",
        "font-size": "12px",
        color: "rgba(0, 0, 0, .65)"
      }, _a3[css_const_exports2.TITLE_CLASS] = {
        "word-break": "break-all",
        "margin-bottom": "3px"
      }, _a3)))
    });
    tooltip.init();
    tooltip.setCapture(false);
    this.tooltip = tooltip;
  };
  return AxisDescription2;
}(base_default12);
var axis_description_default = AxisDescription;

// node_modules/@antv/g2/esm/index.js
registerTheme("dark", createThemeByStyleSheet(antvDark));
registerEngine("canvas", esm_exports2);
registerEngine("svg", esm_exports3);
registerGeometry("Polygon", polygon_default5);
registerGeometry("Interval", interval_default2);
registerGeometry("Schema", schema_default);
registerGeometry("Path", path_default5);
registerGeometry("Point", point_default);
registerGeometry("Line", line_default9);
registerGeometry("Area", area_default);
registerGeometry("Edge", edge_default);
registerGeometry("Heatmap", heatmap_default);
registerGeometry("Violin", violin_default);
registerGeometryLabel("base", base_default14);
registerGeometryLabel("interval", interval_default3);
registerGeometryLabel("pie", pie_default);
registerGeometryLabel("polar", polar_default2);
registerGeometryLabelLayout("overlap", overlap);
registerGeometryLabelLayout("distribute", distribute);
registerGeometryLabelLayout("fixed-overlap", fixedOverlap);
registerGeometryLabelLayout("hide-overlap", hideOverlap);
registerGeometryLabelLayout("limit-in-shape", limitInShape);
registerGeometryLabelLayout("limit-in-canvas", limitInCanvas);
registerGeometryLabelLayout("limit-in-plot", limitInPlot);
registerGeometryLabelLayout("pie-outer", pieOuterLabelLayout);
registerGeometryLabelLayout("adjust-color", adjustColor);
registerGeometryLabelLayout("interval-adjust-position", intervalAdjustPosition);
registerGeometryLabelLayout("interval-hide-overlap", intervalHideOverlap);
registerGeometryLabelLayout("point-adjust-position", pointAdjustPosition);
registerGeometryLabelLayout("pie-spider", pieSpiderLabelLayout);
registerGeometryLabelLayout("path-adjust-position", pathAdjustPosition);
registerAnimation("fade-in", fadeIn);
registerAnimation("fade-out", fadeOut);
registerAnimation("grow-in-x", growInX);
registerAnimation("grow-in-xy", growInXY);
registerAnimation("grow-in-y", growInY);
registerAnimation("scale-in-x", scaleInX);
registerAnimation("scale-in-y", scaleInY);
registerAnimation("wave-in", waveIn);
registerAnimation("zoom-in", zoomIn);
registerAnimation("zoom-out", zoomOut);
registerAnimation("position-update", positionUpdate);
registerAnimation("sector-path-update", sectorPathUpdate);
registerAnimation("path-in", pathIn);
registerFacet("rect", rect_default4);
registerFacet("mirror", mirror_default);
registerFacet("list", list_default);
registerFacet("matrix", matrix_default);
registerFacet("circle", circle_default7);
registerFacet("tree", tree_default);
registerComponentController("axis", axis_default);
registerComponentController("legend", legend_default);
registerComponentController("tooltip", tooltip_default);
registerComponentController("annotation", annotation_default);
registerComponentController("slider", slider_default);
registerComponentController("scrollbar", scrollbar_default);
registerAction("tooltip", geometry_default);
registerAction("sibling-tooltip", sibling_default);
registerAction("ellipsis-text", ellipsis_text_default);
registerAction("element-active", active_default);
registerAction("element-single-active", single_active_default);
registerAction("element-range-active", range_active_default);
registerAction("element-highlight", highlight_default);
registerAction("element-highlight-by-x", highlight_by_x_default);
registerAction("element-highlight-by-color", highlight_by_color_default);
registerAction("element-single-highlight", single_highlight_default);
registerAction("element-range-highlight", range_highlight_default);
registerAction("element-sibling-highlight", range_highlight_default, {
  effectSiblings: true,
  effectByRecord: true
});
registerAction("element-selected", selected_default);
registerAction("element-single-selected", single_selected_default);
registerAction("element-range-selected", range_selected_default);
registerAction("element-link-by-color", link_by_color_default);
registerAction("active-region", active_region_default);
registerAction("list-active", list_active_default);
registerAction("list-selected", list_selected_default);
registerAction("list-highlight", list_highlight_default);
registerAction("list-unchecked", list_unchecked_default);
registerAction("list-checked", list_checked_default);
registerAction("list-focus", list_focus_default);
registerAction("list-radio", list_radio_default);
registerAction("legend-item-highlight", list_highlight_default, {
  componentNames: ["legend"]
});
registerAction("axis-label-highlight", list_highlight_default, {
  componentNames: ["axis"]
});
registerAction("axis-description", axis_description_default);
registerAction("rect-mask", rect_default5);
registerAction("x-rect-mask", dim_rect_default, { dim: "x" });
registerAction("y-rect-mask", dim_rect_default, { dim: "y" });
registerAction("circle-mask", circle_default8);
registerAction("path-mask", path_default6);
registerAction("smooth-path-mask", smooth_path_default);
registerAction("cursor", cursor_default);
registerAction("data-filter", filter_default2);
registerAction("brush", range_filter_default);
registerAction("brush-x", range_filter_default, { dims: ["x"] });
registerAction("brush-y", range_filter_default, { dims: ["y"] });
registerAction("sibling-filter", sibling_filter_default);
registerAction("sibling-x-filter", sibling_filter_default);
registerAction("sibling-y-filter", sibling_filter_default);
registerAction("element-filter", filter_default3);
registerAction("element-sibling-filter", sibling_filter_default2);
registerAction("element-sibling-filter-record", sibling_filter_default2, { byRecord: true });
registerAction("view-drag", drag_default);
registerAction("view-move", move_default);
registerAction("scale-translate", scale_translate_default);
registerAction("scale-zoom", scale_zoom_default);
registerAction("reset-button", button_default, {
  name: "reset-button",
  text: "reset"
});
registerAction("mousewheel-scroll", mousewheel_scroll_default);
function isPointInView(context) {
  return context.isInPlot();
}
registerInteraction("tooltip", {
  start: [
    { trigger: "plot:mousemove", action: "tooltip:show", throttle: { wait: 50, leading: true, trailing: false } },
    { trigger: "plot:touchmove", action: "tooltip:show", throttle: { wait: 50, leading: true, trailing: false } }
  ],
  end: [
    { trigger: "plot:mouseleave", action: "tooltip:hide" },
    { trigger: "plot:leave", action: "tooltip:hide" },
    { trigger: "plot:touchend", action: "tooltip:hide" }
  ]
});
registerInteraction("ellipsis-text", {
  start: [
    {
      trigger: "legend-item-name:mousemove",
      action: "ellipsis-text:show",
      throttle: { wait: 50, leading: true, trailing: false }
    },
    {
      trigger: "legend-item-name:touchstart",
      action: "ellipsis-text:show",
      throttle: { wait: 50, leading: true, trailing: false }
    },
    {
      trigger: "axis-label:mousemove",
      action: "ellipsis-text:show",
      throttle: { wait: 50, leading: true, trailing: false }
    },
    {
      trigger: "axis-label:touchstart",
      action: "ellipsis-text:show",
      throttle: { wait: 50, leading: true, trailing: false }
    }
  ],
  end: [
    { trigger: "legend-item-name:mouseleave", action: "ellipsis-text:hide" },
    { trigger: "legend-item-name:touchend", action: "ellipsis-text:hide" },
    { trigger: "axis-label:mouseleave", action: "ellipsis-text:hide" },
    { trigger: "axis-label:mouseout", action: "ellipsis-text:hide" },
    { trigger: "axis-label:touchend", action: "ellipsis-text:hide" }
  ]
});
registerInteraction("element-active", {
  start: [{ trigger: "element:mouseenter", action: "element-active:active" }],
  end: [{ trigger: "element:mouseleave", action: "element-active:reset" }]
});
registerInteraction("element-selected", {
  start: [{ trigger: "element:click", action: "element-selected:toggle" }]
});
registerInteraction("element-highlight", {
  start: [{ trigger: "element:mouseenter", action: "element-highlight:highlight" }],
  end: [{ trigger: "element:mouseleave", action: "element-highlight:reset" }]
});
registerInteraction("element-highlight-by-x", {
  start: [{ trigger: "element:mouseenter", action: "element-highlight-by-x:highlight" }],
  end: [{ trigger: "element:mouseleave", action: "element-highlight-by-x:reset" }]
});
registerInteraction("element-highlight-by-color", {
  start: [{ trigger: "element:mouseenter", action: "element-highlight-by-color:highlight" }],
  end: [{ trigger: "element:mouseleave", action: "element-highlight-by-color:reset" }]
});
registerInteraction("legend-active", {
  start: [{ trigger: "legend-item:mouseenter", action: ["list-active:active", "element-active:active"] }],
  end: [{ trigger: "legend-item:mouseleave", action: ["list-active:reset", "element-active:reset"] }]
});
registerInteraction("legend-highlight", {
  start: [
    { trigger: "legend-item:mouseenter", action: ["legend-item-highlight:highlight", "element-highlight:highlight"] }
  ],
  end: [{ trigger: "legend-item:mouseleave", action: ["legend-item-highlight:reset", "element-highlight:reset"] }]
});
registerInteraction("axis-label-highlight", {
  start: [
    { trigger: "axis-label:mouseenter", action: ["axis-label-highlight:highlight", "element-highlight:highlight"] }
  ],
  end: [{ trigger: "axis-label:mouseleave", action: ["axis-label-highlight:reset", "element-highlight:reset"] }]
});
registerInteraction("element-list-highlight", {
  start: [{ trigger: "element:mouseenter", action: ["list-highlight:highlight", "element-highlight:highlight"] }],
  end: [{ trigger: "element:mouseleave", action: ["list-highlight:reset", "element-highlight:reset"] }]
});
registerInteraction("element-range-highlight", {
  showEnable: [
    { trigger: "plot:mouseenter", action: "cursor:crosshair" },
    { trigger: "mask:mouseenter", action: "cursor:move" },
    { trigger: "plot:mouseleave", action: "cursor:default" },
    { trigger: "mask:mouseleave", action: "cursor:crosshair" }
  ],
  start: [
    {
      trigger: "plot:mousedown",
      isEnable: function(context) {
        return !context.isInShape("mask");
      },
      action: ["rect-mask:start", "rect-mask:show"]
    },
    {
      trigger: "mask:dragstart",
      action: ["rect-mask:moveStart"]
    }
  ],
  processing: [
    {
      trigger: "plot:mousemove",
      action: ["rect-mask:resize"]
    },
    {
      trigger: "mask:drag",
      action: ["rect-mask:move"]
    },
    {
      trigger: "mask:change",
      action: ["element-range-highlight:highlight"]
    }
  ],
  end: [
    { trigger: "plot:mouseup", action: ["rect-mask:end"] },
    { trigger: "mask:dragend", action: ["rect-mask:moveEnd"] },
    {
      trigger: "document:mouseup",
      isEnable: function(context) {
        return !context.isInPlot();
      },
      action: ["element-range-highlight:clear", "rect-mask:end", "rect-mask:hide"]
    }
  ],
  rollback: [{ trigger: "dblclick", action: ["element-range-highlight:clear", "rect-mask:hide"] }]
});
registerInteraction("brush", {
  showEnable: [
    { trigger: "plot:mouseenter", action: "cursor:crosshair" },
    { trigger: "plot:mouseleave", action: "cursor:default" }
  ],
  start: [
    {
      trigger: "mousedown",
      isEnable: isPointInView,
      action: ["brush:start", "rect-mask:start", "rect-mask:show"]
    }
  ],
  processing: [
    {
      trigger: "mousemove",
      isEnable: isPointInView,
      action: ["rect-mask:resize"]
    }
  ],
  end: [
    {
      trigger: "mouseup",
      isEnable: isPointInView,
      action: ["brush:filter", "brush:end", "rect-mask:end", "rect-mask:hide", "reset-button:show"]
    }
  ],
  rollback: [{ trigger: "reset-button:click", action: ["brush:reset", "reset-button:hide", "cursor:crosshair"] }]
});
registerInteraction("brush-visible", {
  showEnable: [
    { trigger: "plot:mouseenter", action: "cursor:crosshair" },
    { trigger: "plot:mouseleave", action: "cursor:default" }
  ],
  start: [
    {
      trigger: "plot:mousedown",
      action: ["rect-mask:start", "rect-mask:show"]
    }
  ],
  processing: [
    {
      trigger: "plot:mousemove",
      action: ["rect-mask:resize"]
    },
    { trigger: "mask:change", action: ["element-range-highlight:highlight"] }
  ],
  end: [
    {
      trigger: "plot:mouseup",
      action: ["rect-mask:end", "rect-mask:hide", "element-filter:filter", "element-range-highlight:clear"]
    }
  ],
  rollback: [
    {
      trigger: "dblclick",
      action: ["element-filter:clear"]
    }
  ]
});
registerInteraction("brush-x", {
  showEnable: [
    { trigger: "plot:mouseenter", action: "cursor:crosshair" },
    { trigger: "plot:mouseleave", action: "cursor:default" }
  ],
  start: [
    {
      trigger: "mousedown",
      isEnable: isPointInView,
      action: ["brush-x:start", "x-rect-mask:start", "x-rect-mask:show"]
    }
  ],
  processing: [
    {
      trigger: "mousemove",
      isEnable: isPointInView,
      action: ["x-rect-mask:resize"]
    }
  ],
  end: [
    {
      trigger: "mouseup",
      isEnable: isPointInView,
      action: ["brush-x:filter", "brush-x:end", "x-rect-mask:end", "x-rect-mask:hide"]
    }
  ],
  rollback: [{ trigger: "dblclick", action: ["brush-x:reset"] }]
});
registerInteraction("element-path-highlight", {
  showEnable: [
    { trigger: "plot:mouseenter", action: "cursor:crosshair" },
    { trigger: "plot:mouseleave", action: "cursor:default" }
  ],
  start: [
    { trigger: "mousedown", isEnable: isPointInView, action: "path-mask:start" },
    { trigger: "mousedown", isEnable: isPointInView, action: "path-mask:show" }
  ],
  processing: [{ trigger: "mousemove", action: "path-mask:addPoint" }],
  end: [{ trigger: "mouseup", action: "path-mask:end" }],
  rollback: [{ trigger: "dblclick", action: "path-mask:hide" }]
});
registerInteraction("element-single-selected", {
  start: [{ trigger: "element:click", action: "element-single-selected:toggle" }]
});
registerInteraction("legend-filter", {
  showEnable: [
    { trigger: "legend-item:mouseenter", action: ["cursor:pointer", "list-radio:show"] },
    { trigger: "legend-item:mouseleave", action: ["cursor:default", "list-radio:hide"] }
  ],
  start: [
    {
      trigger: "legend-item:click",
      isEnable: function(context) {
        return !context.isInShape("legend-item-radio");
      },
      action: ["legend-item-highlight:reset", "element-highlight:reset", "list-unchecked:toggle", "data-filter:filter", "list-radio:show"]
    },
    {
      trigger: "legend-item-radio:mouseenter",
      action: ["list-radio:showTip"]
    },
    {
      trigger: "legend-item-radio:mouseleave",
      action: ["list-radio:hideTip"]
    },
    {
      trigger: "legend-item-radio:click",
      action: ["list-focus:toggle", "data-filter:filter", "list-radio:show"]
    }
  ]
});
registerInteraction("continuous-filter", {
  start: [{ trigger: "legend:valuechanged", action: "data-filter:filter" }]
});
registerInteraction("continuous-visible-filter", {
  start: [{ trigger: "legend:valuechanged", action: "element-filter:filter" }]
});
registerInteraction("legend-visible-filter", {
  showEnable: [
    { trigger: "legend-item:mouseenter", action: "cursor:pointer" },
    { trigger: "legend-item:mouseleave", action: "cursor:default" }
  ],
  start: [{ trigger: "legend-item:click", action: ["legend-item-highlight:reset", "element-highlight:reset", "list-unchecked:toggle", "element-filter:filter"] }]
});
registerInteraction("active-region", {
  start: [{ trigger: "plot:mousemove", action: "active-region:show" }],
  end: [{ trigger: "plot:mouseleave", action: "active-region:hide" }]
});
registerInteraction("axis-description", {
  start: [{ trigger: "axis-description:mousemove", action: "axis-description:show" }],
  end: [{ trigger: "axis-description:mouseleave", action: "axis-description:hide" }]
});
function isWheelDown2(event) {
  event.gEvent.preventDefault();
  return event.gEvent.originalEvent.deltaY > 0;
}
registerInteraction("view-zoom", {
  start: [
    {
      trigger: "plot:mousewheel",
      isEnable: function(context) {
        return isWheelDown2(context.event);
      },
      action: "scale-zoom:zoomOut",
      throttle: { wait: 100, leading: true, trailing: false }
    },
    {
      trigger: "plot:mousewheel",
      isEnable: function(context) {
        return !isWheelDown2(context.event);
      },
      action: "scale-zoom:zoomIn",
      throttle: { wait: 100, leading: true, trailing: false }
    }
  ]
});
registerInteraction("sibling-tooltip", {
  start: [{ trigger: "plot:mousemove", action: "sibling-tooltip:show" }],
  end: [{ trigger: "plot:mouseleave", action: "sibling-tooltip:hide" }]
});
registerInteraction("plot-mousewheel-scroll", {
  start: [{ trigger: "plot:mousewheel", action: "mousewheel-scroll:scroll" }]
});
export {
  base_default12 as Action,
  EVENTS3 as BRUSH_FILTER_EVENTS,
  chart_default as Chart,
  Controller as ComponentController,
  base_default7 as Coordinate,
  DIRECTION,
  EVENTS2 as ELEMENT_RANGE_HIGHLIGHT_EVENTS,
  element_default2 as Element,
  event_default as Event,
  Facet,
  base_default13 as Geometry,
  base_default14 as GeometryLabel,
  interaction_default as Interaction,
  base_default12 as InteractionAction,
  LAYER,
  base_default4 as Scale,
  tooltip_default as TooltipController,
  Util,
  VERSION,
  VIEW_LIFE_CIRCLE,
  view_default as View,
  getActionClass,
  getAnimation,
  getEngine,
  getFacet,
  getGeometryLabel,
  getGeometryLabelLayout,
  getInteraction,
  getShapeFactory,
  getTheme,
  registerAction,
  registerAnimation,
  registerComponentController,
  registerEngine,
  registerFacet,
  registerGeometry,
  registerGeometryLabel,
  registerGeometryLabelLayout,
  registerInteraction,
  registerShape,
  registerShapeFactory,
  registerTheme
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
//# sourceMappingURL=@antv_g2.js.map

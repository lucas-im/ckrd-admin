"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makePatch = void 0;
const chalk_1 = __importDefault(require("chalk"));
const path_1 = require("./path");
const spawnSafe_1 = require("./spawnSafe");
const filterFiles_1 = require("./filterFiles");
const fs_extra_1 = require("fs-extra");
const rimraf_1 = require("rimraf");
const fs_extra_2 = require("fs-extra");
const tmp_1 = require("tmp");
const patchFs_1 = require("./patchFs");
const PackageDetails_1 = require("./PackageDetails");
const resolveRelativeFileDependencies_1 = require("./resolveRelativeFileDependencies");
const getPackageResolution_1 = require("./getPackageResolution");
const parse_1 = require("./patch/parse");
const zlib_1 = require("zlib");
const getPackageVersion_1 = require("./getPackageVersion");
const createIssue_1 = require("./createIssue");
const child_process_1 = require("child_process");
// globals are set in src/index.ts
const isVerbose = global.patchPackageIsVerbose;
const isDebug = global.patchPackageIsDebug;
const patchPackageVersion = global.patchPackageVersion;
function printNoPackageFoundError(packageName, packageJsonPath) {
    console.error(`No such package ${packageName}

  File not found: ${packageJsonPath}`);
}
function makePatch({ packagePathSpecifier, appPath, packageManager, includePaths, excludePaths, patchDir, createIssue, }) {
    const packageDetails = (0, PackageDetails_1.getPatchDetailsFromCliString)(packagePathSpecifier);
    if (!packageDetails) {
        console.error("No such package", packagePathSpecifier);
        return;
    }
    const appPackageJson = require((0, path_1.join)(appPath, "package.json"));
    const packagePath = (0, path_1.join)(appPath, packageDetails.path);
    const packageJsonPath = (0, path_1.join)(packagePath, "package.json");
    if (isDebug) {
        console.log(`patch-package/makePatch: appPath = ${appPath}`);
        console.log(`patch-package/makePatch: packagePath = ${packagePath}`);
        console.log(`patch-package/makePatch: appPackageJson:`);
        console.dir(appPackageJson);
    }
    if (!(0, fs_extra_1.existsSync)(packageJsonPath)) {
        printNoPackageFoundError(packagePathSpecifier, packageJsonPath);
        process.exit(1);
    }
    const tmpRepo = (0, tmp_1.dirSync)({
        unsafeCleanup: true,
        prefix: "patch-package.tmpRepo.",
    });
    function cleanup() {
        if (isDebug) {
            console.log(`patch-package/makePatch: cleanup: keeping temporary files: ${tmpRepo.name}`);
            return;
        }
        tmpRepo.removeCallback();
    }
    try {
        // finally: cleanup()
        const tmpRepoPackagePath = (0, path_1.join)(tmpRepo.name, packageDetails.path);
        const tmpRepoNpmRoot = tmpRepoPackagePath.slice(0, -`/node_modules/${packageDetails.name}`.length);
        const tmpRepoPackageJsonPath = (0, path_1.join)(tmpRepoNpmRoot, "package.json");
        const patchesDir = (0, path_1.resolve)((0, path_1.join)(appPath, patchDir));
        console.info(chalk_1.default.grey("â€¢"), "Creating temporary folder");
        if (isDebug) {
            console.log(`patch-package/makePatch: tmpRepoNpmRoot = ${tmpRepoNpmRoot}`);
        }
        const resolvedVersion = (0, getPackageResolution_1.getPackageResolution)({
            packageDetails,
            packageManager,
            appPath,
            appPackageJson,
        });
        // make a blank package.json
        (0, fs_extra_1.mkdirpSync)(tmpRepoNpmRoot);
        (0, fs_extra_1.writeFileSync)(tmpRepoPackageJsonPath, JSON.stringify({
            dependencies: {
                [packageDetails.name]: resolvedVersion.version,
            },
            resolutions: (0, resolveRelativeFileDependencies_1.resolveRelativeFileDependencies)(appPath, appPackageJson.resolutions || {}),
        }));
        const declaredVersion = (() => {
            var v = resolvedVersion.version;
            // https://docs.npmjs.com/cli/v7/configuring-npm/package-json
            // <protocol>://[<user>[:<password>]@]<hostname>[:<port>][:][/]<path>[#<commit-ish> | #semver:<semver>]
            // pnpm uses link: protocol instead of file:
            // TODO add more protocols?
            var m = v.match(/^(file|link|http|https|git|git\+https|git\+http|git\+ssh|git\+file|github):(.+)$/);
            if (m) {
                var protocol = m[1];
                var location = m[2];
                var isGit = protocol.startsWith('git');
                var gitCommit = (isGit && location.includes("#")) ? location.split('#').slice(-1)[0] : null;
                if (isDebug) {
                    console.dir({ loc: 'get declaredVersion', isGit, gitCommit });
                }
                if (isGit && !gitCommit) {
                    var error = new Error(`found wildcard git version ${v}. \
package.json must pin the exact version of ${packageDetails.name} \
in the format <protocol>:<packagePath>#<commitHash>. \
commitHash is the full hash with 40 chars.`);
                    delete error.stack;
                    throw error;
                    /* too complex
                    // guess commit hash of installed package
                    var stats = lstatSync(packageDetails.path)
                    if (stats.isSymbolicLink()) {
                      var linkTarget = readlinkSync(packageDetails.path)
                      if (linkTarget.startsWith(".pnpm")) {
                        var match = linkTarget.match(/^\.pnpm\/[^/]+@([0-9a-f]{10})_[0-9a-f]{32}\//)
                        if (match) {
                          gitCommit = match[1]
                          if (isDebug) console.log(`parsed gitCommit ${gitCommit} from pnpm symlink`)
                        }
                      }
                    }
                    */
                }
                if (isGit) {
                    return { full: v, protocol, location, gitCommit };
                }
                else {
                    // sample: https://registry.yarnpkg.com/left-pad/-/left-pad-1.3.0.tgz#5b8a3a7765dfe001261dde915589e782f8c94d1e
                    // hash is sha1sum of tgz file
                    // -> use version number from package's package.json
                    var version = (0, getPackageVersion_1.getPackageVersion)((0, path_1.join)((0, path_1.resolve)(packageDetails.path), "package.json"));
                    if (isVerbose) {
                        console.log(`patch-package/makePatch: using version ${version} from ${packageDetails.name}/package.json`);
                    }
                    return { version };
                }
            }
            // https://docs.npmjs.com/about-semantic-versioning
            // TODO handle protocols? pnpm workspace: protocol does not make sense here, no need to patch local packages
            var m = v.match(/^([~^])(.*)$/);
            if (m) {
                var exampleVersion = m[1];
                if (!exampleVersion) {
                    exampleVersion = '1.0.0';
                }
                console.warn(`patch-package/makePatch: warning: found wildcard version ${v}. \
to ensure successful patching, package.json should pin the exact version of ${packageDetails.name} \
in the format <major>.<minor>.<patch>, for example: "${packageDetails.name}": "${exampleVersion}"`);
            }
            return { full: v, version: v };
        })();
        if (isDebug) {
            //console.log(`patch-package/makePatch: resolvedVersion.originCommit = ${resolvedVersion.originCommit}`)
            console.log(`patch-package/makePatch: declaredVersion.version = ${declaredVersion.version}`);
            console.log(`patch-package/makePatch: declaredVersion.gitCommit = ${declaredVersion.gitCommit}`);
            console.log(`patch-package/makePatch: declaredVersion.full = ${declaredVersion.full}`);
        }
        const packageVersion = (declaredVersion.version || declaredVersion.gitCommit || declaredVersion.full);
        // originCommit is more precise than pkg.version
        if (isDebug) {
            //console.log(`patch-package/makePatch: resolvedVersion.originCommit = ${resolvedVersion.originCommit}`)
            console.log(`patch-package/makePatch: resolvedVersion.version = ${resolvedVersion.version}`);
            console.log(`patch-package/makePatch: packageVersion = ${packageVersion}`);
        }
        //const packageVersion =
        //  resolvedVersion.originCommit ||
        //  getPackageVersion(join(resolve(packageDetails.path), "package.json"))
        // this is broken when installing from git -> version can be a pseudo-version like 1.0.0-canary
        //const packageVersion = getPackageVersion(join(resolve(packageDetails.path), "package.json"))
        // TODO rename resolvedVersion -> declaredVersion
        // FIXME false positive
        // test integration-tests/create-issue/create-issue.test.ts
        // -> patching left-pad prompts to submit an issue
        // https://registry.yarnpkg.com/left-pad/-/left-pad-1.3.0.tgz#5b8a3a7765dfe001261dde915589e782f8c94d1e
        // hash is sha checksum of tgz file -> just use the version 1.3.0
        /*
        const packageVersion = (
          !resolvedVersion.version.match(/^(file:|link:)/) ? resolvedVersion.version :
          getPackageVersion(join(resolve(packageDetails.path), "package.json"))
        )
        */
        if (isDebug) {
            console.log(`patch-package/makePatch: getPackageVersion -> ${(0, getPackageVersion_1.getPackageVersion)((0, path_1.join)((0, path_1.resolve)(packageDetails.path), "package.json"))}`);
            console.log(`patch-package/makePatch: package path = ${packageDetails.path}`);
            console.log(`patch-package/makePatch: package path resolved = ${(0, path_1.resolve)(packageDetails.path)}`);
        }
        // copy .npmrc/.yarnrc in case packages are hosted in private registry
        // tslint:disable-next-line:align
        ;
        [".npmrc", ".yarnrc"].forEach((rcFile) => {
            const rcPath = (0, path_1.join)(appPath, rcFile);
            if ((0, fs_extra_1.existsSync)(rcPath)) {
                (0, fs_extra_2.copySync)(rcPath, (0, path_1.join)(tmpRepo.name, rcFile));
            }
        });
        if (packageManager === "yarn") {
            console.info(chalk_1.default.grey("â€¢"), `Installing ${packageDetails.name}@${packageVersion} with yarn`);
            try {
                // try first without ignoring scripts in case they are required
                // this works in 99.99% of cases
                (0, spawnSafe_1.spawnSafeSync)(`yarn`, ["install", "--ignore-engines"], {
                    cwd: tmpRepoNpmRoot,
                    logStdErrOnError: false,
                });
            }
            catch (e) {
                // try again while ignoring scripts in case the script depends on
                // an implicit context which we havn't reproduced
                (0, spawnSafe_1.spawnSafeSync)(`yarn`, ["install", "--ignore-engines", "--ignore-scripts"], {
                    cwd: tmpRepoNpmRoot,
                });
            }
        }
        else {
            const npmCmd = packageManager === "pnpm" ? "pnpm" : "npm";
            console.info(chalk_1.default.grey("â€¢"), `Installing ${packageDetails.name}@${packageVersion} with ${npmCmd}`);
            try {
                // try first without ignoring scripts in case they are required
                // this works in 99.99% of cases
                if (isVerbose) {
                    console.log(`patch-package/makePatch: run "${npmCmd} install --force" in ${tmpRepoNpmRoot}`);
                }
                (0, spawnSafe_1.spawnSafeSync)(npmCmd, ["install", "--force"], {
                    cwd: tmpRepoNpmRoot,
                    logStdErrOnError: false,
                    stdio: isVerbose ? "inherit" : "ignore",
                });
            }
            catch (e) {
                // try again while ignoring scripts in case the script depends on
                // an implicit context which we havn't reproduced
                if (isVerbose) {
                    console.log(`patch-package/makePatch: run "${npmCmd} install --ignore-scripts --force" in ${tmpRepoNpmRoot}`);
                }
                (0, spawnSafe_1.spawnSafeSync)(npmCmd, ["install", "--ignore-scripts", "--force"], {
                    cwd: tmpRepoNpmRoot,
                    stdio: isVerbose ? "inherit" : "ignore",
                });
            }
            if (packageManager === "pnpm") {
                // workaround for `git diff`: replace symlink with hardlink
                const pkgPath = tmpRepoNpmRoot + "/node_modules/" + packageDetails.name;
                const realPath = (0, fs_extra_1.realpathSync)(pkgPath);
                (0, fs_extra_1.unlinkSync)(pkgPath); // rm symlink
                (0, fs_extra_1.renameSync)(realPath, pkgPath);
            }
        }
        function git(...args) {
            if (isDebug) {
                const argsStr = JSON.stringify(["git", ...args]);
                console.log(`patch-package/makePatch: spawn: args = ${argsStr} + workdir = ${tmpRepo.name}`);
            }
            return (0, spawnSafe_1.spawnSafeSync)("git", args, {
                cwd: tmpRepo.name,
                env: Object.assign(Object.assign({}, process.env), { HOME: tmpRepo.name }),
                maxBuffer: 1024 * 1024 * 100,
            });
        }
        // remove nested node_modules just to be safe
        (0, rimraf_1.sync)((0, path_1.join)(tmpRepoPackagePath, "node_modules"));
        // remove .git just to be safe
        (0, rimraf_1.sync)((0, path_1.join)(tmpRepoPackagePath, ".git"));
        // commit the package
        console.info(chalk_1.default.grey("â€¢"), "Diffing your files with clean files");
        (0, fs_extra_1.writeFileSync)((0, path_1.join)(tmpRepo.name, ".gitignore"), "!/node_modules\n\n");
        git("-c", "init.defaultBranch=main", "init");
        // remove ignored files first
        // use CLI options --exclude and --include
        (0, filterFiles_1.removeIgnoredFiles)(tmpRepoPackagePath, includePaths, excludePaths);
        git("add", "-f", packageDetails.path);
        if (isVerbose) {
            console.log(`git status:\n` + git("status").stdout.toString());
        }
        git("-c", "user.name=patch-package", "-c", "user.email=", "commit", "--allow-empty", "-m", "init");
        // replace package with user's version
        if (isVerbose) {
            console.log(`patch-package/makePatch: remove all files in ${tmpRepoPackagePath}`);
        }
        (0, rimraf_1.sync)(tmpRepoPackagePath);
        if (isVerbose) {
            console.log(`patch-package/makePatch: git status:\n` + git("status").stdout.toString());
        }
        // pnpm installs packages as symlinks, copySync would copy only the symlink
        // with pnpm, realpath resolves to ./node_modules/.pnpm/${name}@${version}
        const srcPath = (0, fs_extra_1.realpathSync)(packagePath);
        if (isVerbose) {
            console.log(`patch-package/makePatch: copy ${srcPath} to ${tmpRepoPackagePath} + skip ${srcPath}/node_modules/`);
        }
        (0, fs_extra_2.copySync)(srcPath, tmpRepoPackagePath, {
            filter: (path) => {
                const doCopy = !path.startsWith(srcPath + "/node_modules/");
                if (isVerbose) {
                    if (doCopy) {
                        console.log(`patch-package/makePatch: copySync: copy file ${path}`);
                    }
                    else {
                        console.log(`patch-package/makePatch: copySync: skip file ${path}`);
                    }
                }
                return doCopy;
            },
        });
        if (isDebug) {
            // list files
            // NOTE this works only on linux
            console.log(`patch-package/makePatch: files in srcPath = ${srcPath}`);
            console.log((0, child_process_1.spawnSync)('find', ['.'], { cwd: srcPath, encoding: 'utf8' }).stdout);
            console.log(`patch-package/makePatch: files in tmpRepoPackagePath = ${tmpRepoPackagePath}`);
            console.log((0, child_process_1.spawnSync)('find', ['.'], { cwd: tmpRepoPackagePath, encoding: 'utf8' }).stdout);
        }
        // remove nested node_modules just to be safe
        (0, rimraf_1.sync)((0, path_1.join)(tmpRepoPackagePath, "node_modules"));
        // remove .git just to be safe
        // NOTE this removes ./node_modules/${dependencyName}/.git not ./.git
        (0, rimraf_1.sync)((0, path_1.join)(tmpRepoPackagePath, ".git"));
        // also remove ignored files like before
        // for example, remove package.json
        // TODO support patching package.json via semantic json diff
        // use CLI options --exclude and --include
        if (isDebug) {
            console.log(`patch-package/makePatch: removing ignored files in tmpRepoPackagePath = ${tmpRepoPackagePath}:`);
        }
        (0, filterFiles_1.removeIgnoredFiles)(tmpRepoPackagePath, includePaths, excludePaths);
        if (isDebug) {
            // list files
            // NOTE this works only on linux
            console.log(`patch-package/makePatch: files in tmpRepoPackagePath = ${tmpRepoPackagePath}:`);
            console.log((0, child_process_1.spawnSync)('find', ['.', '-type', 'f'], { cwd: tmpRepoPackagePath, encoding: 'utf8' }).stdout);
        }
        // stage all files
        git("add", "-f", packageDetails.path);
        if (isVerbose) {
            console.log(`patch-package/makePatch: git status:\n` + git("status").stdout.toString());
        }
        const ignorePaths = ["package-lock.json", "pnpm-lock.yaml"];
        // get diff of changes
        const diffResult = git("diff", "--cached", "--no-color", "--ignore-space-at-eol", "--no-ext-diff", ...ignorePaths.map((path) => `:(exclude,top)${packageDetails.path}/${path}`));
        if (diffResult.stdout.length === 0) {
            console.warn(`â‰ï¸  Not creating patch file for package '${packagePathSpecifier}'`);
            console.warn(`â‰ï¸  There don't appear to be any changes.`);
            cleanup();
            process.exit(1);
            return;
        }
        try {
            (0, parse_1.parsePatchFile)(diffResult.stdout.toString());
        }
        catch (e) {
            if (!(e instanceof Error))
                return;
            if (e.message.includes("Unexpected file mode string: 120000")) {
                console.error(`
â›”ï¸ ${chalk_1.default.red.bold("ERROR")}

  Your changes involve creating symlinks. patch-package does not yet support
  symlinks.
  
  ï¸Please use ${chalk_1.default.bold("--include")} and/or ${chalk_1.default.bold("--exclude")} to narrow the scope of your patch if
  this was unintentional.
`);
            }
            else {
                const outPath = "./patch-package-error.json.gz";
                (0, fs_extra_1.writeFileSync)(outPath, (0, zlib_1.gzipSync)(JSON.stringify({
                    error: { message: e.message, stack: e.stack },
                    patch: diffResult.stdout.toString(),
                })));
                console.error(`
â›”ï¸ ${chalk_1.default.red.bold("ERROR")}
        
  patch-package was unable to read the patch-file made by git. This should not
  happen.
  
  A diagnostic file was written to
  
    ${outPath}
  
  Please attach it to a github issue
  
    https://github.com/ds300/patch-package/issues/new?title=New+patch+parse+failed&body=Please+attach+the+diagnostic+file+by+dragging+it+into+here+ðŸ™
  
  Note that this diagnostic file will contain code from the package you were
  attempting to patch.

`);
            }
            cleanup();
            process.exit(1);
            return;
        }
        // maybe delete existing
        (0, patchFs_1.getPatchFiles)(patchDir).forEach((filename) => {
            const deets = (0, PackageDetails_1.getPackageDetailsFromPatchFilename)(filename);
            if (deets && deets.path === packageDetails.path) {
                (0, fs_extra_1.unlinkSync)((0, path_1.join)(patchDir, filename));
            }
        });
        // patchfiles are parsed in patch/parse.ts function parsePatchLines
        // -> header comments are ignored
        let diffHeader = "";
        diffHeader += `# generated by patch-package ${patchPackageVersion}\n`;
        diffHeader += `#\n`;
        if (isDebug) {
            resolvedVersion.version;
        }
        diffHeader += `# declared package:\n`;
        diffHeader += `#   ${packageDetails.name}: ${resolvedVersion.declaredVersion}\n`;
        // NOTE: we do *not* include the locked version from package-lock.json or yarn.lock or pnpm-lock.yaml or ...
        // because patch-package should work with all package managers (should be manager-agnostic)
        // users can pin versions in package.json
        diffHeader += `#\n`;
        const patchFileName = createPatchFileName({
            packageDetails,
            packageVersion,
        });
        const patchPath = (0, path_1.join)(patchesDir, patchFileName);
        if (!(0, fs_extra_1.existsSync)((0, path_1.dirname)(patchPath))) {
            (0, fs_extra_1.mkdirSync)((0, path_1.dirname)(patchPath), { recursive: true });
        }
        (0, fs_extra_1.writeFileSync)(patchPath, diffHeader + diffResult.stdout);
        console.log(`${chalk_1.default.green("âœ”")} Created file ${(0, path_1.join)(patchDir, patchFileName)}\n`);
        if (createIssue) {
            (0, createIssue_1.openIssueCreationLink)({
                packageDetails,
                patchFileContents: diffResult.stdout.toString(),
                packageVersion,
            });
        }
        else {
            (0, createIssue_1.maybePrintIssueCreationPrompt)(packageDetails, packageManager);
        }
    }
    catch (e) {
        //console.error(e)
        throw e;
    }
    finally {
        cleanup();
    }
}
exports.makePatch = makePatch;
function createPatchFileName({ packageDetails, packageVersion, }) {
    const packageNames = packageDetails.packageNames
        .map((name) => name.replace(/\//g, "+"))
        .join("++");
    return `${packageNames}+${packageVersion}.patch`;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFrZVBhdGNoLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL21ha2VQYXRjaC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxrREFBeUI7QUFDekIsaUNBQStDO0FBQy9DLDJDQUEyQztBQUUzQywrQ0FBa0Q7QUFDbEQsdUNBUWlCO0FBQ2pCLG1DQUF1QztBQUN2Qyx1Q0FBbUM7QUFDbkMsNkJBQTZCO0FBQzdCLHVDQUF5QztBQUN6QyxxREFJeUI7QUFDekIsdUZBQW1GO0FBQ25GLGlFQUE2RDtBQUM3RCx5Q0FBOEM7QUFDOUMsK0JBQStCO0FBQy9CLDJEQUF1RDtBQUN2RCwrQ0FHc0I7QUFDdEIsaURBQXlDO0FBRXpDLGtDQUFrQztBQUNsQyxNQUFNLFNBQVMsR0FBRyxNQUFNLENBQUMscUJBQXFCLENBQUE7QUFDOUMsTUFBTSxPQUFPLEdBQUcsTUFBTSxDQUFDLG1CQUFtQixDQUFBO0FBQzFDLE1BQU0sbUJBQW1CLEdBQUcsTUFBTSxDQUFDLG1CQUFtQixDQUFBO0FBRXRELFNBQVMsd0JBQXdCLENBQy9CLFdBQW1CLEVBQ25CLGVBQXVCO0lBRXZCLE9BQU8sQ0FBQyxLQUFLLENBQ1gsbUJBQW1CLFdBQVc7O29CQUVkLGVBQWUsRUFBRSxDQUNsQyxDQUFBO0FBQ0gsQ0FBQztBQUVELFNBQWdCLFNBQVMsQ0FBQyxFQUN4QixvQkFBb0IsRUFDcEIsT0FBTyxFQUNQLGNBQWMsRUFDZCxZQUFZLEVBQ1osWUFBWSxFQUNaLFFBQVEsRUFDUixXQUFXLEdBU1o7SUFDQyxNQUFNLGNBQWMsR0FBRyxJQUFBLDZDQUE0QixFQUFDLG9CQUFvQixDQUFDLENBQUE7SUFFekUsSUFBSSxDQUFDLGNBQWMsRUFBRTtRQUNuQixPQUFPLENBQUMsS0FBSyxDQUFDLGlCQUFpQixFQUFFLG9CQUFvQixDQUFDLENBQUE7UUFDdEQsT0FBTTtLQUNQO0lBQ0QsTUFBTSxjQUFjLEdBQUcsT0FBTyxDQUFDLElBQUEsV0FBSSxFQUFDLE9BQU8sRUFB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QU0sQ0FBQyxDQUFBO1FBQ3hELE9BQU8sQ0FBQyxHQUFHLENBQ1QsR0FBRyxlQUFLLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxpQkFBaUIsSUFBQSxXQUFJLEVBQUMsUUFBUSxFQUFFLGFBQWEsQ0FBQyxJQUFJLENBQ3RFLENBQUE7UUFDRCxJQUFJLFdBQVcsRUFBRTtZQUNmLElBQUEsbUNBQXFCLEVBQUM7Z0JBQ3BCLGNBQWM7Z0JBQ2QsaUJBQWlCLEVBQUUsVUFBVSxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUU7Z0JBQy9DLGNBQWM7YUFDZixDQUFDLENBQUE7U0FDSDthQUFNO1lBQ0wsSUFBQSwyQ0FBNkIsRUFBQyxjQUFjLEVBQUUsY0FBYyxDQUFDLENBQUE7U0FDOUQ7S0FDRjtJQUFDLE9BQU8sQ0FBTSxFQUFFO1FBQ2Ysa0JBQWtCO1FBQ2xCLE1BQU0sQ0FBQyxDQUFBO0tBQ1I7WUFBUztRQUNSLE9BQU8sRUFBRSxDQUFBO0tBQ1Y7QUFDSCxDQUFDO0FBaGdCRCw4QkFnZ0JDO0FBRUQsU0FBUyxtQkFBbUIsQ0FBQyxFQUMzQixjQUFjLEVBQ2QsY0FBYyxHQUlmO0lBQ0MsTUFBTSxZQUFZLEdBQUcsY0FBYyxDQUFDLFlBQVk7U0FDN0MsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQztTQUN2QyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUE7SUFFYixPQUFPLEdBQUcsWUFBWSxJQUFJLGNBQWMsUUFBUSxDQUFBO0FBQ2xELENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY2hhbGsgZnJvbSBcImNoYWxrXCJcbmltcG9ydCB7IGpvaW4sIGRpcm5hbWUsIHJlc29sdmUgfSBmcm9tIFwiLi9wYXRoXCJcbmltcG9ydCB7IHNwYXduU2FmZVN5bmMgfSBmcm9tIFwiLi9zcGF3blNhZmVcIlxuaW1wb3J0IHsgUGFja2FnZU1hbmFnZXIgfSBmcm9tIFwiLi9kZXRlY3RQYWNrYWdlTWFuYWdlclwiXG5pbXBvcnQgeyByZW1vdmVJZ25vcmVkRmlsZXMgfSBmcm9tIFwiLi9maWx0ZXJGaWxlc1wiXG5pbXBvcnQge1xuICB3cml0ZUZpbGVTeW5jLFxuICBleGlzdHNTeW5jLFxuICBta2RpclN5bmMsXG4gIHVubGlua1N5bmMsXG4gIG1rZGlycFN5bmMsXG4gIHJlYWxwYXRoU3luYyxcbiAgcmVuYW1lU3luYyxcbn0gZnJvbSBcImZzLWV4dHJhXCJcbmltcG9ydCB7IHN5bmMgYXMgcmltcmFmIH0gZnJvbSBcInJpbXJhZlwiXG5pbXBvcnQgeyBjb3B5U3luYyB9IGZyb20gXCJmcy1leHRyYVwiXG5pbXBvcnQgeyBkaXJTeW5jIH0gZnJvbSBcInRtcFwiXG5pbXBvcnQgeyBnZXRQYXRjaEZpbGVzIH0gZnJvbSBcIi4vcGF0Y2hGc1wiXG5pbXBvcnQge1xuICBnZXRQYXRjaERldGFpbHNGcm9tQ2xpU3RyaW5nLFxuICBnZXRQYWNrYWdlRGV0YWlsc0Zyb21QYXRjaEZpbGVuYW1lLFxuICBQYWNrYWdlRGV0YWlscyxcbn0gZnJvbSBcIi4vUGFja2FnZURldGFpbHNcIlxuaW1wb3J0IHsgcmVzb2x2ZVJlbGF0aXZlRmlsZURlcGVuZGVuY2llcyB9IGZyb20gXCIuL3Jlc29sdmVSZWxhdGl2ZUZpbGVEZXBlbmRlbmNpZXNcIlxuaW1wb3J0IHsgZ2V0UGFja2FnZVJlc29sdXRpb24gfSBmcm9tIFwiLi9nZXRQYWNrYWdlUmVzb2x1dGlvblwiXG5pbXBvcnQgeyBwYXJzZVBhdGNoRmlsZSB9IGZyb20gXCIuL3BhdGNoL3BhcnNlXCJcbmltcG9ydCB7IGd6aXBTeW5jIH0gZnJvbSBcInpsaWJcIlxuaW1wb3J0IHsgZ2V0UGFja2FnZVZlcnNpb24gfSBmcm9tIFwiLi9nZXRQYWNrYWdlVmVyc2lvblwiXG5pbXBvcnQge1xuICBtYXliZVByaW50SXNzdWVDcmVhdGlvblByb21wdCxcbiAgb3Blbklzc3VlQ3JlYXRpb25MaW5rLFxufSBmcm9tIFwiLi9jcmVhdGVJc3N1ZVwiXG5pbXBvcnQgeyBzcGF3blN5bmMgfSBmcm9tIFwiY2hpbGRfcHJvY2Vzc1wiXG5cbi8vIGdsb2JhbHMgYXJlIHNldCBpbiBzcmMvaW5kZXgudHNcbmNvbnN0IGlzVmVyYm9zZSA9IGdsb2JhbC5wYXRjaFBhY2thZ2VJc1ZlcmJvc2VcbmNvbnN0IGlzRGVidWcgPSBnbG9iYWwucGF0Y2hQYWNrYWdlSXNEZWJ1Z1xuY29uc3QgcGF0Y2hQYWNrYWdlVmVyc2lvbiA9IGdsb2JhbC5wYXRjaFBhY2thZ2VWZXJzaW9uXG5cbmZ1bmN0aW9uIHByaW50Tm9QYWNrYWdlRm91bmRFcnJvcihcbiAgcGFja2FnZU5hbWU6IHN0cmluZyxcbiAgcGFja2FnZUpzb25QYXRoOiBzdHJpbmcsXG4pIHtcbiAgY29uc29sZS5lcnJvcihcbiAgICBgTm8gc3VjaCBwYWNrYWdlICR7cGFja2FnZU5hbWV9XG5cbiAgRmlsZSBub3QgZm91bmQ6ICR7cGFja2FnZUpzb25QYXRofWAsXG4gIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VQYXRjaCh7XG4gIHBhY2thZ2VQYXRoU3BlY2lmaWVyLFxuICBhcHBQYXRoLFxuICBwYWNrYWdlTWFuYWdlcixcbiAgaW5jbHVkZVBhdGhzLFxuICBleGNsdWRlUGF0aHMsXG4gIHBhdGNoRGlyLFxuICBjcmVhdGVJc3N1ZSxcbn06IHtcbiAgcGFja2FnZVBhdGhTcGVjaWZpZXI6IHN0cmluZ1xuICBhcHBQYXRoOiBzdHJpbmdcbiAgcGFja2FnZU1hbmFnZXI6IFBhY2thZ2VNYW5hZ2VyXG4gIGluY2x1ZGVQYXRoczogUmVnRXhwXG4gIGV4Y2x1ZGVQYXRoczogUmVnRXhwXG4gIHBhdGNoRGlyOiBzdHJpbmdcbiAgY3JlYXRlSXNzdWU6IGJvb2xlYW5cbn0pIHtcbiAgY29uc3QgcGFja2FnZURldGFpbHMgPSBnZXRQYXRjaERldGFpbHNGcm9tQ2xpU3RyaW5nKHBhY2thZ2VQYXRoU3BlY2lmaWVyKVxuXG4gIGlmICghcGFja2FnZURldGFpbHMpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiTm8gc3VjaCBwYWNrYWdlXCIsIHBhY2thZ2VQYXRoU3BlY2lmaWVyKVxuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IGFwcFBhY2thZ2VKc29uID0gcmVxdWlyZShqb2luKGFwcFBhdGgsIFwicGFja2FnZS5qc29uXCIpKVxuICBjb25zdCBwYWNrYWdlUGF0aCA9IGpvaW4oYXBwUGF0aCwgcGFja2FnZURldGFpbHMucGF0aClcbiAgY29uc3QgcGFja2FnZUpzb25QYXRoID0gam9pbihwYWNrYWdlUGF0aCwgXCJwYWNrYWdlLmpzb25cIilcblxuICBpZiAoaXNEZWJ1Zykge1xuICAgIGNvbnNvbGUubG9nKGBwYXRjaC1wYWNrYWdlL21ha2VQYXRjaDogYXBwUGF0aCA9ICR7YXBwUGF0aH1gKVxuICAgIGNvbnNvbGUubG9nKGBwYXRjaC1wYWNrYWdlL21ha2VQYXRjaDogcGFja2FnZVBhdGggPSAke3BhY2thZ2VQYXRofWApXG4gICAgY29uc29sZS5sb2coYHBhdGNoLXBhY2thZ2UvbWFrZVBhdGNoOiBhcHBQYWNrYWdlSnNvbjpgKVxuICAgIGNvbnNvbGUuZGlyKGFwcFBhY2thZ2VKc29uKVxuICB9XG5cbiAgaWYgKCFleGlzdHNTeW5jKHBhY2thZ2VKc29uUGF0aCkpIHtcbiAgICBwcmludE5vUGFja2FnZUZvdW5kRXJyb3IocGFja2FnZVBhdGhTcGVjaWZpZXIsIHBhY2thZ2VKc29uUGF0aClcbiAgICBwcm9jZXNzLmV4aXQoMSlcbiAgfVxuXG4gIGNvbnN0IHRtcFJlcG8gPSBkaXJTeW5jKHtcbiAgICB1bnNhZmVDbGVhbnVwOiB0cnVlLFxuICAgIHByZWZpeDogXCJwYXRjaC1wYWNrYWdlLnRtcFJlcG8uXCIsXG4gIH0pXG5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBpZiAoaXNEZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coYHBhdGNoLXBhY2thZ2UvbWFrZVBhdGNoOiBjbGVhbnVwOiBrZWVwaW5nIHRlbXBvcmFyeSBmaWxlczogJHt0bXBSZXBvLm5hbWV9YClcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB0bXBSZXBvLnJlbW92ZUNhbGxiYWNrKClcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gZmluYWxseTogY2xlYW51cCgpXG5cbiAgICBjb25zdCB0bXBSZXBvUGFja2FnZVBhdGggPSBqb2luKHRtcFJlcG8ubmFtZSwgcGFja2FnZURldGFpbHMucGF0aClcbiAgICBjb25zdCB0bXBSZXBvTnBtUm9vdCA9IHRtcFJlcG9QYWNrYWdlUGF0aC5zbGljZShcbiAgICAgIDAsXG4gICAgICAtYC9ub2RlX21vZHVsZXMvJHtwYWNrYWdlRGV0YWlscy5uYW1lfWAubGVuZ3RoLFxuICAgIClcblxuICAgIGNvbnN0IHRtcFJlcG9QYWNrYWdlSnNvblBhdGggPSBqb2luKHRtcFJlcG9OcG1Sb290LCBcInBhY2thZ2UuanNvblwiKVxuXG4gICAgY29uc3QgcGF0Y2hlc0RpciA9IHJlc29sdmUoam9pbihhcHBQYXRoLCBwYXRjaERpcikpXG5cbiAgICBjb25zb2xlLmluZm8oY2hhbGsuZ3JleShcIuKAolwiKSwgXCJDcmVhdGluZyB0ZW1wb3JhcnkgZm9sZGVyXCIpXG5cbiAgICBpZiAoaXNEZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coXG4gICAgICAgIGBwYXRjaC1wYWNrYWdlL21ha2VQYXRjaDogdG1wUmVwb05wbVJvb3QgPSAke3RtcFJlcG9OcG1Sb290fWAsXG4gICAgICApXG4gICAgfVxuXG4gICAgY29uc3QgcmVzb2x2ZWRWZXJzaW9uID0gZ2V0UGFja2FnZVJlc29sdXRpb24oe1xuICAgICAgcGFja2FnZURldGFpbHMsXG4gICAgICBwYWNrYWdlTWFuYWdlcixcbiAgICAgIGFwcFBhdGgsXG4gICAgICBhcHBQYWNrYWdlSnNvbixcbiAgICB9KVxuXG4gICAgLy8gbWFrZSBhIGJsYW5rIHBhY2thZ2UuanNvblxuICAgIG1rZGlycFN5bmModG1wUmVwb05wbVJvb3QpXG4gICAgd3JpdGVGaWxlU3luYyhcbiAgICAgIHRtcFJlcG9QYWNrYWdlSnNvblBhdGgsXG4gICAgICBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIGRlcGVuZGVuY2llczoge1xuICAgICAgICAgIFtwYWNrYWdlRGV0YWlscy5uYW1lXTogcmVzb2x2ZWRWZXJzaW9uLnZlcnNpb24sXG4gICAgICAgIH0sXG4gICAgICAgIHJlc29sdXRpb25zOiByZXNvbHZlUmVsYXRpdmVGaWxlRGVwZW5kZW5jaWVzKFxuICAgICAgICAgIGFwcFBhdGgsXG4gICAgICAgICAgYXBwUGFja2FnZUpzb24ucmVzb2x1dGlvbnMgfHwge30sXG4gICAgICAgICksXG4gICAgICB9KSxcbiAgICApXG5cbiAgICBjb25zdCBkZWNsYXJlZFZlcnNpb24gPSAoKCkgPT4ge1xuICAgICAgdmFyIHYgPSByZXNvbHZlZFZlcnNpb24udmVyc2lvblxuICAgICAgLy8gaHR0cHM6Ly9kb2NzLm5wbWpzLmNvbS9jbGkvdjcvY29uZmlndXJpbmctbnBtL3BhY2thZ2UtanNvblxuICAgICAgLy8gPHByb3RvY29sPjovL1s8dXNlcj5bOjxwYXNzd29yZD5dQF08aG9zdG5hbWU+Wzo8cG9ydD5dWzpdWy9dPHBhdGg+WyM8Y29tbWl0LWlzaD4gfCAjc2VtdmVyOjxzZW12ZXI+XVxuICAgICAgLy8gcG5wbSB1c2VzIGxpbms6IHByb3RvY29sIGluc3RlYWQgb2YgZmlsZTpcbiAgICAgIC8vIFRPRE8gYWRkIG1vcmUgcHJvdG9jb2xzP1xuICAgICAgdmFyIG0gPSB2Lm1hdGNoKC9eKGZpbGV8bGlua3xodHRwfGh0dHBzfGdpdHxnaXRcXCtodHRwc3xnaXRcXCtodHRwfGdpdFxcK3NzaHxnaXRcXCtmaWxlfGdpdGh1Yik6KC4rKSQvKVxuICAgICAgaWYgKG0pIHtcbiAgICAgICAgdmFyIHByb3RvY29sID0gbVsxXVxuICAgICAgICB2YXIgbG9jYXRpb24gPSBtWzJdXG4gICAgICAgIHZhciBpc0dpdCA9IHByb3RvY29sLnN0YXJ0c1dpdGgoJ2dpdCcpXG4gICAgICAgIHZhciBnaXRDb21taXQgPSAoaXNHaXQgJiYgbG9jYXRpb24uaW5jbHVkZXMoXCIjXCIpKSA/IGxvY2F0aW9uLnNwbGl0KCcjJykuc2xpY2UoLTEpWzBdIDogbnVsbFxuICAgICAgICBpZiAoaXNEZWJ1Zykge1xuICAgICAgICAgIGNvbnNvbGUuZGlyKHsgbG9jOiAnZ2V0IGRlY2xhcmVkVmVyc2lvbicsIGlzR2l0LCBnaXRDb21taXQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzR2l0ICYmICFnaXRDb21taXQpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoYGZvdW5kIHdpbGRjYXJkIGdpdCB2ZXJzaW9uICR7dn0uIFxcXG5wYWNrYWdlLmpzb24gbXVzdCBwaW4gdGhlIGV4YWN0IHZlcnNpb24gb2YgJHtwYWNrYWdlRGV0YWlscy5uYW1lfSBcXFxuaW4gdGhlIGZvcm1hdCA8cHJvdG9jb2w+OjxwYWNrYWdlUGF0aD4jPGNvbW1pdEhhc2g+LiBcXFxuY29tbWl0SGFzaCBpcyB0aGUgZnVsbCBoYXNoIHdpdGggNDAgY2hhcnMuYClcbiAgICAgICAgICBkZWxldGUgZXJyb3Iuc3RhY2tcbiAgICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgICAgIC8qIHRvbyBjb21wbGV4XG4gICAgICAgICAgLy8gZ3Vlc3MgY29tbWl0IGhhc2ggb2YgaW5zdGFsbGVkIHBhY2thZ2VcbiAgICAgICAgICB2YXIgc3RhdHMgPSBsc3RhdFN5bmMocGFja2FnZURldGFpbHMucGF0aClcbiAgICAgICAgICBpZiAoc3RhdHMuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgICAgICAgICAgdmFyIGxpbmtUYXJnZXQgPSByZWFkbGlua1N5bmMocGFja2FnZURldGFpbHMucGF0aClcbiAgICAgICAgICAgIGlmIChsaW5rVGFyZ2V0LnN0YXJ0c1dpdGgoXCIucG5wbVwiKSkge1xuICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBsaW5rVGFyZ2V0Lm1hdGNoKC9eXFwucG5wbVxcL1teL10rQChbMC05YS1mXXsxMH0pX1swLTlhLWZdezMyfVxcLy8pXG4gICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIGdpdENvbW1pdCA9IG1hdGNoWzFdXG4gICAgICAgICAgICAgICAgaWYgKGlzRGVidWcpIGNvbnNvbGUubG9nKGBwYXJzZWQgZ2l0Q29tbWl0ICR7Z2l0Q29tbWl0fSBmcm9tIHBucG0gc3ltbGlua2ApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgKi9cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNHaXQpIHtcbiAgICAgICAgICByZXR1cm4geyBmdWxsOiB2LCBwcm90b2NvbCwgbG9jYXRpb24sIGdpdENvbW1pdCB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgLy8gc2FtcGxlOiBodHRwczovL3JlZ2lzdHJ5Lnlhcm5wa2cuY29tL2xlZnQtcGFkLy0vbGVmdC1wYWQtMS4zLjAudGd6IzViOGEzYTc3NjVkZmUwMDEyNjFkZGU5MTU1ODllNzgyZjhjOTRkMWVcbiAgICAgICAgICAvLyBoYXNoIGlzIHNoYTFzdW0gb2YgdGd6IGZpbGVcbiAgICAgICAgICAvLyAtPiB1c2UgdmVyc2lvbiBudW1iZXIgZnJvbSBwYWNrYWdlJ3MgcGFja2FnZS5qc29uXG4gICAgICAgICAgdmFyIHZlcnNpb24gPSBnZXRQYWNrYWdlVmVyc2lvbihqb2luKHJlc29sdmUocGFja2FnZURldGFpbHMucGF0aCksIFwicGFja2FnZS5qc29uXCIpKVxuICAgICAgICAgIGlmIChpc1ZlcmJvc2UpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBwYXRjaC1wYWNrYWdlL21ha2VQYXRjaDogdXNpbmcgdmVyc2lvbiAke3ZlcnNpb259IGZyb20gJHtwYWNrYWdlRGV0YWlscy5uYW1lfS9wYWNrYWdlLmpzb25gKVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4geyB2ZXJzaW9uIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gaHR0cHM6Ly9kb2NzLm5wbWpzLmNvbS9hYm91dC1zZW1hbnRpYy12ZXJzaW9uaW5nXG4gICAgICAvLyBUT0RPIGhhbmRsZSBwcm90b2NvbHM/IHBucG0gd29ya3NwYWNlOiBwcm90b2NvbCBkb2VzIG5vdCBtYWtlIHNlbnNlIGhlcmUsIG5vIG5lZWQgdG8gcGF0Y2ggbG9jYWwgcGFja2FnZXNcbiAgICAgIHZhciBtID0gdi5tYXRjaCgvXihbfl5dKSguKikkLylcbiAgICAgIGlmIChtKSB7XG4gICAgICAgIHZhciBleGFtcGxlVmVyc2lvbiA9IG1bMV1cbiAgICAgICAgaWYgKCFleGFtcGxlVmVyc2lvbikge1xuICAgICAgICAgIGV4YW1wbGVWZXJzaW9uID0gJzEuMC4wJ1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUud2FybihgcGF0Y2gtcGFja2FnZS9tYWtlUGF0Y2g6IHdhcm5pbmc6IGZvdW5kIHdpbGRjYXJkIHZlcnNpb24gJHt2fS4gXFxcbnRvIGVuc3VyZSBzdWNjZXNzZnVsIHBhdGNoaW5nLCBwYWNrYWdlLmpzb24gc2hvdWxkIHBpbiB0aGUgZXhhY3QgdmVyc2lvbiBvZiAke3BhY2thZ2VEZXRhaWxzLm5hbWV9IFxcXG5pbiB0aGUgZm9ybWF0IDxtYWpvcj4uPG1pbm9yPi48cGF0Y2g+LCBmb3IgZXhhbXBsZTogXCIke3BhY2thZ2VEZXRhaWxzLm5hbWV9XCI6IFwiJHtleGFtcGxlVmVyc2lvbn1cImApXG4gICAgICB9XG4gICAgICByZXR1cm4geyBmdWxsOiB2LCB2ZXJzaW9uOiB2IH1cbiAgICB9KSgpXG5cbiAgICBpZiAoaXNEZWJ1Zykge1xuICAgICAgLy9jb25zb2xlLmxvZyhgcGF0Y2gtcGFja2FnZS9tYWtlUGF0Y2g6IHJlc29sdmVkVmVyc2lvbi5vcmlnaW5Db21taXQgPSAke3Jlc29sdmVkVmVyc2lvbi5vcmlnaW5Db21taXR9YClcbiAgICAgIGNvbnNvbGUubG9nKGBwYXRjaC1wYWNrYWdlL21ha2VQYXRjaDogZGVjbGFyZWRWZXJzaW9uLnZlcnNpb24gPSAke2RlY2xhcmVkVmVyc2lvbi52ZXJzaW9ufWApXG4gICAgICBjb25zb2xlLmxvZyhgcGF0Y2gtcGFja2FnZS9tYWtlUGF0Y2g6IGRlY2xhcmVkVmVyc2lvbi5naXRDb21taXQgPSAke2RlY2xhcmVkVmVyc2lvbi5naXRDb21taXR9YClcbiAgICAgIGNvbnNvbGUubG9nKGBwYXRjaC1wYWNrYWdlL21ha2VQYXRjaDogZGVjbGFyZWRWZXJzaW9uLmZ1bGwgPSAke2RlY2xhcmVkVmVyc2lvbi5mdWxsfWApXG4gICAgfVxuXG4gICAgY29uc3QgcGFja2FnZVZlcnNpb24gPSAoXG4gICAgICBkZWNsYXJlZFZlcnNpb24udmVyc2lvbiB8fCBkZWNsYXJlZFZlcnNpb24uZ2l0Q29tbWl0IHx8IGRlY2xhcmVkVmVyc2lvbi5mdWxsXG4gICAgKVxuXG4gICAgLy8gb3JpZ2luQ29tbWl0IGlzIG1vcmUgcHJlY2lzZSB0aGFuIHBrZy52ZXJzaW9uXG4gICAgaWYgKGlzRGVidWcpIHtcbiAgICAgIC8vY29uc29sZS5sb2coYHBhdGNoLXBhY2thZ2UvbWFrZVBhdGNoOiByZXNvbHZlZFZlcnNpb24ub3JpZ2luQ29tbWl0ID0gJHtyZXNvbHZlZFZlcnNpb24ub3JpZ2luQ29tbWl0fWApXG4gICAgICBjb25zb2xlLmxvZyhgcGF0Y2gtcGFja2FnZS9tYWtlUGF0Y2g6IHJlc29sdmVkVmVyc2lvbi52ZXJzaW9uID0gJHtyZXNvbHZlZFZlcnNpb24udmVyc2lvbn1gKVxuICAgICAgY29uc29sZS5sb2coYHBhdGNoLXBhY2thZ2UvbWFrZVBhdGNoOiBwYWNrYWdlVmVyc2lvbiA9ICR7cGFja2FnZVZlcnNpb259YClcbiAgICB9XG5cbiAgICAvL2NvbnN0IHBhY2thZ2VWZXJzaW9uID1cbiAgICAvLyAgcmVzb2x2ZWRWZXJzaW9uLm9yaWdpbkNvbW1pdCB8fFxuICAgIC8vICBnZXRQYWNrYWdlVmVyc2lvbihqb2luKHJlc29sdmUocGFja2FnZURldGFpbHMucGF0aCksIFwicGFja2FnZS5qc29uXCIpKVxuXG4gICAgLy8gdGhpcyBpcyBicm9rZW4gd2hlbiBpbnN0YWxsaW5nIGZyb20gZ2l0IC0+IHZlcnNpb24gY2FuIGJlIGEgcHNldWRvLXZlcnNpb24gbGlrZSAxLjAuMC1jYW5hcnlcbiAgICAvL2NvbnN0IHBhY2thZ2VWZXJzaW9uID0gZ2V0UGFja2FnZVZlcnNpb24oam9pbihyZXNvbHZlKHBhY2thZ2VEZXRhaWxzLnBhdGgpLCBcInBhY2thZ2UuanNvblwiKSlcblxuICAgIC8vIFRPRE8gcmVuYW1lIHJlc29sdmVkVmVyc2lvbiAtPiBkZWNsYXJlZFZlcnNpb25cblxuICAgIC8vIEZJWE1FIGZhbHNlIHBvc2l0aXZlXG4gICAgLy8gdGVzdCBpbnRlZ3JhdGlvbi10ZXN0cy9jcmVhdGUtaXNzdWUvY3JlYXRlLWlzc3VlLnRlc3QudHNcbiAgICAvLyAtPiBwYXRjaGluZyBsZWZ0LXBhZCBwcm9tcHRzIHRvIHN1Ym1pdCBhbiBpc3N1ZVxuICAgIC8vIGh0dHBzOi8vcmVnaXN0cnkueWFybnBrZy5jb20vbGVmdC1wYWQvLS9sZWZ0LXBhZC0xLjMuMC50Z3ojNWI4YTNhNzc2NWRmZTAwMTI2MWRkZTkxNTU4OWU3ODJmOGM5NGQxZVxuICAgIC8vIGhhc2ggaXMgc2hhIGNoZWNrc3VtIG9mIHRneiBmaWxlIC0+IGp1c3QgdXNlIHRoZSB2ZXJzaW9uIDEuMy4wXG4gICAgLypcbiAgICBjb25zdCBwYWNrYWdlVmVyc2lvbiA9IChcbiAgICAgICFyZXNvbHZlZFZlcnNpb24udmVyc2lvbi5tYXRjaCgvXihmaWxlOnxsaW5rOikvKSA/IHJlc29sdmVkVmVyc2lvbi52ZXJzaW9uIDpcbiAgICAgIGdldFBhY2thZ2VWZXJzaW9uKGpvaW4ocmVzb2x2ZShwYWNrYWdlRGV0YWlscy5wYXRoKSwgXCJwYWNrYWdlLmpzb25cIikpXG4gICAgKVxuICAgICovXG5cbiAgICBpZiAoaXNEZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coYHBhdGNoLXBhY2thZ2UvbWFrZVBhdGNoOiBnZXRQYWNrYWdlVmVyc2lvbiAtPiAke2dldFBhY2thZ2VWZXJzaW9uKGpvaW4ocmVzb2x2ZShwYWNrYWdlRGV0YWlscy5wYXRoKSwgXCJwYWNrYWdlLmpzb25cIikpfWApXG4gICAgICBjb25zb2xlLmxvZyhgcGF0Y2gtcGFja2FnZS9tYWtlUGF0Y2g6IHBhY2thZ2UgcGF0aCA9ICR7cGFja2FnZURldGFpbHMucGF0aH1gKVxuICAgICAgY29uc29sZS5sb2coYHBhdGNoLXBhY2thZ2UvbWFrZVBhdGNoOiBwYWNrYWdlIHBhdGggcmVzb2x2ZWQgPSAke3Jlc29sdmUocGFja2FnZURldGFpbHMucGF0aCl9YClcbiAgICB9XG5cbiAgICAvLyBjb3B5IC5ucG1yYy8ueWFybnJjIGluIGNhc2UgcGFja2FnZXMgYXJlIGhvc3RlZCBpbiBwcml2YXRlIHJlZ2lzdHJ5XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmFsaWduXG4gICAgO1tcIi5ucG1yY1wiLCBcIi55YXJucmNcIl0uZm9yRWFjaCgocmNGaWxlKSA9PiB7XG4gICAgICBjb25zdCByY1BhdGggPSBqb2luKGFwcFBhdGgsIHJjRmlsZSlcbiAgICAgIGlmIChleGlzdHNTeW5jKHJjUGF0aCkpIHtcbiAgICAgICAgY29weVN5bmMocmNQYXRoLCBqb2luKHRtcFJlcG8ubmFtZSwgcmNGaWxlKSlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgaWYgKHBhY2thZ2VNYW5hZ2VyID09PSBcInlhcm5cIikge1xuICAgICAgY29uc29sZS5pbmZvKFxuICAgICAgICBjaGFsay5ncmV5KFwi4oCiXCIpLFxuICAgICAgICBgSW5zdGFsbGluZyAke3BhY2thZ2VEZXRhaWxzLm5hbWV9QCR7cGFja2FnZVZlcnNpb259IHdpdGggeWFybmAsXG4gICAgICApXG4gICAgICB0cnkge1xuICAgICAgICAvLyB0cnkgZmlyc3Qgd2l0aG91dCBpZ25vcmluZyBzY3JpcHRzIGluIGNhc2UgdGhleSBhcmUgcmVxdWlyZWRcbiAgICAgICAgLy8gdGhpcyB3b3JrcyBpbiA5OS45OSUgb2YgY2FzZXNcbiAgICAgICAgc3Bhd25TYWZlU3luYyhgeWFybmAsIFtcImluc3RhbGxcIiwgXCItLWlnbm9yZS1lbmdpbmVzXCJdLCB7XG4gICAgICAgICAgY3dkOiB0bXBSZXBvTnBtUm9vdCxcbiAgICAgICAgICBsb2dTdGRFcnJPbkVycm9yOiBmYWxzZSxcbiAgICAgICAgfSlcbiAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICAvLyB0cnkgYWdhaW4gd2hpbGUgaWdub3Jpbmcgc2NyaXB0cyBpbiBjYXNlIHRoZSBzY3JpcHQgZGVwZW5kcyBvblxuICAgICAgICAvLyBhbiBpbXBsaWNpdCBjb250ZXh0IHdoaWNoIHdlIGhhdm4ndCByZXByb2R1Y2VkXG4gICAgICAgIHNwYXduU2FmZVN5bmMoXG4gICAgICAgICAgYHlhcm5gLFxuICAgICAgICAgIFtcImluc3RhbGxcIiwgXCItLWlnbm9yZS1lbmdpbmVzXCIsIFwiLS1pZ25vcmUtc2NyaXB0c1wiXSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjd2Q6IHRtcFJlcG9OcG1Sb290LFxuICAgICAgICAgIH0sXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbnBtQ21kID0gcGFja2FnZU1hbmFnZXIgPT09IFwicG5wbVwiID8gXCJwbnBtXCIgOiBcIm5wbVwiXG4gICAgICBjb25zb2xlLmluZm8oXG4gICAgICAgIGNoYWxrLmdyZXkoXCLigKJcIiksXG4gICAgICAgIGBJbnN0YWxsaW5nICR7cGFja2FnZURldGFpbHMubmFtZX1AJHtwYWNrYWdlVmVyc2lvbn0gd2l0aCAke25wbUNtZH1gLFxuICAgICAgKVxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gdHJ5IGZpcnN0IHdpdGhvdXQgaWdub3Jpbmcgc2NyaXB0cyBpbiBjYXNlIHRoZXkgYXJlIHJlcXVpcmVkXG4gICAgICAgIC8vIHRoaXMgd29ya3MgaW4gOTkuOTklIG9mIGNhc2VzXG4gICAgICAgIGlmIChpc1ZlcmJvc2UpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgIGBwYXRjaC1wYWNrYWdlL21ha2VQYXRjaDogcnVuIFwiJHtucG1DbWR9IGluc3RhbGwgLS1mb3JjZVwiIGluICR7dG1wUmVwb05wbVJvb3R9YCxcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgICAgc3Bhd25TYWZlU3luYyhucG1DbWQsIFtcImluc3RhbGxcIiwgXCItLWZvcmNlXCJdLCB7XG4gICAgICAgICAgY3dkOiB0bXBSZXBvTnBtUm9vdCxcbiAgICAgICAgICBsb2dTdGRFcnJPbkVycm9yOiBmYWxzZSxcbiAgICAgICAgICBzdGRpbzogaXNWZXJib3NlID8gXCJpbmhlcml0XCIgOiBcImlnbm9yZVwiLFxuICAgICAgICB9KVxuICAgICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAgIC8vIHRyeSBhZ2FpbiB3aGlsZSBpZ25vcmluZyBzY3JpcHRzIGluIGNhc2UgdGhlIHNjcmlwdCBkZXBlbmRzIG9uXG4gICAgICAgIC8vIGFuIGltcGxpY2l0IGNvbnRleHQgd2hpY2ggd2UgaGF2bid0IHJlcHJvZHVjZWRcbiAgICAgICAgaWYgKGlzVmVyYm9zZSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgYHBhdGNoLXBhY2thZ2UvbWFrZVBhdGNoOiBydW4gXCIke25wbUNtZH0gaW5zdGFsbCAtLWlnbm9yZS1zY3JpcHRzIC0tZm9yY2VcIiBpbiAke3RtcFJlcG9OcG1Sb290fWAsXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIHNwYXduU2FmZVN5bmMobnBtQ21kLCBbXCJpbnN0YWxsXCIsIFwiLS1pZ25vcmUtc2NyaXB0c1wiLCBcIi0tZm9yY2VcIl0sIHtcbiAgICAgICAgICBjd2Q6IHRtcFJlcG9OcG1Sb290LFxuICAgICAgICAgIHN0ZGlvOiBpc1ZlcmJvc2UgPyBcImluaGVyaXRcIiA6IFwiaWdub3JlXCIsXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICBpZiAocGFja2FnZU1hbmFnZXIgPT09IFwicG5wbVwiKSB7XG4gICAgICAgIC8vIHdvcmthcm91bmQgZm9yIGBnaXQgZGlmZmA6IHJlcGxhY2Ugc3ltbGluayB3aXRoIGhhcmRsaW5rXG4gICAgICAgIGNvbnN0IHBrZ1BhdGggPSB0bXBSZXBvTnBtUm9vdCArIFwiL25vZGVfbW9kdWxlcy9cIiArIHBhY2thZ2VEZXRhaWxzLm5hbWVcbiAgICAgICAgY29uc3QgcmVhbFBhdGggPSByZWFscGF0aFN5bmMocGtnUGF0aClcbiAgICAgICAgdW5saW5rU3luYyhwa2dQYXRoKSAvLyBybSBzeW1saW5rXG4gICAgICAgIHJlbmFtZVN5bmMocmVhbFBhdGgsIHBrZ1BhdGgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2l0KC4uLmFyZ3M6IHN0cmluZ1tdKSB7XG4gICAgICBpZiAoaXNEZWJ1Zykge1xuICAgICAgICBjb25zdCBhcmdzU3RyID0gSlNPTi5zdHJpbmdpZnkoW1wiZ2l0XCIsIC4uLmFyZ3NdKVxuICAgICAgICBjb25zb2xlLmxvZyhgcGF0Y2gtcGFja2FnZS9tYWtlUGF0Y2g6IHNwYXduOiBhcmdzID0gJHthcmdzU3RyfSArIHdvcmtkaXIgPSAke3RtcFJlcG8ubmFtZX1gKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNwYXduU2FmZVN5bmMoXCJnaXRcIiwgYXJncywge1xuICAgICAgICBjd2Q6IHRtcFJlcG8ubmFtZSxcbiAgICAgICAgZW52OiB7IC4uLnByb2Nlc3MuZW52LCBIT01FOiB0bXBSZXBvLm5hbWUgfSxcbiAgICAgICAgbWF4QnVmZmVyOiAxMDI0ICogMTAyNCAqIDEwMCxcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIG5lc3RlZCBub2RlX21vZHVsZXMganVzdCB0byBiZSBzYWZlXG4gICAgcmltcmFmKGpvaW4odG1wUmVwb1BhY2thZ2VQYXRoLCBcIm5vZGVfbW9kdWxlc1wiKSlcbiAgICAvLyByZW1vdmUgLmdpdCBqdXN0IHRvIGJlIHNhZmVcbiAgICByaW1yYWYoam9pbih0bXBSZXBvUGFja2FnZVBhdGgsIFwiLmdpdFwiKSlcblxuICAgIC8vIGNvbW1pdCB0aGUgcGFja2FnZVxuICAgIGNvbnNvbGUuaW5mbyhjaGFsay5ncmV5KFwi4oCiXCIpLCBcIkRpZmZpbmcgeW91ciBmaWxlcyB3aXRoIGNsZWFuIGZpbGVzXCIpXG4gICAgd3JpdGVGaWxlU3luYyhqb2luKHRtcFJlcG8ubmFtZSwgXCIuZ2l0aWdub3JlXCIpLCBcIiEvbm9kZV9tb2R1bGVzXFxuXFxuXCIpXG4gICAgZ2l0KFwiLWNcIiwgXCJpbml0LmRlZmF1bHRCcmFuY2g9bWFpblwiLCBcImluaXRcIilcblxuICAgIC8vIHJlbW92ZSBpZ25vcmVkIGZpbGVzIGZpcnN0XG4gICAgLy8gdXNlIENMSSBvcHRpb25zIC0tZXhjbHVkZSBhbmQgLS1pbmNsdWRlXG4gICAgcmVtb3ZlSWdub3JlZEZpbGVzKHRtcFJlcG9QYWNrYWdlUGF0aCwgaW5jbHVkZVBhdGhzLCBleGNsdWRlUGF0aHMpXG5cbiAgICBnaXQoXCJhZGRcIiwgXCItZlwiLCBwYWNrYWdlRGV0YWlscy5wYXRoKVxuICAgIGlmIChpc1ZlcmJvc2UpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBnaXQgc3RhdHVzOlxcbmAgKyBnaXQoXCJzdGF0dXNcIikuc3Rkb3V0LnRvU3RyaW5nKCkpXG4gICAgfVxuICAgIGdpdChcIi1jXCIsIFwidXNlci5uYW1lPXBhdGNoLXBhY2thZ2VcIiwgXCItY1wiLCBcInVzZXIuZW1haWw9XCIsIFwiY29tbWl0XCIsIFwiLS1hbGxvdy1lbXB0eVwiLCBcIi1tXCIsIFwiaW5pdFwiKVxuXG4gICAgLy8gcmVwbGFjZSBwYWNrYWdlIHdpdGggdXNlcidzIHZlcnNpb25cbiAgICBpZiAoaXNWZXJib3NlKSB7XG4gICAgICBjb25zb2xlLmxvZyhgcGF0Y2gtcGFja2FnZS9tYWtlUGF0Y2g6IHJlbW92ZSBhbGwgZmlsZXMgaW4gJHt0bXBSZXBvUGFja2FnZVBhdGh9YClcbiAgICB9XG4gICAgcmltcmFmKHRtcFJlcG9QYWNrYWdlUGF0aClcblxuICAgIGlmIChpc1ZlcmJvc2UpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBwYXRjaC1wYWNrYWdlL21ha2VQYXRjaDogZ2l0IHN0YXR1czpcXG5gICsgZ2l0KFwic3RhdHVzXCIpLnN0ZG91dC50b1N0cmluZygpKVxuICAgIH1cblxuICAgIC8vIHBucG0gaW5zdGFsbHMgcGFja2FnZXMgYXMgc3ltbGlua3MsIGNvcHlTeW5jIHdvdWxkIGNvcHkgb25seSB0aGUgc3ltbGlua1xuICAgIC8vIHdpdGggcG5wbSwgcmVhbHBhdGggcmVzb2x2ZXMgdG8gLi9ub2RlX21vZHVsZXMvLnBucG0vJHtuYW1lfUAke3ZlcnNpb259XG4gICAgY29uc3Qgc3JjUGF0aCA9IHJlYWxwYXRoU3luYyhwYWNrYWdlUGF0aClcbiAgICBpZiAoaXNWZXJib3NlKSB7XG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgYHBhdGNoLXBhY2thZ2UvbWFrZVBhdGNoOiBjb3B5ICR7c3JjUGF0aH0gdG8gJHt0bXBSZXBvUGFja2FnZVBhdGh9ICsgc2tpcCAke3NyY1BhdGh9L25vZGVfbW9kdWxlcy9gLFxuICAgICAgKVxuICAgIH1cbiAgICBjb3B5U3luYyhzcmNQYXRoLCB0bXBSZXBvUGFja2FnZVBhdGgsIHtcbiAgICAgIGZpbHRlcjogKHBhdGgpID0+IHtcbiAgICAgICAgY29uc3QgZG9Db3B5ID0gIXBhdGguc3RhcnRzV2l0aChzcmNQYXRoICsgXCIvbm9kZV9tb2R1bGVzL1wiKVxuICAgICAgICBpZiAoaXNWZXJib3NlKSB7XG4gICAgICAgICAgaWYgKGRvQ29weSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYHBhdGNoLXBhY2thZ2UvbWFrZVBhdGNoOiBjb3B5U3luYzogY29weSBmaWxlICR7cGF0aH1gKVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBwYXRjaC1wYWNrYWdlL21ha2VQYXRjaDogY29weVN5bmM6IHNraXAgZmlsZSAke3BhdGh9YClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvQ29weVxuICAgICAgfSxcbiAgICB9KVxuXG4gICAgaWYgKGlzRGVidWcpIHtcbiAgICAgIC8vIGxpc3QgZmlsZXNcbiAgICAgIC8vIE5PVEUgdGhpcyB3b3JrcyBvbmx5IG9uIGxpbnV4XG4gICAgICBjb25zb2xlLmxvZyhgcGF0Y2gtcGFja2FnZS9tYWtlUGF0Y2g6IGZpbGVzIGluIHNyY1BhdGggPSAke3NyY1BhdGh9YClcbiAgICAgIGNvbnNvbGUubG9nKHNwYXduU3luYygnZmluZCcsIFsnLiddLCB7IGN3ZDogc3JjUGF0aCwgZW5jb2Rpbmc6ICd1dGY4JyB9KS5zdGRvdXQpXG4gICAgICBjb25zb2xlLmxvZyhgcGF0Y2gtcGFja2FnZS9tYWtlUGF0Y2g6IGZpbGVzIGluIHRtcFJlcG9QYWNrYWdlUGF0aCA9ICR7dG1wUmVwb1BhY2thZ2VQYXRofWApXG4gICAgICBjb25zb2xlLmxvZyhzcGF3blN5bmMoJ2ZpbmQnLCBbJy4nXSwgeyBjd2Q6IHRtcFJlcG9QYWNrYWdlUGF0aCwgZW5jb2Rpbmc6ICd1dGY4JyB9KS5zdGRvdXQpXG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIG5lc3RlZCBub2RlX21vZHVsZXMganVzdCB0byBiZSBzYWZlXG4gICAgcmltcmFmKGpvaW4odG1wUmVwb1BhY2thZ2VQYXRoLCBcIm5vZGVfbW9kdWxlc1wiKSlcblxuICAgIC8vIHJlbW92ZSAuZ2l0IGp1c3QgdG8gYmUgc2FmZVxuICAgIC8vIE5PVEUgdGhpcyByZW1vdmVzIC4vbm9kZV9tb2R1bGVzLyR7ZGVwZW5kZW5jeU5hbWV9Ly5naXQgbm90IC4vLmdpdFxuICAgIHJpbXJhZihqb2luKHRtcFJlcG9QYWNrYWdlUGF0aCwgXCIuZ2l0XCIpKVxuXG4gICAgLy8gYWxzbyByZW1vdmUgaWdub3JlZCBmaWxlcyBsaWtlIGJlZm9yZVxuICAgIC8vIGZvciBleGFtcGxlLCByZW1vdmUgcGFja2FnZS5qc29uXG4gICAgLy8gVE9ETyBzdXBwb3J0IHBhdGNoaW5nIHBhY2thZ2UuanNvbiB2aWEgc2VtYW50aWMganNvbiBkaWZmXG4gICAgLy8gdXNlIENMSSBvcHRpb25zIC0tZXhjbHVkZSBhbmQgLS1pbmNsdWRlXG5cbiAgICBpZiAoaXNEZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coYHBhdGNoLXBhY2thZ2UvbWFrZVBhdGNoOiByZW1vdmluZyBpZ25vcmVkIGZpbGVzIGluIHRtcFJlcG9QYWNrYWdlUGF0aCA9ICR7dG1wUmVwb1BhY2thZ2VQYXRofTpgKVxuICAgIH1cbiAgICByZW1vdmVJZ25vcmVkRmlsZXModG1wUmVwb1BhY2thZ2VQYXRoLCBpbmNsdWRlUGF0aHMsIGV4Y2x1ZGVQYXRocylcblxuICAgIGlmIChpc0RlYnVnKSB7XG4gICAgICAvLyBsaXN0IGZpbGVzXG4gICAgICAvLyBOT1RFIHRoaXMgd29ya3Mgb25seSBvbiBsaW51eFxuICAgICAgY29uc29sZS5sb2coYHBhdGNoLXBhY2thZ2UvbWFrZVBhdGNoOiBmaWxlcyBpbiB0bXBSZXBvUGFja2FnZVBhdGggPSAke3RtcFJlcG9QYWNrYWdlUGF0aH06YClcbiAgICAgIGNvbnNvbGUubG9nKHNwYXduU3luYygnZmluZCcsIFsnLicsICctdHlwZScsICdmJ10sIHsgY3dkOiB0bXBSZXBvUGFja2FnZVBhdGgsIGVuY29kaW5nOiAndXRmOCcgfSkuc3Rkb3V0KVxuICAgIH1cblxuICAgIC8vIHN0YWdlIGFsbCBmaWxlc1xuICAgIGdpdChcImFkZFwiLCBcIi1mXCIsIHBhY2thZ2VEZXRhaWxzLnBhdGgpXG5cbiAgICBpZiAoaXNWZXJib3NlKSB7XG4gICAgICBjb25zb2xlLmxvZyhgcGF0Y2gtcGFja2FnZS9tYWtlUGF0Y2g6IGdpdCBzdGF0dXM6XFxuYCArIGdpdChcInN0YXR1c1wiKS5zdGRvdXQudG9TdHJpbmcoKSlcbiAgICB9XG5cbiAgICBjb25zdCBpZ25vcmVQYXRocyA9IFtcInBhY2thZ2UtbG9jay5qc29uXCIsIFwicG5wbS1sb2NrLnlhbWxcIl1cblxuICAgIC8vIGdldCBkaWZmIG9mIGNoYW5nZXNcbiAgICBjb25zdCBkaWZmUmVzdWx0ID0gZ2l0KFxuICAgICAgXCJkaWZmXCIsXG4gICAgICBcIi0tY2FjaGVkXCIsXG4gICAgICBcIi0tbm8tY29sb3JcIixcbiAgICAgIFwiLS1pZ25vcmUtc3BhY2UtYXQtZW9sXCIsXG4gICAgICBcIi0tbm8tZXh0LWRpZmZcIixcbiAgICAgIC4uLmlnbm9yZVBhdGhzLm1hcChcbiAgICAgICAgKHBhdGgpID0+IGA6KGV4Y2x1ZGUsdG9wKSR7cGFja2FnZURldGFpbHMucGF0aH0vJHtwYXRofWAsXG4gICAgICApLFxuICAgIClcblxuICAgIGlmIChkaWZmUmVzdWx0LnN0ZG91dC5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYOKBie+4jyAgTm90IGNyZWF0aW5nIHBhdGNoIGZpbGUgZm9yIHBhY2thZ2UgJyR7cGFja2FnZVBhdGhTcGVjaWZpZXJ9J2AsXG4gICAgICApXG4gICAgICBjb25zb2xlLndhcm4oYOKBie+4jyAgVGhlcmUgZG9uJ3QgYXBwZWFyIHRvIGJlIGFueSBjaGFuZ2VzLmApXG4gICAgICBjbGVhbnVwKClcbiAgICAgIHByb2Nlc3MuZXhpdCgxKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHBhcnNlUGF0Y2hGaWxlKGRpZmZSZXN1bHQuc3Rkb3V0LnRvU3RyaW5nKCkpXG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICBpZiAoIShlIGluc3RhbmNlb2YgRXJyb3IpKSByZXR1cm5cbiAgICAgIGlmIChcbiAgICAgICAgZS5tZXNzYWdlLmluY2x1ZGVzKFwiVW5leHBlY3RlZCBmaWxlIG1vZGUgc3RyaW5nOiAxMjAwMDBcIilcbiAgICAgICkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBcbuKblO+4jyAke2NoYWxrLnJlZC5ib2xkKFwiRVJST1JcIil9XG5cbiAgWW91ciBjaGFuZ2VzIGludm9sdmUgY3JlYXRpbmcgc3ltbGlua3MuIHBhdGNoLXBhY2thZ2UgZG9lcyBub3QgeWV0IHN1cHBvcnRcbiAgc3ltbGlua3MuXG4gIFxuICDvuI9QbGVhc2UgdXNlICR7Y2hhbGsuYm9sZChcIi0taW5jbHVkZVwiKX0gYW5kL29yICR7Y2hhbGsuYm9sZChcbiAgICAgICAgICBcIi0tZXhjbHVkZVwiLFxuICAgICAgICApfSB0byBuYXJyb3cgdGhlIHNjb3BlIG9mIHlvdXIgcGF0Y2ggaWZcbiAgdGhpcyB3YXMgdW5pbnRlbnRpb25hbC5cbmApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBvdXRQYXRoID0gXCIuL3BhdGNoLXBhY2thZ2UtZXJyb3IuanNvbi5nelwiXG4gICAgICAgIHdyaXRlRmlsZVN5bmMoXG4gICAgICAgICAgb3V0UGF0aCxcbiAgICAgICAgICBnemlwU3luYyhcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgZXJyb3I6IHsgbWVzc2FnZTogZS5tZXNzYWdlLCBzdGFjazogZS5zdGFjayB9LFxuICAgICAgICAgICAgICBwYXRjaDogZGlmZlJlc3VsdC5zdGRvdXQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICksXG4gICAgICAgIClcbiAgICAgICAgY29uc29sZS5lcnJvcihgXG7im5TvuI8gJHtjaGFsay5yZWQuYm9sZChcIkVSUk9SXCIpfVxuICAgICAgICBcbiAgcGF0Y2gtcGFja2FnZSB3YXMgdW5hYmxlIHRvIHJlYWQgdGhlIHBhdGNoLWZpbGUgbWFkZSBieSBnaXQuIFRoaXMgc2hvdWxkIG5vdFxuICBoYXBwZW4uXG4gIFxuICBBIGRpYWdub3N0aWMgZmlsZSB3YXMgd3JpdHRlbiB0b1xuICBcbiAgICAke291dFBhdGh9XG4gIFxuICBQbGVhc2UgYXR0YWNoIGl0IHRvIGEgZ2l0aHViIGlzc3VlXG4gIFxuICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9kczMwMC9wYXRjaC1wYWNrYWdlL2lzc3Vlcy9uZXc/dGl0bGU9TmV3K3BhdGNoK3BhcnNlK2ZhaWxlZCZib2R5PVBsZWFzZSthdHRhY2grdGhlK2RpYWdub3N0aWMrZmlsZStieStkcmFnZ2luZytpdCtpbnRvK2hlcmUr8J+Zj1xuICBcbiAgTm90ZSB0aGF0IHRoaXMgZGlhZ25vc3RpYyBmaWxlIHdpbGwgY29udGFpbiBjb2RlIGZyb20gdGhlIHBhY2thZ2UgeW91IHdlcmVcbiAgYXR0ZW1wdGluZyB0byBwYXRjaC5cblxuYClcbiAgICAgIH1cbiAgICAgIGNsZWFudXAoKVxuICAgICAgcHJvY2Vzcy5leGl0KDEpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBtYXliZSBkZWxldGUgZXhpc3RpbmdcbiAgICBnZXRQYXRjaEZpbGVzKHBhdGNoRGlyKS5mb3JFYWNoKChmaWxlbmFtZSkgPT4ge1xuICAgICAgY29uc3QgZGVldHMgPSBnZXRQYWNrYWdlRGV0YWlsc0Zyb21QYXRjaEZpbGVuYW1lKGZpbGVuYW1lKVxuICAgICAgaWYgKGRlZXRzICYmIGRlZXRzLnBhdGggPT09IHBhY2thZ2VEZXRhaWxzLnBhdGgpIHtcbiAgICAgICAgdW5saW5rU3luYyhqb2luKHBhdGNoRGlyLCBmaWxlbmFtZSkpXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIHBhdGNoZmlsZXMgYXJlIHBhcnNlZCBpbiBwYXRjaC9wYXJzZS50cyBmdW5jdGlvbiBwYXJzZVBhdGNoTGluZXNcbiAgICAvLyAtPiBoZWFkZXIgY29tbWVudHMgYXJlIGlnbm9yZWRcbiAgICBsZXQgZGlmZkhlYWRlciA9IFwiXCJcbiAgICBkaWZmSGVhZGVyICs9IGAjIGdlbmVyYXRlZCBieSBwYXRjaC1wYWNrYWdlICR7cGF0Y2hQYWNrYWdlVmVyc2lvbn1cXG5gXG4gICAgZGlmZkhlYWRlciArPSBgI1xcbmBcbiAgICBpZiAoaXNEZWJ1Zykge1xuICAgICAgcmVzb2x2ZWRWZXJzaW9uLnZlcnNpb25cbiAgICB9XG4gICAgZGlmZkhlYWRlciArPSBgIyBkZWNsYXJlZCBwYWNrYWdlOlxcbmBcbiAgICBkaWZmSGVhZGVyICs9IGAjICAgJHtwYWNrYWdlRGV0YWlscy5uYW1lfTogJHtyZXNvbHZlZFZlcnNpb24uZGVjbGFyZWRWZXJzaW9ufVxcbmBcbiAgICAvLyBOT1RFOiB3ZSBkbyAqbm90KiBpbmNsdWRlIHRoZSBsb2NrZWQgdmVyc2lvbiBmcm9tIHBhY2thZ2UtbG9jay5qc29uIG9yIHlhcm4ubG9jayBvciBwbnBtLWxvY2sueWFtbCBvciAuLi5cbiAgICAvLyBiZWNhdXNlIHBhdGNoLXBhY2thZ2Ugc2hvdWxkIHdvcmsgd2l0aCBhbGwgcGFja2FnZSBtYW5hZ2VycyAoc2hvdWxkIGJlIG1hbmFnZXItYWdub3N0aWMpXG4gICAgLy8gdXNlcnMgY2FuIHBpbiB2ZXJzaW9ucyBpbiBwYWNrYWdlLmpzb25cbiAgICBkaWZmSGVhZGVyICs9IGAjXFxuYFxuXG4gICAgY29uc3QgcGF0Y2hGaWxlTmFtZSA9IGNyZWF0ZVBhdGNoRmlsZU5hbWUoe1xuICAgICAgcGFja2FnZURldGFpbHMsXG4gICAgICBwYWNrYWdlVmVyc2lvbixcbiAgICB9KVxuXG4gICAgY29uc3QgcGF0Y2hQYXRoID0gam9pbihwYXRjaGVzRGlyLCBwYXRjaEZpbGVOYW1lKVxuICAgIGlmICghZXhpc3RzU3luYyhkaXJuYW1lKHBhdGNoUGF0aCkpKSB7XG4gICAgICBta2RpclN5bmMoZGlybmFtZShwYXRjaFBhdGgpLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KVxuICAgIH1cbiAgICB3cml0ZUZpbGVTeW5jKHBhdGNoUGF0aCwgZGlmZkhlYWRlciArIGRpZmZSZXN1bHQuc3Rkb3V0KVxuICAgIGNvbnNvbGUubG9nKFxuICAgICAgYCR7Y2hhbGsuZ3JlZW4oXCLinJRcIil9IENyZWF0ZWQgZmlsZSAke2pvaW4ocGF0Y2hEaXIsIHBhdGNoRmlsZU5hbWUpfVxcbmAsXG4gICAgKVxuICAgIGlmIChjcmVhdGVJc3N1ZSkge1xuICAgICAgb3Blbklzc3VlQ3JlYXRpb25MaW5rKHtcbiAgICAgICAgcGFja2FnZURldGFpbHMsXG4gICAgICAgIHBhdGNoRmlsZUNvbnRlbnRzOiBkaWZmUmVzdWx0LnN0ZG91dC50b1N0cmluZygpLFxuICAgICAgICBwYWNrYWdlVmVyc2lvbixcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIG1heWJlUHJpbnRJc3N1ZUNyZWF0aW9uUHJvbXB0KHBhY2thZ2VEZXRhaWxzLCBwYWNrYWdlTWFuYWdlcilcbiAgICB9XG4gIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgIC8vY29uc29sZS5lcnJvcihlKVxuICAgIHRocm93IGVcbiAgfSBmaW5hbGx5IHtcbiAgICBjbGVhbnVwKClcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVQYXRjaEZpbGVOYW1lKHtcbiAgcGFja2FnZURldGFpbHMsXG4gIHBhY2thZ2VWZXJzaW9uLFxufToge1xuICBwYWNrYWdlRGV0YWlsczogUGFja2FnZURldGFpbHNcbiAgcGFja2FnZVZlcnNpb246IHN0cmluZ1xufSkge1xuICBjb25zdCBwYWNrYWdlTmFtZXMgPSBwYWNrYWdlRGV0YWlscy5wYWNrYWdlTmFtZXNcbiAgICAubWFwKChuYW1lKSA9PiBuYW1lLnJlcGxhY2UoL1xcLy9nLCBcIitcIikpXG4gICAgLmpvaW4oXCIrK1wiKVxuXG4gIHJldHVybiBgJHtwYWNrYWdlTmFtZXN9KyR7cGFja2FnZVZlcnNpb259LnBhdGNoYFxufVxuIl19
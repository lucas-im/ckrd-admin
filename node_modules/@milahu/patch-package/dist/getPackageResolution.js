"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPackageResolution = void 0;
const path_1 = require("./path");
const PackageDetails_1 = require("./PackageDetails");
const detectPackageManager_1 = require("./detectPackageManager");
const fs_extra_1 = require("fs-extra");
const lockfile_1 = require("@yarnpkg/lockfile");
const find_yarn_workspace_root_1 = __importDefault(require("find-yarn-workspace-root"));
const getPackageVersion_1 = require("./getPackageVersion");
//import { execSync } from "child_process"
//const isVerbose = global.patchPackageIsVerbose
const isDebug = global.patchPackageIsDebug;
function getPackageResolution({ packageDetails, packageManager, appPath, appPackageJson, }) {
    if (isDebug) {
        console.log(`patch-package/getPackageResolution:`);
        console.dir({
            packageDetails,
            packageManager,
            appPath,
            appPackageJson, // parent package
        });
    }
    const declaredVersion = (appPackageJson.dependencies &&
        appPackageJson.dependencies[packageDetails.name]) ||
        (appPackageJson.devDependencies &&
            appPackageJson.devDependencies[packageDetails.name]);
    if (isDebug) {
        console.log(`patch-package/getPackageResolution: declaredVersion = ${declaredVersion}`);
    }
    if (declaredVersion.startsWith('file:')) {
        // supported by all managers
        // resolve relative file path
        const filePath = (0, path_1.resolve)(appPath, declaredVersion.slice("file:".length));
        if (isDebug) {
            console.log(`patch-package/getPackageResolution: resolved filePath ${filePath}`);
        }
        return {
            declaredVersion,
            version: `file:${filePath}`,
        };
    }
    if (packageManager === "yarn") {
        let lockFilePath = "yarn.lock";
        if (!(0, fs_extra_1.existsSync)(lockFilePath)) {
            if (isDebug) {
                console.log(`patch-package/getPackageResolution: yarn.lock is not here, trying findYarnWorkspaceRoot`);
            }
            const workspaceRoot = (0, find_yarn_workspace_root_1.default)();
            if (!workspaceRoot) {
                throw new Error("Can't find yarn.lock file");
            }
            if (isDebug) {
                console.log(`patch-package/getPackageResolution: found yarn workspace: ${workspaceRoot}`);
            }
            lockFilePath = (0, path_1.join)(workspaceRoot, "yarn.lock");
        }
        if (!(0, fs_extra_1.existsSync)(lockFilePath)) {
            throw new Error("Can't find yarn.lock file");
        }
        if (isDebug) {
            console.log(`patch-package/getPackageResolution: found yarn lockfile: ${lockFilePath}`);
        }
        const appLockFile = (0, lockfile_1.parse)((0, fs_extra_1.readFileSync)(lockFilePath).toString());
        if (appLockFile.type !== "success") {
            throw new Error("Can't parse lock file");
        }
        const installedVersion = (0, getPackageVersion_1.getPackageVersion)((0, path_1.join)((0, path_1.resolve)(appPath, packageDetails.path), "package.json"));
        const entries = Object.entries(appLockFile.object).filter(([k, v]) => k.startsWith(packageDetails.name + "@") &&
            v.version === installedVersion);
        const resolutions = entries.map(([_, v]) => v.resolved);
        if (resolutions.length === 0) {
            throw new Error(`Can't find lockfile entry for ${packageDetails.pathSpecifier}`);
        }
        if (new Set(resolutions).size !== 1) {
            console.warn(`Ambigious lockfile entries for ${packageDetails.pathSpecifier}. Using version ${installedVersion}`);
            return {
                declaredVersion,
                version: installedVersion,
            };
        }
        if (resolutions[0]) {
            return {
                declaredVersion,
                version: resolutions[0]
            };
        }
        const resolution = entries[0][0].slice(packageDetails.name.length + 1);
        // resolve relative file path
        if (resolution.startsWith("file:.")) {
            return {
                declaredVersion,
                version: `file:${(0, path_1.resolve)(appPath, resolution.slice("file:".length))}`,
            };
        }
        return {
            declaredVersion,
            version: resolution,
        };
    }
    else if (packageManager === "pnpm") {
        // WORKAROUND for pnpm bug? pnpm-lock.yaml says version 1.2.3 for linked packages, not link:../../path/to/package
        // TODO validate: declaredVersion must not be wildcard
        return {
            declaredVersion,
            version: declaredVersion,
        };
        // TODO dont use lockfiles at all?
        // package versions should be pinned in /package.json, so it works with all package managers at all times
        /*
        const lockfile = require("js-yaml").load(
          require("fs").readFileSync(join(appPath, "pnpm-lock.yaml"), "utf8"),
        )
        if (isDebug) {
          console.log(`patch-package/getPackageResolution: appPath = ${appPath}`)
          console.log(`patch-package/getPackageResolution: packageDetails:`)
          console.dir(packageDetails)
          console.log(
            `patch-package/getPackageResolution: packageDetails.name = ${packageDetails.name}`,
          )
          console.log(
            `patch-package/getPackageResolution: lockfile.dependencies[packageDetails.name] = ${
              lockfile.dependencies[packageDetails.name]
            }`,
          )
          console.log(
            `patch-package/getPackageResolution: lockfile.devDependencies[packageDetails.name] = ${
              lockfile.devDependencies[packageDetails.name]
            }`,
          )
        }
        let resolvedVersion =
          (lockfile.dependencies && lockfile.dependencies[packageDetails.name]) ||
          (lockfile.devDependencies &&
            lockfile.devDependencies[packageDetails.name])
        if (declaredVersion.startsWith("link:")) {
          // WORKAROUND
          if (isDebug) {
            console.log(
              `patch-package/getPackageResolution: using declaredVersion ${declaredVersion}, not resolvedVersion ${resolvedVersion}`,
            )
          }
          resolvedVersion = declaredVersion
        }
        if (isDebug) {
          console.log(
            `patch-package/getPackageResolution: resolvedVersion = ${resolvedVersion}`,
          )
        }
        if (resolvedVersion.startsWith("link:")) {
          const localPath = resolve(resolvedVersion.slice(5))
          if (isVerbose) {
            console.log(
              `patch-package/getPackageResolution: pnpm installed ${packageDetails.name} from ${localPath}`,
            )
          }
          if (existsSync(localPath + "/.git")) {
            // we hope that the originCommit will be available for future downloads
            // otherwise our patch will not work ...
            // ideally, we would use the last stable release before originCommit from npm or github
            function exec(cmd: string) {
              return execSync(cmd, {
                cwd: localPath,
                windowsHide: true,
                encoding: "utf8",
              }).trim()
            }
            const originUrl = exec("git remote get-url origin")
            // TODO what if the upstream repo is not called "origin"?
            const originCommit = exec("git rev-parse origin/HEAD") // npm needs the long commit hash
            resolvedVersion = `git+${originUrl}#${originCommit}`
            if (isVerbose) {
              console.log(
                `patch-package/getPackageResolution: using ${packageDetails.name} version ${resolvedVersion} from git origin/HEAD in ${localPath}`,
              )
            }
            return { version: resolvedVersion, originCommit }
          }
          const pkgJson = localPath + "/package.json"
          if (existsSync(pkgJson)) {
            resolvedVersion = require(pkgJson).version
            console.warn(
              `warning: using ${packageDetails.name} version ${resolvedVersion} from ${pkgJson}`,
            )
            return { version: resolvedVersion }
          }
        }
        if (isVerbose) {
          console.log(
            `patch-package/getPackageResolution: using ${packageDetails.name} version ${resolvedVersion}`,
          )
        }
        return { version: resolvedVersion }
        */
    }
    else {
        const lockfile = require((0, path_1.join)(appPath, packageManager === "npm-shrinkwrap"
            ? "npm-shrinkwrap.json"
            : "package-lock.json"));
        const lockFileStack = [lockfile];
        for (const name of packageDetails.packageNames.slice(0, -1)) {
            const child = lockFileStack[0].dependencies;
            if (child && name in child) {
                lockFileStack.push(child[name]);
            }
        }
        lockFileStack.reverse();
        const relevantStackEntry = lockFileStack.find((entry) => entry.dependencies && packageDetails.name in entry.dependencies);
        const pkg = relevantStackEntry.dependencies[packageDetails.name];
        return {
            declaredVersion,
            version: pkg.resolved || pkg.from || pkg.version,
        };
    }
}
exports.getPackageResolution = getPackageResolution;
if (require.main === module) {
    const packageDetails = (0, PackageDetails_1.getPatchDetailsFromCliString)(process.argv[2]);
    if (!packageDetails) {
        console.error(`Can't find package ${process.argv[2]}`);
        process.exit(1);
        throw new Error();
    }
    console.log(getPackageResolution({
        appPath: process.cwd(),
        packageDetails,
        packageManager: (0, detectPackageManager_1.detectPackageManager)(process.cwd(), null),
        appPackageJson: {}, // TODO?
    }));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2V0UGFja2FnZVJlc29sdXRpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvZ2V0UGFja2FnZVJlc29sdXRpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsaUNBQXNDO0FBQ3RDLHFEQUErRTtBQUMvRSxpRUFBNkU7QUFDN0UsdUNBQW1EO0FBQ25ELGdEQUE4RDtBQUM5RCx3RkFBNEQ7QUFDNUQsMkRBQXVEO0FBQ3ZELDBDQUEwQztBQUUxQyxnREFBZ0Q7QUFDaEQsTUFBTSxPQUFPLEdBQUcsTUFBTSxDQUFDLG1CQUFtQixDQUFBO0FBRTFDLFNBQWdCLG9CQUFvQixDQUFDLEVBQ25DLGNBQWMsRUFDZCxjQUFjLEVBQ2QsT0FBTyxFQUNQLGNBQWMsR0FNZjtJQUVDLElBQUksT0FBTyxFQUFFO1FBQ1gsT0FBTyxDQUFDLEdBQUcsQ0FBQyxxQ0FBcUMsQ0FBQyxDQUFBO1FBQ2xELE9BQU8sQ0FBQyxHQUFHLENBQUM7WUFDVixjQUFjO1lBQ2QsY0FBYztZQUNkLE9BQU87WUFDUCxjQUFjLEVBQUUsaUJBQWlCO1NBQ2xDLENBQUMsQ0FBQTtLQUNIO0lBRUQsTUFBTSxlQUFlLEdBQ25CLENBQUMsY0FBYyxDQUFDLFlBQVk7UUFDMUIsY0FBYyxDQUFDLFlBQVksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDbkQsQ0FBQyxjQUFjLENBQUMsZUFBZTtZQUM3QixjQUFjLENBQUMsZUFBZSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFBO0lBQ3hELElBQUksT0FBTyxFQUFFO1FBQ1gsT0FBTyxDQUFDLEdBQUcsQ0FDVCx5REFBeUQsZUFBZSxFQUFFLENBQzNFLENBQUE7S0FDRjtJQUVELElBQUksZUFBZSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsRUFBRTtRQUN2Qyw0QkFBNEI7UUFDNUIsNkJBQTZCO1FBQzdCLE1BQU0sUUFBUSxHQUFHLElBQUEsY0FBTyxFQUFDLE9BQU8sRUFBRSxlQUFl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QUcsRUFBRTtRQUN0QixjQUFjO1FBQ2QsY0FBYyxFQUFFLElBQUEsMkNBQW9CLEVBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxFQUFFLElBQUksQ0FBQztRQUN6RCxjQUFjLEVBQUUsRUFBRSxFQUFFLFFBQVE7S0FDN0IsQ0FBQyxDQUNILENBQUE7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGpvaW4sIHJlc29sdmUgfSBmcm9tIFwiLi9wYXRoXCJcbmltcG9ydCB7IFBhY2thZ2VEZXRhaWxzLCBnZXRQYXRjaERldGFpbHNGcm9tQ2xpU3RyaW5nIH0gZnJvbSBcIi4vUGFja2FnZURldGFpbHNcIlxuaW1wb3J0IHsgUGFja2FnZU1hbmFnZXIsIGRldGVjdFBhY2thZ2VNYW5hZ2VyIH0gZnJvbSBcIi4vZGV0ZWN0UGFja2FnZU1hbmFnZXJcIlxuaW1wb3J0IHsgcmVhZEZpbGVTeW5jLCBleGlzdHNTeW5jIH0gZnJvbSBcImZzLWV4dHJhXCJcbmltcG9ydCB7IHBhcnNlIGFzIHBhcnNlWWFybkxvY2tGaWxlIH0gZnJvbSBcIkB5YXJucGtnL2xvY2tmaWxlXCJcbmltcG9ydCBmaW5kWWFybldvcmtzcGFjZVJvb3QgZnJvbSBcImZpbmQteWFybi13b3Jrc3BhY2Utcm9vdFwiXG5pbXBvcnQgeyBnZXRQYWNrYWdlVmVyc2lvbiB9IGZyb20gXCIuL2dldFBhY2thZ2VWZXJzaW9uXCJcbi8vaW1wb3J0IHsgZXhlY1N5bmMgfSBmcm9tIFwiY2hpbGRfcHJvY2Vzc1wiXG5cbi8vY29uc3QgaXNWZXJib3NlID0gZ2xvYmFsLnBhdGNoUGFja2FnZUlzVmVyYm9zZVxuY29uc3QgaXNEZWJ1ZyA9IGdsb2JhbC5wYXRjaFBhY2thZ2VJc0RlYnVnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQYWNrYWdlUmVzb2x1dGlvbih7XG4gIHBhY2thZ2VEZXRhaWxzLFxuICBwYWNrYWdlTWFuYWdlcixcbiAgYXBwUGF0aCxcbiAgYXBwUGFja2FnZUpzb24sXG59OiB7XG4gIHBhY2thZ2VEZXRhaWxzOiBQYWNrYWdlRGV0YWlsc1xuICBwYWNrYWdlTWFuYWdlcjogUGFja2FnZU1hbmFnZXJcbiAgYXBwUGF0aDogc3RyaW5nXG4gIGFwcFBhY2thZ2VKc29uOiBhbnlcbn0pIHtcblxuICBpZiAoaXNEZWJ1Zykge1xuICAgIGNvbnNvbGUubG9nKGBwYXRjaC1wYWNrYWdlL2dldFBhY2thZ2VSZXNvbHV0aW9uOmApXG4gICAgY29uc29sZS5kaXIoe1xuICAgICAgcGFja2FnZURldGFpbHMsIC8vIGRlcGVuZGVuY3lcbiAgICAgIHBhY2thZ2VNYW5hZ2VyLFxuICAgICAgYXBwUGF0aCwgLy8gZmlsZTogcHJvdG9jb2wgdmVyc2lvbnMgYXJlIHJlbGF0aXZlIHRvIGFwcFBhdGhcbiAgICAgIGFwcFBhY2thZ2VKc29uLCAvLyBwYXJlbnQgcGFja2FnZVxuICAgIH0pXG4gIH1cblxuICBjb25zdCBkZWNsYXJlZFZlcnNpb24gPVxuICAgIChhcHBQYWNrYWdlSnNvbi5kZXBlbmRlbmNpZXMgJiZcbiAgICAgIGFwcFBhY2thZ2VKc29uLmRlcGVuZGVuY2llc1twYWNrYWdlRGV0YWlscy5uYW1lXSkgfHxcbiAgICAoYXBwUGFja2FnZUpzb24uZGV2RGVwZW5kZW5jaWVzICYmXG4gICAgICBhcHBQYWNrYWdlSnNvbi5kZXZEZXBlbmRlbmNpZXNbcGFja2FnZURldGFpbHMubmFtZV0pXG4gIGlmIChpc0RlYnVnKSB7XG4gICAgY29uc29sZS5sb2coXG4gICAgICBgcGF0Y2gtcGFja2FnZS9nZXRQYWNrYWdlUmVzb2x1dGlvbjogZGVjbGFyZWRWZXJzaW9uID0gJHtkZWNsYXJlZFZlcnNpb259YCxcbiAgICApXG4gIH1cblxuICBpZiAoZGVjbGFyZWRWZXJzaW9uLnN0YXJ0c1dpdGgoJ2ZpbGU6JykpIHtcbiAgICAvLyBzdXBwb3J0ZWQgYnkgYWxsIG1hbmFnZXJzXG4gICAgLy8gcmVzb2x2ZSByZWxhdGl2ZSBmaWxlIHBhdGhcbiAgICBjb25zdCBmaWxlUGF0aCA9IHJlc29sdmUoYXBwUGF0aCwgZGVjbGFyZWRWZXJzaW9uLnNsaWNlKFwiZmlsZTpcIi5sZW5ndGgpKVxuICAgIGlmIChpc0RlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhgcGF0Y2gtcGFja2FnZS9nZXRQYWNrYWdlUmVzb2x1dGlvbjogcmVzb2x2ZWQgZmlsZVBhdGggJHtmaWxlUGF0aH1gKVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZGVjbGFyZWRWZXJzaW9uLFxuICAgICAgdmVyc2lvbjogYGZpbGU6JHtmaWxlUGF0aH1gLFxuICAgIH1cbiAgfVxuXG4gIGlmIChwYWNrYWdlTWFuYWdlciA9PT0gXCJ5YXJuXCIpIHtcbiAgICBsZXQgbG9ja0ZpbGVQYXRoID0gXCJ5YXJuLmxvY2tcIlxuICAgIGlmICghZXhpc3RzU3luYyhsb2NrRmlsZVBhdGgpKSB7XG4gICAgICBpZiAoaXNEZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZyhgcGF0Y2gtcGFja2FnZS9nZXRQYWNrYWdlUmVzb2x1dGlvbjogeWFybi5sb2NrIGlzIG5vdCBoZXJlLCB0cnlpbmcgZmluZFlhcm5Xb3Jrc3BhY2VSb290YClcbiAgICAgIH1cbiAgICAgICAgY29uc3Qgd29ya3NwYWNlUm9vdCA9IGZpbmRZYXJuV29ya3NwYWNlUm9vdCgpXG4gICAgICBpZiAoIXdvcmtzcGFjZVJvb3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgZmluZCB5YXJuLmxvY2sgZmlsZVwiKVxuICAgICAgfVxuICAgICAgaWYgKGlzRGVidWcpIHtcbiAgICAgICAgY29uc29sZS5sb2coYHBhdGNoLXBhY2thZ2UvZ2V0UGFja2FnZVJlc29sdXRpb246IGZvdW5kIHlhcm4gd29ya3NwYWNlOiAke3dvcmtzcGFjZVJvb3R9YClcbiAgICAgIH1cbiAgICAgIGxvY2tGaWxlUGF0aCA9IGpvaW4od29ya3NwYWNlUm9vdCwgXCJ5YXJuLmxvY2tcIilcbiAgICB9XG4gICAgaWYgKCFleGlzdHNTeW5jKGxvY2tGaWxlUGF0aCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGZpbmQgeWFybi5sb2NrIGZpbGVcIilcbiAgICB9XG4gICAgaWYgKGlzRGVidWcpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBwYXRjaC1wYWNrYWdlL2dldFBhY2thZ2VSZXNvbHV0aW9uOiBmb3VuZCB5YXJuIGxvY2tmaWxlOiAke2xvY2tGaWxlUGF0aH1gKVxuICAgIH1cbiAgICBjb25zdCBhcHBMb2NrRmlsZSA9IHBhcnNlWWFybkxvY2tGaWxlKHJlYWRGaWxlU3luYyhsb2NrRmlsZVBhdGgpLnRvU3RyaW5nKCkpXG4gICAgaWYgKGFwcExvY2tGaWxlLnR5cGUgIT09IFwic3VjY2Vzc1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBwYXJzZSBsb2NrIGZpbGVcIilcbiAgICB9XG5cbiAgICBjb25zdCBpbnN0YWxsZWRWZXJzaW9uID0gZ2V0UGFja2FnZVZlcnNpb24oXG4gICAgICBqb2luKHJlc29sdmUoYXBwUGF0aCwgcGFja2FnZURldGFpbHMucGF0aCksIFwicGFja2FnZS5qc29uXCIpLFxuICAgIClcblxuICAgIGNvbnN0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhhcHBMb2NrRmlsZS5vYmplY3QpLmZpbHRlcihcbiAgICAgIChbaywgdl0pID0+XG4gICAgICAgIGsuc3RhcnRzV2l0aChwYWNrYWdlRGV0YWlscy5uYW1lICsgXCJAXCIpICYmXG4gICAgICAgIHYudmVyc2lvbiA9PT0gaW5zdGFsbGVkVmVyc2lvbixcbiAgICApXG5cbiAgICBjb25zdCByZXNvbHV0aW9ucyA9IGVudHJpZXMubWFwKChbXywgdl0pID0+IHYucmVzb2x2ZWQpXG5cbiAgICBpZiAocmVzb2x1dGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW4ndCBmaW5kIGxvY2tmaWxlIGVudHJ5IGZvciAke3BhY2thZ2VEZXRhaWxzLnBhdGhTcGVjaWZpZXJ9YCxcbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAobmV3IFNldChyZXNvbHV0aW9ucykuc2l6ZSAhPT0gMSkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgQW1iaWdpb3VzIGxvY2tmaWxlIGVudHJpZXMgZm9yICR7cGFja2FnZURldGFpbHMucGF0aFNwZWNpZmllcn0uIFVzaW5nIHZlcnNpb24gJHtpbnN0YWxsZWRWZXJzaW9ufWAsXG4gICAgICApXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkZWNsYXJlZFZlcnNpb24sXG4gICAgICAgIHZlcnNpb246IGluc3RhbGxlZFZlcnNpb24sXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlc29sdXRpb25zWzBdKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkZWNsYXJlZFZlcnNpb24sXG4gICAgICAgIHZlcnNpb246IHJlc29sdXRpb25zWzBdXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IGVudHJpZXNbMF1bMF0uc2xpY2UocGFja2FnZURldGFpbHMubmFtZS5sZW5ndGggKyAxKVxuXG4gICAgLy8gcmVzb2x2ZSByZWxhdGl2ZSBmaWxlIHBhdGhcbiAgICBpZiAocmVzb2x1dGlvbi5zdGFydHNXaXRoKFwiZmlsZTouXCIpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkZWNsYXJlZFZlcnNpb24sXG4gICAgICAgIHZlcnNpb246IGBmaWxlOiR7cmVzb2x2ZShhcHBQYXRoLCByZXNvbHV0aW9uLnNsaWNlKFwiZmlsZTpcIi5sZW5ndGgpKX1gLFxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZGVjbGFyZWRWZXJzaW9uLFxuICAgICAgdmVyc2lvbjogcmVzb2x1dGlvbixcbiAgICB9XG4gIH0gZWxzZSBpZiAocGFja2FnZU1hbmFnZXIgPT09IFwicG5wbVwiKSB7XG4gICAgLy8gV09SS0FST1VORCBmb3IgcG5wbSBidWc/IHBucG0tbG9jay55YW1sIHNheXMgdmVyc2lvbiAxLjIuMyBmb3IgbGlua2VkIHBhY2thZ2VzLCBub3QgbGluazouLi8uLi9wYXRoL3RvL3BhY2thZ2VcbiAgICAvLyBUT0RPIHZhbGlkYXRlOiBkZWNsYXJlZFZlcnNpb24gbXVzdCBub3QgYmUgd2lsZGNhcmRcbiAgICByZXR1cm4ge1xuICAgICAgZGVjbGFyZWRWZXJzaW9uLFxuICAgICAgdmVyc2lvbjogZGVjbGFyZWRWZXJzaW9uLFxuICAgIH1cblxuICAgIC8vIFRPRE8gZG9udCB1c2UgbG9ja2ZpbGVzIGF0IGFsbD9cbiAgICAvLyBwYWNrYWdlIHZlcnNpb25zIHNob3VsZCBiZSBwaW5uZWQgaW4gL3BhY2thZ2UuanNvbiwgc28gaXQgd29ya3Mgd2l0aCBhbGwgcGFja2FnZSBtYW5hZ2VycyBhdCBhbGwgdGltZXNcbiAgICAvKlxuICAgIGNvbnN0IGxvY2tmaWxlID0gcmVxdWlyZShcImpzLXlhbWxcIikubG9hZChcbiAgICAgIHJlcXVpcmUoXCJmc1wiKS5yZWFkRmlsZVN5bmMoam9pbihhcHBQYXRoLCBcInBucG0tbG9jay55YW1sXCIpLCBcInV0ZjhcIiksXG4gICAgKVxuICAgIGlmIChpc0RlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhgcGF0Y2gtcGFja2FnZS9nZXRQYWNrYWdlUmVzb2x1dGlvbjogYXBwUGF0aCA9ICR7YXBwUGF0aH1gKVxuICAgICAgY29uc29sZS5sb2coYHBhdGNoLXBhY2thZ2UvZ2V0UGFja2FnZVJlc29sdXRpb246IHBhY2thZ2VEZXRhaWxzOmApXG4gICAgICBjb25zb2xlLmRpcihwYWNrYWdlRGV0YWlscylcbiAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICBgcGF0Y2gtcGFja2FnZS9nZXRQYWNrYWdlUmVzb2x1dGlvbjogcGFja2FnZURldGFpbHMubmFtZSA9ICR7cGFja2FnZURldGFpbHMubmFtZX1gLFxuICAgICAgKVxuICAgICAgY29uc29sZS5sb2coXG4gICAgICAgIGBwYXRjaC1wYWNrYWdlL2dldFBhY2thZ2VSZXNvbHV0aW9uOiBsb2NrZmlsZS5kZXBlbmRlbmNpZXNbcGFja2FnZURldGFpbHMubmFtZV0gPSAke1xuICAgICAgICAgIGxvY2tmaWxlLmRlcGVuZGVuY2llc1twYWNrYWdlRGV0YWlscy5uYW1lXVxuICAgICAgICB9YCxcbiAgICAgIClcbiAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICBgcGF0Y2gtcGFja2FnZS9nZXRQYWNrYWdlUmVzb2x1dGlvbjogbG9ja2ZpbGUuZGV2RGVwZW5kZW5jaWVzW3BhY2thZ2VEZXRhaWxzLm5hbWVdID0gJHtcbiAgICAgICAgICBsb2NrZmlsZS5kZXZEZXBlbmRlbmNpZXNbcGFja2FnZURldGFpbHMubmFtZV1cbiAgICAgICAgfWAsXG4gICAgICApXG4gICAgfVxuICAgIGxldCByZXNvbHZlZFZlcnNpb24gPVxuICAgICAgKGxvY2tmaWxlLmRlcGVuZGVuY2llcyAmJiBsb2NrZmlsZS5kZXBlbmRlbmNpZXNbcGFja2FnZURldGFpbHMubmFtZV0pIHx8XG4gICAgICAobG9ja2ZpbGUuZGV2RGVwZW5kZW5jaWVzICYmXG4gICAgICAgIGxvY2tmaWxlLmRldkRlcGVuZGVuY2llc1twYWNrYWdlRGV0YWlscy5uYW1lXSlcbiAgICBpZiAoZGVjbGFyZWRWZXJzaW9uLnN0YXJ0c1dpdGgoXCJsaW5rOlwiKSkge1xuICAgICAgLy8gV09SS0FST1VORFxuICAgICAgaWYgKGlzRGVidWcpIHtcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgYHBhdGNoLXBhY2thZ2UvZ2V0UGFja2FnZVJlc29sdXRpb246IHVzaW5nIGRlY2xhcmVkVmVyc2lvbiAke2RlY2xhcmVkVmVyc2lvbn0sIG5vdCByZXNvbHZlZFZlcnNpb24gJHtyZXNvbHZlZFZlcnNpb259YCxcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgcmVzb2x2ZWRWZXJzaW9uID0gZGVjbGFyZWRWZXJzaW9uXG4gICAgfVxuICAgIGlmIChpc0RlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgYHBhdGNoLXBhY2thZ2UvZ2V0UGFja2FnZVJlc29sdXRpb246IHJlc29sdmVkVmVyc2lvbiA9ICR7cmVzb2x2ZWRWZXJzaW9ufWAsXG4gICAgICApXG4gICAgfVxuICAgIGlmIChyZXNvbHZlZFZlcnNpb24uc3RhcnRzV2l0aChcImxpbms6XCIpKSB7XG4gICAgICBjb25zdCBsb2NhbFBhdGggPSByZXNvbHZlKHJlc29sdmVkVmVyc2lvbi5zbGljZSg1KSlcbiAgICAgIGlmIChpc1ZlcmJvc2UpIHtcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgYHBhdGNoLXBhY2thZ2UvZ2V0UGFja2FnZVJlc29sdXRpb246IHBucG0gaW5zdGFsbGVkICR7cGFja2FnZURldGFpbHMubmFtZX0gZnJvbSAke2xvY2FsUGF0aH1gLFxuICAgICAgICApXG4gICAgICB9XG4gICAgICBpZiAoZXhpc3RzU3luYyhsb2NhbFBhdGggKyBcIi8uZ2l0XCIpKSB7XG4gICAgICAgIC8vIHdlIGhvcGUgdGhhdCB0aGUgb3JpZ2luQ29tbWl0IHdpbGwgYmUgYXZhaWxhYmxlIGZvciBmdXR1cmUgZG93bmxvYWRzXG4gICAgICAgIC8vIG90aGVyd2lzZSBvdXIgcGF0Y2ggd2lsbCBub3Qgd29yayAuLi5cbiAgICAgICAgLy8gaWRlYWxseSwgd2Ugd291bGQgdXNlIHRoZSBsYXN0IHN0YWJsZSByZWxlYXNlIGJlZm9yZSBvcmlnaW5Db21taXQgZnJvbSBucG0gb3IgZ2l0aHViXG4gICAgICAgIGZ1bmN0aW9uIGV4ZWMoY21kOiBzdHJpbmcpIHtcbiAgICAgICAgICByZXR1cm4gZXhlY1N5bmMoY21kLCB7XG4gICAgICAgICAgICBjd2Q6IGxvY2FsUGF0aCxcbiAgICAgICAgICAgIHdpbmRvd3NIaWRlOiB0cnVlLFxuICAgICAgICAgICAgZW5jb2Rpbmc6IFwidXRmOFwiLFxuICAgICAgICAgIH0pLnRyaW0oKVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9yaWdpblVybCA9IGV4ZWMoXCJnaXQgcmVtb3RlIGdldC11cmwgb3JpZ2luXCIpXG4gICAgICAgIC8vIFRPRE8gd2hhdCBpZiB0aGUgdXBzdHJlYW0gcmVwbyBpcyBub3QgY2FsbGVkIFwib3JpZ2luXCI/XG4gICAgICAgIGNvbnN0IG9yaWdpbkNvbW1pdCA9IGV4ZWMoXCJnaXQgcmV2LXBhcnNlIG9yaWdpbi9IRUFEXCIpIC8vIG5wbSBuZWVkcyB0aGUgbG9uZyBjb21taXQgaGFzaFxuICAgICAgICByZXNvbHZlZFZlcnNpb24gPSBgZ2l0KyR7b3JpZ2luVXJsfSMke29yaWdpbkNvbW1pdH1gXG4gICAgICAgIGlmIChpc1ZlcmJvc2UpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgIGBwYXRjaC1wYWNrYWdlL2dldFBhY2thZ2VSZXNvbHV0aW9uOiB1c2luZyAke3BhY2thZ2VEZXRhaWxzLm5hbWV9IHZlcnNpb24gJHtyZXNvbHZlZFZlcnNpb259IGZyb20gZ2l0IG9yaWdpbi9IRUFEIGluICR7bG9jYWxQYXRofWAsXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHZlcnNpb246IHJlc29sdmVkVmVyc2lvbiwgb3JpZ2luQ29tbWl0IH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHBrZ0pzb24gPSBsb2NhbFBhdGggKyBcIi9wYWNrYWdlLmpzb25cIlxuICAgICAgaWYgKGV4aXN0c1N5bmMocGtnSnNvbikpIHtcbiAgICAgICAgcmVzb2x2ZWRWZXJzaW9uID0gcmVxdWlyZShwa2dKc29uKS52ZXJzaW9uXG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBgd2FybmluZzogdXNpbmcgJHtwYWNrYWdlRGV0YWlscy5uYW1lfSB2ZXJzaW9uICR7cmVzb2x2ZWRWZXJzaW9ufSBmcm9tICR7cGtnSnNvbn1gLFxuICAgICAgICApXG4gICAgICAgIHJldHVybiB7IHZlcnNpb246IHJlc29sdmVkVmVyc2lvbiB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc1ZlcmJvc2UpIHtcbiAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICBgcGF0Y2gtcGFja2FnZS9nZXRQYWNrYWdlUmVzb2x1dGlvbjogdXNpbmcgJHtwYWNrYWdlRGV0YWlscy5uYW1lfSB2ZXJzaW9uICR7cmVzb2x2ZWRWZXJzaW9ufWAsXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiB7IHZlcnNpb246IHJlc29sdmVkVmVyc2lvbiB9XG4gICAgKi9cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBsb2NrZmlsZSA9IHJlcXVpcmUoam9pbihcbiAgICAgIGFwcFBhdGgsXG4gICAgICBwYWNrYWdlTWFuYWdlciA9PT0gXCJucG0tc2hyaW5rd3JhcFwiXG4gICAgICAgID8gXCJucG0tc2hyaW5rd3JhcC5qc29uXCJcbiAgICAgICAgOiBcInBhY2thZ2UtbG9jay5qc29uXCIsXG4gICAgKSlcbiAgICBjb25zdCBsb2NrRmlsZVN0YWNrID0gW2xvY2tmaWxlXVxuICAgIGZvciAoY29uc3QgbmFtZSBvZiBwYWNrYWdlRGV0YWlscy5wYWNrYWdlTmFtZXMuc2xpY2UoMCwgLTEpKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGxvY2tGaWxlU3RhY2tbMF0uZGVwZW5kZW5jaWVzXG4gICAgICBpZiAoY2hpbGQgJiYgbmFtZSBpbiBjaGlsZCkge1xuICAgICAgICBsb2NrRmlsZVN0YWNrLnB1c2goY2hpbGRbbmFtZV0pXG4gICAgICB9XG4gICAgfVxuICAgIGxvY2tGaWxlU3RhY2sucmV2ZXJzZSgpXG4gICAgY29uc3QgcmVsZXZhbnRTdGFja0VudHJ5ID0gbG9ja0ZpbGVTdGFjay5maW5kKFxuICAgICAgKGVudHJ5KSA9PlxuICAgICAgICBlbnRyeS5kZXBlbmRlbmNpZXMgJiYgcGFja2FnZURldGFpbHMubmFtZSBpbiBlbnRyeS5kZXBlbmRlbmNpZXMsXG4gICAgKVxuICAgIGNvbnN0IHBrZyA9IHJlbGV2YW50U3RhY2tFbnRyeS5kZXBlbmRlbmNpZXNbcGFja2FnZURldGFpbHMubmFtZV1cbiAgICByZXR1cm4ge1xuICAgICAgZGVjbGFyZWRWZXJzaW9uLFxuICAgICAgdmVyc2lvbjogcGtnLnJlc29sdmVkIHx8IHBrZy5mcm9tIHx8IHBrZy52ZXJzaW9uLFxuICAgIH1cbiAgfVxufVxuXG5pZiAocmVxdWlyZS5tYWluID09PSBtb2R1bGUpIHtcbiAgY29uc3QgcGFja2FnZURldGFpbHMgPSBnZXRQYXRjaERldGFpbHNGcm9tQ2xpU3RyaW5nKHByb2Nlc3MuYXJndlsyXSlcbiAgaWYgKCFwYWNrYWdlRGV0YWlscykge1xuICAgIGNvbnNvbGUuZXJyb3IoYENhbid0IGZpbmQgcGFja2FnZSAke3Byb2Nlc3MuYXJndlsyXX1gKVxuICAgIHByb2Nlc3MuZXhpdCgxKVxuICAgIHRocm93IG5ldyBFcnJvcigpXG4gIH1cbiAgY29uc29sZS5sb2coXG4gICAgZ2V0UGFja2FnZVJlc29sdXRpb24oe1xuICAgICAgYXBwUGF0aDogcHJvY2Vzcy5jd2QoKSxcbiAgICAgIHBhY2thZ2VEZXRhaWxzLFxuICAgICAgcGFja2FnZU1hbmFnZXI6IGRldGVjdFBhY2thZ2VNYW5hZ2VyKHByb2Nlc3MuY3dkKCksIG51bGwpLFxuICAgICAgYXBwUGFja2FnZUpzb246IHt9LCAvLyBUT0RPP1xuICAgIH0pLFxuICApXG59XG4iXX0=
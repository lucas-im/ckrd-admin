"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.applyPatch = exports.applyPatchesForApp = void 0;
const chalk_1 = __importDefault(require("chalk"));
const patchFs_1 = require("./patchFs");
const apply_1 = require("./patch/apply");
const fs_extra_1 = require("fs-extra");
const path_1 = require("./path");
const path_2 = require("path");
const PackageDetails_1 = require("./PackageDetails");
const reverse_1 = require("./patch/reverse");
const semver_1 = __importDefault(require("semver"));
const read_1 = require("./patch/read");
const packageIsDevDependency_1 = require("./packageIsDevDependency");
class PatchApplicationError extends Error {
    constructor(msg) {
        super(msg);
    }
}
function findPatchFiles(patchesDirectory) {
    if (!(0, fs_extra_1.existsSync)(patchesDirectory)) {
        return [];
    }
    return (0, patchFs_1.getPatchFiles)(patchesDirectory);
}
function getInstalledPackageVersion({ appPath, path, pathSpecifier, isDevOnly, patchFilename, }) {
    const packageDir = (0, path_1.join)(appPath, path);
    if (!(0, fs_extra_1.existsSync)(packageDir)) {
        if (process.env.NODE_ENV === "production" && isDevOnly) {
            return null;
        }
        let err = `${chalk_1.default.red("Error:")} Patch file found for package ${path_2.posix.basename(pathSpecifier)}` + ` which is not present at ${(0, path_1.relative)(".", packageDir)}`;
        if (!isDevOnly && process.env.NODE_ENV === "production") {
            err += `

  If this package is a dev dependency, rename the patch file to
  
    ${chalk_1.default.bold(patchFilename.replace(".patch", ".dev.patch"))}
`;
        }
        throw new PatchApplicationError(err);
    }
    const { version } = require((0, path_1.join)(packageDir, "package.json"));
    // normalize version for `npm ci`
    const result = semver_1.default.valid(version);
    if (result === null) {
        throw new PatchApplicationError(`${chalk_1.default.red("Error:")} Version string '${version}' cannot be parsed from ${(0, path_1.join)(packageDir, "package.json")}`);
    }
    return result;
}
function applyPatchesForApp({ appPath, reverse, patchDir, shouldExitWithError, }) {
    const patchesDirectory = (0, path_1.join)(appPath, patchDir);
    const files = findPatchFiles(patchesDirectory);
    if (files.length === 0) {
        console.error(chalk_1.default.blueBright("No patch files found"));
        return;
    }
    const errors = [];
    const warnings = [];
    for (const filename of files) {
        try {
            const packageDetails = (0, PackageDetails_1.getPackageDetailsFromPatchFilename)(filename);
            if (!packageDetails) {
                warnings.push(`Unrecognized patch file in patches directory ${filename}`);
                continue;
            }
            const { name, version, path, pathSpecifier, isDevOnly, patchFilename, } = packageDetails;
            const installedPackageVersion = getInstalledPackageVersion({
                appPath,
                path,
                pathSpecifier,
                isDevOnly: isDevOnly ||
                    // check for direct-dependents in prod
                    (process.env.NODE_ENV === "production" &&
                        (0, packageIsDevDependency_1.packageIsDevDependency)({ appPath, packageDetails })),
                patchFilename,
            });
            if (!installedPackageVersion) {
                // it's ok we're in production mode and this is a dev only package
                console.log(`Skipping dev-only ${chalk_1.default.bold(pathSpecifier)}@${version} ${chalk_1.default.blue("✔")}`);
                continue;
            }
            if (applyPatch({
                patchFilePath: (0, path_1.resolve)(patchesDirectory, filename),
                reverse,
                packageDetails,
                patchDir,
            })) {
                // yay patch was applied successfully
                // print warning if version mismatch
                if (installedPackageVersion !== version) {
                    warnings.push(createVersionMismatchWarning({
                        packageName: name,
                        actualVersion: installedPackageVersion,
                        originalVersion: version,
                        pathSpecifier,
                        path,
                    }));
                }
                console.log(`${chalk_1.default.bold(pathSpecifier)}@${version} ${chalk_1.default.green("✔")}`);
            }
            else if (installedPackageVersion === version) {
                // completely failed to apply patch
                // TODO: propagate useful error messages from patch application
                errors.push(createBrokenPatchFileError({
                    packageName: name,
                    patchFileName: filename,
                    pathSpecifier,
                    path,
                }));
            }
            else {
                errors.push(createPatchApplictionFailureError({
                    packageName: name,
                    actualVersion: installedPackageVersion,
                    originalVersion: version,
                    patchFileName: filename,
                    path,
                    pathSpecifier,
                }));
            }
        }
        catch (error) {
            if (error instanceof PatchApplicationError) {
                errors.push(error.message);
            }
            else {
                errors.push(createUnexpectedError({ filename, error }));
            }
        }
    }
    for (const warning of warnings) {
        console.warn(warning);
    }
    for (const error of errors) {
        console.error(error);
    }
    const problemsSummary = [];
    if (warnings.length) {
        problemsSummary.push(chalk_1.default.yellow(`${warnings.length} warning(s)`));
    }
    if (errors.length) {
        problemsSummary.push(chalk_1.default.red(`${errors.length} error(s)`));
    }
    if (problemsSummary.length) {
        console.error("---");
        console.error("patch-package finished with", problemsSummary.join(", ") + ".");
    }
    if (errors.length) {
        process.exit(shouldExitWithError ? 1 : 0);
    }
}
exports.applyPatchesForApp = applyPatchesForApp;
function applyPatch({ patchFilePath, reverse, packageDetails, patchDir, }) {
    const patch = (0, read_1.readPatch)({ patchFilePath, packageDetails, patchDir });
    try {
        (0, apply_1.executeEffects)(reverse ? (0, reverse_1.reversePatch)(patch) : patch, { dryRun: false });
    }
    catch (e) {
        try {
            (0, apply_1.executeEffects)(reverse ? patch : (0, reverse_1.reversePatch)(patch), { dryRun: true });
        }
        catch (e) {
            return false;
        }
    }
    return true;
}
exports.applyPatch = applyPatch;
function createVersionMismatchWarning({ packageName, actualVersion, originalVersion, pathSpecifier, path, }) {
    return `
${chalk_1.default.yellow("Warning:")} patch-package detected a patch file version mismatch

  Don't worry! This is probably fine. The patch was still applied
  successfully. Here's the deets:

  Patch file created for

    ${packageName}@${chalk_1.default.bold(originalVersion)}

  applied to

    ${packageName}@${chalk_1.default.bold(actualVersion)}
  
  At path
  
    ${path}

  This warning is just to give you a heads-up. There is a small chance of
  breakage even though the patch was applied successfully. Make sure the package
  still behaves like you expect (you wrote tests, right?) and then run

    ${chalk_1.default.bold(`patch-package ${pathSpecifier}`)}

  to update the version in the patch file name and make this warning go away.
`;
}
function createBrokenPatchFileError({ packageName, patchFileName, path, pathSpecifier, }) {
    return `
${chalk_1.default.red.bold("**ERROR**")} ${chalk_1.default.red(`Failed to apply patch for package ${chalk_1.default.bold(packageName)} at path`)}
  
    ${path}

  This error was caused because patch-package cannot apply the following patch file:

    patches/${patchFileName}

  Try removing node_modules and trying again. If that doesn't work, maybe there was
  an accidental change made to the patch file? Try recreating it by manually
  editing the appropriate files and running:
  
    patch-package ${pathSpecifier}
  
  If that doesn't work, then it's a bug in patch-package, so please submit a bug
  report. Thanks!

    https://github.com/ds300/patch-package/issues
    
`;
}
function createPatchApplictionFailureError({ packageName, actualVersion, originalVersion, patchFileName, path, pathSpecifier, }) {
    return `
${chalk_1.default.red.bold("**ERROR**")} ${chalk_1.default.red(`Failed to apply patch for package ${chalk_1.default.bold(packageName)} at path`)}
  
    ${path}

  This error was caused because ${chalk_1.default.bold(packageName)} has changed since you
  made the patch file for it. This introduced conflicts with your patch,
  just like a merge conflict in Git when separate incompatible changes are
  made to the same piece of code.

  Maybe this means your patch file is no longer necessary, in which case
  hooray! Just delete it!

  Otherwise, you need to generate a new patch file.

  To generate a new one, just repeat the steps you made to generate the first
  one.

  i.e. manually make the appropriate file changes, then run 

    patch-package ${pathSpecifier}

  Info:
    Patch file: patches/${patchFileName}
    Patch was made for version: ${chalk_1.default.green.bold(originalVersion)}
    Installed version: ${chalk_1.default.red.bold(actualVersion)}
`;
}
function createUnexpectedError({ filename, error, }) {
    var stack = (error instanceof Error) ? error.stack : error;
    return `
${chalk_1.default.red.bold("**ERROR**")} ${chalk_1.default.red(`Failed to apply patch file ${chalk_1.default.bold(filename)}`)}
  
${stack}

  `;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBwbHlQYXRjaGVzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2FwcGx5UGF0Y2hlcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxrREFBeUI7QUFDekIsdUNBQXlDO0FBQ3pDLHlDQUE4QztBQUM5Qyx1Q0FBcUM7QUFDckMsaUNBQWdEO0FBQ2hELCtCQUE0QjtBQUM1QixxREFHeUI7QUFDekIsNkNBQThDO0FBQzlDLG9EQUEyQjtBQUMzQix1Q0FBd0M7QUFDeEMscUVBQWlFO0FBRWpFLE1BQU0scUJBQXNCLFNBQVEsS0FBSztJQUN2QyxZQUFZLEdBQVc7UUFDckIsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFBO0lBQ1osQ0FBQztDQUNGO0FBRUQsU0FBUyxjQUFjLENBQUMsZ0JBQXdCO0lBQzlDLElBQUksQ0FBQyxJQUFBLHFCQUFVLEVBQUMsZ0JBQWdCLENBQUMsRUFBRTtRQUNqQyxPQUFPLEVBQUUsQ0FBQTtLQUNWO0lBRUQsT0FBTyxJQUFBLHVCQUFhLEVBQUMsZ0JBQWdCLENBQWEsQ0FBQTtBQUNwRCxDQUFDO0FBRUQsU0FBUywwQkFBMEIsQ0FBQyxFQUNsQyxPQUFPLEVBQ1AsSUFBSSxFQUNKLGFBQWEsRUFDYixTQUFTLEVBQ1QsYUFBYSxHQU9kO0lBQ0MsTUFBTSxVQUFVLEdBQUcsSUFBQSxXQUFJLEVBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxDQUFBO0lBQ3RDLElBQUksQ0FBQyxJQUFBLHFCQUFVLEVBQUMsVUFBVSxDQUFDLEVBQUU7UUFDM0IsSUFBSSxPQUFPLENBQUMsR0FBRyxDQUFDLFFBQVEsS0FBSyxZQUFZLElBQUksU0FBUyxFQUFFO1lBQ3RELE9BQU8sSUFBSSxDQUFBO1NBQ1o7UUFFRCxJQUFJLEdBQUcsR0FDTCxHQUFHLGVBQUssQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLGlDQUFpQyxZQUFLLENBQUMsUUFBUSxDQUNuRSxhQUFhLENBQ2QsRUFBRSxHQUFHLDRCQUE0QixJQUFBLGVBQVEs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eyBnZXRQYXRjaEZpbGVzIH0gZnJvbSBcIi4vcGF0Y2hGc1wiXG5pbXBvcnQgeyBleGVjdXRlRWZmZWN0cyB9IGZyb20gXCIuL3BhdGNoL2FwcGx5XCJcbmltcG9ydCB7IGV4aXN0c1N5bmMgfSBmcm9tIFwiZnMtZXh0cmFcIlxuaW1wb3J0IHsgam9pbiwgcmVzb2x2ZSwgcmVsYXRpdmUgfSBmcm9tIFwiLi9wYXRoXCJcbmltcG9ydCB7IHBvc2l4IH0gZnJvbSBcInBhdGhcIlxuaW1wb3J0IHtcbiAgZ2V0UGFja2FnZURldGFpbHNGcm9tUGF0Y2hGaWxlbmFtZSxcbiAgUGFja2FnZURldGFpbHMsXG59IGZyb20gXCIuL1BhY2thZ2VEZXRhaWxzXCJcbmltcG9ydCB7IHJldmVyc2VQYXRjaCB9IGZyb20gXCIuL3BhdGNoL3JldmVyc2VcIlxuaW1wb3J0IHNlbXZlciBmcm9tIFwic2VtdmVyXCJcbmltcG9ydCB7IHJlYWRQYXRjaCB9IGZyb20gXCIuL3BhdGNoL3JlYWRcIlxuaW1wb3J0IHsgcGFja2FnZUlzRGV2RGVwZW5kZW5jeSB9IGZyb20gXCIuL3BhY2thZ2VJc0RldkRlcGVuZGVuY3lcIlxuXG5jbGFzcyBQYXRjaEFwcGxpY2F0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1zZzogc3RyaW5nKSB7XG4gICAgc3VwZXIobXNnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRQYXRjaEZpbGVzKHBhdGNoZXNEaXJlY3Rvcnk6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgaWYgKCFleGlzdHNTeW5jKHBhdGNoZXNEaXJlY3RvcnkpKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cblxuICByZXR1cm4gZ2V0UGF0Y2hGaWxlcyhwYXRjaGVzRGlyZWN0b3J5KSBhcyBzdHJpbmdbXVxufVxuXG5mdW5jdGlvbiBnZXRJbnN0YWxsZWRQYWNrYWdlVmVyc2lvbih7XG4gIGFwcFBhdGgsXG4gIHBhdGgsXG4gIHBhdGhTcGVjaWZpZXIsXG4gIGlzRGV2T25seSxcbiAgcGF0Y2hGaWxlbmFtZSxcbn06IHtcbiAgYXBwUGF0aDogc3RyaW5nXG4gIHBhdGg6IHN0cmluZ1xuICBwYXRoU3BlY2lmaWVyOiBzdHJpbmdcbiAgaXNEZXZPbmx5OiBib29sZWFuXG4gIHBhdGNoRmlsZW5hbWU6IHN0cmluZ1xufSk6IG51bGwgfCBzdHJpbmcge1xuICBjb25zdCBwYWNrYWdlRGlyID0gam9pbihhcHBQYXRoLCBwYXRoKVxuICBpZiAoIWV4aXN0c1N5bmMocGFja2FnZURpcikpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiICYmIGlzRGV2T25seSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICBsZXQgZXJyID1cbiAgICAgIGAke2NoYWxrLnJlZChcIkVycm9yOlwiKX0gUGF0Y2ggZmlsZSBmb3VuZCBmb3IgcGFja2FnZSAke3Bvc2l4LmJhc2VuYW1lKFxuICAgICAgICBwYXRoU3BlY2lmaWVyLFxuICAgICAgKX1gICsgYCB3aGljaCBpcyBub3QgcHJlc2VudCBhdCAke3JlbGF0aXZlKFwiLlwiLCBwYWNrYWdlRGlyKX1gXG5cbiAgICBpZiAoIWlzRGV2T25seSAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGVyciArPSBgXG5cbiAgSWYgdGhpcyBwYWNrYWdlIGlzIGEgZGV2IGRlcGVuZGVuY3ksIHJlbmFtZSB0aGUgcGF0Y2ggZmlsZSB0b1xuICBcbiAgICAke2NoYWxrLmJvbGQocGF0Y2hGaWxlbmFtZS5yZXBsYWNlKFwiLnBhdGNoXCIsIFwiLmRldi5wYXRjaFwiKSl9XG5gXG4gICAgfVxuICAgIHRocm93IG5ldyBQYXRjaEFwcGxpY2F0aW9uRXJyb3IoZXJyKVxuICB9XG5cbiAgY29uc3QgeyB2ZXJzaW9uIH0gPSByZXF1aXJlKGpvaW4ocGFja2FnZURpciwgXCJwYWNrYWdlLmpzb25cIikpXG4gIC8vIG5vcm1hbGl6ZSB2ZXJzaW9uIGZvciBgbnBtIGNpYFxuICBjb25zdCByZXN1bHQgPSBzZW12ZXIudmFsaWQodmVyc2lvbilcbiAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBQYXRjaEFwcGxpY2F0aW9uRXJyb3IoXG4gICAgICBgJHtjaGFsay5yZWQoXG4gICAgICAgIFwiRXJyb3I6XCIsXG4gICAgICApfSBWZXJzaW9uIHN0cmluZyAnJHt2ZXJzaW9ufScgY2Fubm90IGJlIHBhcnNlZCBmcm9tICR7am9pbihcbiAgICAgICAgcGFja2FnZURpcixcbiAgICAgICAgXCJwYWNrYWdlLmpzb25cIixcbiAgICAgICl9YCxcbiAgICApXG4gIH1cblxuICByZXR1cm4gcmVzdWx0IGFzIHN0cmluZ1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlQYXRjaGVzRm9yQXBwKHtcbiAgYXBwUGF0aCxcbiAgcmV2ZXJzZSxcbiAgcGF0Y2hEaXIsXG4gIHNob3VsZEV4aXRXaXRoRXJyb3IsXG59OiB7XG4gIGFwcFBhdGg6IHN0cmluZ1xuICByZXZlcnNlOiBib29sZWFuXG4gIHBhdGNoRGlyOiBzdHJpbmdcbiAgc2hvdWxkRXhpdFdpdGhFcnJvcjogYm9vbGVhblxufSk6IHZvaWQge1xuICBjb25zdCBwYXRjaGVzRGlyZWN0b3J5ID0gam9pbihhcHBQYXRoLCBwYXRjaERpcilcbiAgY29uc3QgZmlsZXMgPSBmaW5kUGF0Y2hGaWxlcyhwYXRjaGVzRGlyZWN0b3J5KVxuXG4gIGlmIChmaWxlcy5sZW5ndGggPT09IDApIHtcbiAgICBjb25zb2xlLmVycm9yKGNoYWxrLmJsdWVCcmlnaHQoXCJObyBwYXRjaCBmaWxlcyBmb3VuZFwiKSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IGVycm9yczogc3RyaW5nW10gPSBbXVxuICBjb25zdCB3YXJuaW5nczogc3RyaW5nW10gPSBbXVxuXG4gIGZvciAoY29uc3QgZmlsZW5hbWUgb2YgZmlsZXMpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGFja2FnZURldGFpbHMgPSBnZXRQYWNrYWdlRGV0YWlsc0Zyb21QYXRjaEZpbGVuYW1lKGZpbGVuYW1lKVxuXG4gICAgICBpZiAoIXBhY2thZ2VEZXRhaWxzKSB7XG4gICAgICAgIHdhcm5pbmdzLnB1c2goXG4gICAgICAgICAgYFVucmVjb2duaXplZCBwYXRjaCBmaWxlIGluIHBhdGNoZXMgZGlyZWN0b3J5ICR7ZmlsZW5hbWV9YCxcbiAgICAgICAgKVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBjb25zdCB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHZlcnNpb24sXG4gICAgICAgIHBhdGgsXG4gICAgICAgIHBhdGhTcGVjaWZpZXIsXG4gICAgICAgIGlzRGV2T25seSxcbiAgICAgICAgcGF0Y2hGaWxlbmFtZSxcbiAgICAgIH0gPSBwYWNrYWdlRGV0YWlsc1xuXG4gICAgICBjb25zdCBpbnN0YWxsZWRQYWNrYWdlVmVyc2lvbiA9IGdldEluc3RhbGxlZFBhY2thZ2VWZXJzaW9uKHtcbiAgICAgICAgYXBwUGF0aCxcbiAgICAgICAgcGF0aCxcbiAgICAgICAgcGF0aFNwZWNpZmllcixcbiAgICAgICAgaXNEZXZPbmx5OlxuICAgICAgICAgIGlzRGV2T25seSB8fFxuICAgICAgICAgIC8vIGNoZWNrIGZvciBkaXJlY3QtZGVwZW5kZW50cyBpbiBwcm9kXG4gICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiAmJlxuICAgICAgICAgICAgcGFja2FnZUlzRGV2RGVwZW5kZW5jeSh7IGFwcFBhdGgsIHBhY2thZ2VEZXRhaWxzIH0pKSxcbiAgICAgICAgcGF0Y2hGaWxlbmFtZSxcbiAgICAgIH0pXG4gICAgICBpZiAoIWluc3RhbGxlZFBhY2thZ2VWZXJzaW9uKSB7XG4gICAgICAgIC8vIGl0J3Mgb2sgd2UncmUgaW4gcHJvZHVjdGlvbiBtb2RlIGFuZCB0aGlzIGlzIGEgZGV2IG9ubHkgcGFja2FnZVxuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICBgU2tpcHBpbmcgZGV2LW9ubHkgJHtjaGFsay5ib2xkKFxuICAgICAgICAgICAgcGF0aFNwZWNpZmllcixcbiAgICAgICAgICApfUAke3ZlcnNpb259ICR7Y2hhbGsuYmx1ZShcIuKclFwiKX1gLFxuICAgICAgICApXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgYXBwbHlQYXRjaCh7XG4gICAgICAgICAgcGF0Y2hGaWxlUGF0aDogcmVzb2x2ZShwYXRjaGVzRGlyZWN0b3J5LCBmaWxlbmFtZSkgYXMgc3RyaW5nLFxuICAgICAgICAgIHJldmVyc2UsXG4gICAgICAgICAgcGFja2FnZURldGFpbHMsXG4gICAgICAgICAgcGF0Y2hEaXIsXG4gICAgICAgIH0pXG4gICAgICApIHtcbiAgICAgICAgLy8geWF5IHBhdGNoIHdhcyBhcHBsaWVkIHN1Y2Nlc3NmdWxseVxuICAgICAgICAvLyBwcmludCB3YXJuaW5nIGlmIHZlcnNpb24gbWlzbWF0Y2hcbiAgICAgICAgaWYgKGluc3RhbGxlZFBhY2thZ2VWZXJzaW9uICE9PSB2ZXJzaW9uKSB7XG4gICAgICAgICAgd2FybmluZ3MucHVzaChcbiAgICAgICAgICAgIGNyZWF0ZVZlcnNpb25NaXNtYXRjaFdhcm5pbmcoe1xuICAgICAgICAgICAgICBwYWNrYWdlTmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgYWN0dWFsVmVyc2lvbjogaW5zdGFsbGVkUGFja2FnZVZlcnNpb24sXG4gICAgICAgICAgICAgIG9yaWdpbmFsVmVyc2lvbjogdmVyc2lvbixcbiAgICAgICAgICAgICAgcGF0aFNwZWNpZmllcixcbiAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICBgJHtjaGFsay5ib2xkKHBhdGhTcGVjaWZpZXIpfUAke3ZlcnNpb259ICR7Y2hhbGsuZ3JlZW4oXCLinJRcIil9YCxcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIGlmIChpbnN0YWxsZWRQYWNrYWdlVmVyc2lvbiA9PT0gdmVyc2lvbikge1xuICAgICAgICAvLyBjb21wbGV0ZWx5IGZhaWxlZCB0byBhcHBseSBwYXRjaFxuICAgICAgICAvLyBUT0RPOiBwcm9wYWdhdGUgdXNlZnVsIGVycm9yIG1lc3NhZ2VzIGZyb20gcGF0Y2ggYXBwbGljYXRpb25cbiAgICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgICAgY3JlYXRlQnJva2VuUGF0Y2hGaWxlRXJyb3Ioe1xuICAgICAgICAgICAgcGFja2FnZU5hbWU6IG5hbWUsXG4gICAgICAgICAgICBwYXRjaEZpbGVOYW1lOiBmaWxlbmFtZSxcbiAgICAgICAgICAgIHBhdGhTcGVjaWZpZXIsXG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgIH0pLFxuICAgICAgICApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcnMucHVzaChcbiAgICAgICAgICBjcmVhdGVQYXRjaEFwcGxpY3Rpb25GYWlsdXJlRXJyb3Ioe1xuICAgICAgICAgICAgcGFja2FnZU5hbWU6IG5hbWUsXG4gICAgICAgICAgICBhY3R1YWxWZXJzaW9uOiBpbnN0YWxsZWRQYWNrYWdlVmVyc2lvbixcbiAgICAgICAgICAgIG9yaWdpbmFsVmVyc2lvbjogdmVyc2lvbixcbiAgICAgICAgICAgIHBhdGNoRmlsZU5hbWU6IGZpbGVuYW1lLFxuICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgIHBhdGhTcGVjaWZpZXIsXG4gICAgICAgICAgfSksXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBQYXRjaEFwcGxpY2F0aW9uRXJyb3IpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goZXJyb3IubWVzc2FnZSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9ycy5wdXNoKGNyZWF0ZVVuZXhwZWN0ZWRFcnJvcih7IGZpbGVuYW1lLCBlcnJvciB9KSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKGNvbnN0IHdhcm5pbmcgb2Ygd2FybmluZ3MpIHtcbiAgICBjb25zb2xlLndhcm4od2FybmluZylcbiAgfVxuICBmb3IgKGNvbnN0IGVycm9yIG9mIGVycm9ycykge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpXG4gIH1cblxuICBjb25zdCBwcm9ibGVtc1N1bW1hcnk6IHN0cmluZ1tdID0gW11cbiAgaWYgKHdhcm5pbmdzLmxlbmd0aCkge1xuICAgIHByb2JsZW1zU3VtbWFyeS5wdXNoKGNoYWxrLnllbGxvdyhgJHt3YXJuaW5ncy5sZW5ndGh9IHdhcm5pbmcocylgKSlcbiAgfVxuICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgIHByb2JsZW1zU3VtbWFyeS5wdXNoKGNoYWxrLnJlZChgJHtlcnJvcnMubGVuZ3RofSBlcnJvcihzKWApKVxuICB9XG5cbiAgaWYgKHByb2JsZW1zU3VtbWFyeS5sZW5ndGgpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiLS0tXCIpXG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgIFwicGF0Y2gtcGFja2FnZSBmaW5pc2hlZCB3aXRoXCIsXG4gICAgICBwcm9ibGVtc1N1bW1hcnkuam9pbihcIiwgXCIpICsgXCIuXCIsXG4gICAgKVxuICB9XG5cbiAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICBwcm9jZXNzLmV4aXQoc2hvdWxkRXhpdFdpdGhFcnJvciA/IDEgOiAwKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVBhdGNoKHtcbiAgcGF0Y2hGaWxlUGF0aCxcbiAgcmV2ZXJzZSxcbiAgcGFja2FnZURldGFpbHMsXG4gIHBhdGNoRGlyLFxufToge1xuICBwYXRjaEZpbGVQYXRoOiBzdHJpbmdcbiAgcmV2ZXJzZTogYm9vbGVhblxuICBwYWNrYWdlRGV0YWlsczogUGFja2FnZURldGFpbHNcbiAgcGF0Y2hEaXI6IHN0cmluZ1xufSk6IGJvb2xlYW4ge1xuICBjb25zdCBwYXRjaCA9IHJlYWRQYXRjaCh7IHBhdGNoRmlsZVBhdGgsIHBhY2thZ2VEZXRhaWxzLCBwYXRjaERpciB9KVxuICB0cnkge1xuICAgIGV4ZWN1dGVFZmZlY3RzKHJldmVyc2UgPyByZXZlcnNlUGF0Y2gocGF0Y2gpIDogcGF0Y2gsIHsgZHJ5UnVuOiBmYWxzZSB9KVxuICB9IGNhdGNoIChlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGV4ZWN1dGVFZmZlY3RzKHJldmVyc2UgPyBwYXRjaCA6IHJldmVyc2VQYXRjaChwYXRjaCksIHsgZHJ5UnVuOiB0cnVlIH0pXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gY3JlYXRlVmVyc2lvbk1pc21hdGNoV2FybmluZyh7XG4gIHBhY2thZ2VOYW1lLFxuICBhY3R1YWxWZXJzaW9uLFxuICBvcmlnaW5hbFZlcnNpb24sXG4gIHBhdGhTcGVjaWZpZXIsXG4gIHBhdGgsXG59OiB7XG4gIHBhY2thZ2VOYW1lOiBzdHJpbmdcbiAgYWN0dWFsVmVyc2lvbjogc3RyaW5nXG4gIG9yaWdpbmFsVmVyc2lvbjogc3RyaW5nXG4gIHBhdGhTcGVjaWZpZXI6IHN0cmluZ1xuICBwYXRoOiBzdHJpbmdcbn0pIHtcbiAgcmV0dXJuIGBcbiR7Y2hhbGsueWVsbG93KFwiV2FybmluZzpcIil9IHBhdGNoLXBhY2thZ2UgZGV0ZWN0ZWQgYSBwYXRjaCBmaWxlIHZlcnNpb24gbWlzbWF0Y2hcblxuICBEb24ndCB3b3JyeSEgVGhpcyBpcyBwcm9iYWJseSBmaW5lLiBUaGUgcGF0Y2ggd2FzIHN0aWxsIGFwcGxpZWRcbiAgc3VjY2Vzc2Z1bGx5LiBIZXJlJ3MgdGhlIGRlZXRzOlxuXG4gIFBhdGNoIGZpbGUgY3JlYXRlZCBmb3JcblxuICAgICR7cGFja2FnZU5hbWV9QCR7Y2hhbGsuYm9sZChvcmlnaW5hbFZlcnNpb24pfVxuXG4gIGFwcGxpZWQgdG9cblxuICAgICR7cGFja2FnZU5hbWV9QCR7Y2hhbGsuYm9sZChhY3R1YWxWZXJzaW9uKX1cbiAgXG4gIEF0IHBhdGhcbiAgXG4gICAgJHtwYXRofVxuXG4gIFRoaXMgd2FybmluZyBpcyBqdXN0IHRvIGdpdmUgeW91IGEgaGVhZHMtdXAuIFRoZXJlIGlzIGEgc21hbGwgY2hhbmNlIG9mXG4gIGJyZWFrYWdlIGV2ZW4gdGhvdWdoIHRoZSBwYXRjaCB3YXMgYXBwbGllZCBzdWNjZXNzZnVsbHkuIE1ha2Ugc3VyZSB0aGUgcGFja2FnZVxuICBzdGlsbCBiZWhhdmVzIGxpa2UgeW91IGV4cGVjdCAoeW91IHdyb3RlIHRlc3RzLCByaWdodD8pIGFuZCB0aGVuIHJ1blxuXG4gICAgJHtjaGFsay5ib2xkKGBwYXRjaC1wYWNrYWdlICR7cGF0aFNwZWNpZmllcn1gKX1cblxuICB0byB1cGRhdGUgdGhlIHZlcnNpb24gaW4gdGhlIHBhdGNoIGZpbGUgbmFtZSBhbmQgbWFrZSB0aGlzIHdhcm5pbmcgZ28gYXdheS5cbmBcbn1cblxuZnVuY3Rpb24gY3JlYXRlQnJva2VuUGF0Y2hGaWxlRXJyb3Ioe1xuICBwYWNrYWdlTmFtZSxcbiAgcGF0Y2hGaWxlTmFtZSxcbiAgcGF0aCxcbiAgcGF0aFNwZWNpZmllcixcbn06IHtcbiAgcGFja2FnZU5hbWU6IHN0cmluZ1xuICBwYXRjaEZpbGVOYW1lOiBzdHJpbmdcbiAgcGF0aDogc3RyaW5nXG4gIHBhdGhTcGVjaWZpZXI6IHN0cmluZ1xufSkge1xuICByZXR1cm4gYFxuJHtjaGFsay5yZWQuYm9sZChcIioqRVJST1IqKlwiKX0gJHtjaGFsay5yZWQoXG4gICAgYEZhaWxlZCB0byBhcHBseSBwYXRjaCBmb3IgcGFja2FnZSAke2NoYWxrLmJvbGQocGFja2FnZU5hbWUpfSBhdCBwYXRoYCxcbiAgKX1cbiAgXG4gICAgJHtwYXRofVxuXG4gIFRoaXMgZXJyb3Igd2FzIGNhdXNlZCBiZWNhdXNlIHBhdGNoLXBhY2thZ2UgY2Fubm90IGFwcGx5IHRoZSBmb2xsb3dpbmcgcGF0Y2ggZmlsZTpcblxuICAgIHBhdGNoZXMvJHtwYXRjaEZpbGVOYW1lfVxuXG4gIFRyeSByZW1vdmluZyBub2RlX21vZHVsZXMgYW5kIHRyeWluZyBhZ2Fpbi4gSWYgdGhhdCBkb2Vzbid0IHdvcmssIG1heWJlIHRoZXJlIHdhc1xuICBhbiBhY2NpZGVudGFsIGNoYW5nZSBtYWRlIHRvIHRoZSBwYXRjaCBmaWxlPyBUcnkgcmVjcmVhdGluZyBpdCBieSBtYW51YWxseVxuICBlZGl0aW5nIHRoZSBhcHByb3ByaWF0ZSBmaWxlcyBhbmQgcnVubmluZzpcbiAgXG4gICAgcGF0Y2gtcGFja2FnZSAke3BhdGhTcGVjaWZpZXJ9XG4gIFxuICBJZiB0aGF0IGRvZXNuJ3Qgd29yaywgdGhlbiBpdCdzIGEgYnVnIGluIHBhdGNoLXBhY2thZ2UsIHNvIHBsZWFzZSBzdWJtaXQgYSBidWdcbiAgcmVwb3J0LiBUaGFua3MhXG5cbiAgICBodHRwczovL2dpdGh1Yi5jb20vZHMzMDAvcGF0Y2gtcGFja2FnZS9pc3N1ZXNcbiAgICBcbmBcbn1cblxuZnVuY3Rpb24gY3JlYXRlUGF0Y2hBcHBsaWN0aW9uRmFpbHVyZUVycm9yKHtcbiAgcGFja2FnZU5hbWUsXG4gIGFjdHVhbFZlcnNpb24sXG4gIG9yaWdpbmFsVmVyc2lvbixcbiAgcGF0Y2hGaWxlTmFtZSxcbiAgcGF0aCxcbiAgcGF0aFNwZWNpZmllcixcbn06IHtcbiAgcGFja2FnZU5hbWU6IHN0cmluZ1xuICBhY3R1YWxWZXJzaW9uOiBzdHJpbmdcbiAgb3JpZ2luYWxWZXJzaW9uOiBzdHJpbmdcbiAgcGF0Y2hGaWxlTmFtZTogc3RyaW5nXG4gIHBhdGg6IHN0cmluZ1xuICBwYXRoU3BlY2lmaWVyOiBzdHJpbmdcbn0pIHtcbiAgcmV0dXJuIGBcbiR7Y2hhbGsucmVkLmJvbGQoXCIqKkVSUk9SKipcIil9ICR7Y2hhbGsucmVkKFxuICAgIGBGYWlsZWQgdG8gYXBwbHkgcGF0Y2ggZm9yIHBhY2thZ2UgJHtjaGFsay5ib2xkKHBhY2thZ2VOYW1lKX0gYXQgcGF0aGAsXG4gICl9XG4gIFxuICAgICR7cGF0aH1cblxuICBUaGlzIGVycm9yIHdhcyBjYXVzZWQgYmVjYXVzZSAke2NoYWxrLmJvbGQocGFja2FnZU5hbWUpfSBoYXMgY2hhbmdlZCBzaW5jZSB5b3VcbiAgbWFkZSB0aGUgcGF0Y2ggZmlsZSBmb3IgaXQuIFRoaXMgaW50cm9kdWNlZCBjb25mbGljdHMgd2l0aCB5b3VyIHBhdGNoLFxuICBqdXN0IGxpa2UgYSBtZXJnZSBjb25mbGljdCBpbiBHaXQgd2hlbiBzZXBhcmF0ZSBpbmNvbXBhdGlibGUgY2hhbmdlcyBhcmVcbiAgbWFkZSB0byB0aGUgc2FtZSBwaWVjZSBvZiBjb2RlLlxuXG4gIE1heWJlIHRoaXMgbWVhbnMgeW91ciBwYXRjaCBmaWxlIGlzIG5vIGxvbmdlciBuZWNlc3NhcnksIGluIHdoaWNoIGNhc2VcbiAgaG9vcmF5ISBKdXN0IGRlbGV0ZSBpdCFcblxuICBPdGhlcndpc2UsIHlvdSBuZWVkIHRvIGdlbmVyYXRlIGEgbmV3IHBhdGNoIGZpbGUuXG5cbiAgVG8gZ2VuZXJhdGUgYSBuZXcgb25lLCBqdXN0IHJlcGVhdCB0aGUgc3RlcHMgeW91IG1hZGUgdG8gZ2VuZXJhdGUgdGhlIGZpcnN0XG4gIG9uZS5cblxuICBpLmUuIG1hbnVhbGx5IG1ha2UgdGhlIGFwcHJvcHJpYXRlIGZpbGUgY2hhbmdlcywgdGhlbiBydW4gXG5cbiAgICBwYXRjaC1wYWNrYWdlICR7cGF0aFNwZWNpZmllcn1cblxuICBJbmZvOlxuICAgIFBhdGNoIGZpbGU6IHBhdGNoZXMvJHtwYXRjaEZpbGVOYW1lfVxuICAgIFBhdGNoIHdhcyBtYWRlIGZvciB2ZXJzaW9uOiAke2NoYWxrLmdyZWVuLmJvbGQob3JpZ2luYWxWZXJzaW9uKX1cbiAgICBJbnN0YWxsZWQgdmVyc2lvbjogJHtjaGFsay5yZWQuYm9sZChhY3R1YWxWZXJzaW9uKX1cbmBcbn1cblxuZnVuY3Rpb24gY3JlYXRlVW5leHBlY3RlZEVycm9yKHtcbiAgZmlsZW5hbWUsXG4gIGVycm9yLFxufToge1xuICBmaWxlbmFtZTogc3RyaW5nXG4gIGVycm9yOiBhbnlcbn0pIHtcbiAgdmFyIHN0YWNrID0gKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpID8gZXJyb3Iuc3RhY2sgOiBlcnJvclxuICByZXR1cm4gYFxuJHtjaGFsay5yZWQuYm9sZChcIioqRVJST1IqKlwiKX0gJHtjaGFsay5yZWQoXG4gICAgYEZhaWxlZCB0byBhcHBseSBwYXRjaCBmaWxlICR7Y2hhbGsuYm9sZChmaWxlbmFtZSl9YCxcbiAgKX1cbiAgXG4ke3N0YWNrfVxuXG4gIGBcbn1cbiJdfQ==
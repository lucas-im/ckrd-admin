var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
import { defineComponent, computed, openBlock, createElementBlock, normalizeStyle, unref, renderSlot, ref, watch, onUnmounted, createBlock, mergeProps, withCtx, createCommentVNode, createVNode } from "vue";
function ampCount(selector) {
  let cnt = 0;
  for (let i = 0; i < selector.length; ++i) {
    if (selector[i] === "&")
      ++cnt;
  }
  return cnt;
}
const separatorRegex = /\s*,(?![^(]*\))\s*/g;
const extraSpaceRegex = /\s+/g;
function resolveSelectorWithAmp(amp, selector) {
  const nextAmp = [];
  selector.split(separatorRegex).forEach((partialSelector) => {
    let round = ampCount(partialSelector);
    if (!round) {
      amp.forEach((partialAmp) => {
        nextAmp.push((partialAmp && partialAmp + " ") + partialSelector);
      });
      return;
    } else if (round === 1) {
      amp.forEach((partialAmp) => {
        nextAmp.push(partialSelector.replace("&", partialAmp));
      });
      return;
    }
    let partialNextAmp = [
      partialSelector
    ];
    while (round--) {
      const nextPartialNextAmp = [];
      partialNextAmp.forEach((selectorItr) => {
        amp.forEach((partialAmp) => {
          nextPartialNextAmp.push(selectorItr.replace("&", partialAmp));
        });
      });
      partialNextAmp = nextPartialNextAmp;
    }
    partialNextAmp.forEach((part) => nextAmp.push(part));
  });
  return nextAmp;
}
function resolveSelector(amp, selector) {
  const nextAmp = [];
  selector.split(separatorRegex).forEach((partialSelector) => {
    amp.forEach((partialAmp) => {
      nextAmp.push((partialAmp && partialAmp + " ") + partialSelector);
    });
  });
  return nextAmp;
}
function parseSelectorPath(selectorPaths) {
  let amp = [""];
  selectorPaths.forEach((selector) => {
    selector = selector && selector.trim();
    if (!selector) {
      return;
    }
    if (selector.includes("&")) {
      amp = resolveSelectorWithAmp(amp, selector);
    } else {
      amp = resolveSelector(amp, selector);
    }
  });
  return amp.join(", ").replace(extraSpaceRegex, " ");
}
function removeElement(el) {
  if (!el)
    return;
  const parentElement = el.parentElement;
  if (parentElement)
    parentElement.removeChild(el);
}
function queryElement(id) {
  return document.querySelector(`style[cssr-id="${id}"]`);
}
function createElement(id) {
  const el = document.createElement("style");
  el.setAttribute("cssr-id", id);
  return el;
}
function isMediaOrSupports(selector) {
  if (!selector)
    return false;
  return /^\s*@(s|m)/.test(selector);
}
const kebabRegex = /[A-Z]/g;
function kebabCase(pattern) {
  return pattern.replace(kebabRegex, (match) => "-" + match.toLowerCase());
}
function unwrapProperty(prop, indent = "  ") {
  if (typeof prop === "object" && prop !== null) {
    return " {\n" + Object.entries(prop).map((v) => {
      return indent + `  ${kebabCase(v[0])}: ${v[1]};`;
    }).join("\n") + "\n" + indent + "}";
  }
  return `: ${prop};`;
}
function unwrapProperties(props, instance, params) {
  if (typeof props === "function") {
    return props({
      context: instance.context,
      props: params
    });
  }
  return props;
}
function createStyle(selector, props, instance, params) {
  if (!props)
    return "";
  const unwrappedProps = unwrapProperties(props, instance, params);
  if (!unwrappedProps)
    return "";
  if (typeof unwrappedProps === "string") {
    return `${selector} {
${unwrappedProps}
}`;
  }
  const propertyNames = Object.keys(unwrappedProps);
  if (propertyNames.length === 0) {
    if (instance.config.keepEmptyBlock)
      return selector + " {\n}";
    return "";
  }
  const statements = selector ? [
    selector + " {"
  ] : [];
  propertyNames.forEach((propertyName) => {
    const property = unwrappedProps[propertyName];
    if (propertyName === "raw") {
      statements.push("\n" + property + "\n");
      return;
    }
    propertyName = kebabCase(propertyName);
    if (property !== null && property !== void 0) {
      statements.push(`  ${propertyName}${unwrapProperty(property)}`);
    }
  });
  if (selector) {
    statements.push("}");
  }
  return statements.join("\n");
}
function loopCNodeListWithCallback(children, options, callback) {
  if (!children)
    return;
  children.forEach((child) => {
    if (Array.isArray(child)) {
      loopCNodeListWithCallback(child, options, callback);
    } else if (typeof child === "function") {
      const grandChildren = child(options);
      if (Array.isArray(grandChildren)) {
        loopCNodeListWithCallback(grandChildren, options, callback);
      } else if (grandChildren) {
        callback(grandChildren);
      }
    } else if (child) {
      callback(child);
    }
  });
}
function traverseCNode(node, selectorPaths, styles, instance, params, styleSheet) {
  const $ = node.$;
  let blockSelector = "";
  if (!$ || typeof $ === "string") {
    if (isMediaOrSupports($)) {
      blockSelector = $;
    } else {
      selectorPaths.push($);
    }
  } else if (typeof $ === "function") {
    const selector2 = $({
      context: instance.context,
      props: params
    });
    if (isMediaOrSupports(selector2)) {
      blockSelector = selector2;
    } else {
      selectorPaths.push(selector2);
    }
  } else {
    if ($.before)
      $.before(instance.context);
    if (!$.$ || typeof $.$ === "string") {
      if (isMediaOrSupports($.$)) {
        blockSelector = $.$;
      } else {
        selectorPaths.push($.$);
      }
    } else if ($.$) {
      const selector2 = $.$({
        context: instance.context,
        props: params
      });
      if (isMediaOrSupports(selector2)) {
        blockSelector = selector2;
      } else {
        selectorPaths.push(selector2);
      }
    }
  }
  const selector = parseSelectorPath(selectorPaths);
  const style = createStyle(selector, node.props, instance, params);
  if (blockSelector) {
    styles.push(`${blockSelector} {`);
    if (styleSheet && style) {
      styleSheet.insertRule(`${blockSelector} {
${style}
}
`);
    }
  } else {
    if (styleSheet && style) {
      styleSheet.insertRule(style);
    }
    if (!styleSheet && style.length)
      styles.push(style);
  }
  if (node.children) {
    loopCNodeListWithCallback(node.children, {
      context: instance.context,
      props: params
    }, (childNode) => {
      if (typeof childNode === "string") {
        const style2 = createStyle(selector, { raw: childNode }, instance, params);
        if (styleSheet) {
          styleSheet.insertRule(style2);
        } else {
          styles.push(style2);
        }
      } else {
        traverseCNode(childNode, selectorPaths, styles, instance, params, styleSheet);
      }
    });
  }
  selectorPaths.pop();
  if (blockSelector) {
    styles.push("}");
  }
  if ($ && $.after)
    $.after(instance.context);
}
function render(node, instance, props, insertRule = false) {
  const styles = [];
  traverseCNode(node, [], styles, instance, props, insertRule ? node.instance.__styleSheet : void 0);
  if (insertRule)
    return "";
  return styles.join("\n\n");
}
function murmur2(str) {
  var h = 0;
  var k, i = 0, len = str.length;
  for (; len >= 4; ++i, len -= 4) {
    k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
    k = (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
    k ^= k >>> 24;
    h = (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^ (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h ^= (str.charCodeAt(i + 2) & 255) << 16;
    case 2:
      h ^= (str.charCodeAt(i + 1) & 255) << 8;
    case 1:
      h ^= str.charCodeAt(i) & 255;
      h = (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  }
  h ^= h >>> 13;
  h = (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  return ((h ^ h >>> 15) >>> 0).toString(36);
}
if (typeof window !== "undefined") {
  window.__cssrContext = {};
}
function unmount(intance, node, id) {
  const { els } = node;
  if (id === void 0) {
    els.forEach(removeElement);
    node.els = [];
  } else {
    const target = queryElement(id);
    if (target && els.includes(target)) {
      removeElement(target);
      node.els = els.filter((el) => el !== target);
    }
  }
}
function addElementToList(els, target) {
  els.push(target);
}
function mount(instance, node, id, props, head, silent, force, anchorMetaName, ssrAdapter) {
  if (silent && !ssrAdapter) {
    if (id === void 0) {
      console.error("[css-render/mount]: `id` is required in `silent` mode.");
      return;
    }
    const cssrContext = window.__cssrContext;
    if (!cssrContext[id]) {
      cssrContext[id] = true;
      render(node, instance, props, silent);
    }
    return;
  }
  let style;
  if (id === void 0) {
    style = node.render(props);
    id = murmur2(style);
  }
  if (ssrAdapter) {
    ssrAdapter.adapter(id, style !== null && style !== void 0 ? style : node.render(props));
    return;
  }
  const queriedTarget = queryElement(id);
  if (queriedTarget !== null && !force) {
    return queriedTarget;
  }
  const target = queriedTarget !== null && queriedTarget !== void 0 ? queriedTarget : createElement(id);
  if (style === void 0)
    style = node.render(props);
  target.textContent = style;
  if (queriedTarget !== null)
    return queriedTarget;
  if (anchorMetaName) {
    const anchorMetaEl = document.head.querySelector(`meta[name="${anchorMetaName}"]`);
    if (anchorMetaEl) {
      document.head.insertBefore(target, anchorMetaEl);
      addElementToList(node.els, target);
      return target;
    }
  }
  if (head) {
    document.head.insertBefore(target, document.head.querySelector("style, link"));
  } else {
    document.head.appendChild(target);
  }
  addElementToList(node.els, target);
  return target;
}
function wrappedRender(props) {
  return render(this, this.instance, props);
}
function wrappedMount(options = {}) {
  const { id, ssr, props, head = false, silent = false, force = false, anchorMetaName } = options;
  const targetElement = mount(this.instance, this, id, props, head, silent, force, anchorMetaName, ssr);
  return targetElement;
}
function wrappedUnmount(options = {}) {
  const { id } = options;
  unmount(this.instance, this, id);
}
const createCNode = function(instance, $, props, children) {
  return {
    instance,
    $,
    props,
    children,
    els: [],
    render: wrappedRender,
    mount: wrappedMount,
    unmount: wrappedUnmount
  };
};
const c = function(instance, $, props, children) {
  if (Array.isArray($)) {
    return createCNode(instance, { $: null }, null, $);
  } else if (Array.isArray(props)) {
    return createCNode(instance, $, null, props);
  } else if (Array.isArray(children)) {
    return createCNode(instance, $, props, children);
  } else {
    return createCNode(instance, $, props, null);
  }
};
function CssRender(config = {}) {
  let styleSheet = null;
  const cssr = {
    c: (...args) => c(cssr, ...args),
    use: (plugin, ...args) => plugin.install(cssr, ...args),
    find: queryElement,
    context: {},
    config,
    get __styleSheet() {
      if (!styleSheet) {
        const style = document.createElement("style");
        document.head.appendChild(style);
        styleSheet = document.styleSheets[document.styleSheets.length - 1];
        return styleSheet;
      }
      return styleSheet;
    }
  };
  return cssr;
}
const __default__$5 = { name: "LayoutHeader" };
const _sfc_main$5 = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$5), {
  props: {
    fixed: { type: Boolean, default: true },
    zIndex: { default: 1001 },
    useMinWidthLayout: { type: Boolean },
    minWidth: { default: 1200 },
    height: { default: 56 },
    paddingLeft: { default: 0 },
    transitionDuration: { default: 300 },
    transitionTimingFunction: { default: "ease-in-out" }
  },
  setup(__props) {
    const props = __props;
    const style = computed(() => {
      const { fixed, zIndex, minWidth, height, paddingLeft, transitionDuration, transitionTimingFunction } = props;
      const position = fixed ? "fixed" : "static";
      const minWidthStyle = props.useMinWidthLayout ? `min-width:${minWidth}px;` : "";
      return `position:${position};z-index:${zIndex};${minWidthStyle}height:${height}px;padding-left:${paddingLeft}px;transition-duration:${transitionDuration}ms;transition-timing-function:${transitionTimingFunction};`;
    });
    const { c: c2 } = CssRender();
    const cStyle = c2(".admin-layout__header", {
      left: 0,
      top: 0,
      flexShrink: 0,
      boxSizing: "border-box",
      width: "100%",
      transitionProperty: "padding-left"
    });
    cStyle.render();
    cStyle.mount();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("header", {
        class: "admin-layout__header",
        style: normalizeStyle(unref(style))
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 4);
    };
  }
}));
const __default__$4 = { name: "LayoutTab" };
const _sfc_main$4 = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$4), {
  props: {
    fixed: { type: Boolean, default: true },
    top: { default: 56 },
    zIndex: { default: 999 },
    useMinWidthLayout: { type: Boolean },
    minWidth: { default: 1200 },
    height: { default: 56 },
    paddingLeft: { default: 0 },
    transitionDuration: { default: 300 },
    transitionTimingFunction: { default: "ease-in-out" }
  },
  setup(__props) {
    const props = __props;
    const style = computed(() => {
      const { fixed, top, zIndex, minWidth, height, paddingLeft, transitionDuration, transitionTimingFunction } = props;
      const position = fixed ? "fixed" : "static";
      const minWidthStyle = props.useMinWidthLayout ? `min-width: ${minWidth}px;` : "";
      return `position:${position};top:${top}px;z-index:${zIndex};${minWidthStyle}height:${height}px;padding-left:${paddingLeft}px;transition-duration:${transitionDuration}ms;transition-timing-function:${transitionTimingFunction};`;
    });
    const { c: c2 } = CssRender();
    const cStyle = c2(".admin-layout__tab", {
      left: 0,
      flexShrink: 0,
      boxSizing: "border-box",
      width: "100%",
      transitionProperty: "padding-left"
    });
    cStyle.render();
    cStyle.mount();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "admin-layout__tab",
        style: normalizeStyle(unref(style))
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 4);
    };
  }
}));
const __default__$3 = { name: "LayoutSider" };
const _sfc_main$3 = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$3), {
  props: {
    zIndex: { default: 1002 },
    width: { default: 200 },
    paddingTop: { default: 0 },
    transitionDuration: { default: 300 },
    transitionTimingFunction: { default: "ease-in-out" }
  },
  setup(__props) {
    const props = __props;
    const style = computed(() => {
      const { zIndex, width, paddingTop, transitionDuration, transitionTimingFunction } = props;
      return `z-index:${zIndex};width:${width}px;padding-top:${paddingTop}px;transition-duration:${transitionDuration}ms;transition-timing-function:${transitionTimingFunction};`;
    });
    const { c: c2 } = CssRender();
    const cStyle = c2(".admin-layout__sider", {
      position: "fixed",
      left: 0,
      top: 0,
      boxSizing: "border-box",
      width: "100%",
      height: "100%",
      transitionProperty: "all"
    });
    cStyle.render();
    cStyle.mount();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("aside", {
        class: "admin-layout__sider",
        style: normalizeStyle(unref(style))
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 4);
    };
  }
}));
const __default__$2 = { name: "LayoutContent" };
const _sfc_main$2 = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$2), {
  props: {
    paddingTop: { default: 0 },
    paddingBottom: { default: 0 },
    paddingLeft: { default: 0 },
    overflowHidden: { type: Boolean },
    transitionDuration: { default: 300 },
    transitionTimingFunction: { default: "ease-in-out" }
  },
  setup(__props) {
    const props = __props;
    const style = computed(() => {
      const { paddingTop, paddingBottom, paddingLeft, transitionDuration, transitionTimingFunction } = props;
      const overflowStyle = `overflow:${props.overflowHidden ? "hidden" : "visible"};`;
      return `padding-top:${paddingTop}px;padding-bottom:${paddingBottom}px;padding-left:${paddingLeft}px;${overflowStyle}transition-duration:${transitionDuration}ms;transition-timing-function:${transitionTimingFunction};`;
    });
    const { c: c2 } = CssRender();
    const cStyle = c2(".admin-layout__content", {
      flexGrow: 1,
      boxSizing: "border-box",
      width: "100%",
      transitionProperty: "padding-left"
    });
    cStyle.render();
    cStyle.mount();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("main", {
        style: normalizeStyle(unref(style)),
        class: "admin-layout__content"
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 4);
    };
  }
}));
const __default__$1 = { name: "LayoutFooter" };
const _sfc_main$1 = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$1), {
  props: {
    fixed: { type: Boolean, default: true },
    zIndex: { default: 999 },
    useMinWidthLayout: { type: Boolean },
    minWidth: { default: 1200 },
    height: { default: 56 },
    paddingLeft: { default: 0 },
    transitionDuration: { default: 300 },
    transitionTimingFunction: { default: "ease-in-out" }
  },
  setup(__props) {
    const props = __props;
    const style = computed(() => {
      const { fixed, zIndex, minWidth, height, paddingLeft, transitionDuration, transitionTimingFunction } = props;
      const position = fixed ? "fixed" : "static";
      const minWidthStyle = props.useMinWidthLayout ? `min-width:${minWidth}px;` : "";
      return `position:${position};z-index:${zIndex};${minWidthStyle}height:${height}px;padding-left:${paddingLeft}px;transition-duration:${transitionDuration}ms;transition-timing-function:${transitionTimingFunction};`;
    });
    const { c: c2 } = CssRender();
    const cStyle = c2(".admin-layout__footer", {
      left: 0,
      bottom: 0,
      flexShrink: 0,
      boxSizing: "border-box",
      width: "100%",
      transitionProperty: "padding-left"
    });
    cStyle.render();
    cStyle.mount();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("footer", {
        class: "admin-layout__footer",
        style: normalizeStyle(unref(style))
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 4);
    };
  }
}));
function useFixedTransformStyle(isFixed) {
  const scrollLeft = ref(0);
  const transformStyle = computed(() => `transform: translateX(${-scrollLeft.value}px);`);
  let isInit = false;
  function setScrollLeft(sLeft) {
    scrollLeft.value = sLeft;
  }
  function scrollHandler() {
    var _a;
    const sLeft = ((_a = document.scrollingElement) == null ? void 0 : _a.scrollLeft) || 0;
    setScrollLeft(sLeft);
  }
  function initScrollLeft() {
    scrollHandler();
  }
  function addScrollEventListener() {
    document.addEventListener("scroll", scrollHandler);
  }
  function removeScrollEventListener() {
    if (!isInit)
      return;
    document.removeEventListener("scroll", scrollHandler);
  }
  function init() {
    initScrollLeft();
    addScrollEventListener();
    isInit = true;
  }
  watch(isFixed, (newValue) => {
    if (newValue) {
      init();
    } else {
      removeScrollEventListener();
    }
  }, { immediate: true });
  onUnmounted(() => {
    removeScrollEventListener();
  });
  return transformStyle;
}
const __default__ = { name: "AdminLayout" };
const _sfc_main = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__), {
  props: {
    mode: { default: "vertical" },
    isMobile: { type: Boolean, default: false },
    maskBg: { default: "rgba(0,0,0,0.3)" },
    useMinWidthLayout: { type: Boolean, default: false },
    minWidth: { default: 1200 },
    headerVisible: { type: Boolean, default: true },
    headerHeight: { default: 56 },
    tabVisible: { type: Boolean, default: true },
    tabHeight: { default: 44 },
    fixedHeaderAndTab: { type: Boolean, default: true },
    addMainOverflowHidden: { type: Boolean, default: false },
    footerVisible: { type: Boolean, default: true },
    footerHeight: { default: 48 },
    fixedFooter: { type: Boolean, default: true },
    siderVisible: { type: Boolean, default: true },
    siderWidth: { default: 200 },
    siderCollapsedWidth: { default: 64 },
    siderCollapse: { type: Boolean, default: false },
    transitionDuration: { default: 300 },
    transitionTimingFunction: { default: "ease-in-out" }
  },
  emits: ["update:sider-collapse"],
  setup(__props, { emit }) {
    const props = __props;
    const style = computed(() => props.useMinWidthLayout ? `min-width:${props.minWidth}px;` : "");
    const hasFixedEl = computed(() => props.useMinWidthLayout && (props.fixedHeaderAndTab || props.fixedFooter));
    const transformStyle = useFixedTransformStyle(hasFixedEl);
    const headerAndTabTransform = computed(() => props.fixedHeaderAndTab ? transformStyle.value : "");
    const footerTransform = computed(() => props.fixedFooter ? transformStyle.value : "");
    const commonProps = computed(() => {
      const { transitionDuration, transitionTimingFunction } = props;
      return {
        transitionDuration,
        transitionTimingFunction
      };
    });
    const isVertical = computed(() => props.mode === "vertical");
    const headerZIndex = 1001;
    const tabZIndex = 999;
    const siderZIndex = computed(() => props.isMobile || isVertical.value ? 1003 : 1e3);
    const footerZIndex = 998;
    const siderCollapseStatus = computed({
      get() {
        return props.siderCollapse;
      },
      set(collapse) {
        emit("update:sider-collapse", collapse);
      }
    });
    function handleClickMask() {
      siderCollapseStatus.value = true;
    }
    const showMask = computed(() => props.isMobile && !siderCollapseStatus.value);
    const siderStyle = computed(() => {
      const { transitionDuration, transitionTimingFunction } = props;
      const sStyle = `background-color:${props.maskBg};transition-duration:${transitionDuration}ms;transition-timing-function:${transitionTimingFunction};`;
      return sStyle;
    });
    const currentSiderWidth = computed(() => {
      const { siderWidth, siderCollapsedWidth } = props;
      const collapseWidth = props.isMobile ? 0 : siderCollapsedWidth;
      const width = siderCollapseStatus.value ? collapseWidth : siderWidth;
      return props.siderVisible ? width : 0;
    });
    const commonPaddingLeft = computed(() => props.isMobile ? 0 : currentSiderWidth.value);
    const headerPaddingLeft = computed(() => isVertical.value ? commonPaddingLeft.value : 0);
    const siderPaddingTop = computed(() => !props.isMobile && !isVertical.value && props.headerVisible ? props.headerHeight : 0);
    const contentPaddingTop = computed(() => {
      let height = 0;
      if (props.fixedHeaderAndTab) {
        if (props.headerVisible) {
          height += props.headerHeight;
        }
        if (props.tabVisible) {
          height += props.tabHeight;
        }
      }
      return height;
    });
    const contentPaddingBottom = computed(() => props.fixedFooter && props.footerVisible ? props.footerHeight : 0);
    const { c: c2 } = CssRender();
    const cStyle = c2(".admin-layout", {
      display: "flex",
      flexDirection: "column",
      width: "100%",
      height: "100%"
    }, [
      c2("&__sider-mask", {
        position: "fixed",
        left: 0,
        top: 0,
        zIndex: 1002,
        width: "100%",
        height: "100%",
        transitionProperty: "background-color"
      })
    ]);
    cStyle.render();
    cStyle.mount();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "admin-layout",
        style: normalizeStyle(unref(style))
      }, [
        __props.headerVisible ? (openBlock(), createBlock(unref(_sfc_main$5), mergeProps({ key: 0 }, unref(commonProps), {
          fixed: __props.fixedHeaderAndTab,
          "z-index": headerZIndex,
          "min-width": __props.minWidth,
          height: __props.headerHeight,
          "padding-left": unref(headerPaddingLeft),
          style: unref(headerAndTabTransform)
        }), {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "header")
          ]),
          _: 3
        }, 16, ["fixed", "min-width", "height", "padding-left", "style"])) : createCommentVNode("", true),
        __props.tabVisible ? (openBlock(), createBlock(unref(_sfc_main$4), mergeProps({ key: 1 }, unref(commonProps), {
          fixed: __props.fixedHeaderAndTab,
          "z-index": tabZIndex,
          "min-width": __props.minWidth,
          top: __props.headerHeight,
          height: __props.tabHeight,
          "padding-left": unref(commonPaddingLeft),
          style: unref(headerAndTabTransform)
        }), {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "tab")
          ]),
          _: 3
        }, 16, ["fixed", "min-width", "top", "height", "padding-left", "style"])) : createCommentVNode("", true),
        __props.siderVisible ? (openBlock(), createBlock(unref(_sfc_main$3), mergeProps({ key: 2 }, unref(commonProps), {
          "z-index": unref(siderZIndex),
          width: unref(currentSiderWidth),
          "padding-top": unref(siderPaddingTop)
        }), {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "sider")
          ]),
          _: 3
        }, 16, ["z-index", "width", "padding-top"])) : createCommentVNode("", true),
        unref(showMask) ? (openBlock(), createElementBlock("div", {
          key: 3,
          class: "admin-layout__sider-mask",
          style: normalizeStyle(unref(siderStyle)),
          onClick: handleClickMask
        }, null, 4)) : createCommentVNode("", true),
        createVNode(unref(_sfc_main$2), mergeProps(unref(commonProps), {
          "padding-top": unref(contentPaddingTop),
          "padding-bottom": unref(contentPaddingBottom),
          "padding-left": unref(commonPaddingLeft),
          "overflow-hidden": __props.addMainOverflowHidden
        }), {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 16, ["padding-top", "padding-bottom", "padding-left", "overflow-hidden"]),
        __props.footerVisible ? (openBlock(), createBlock(unref(_sfc_main$1), mergeProps({ key: 4 }, unref(commonProps), {
          fixed: __props.fixedFooter,
          "z-index": footerZIndex,
          "min-width": __props.minWidth,
          height: __props.footerHeight,
          "padding-left": unref(commonPaddingLeft),
          style: unref(footerTransform)
        }), {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "footer")
          ]),
          _: 3
        }, 16, ["fixed", "min-width", "height", "padding-left", "style"])) : createCommentVNode("", true)
      ], 4);
    };
  }
}));
function install(app) {
  app.component("AdminLayout", _sfc_main);
}
_sfc_main.install = install;
export { _sfc_main as default };
